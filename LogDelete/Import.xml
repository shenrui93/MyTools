<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Import</name>
    </assembly>
    <members>
        <member name="P:Ionic.BZip2.BitWriter.RemainingBits">
            <summary>
              Delivers the remaining bits, left-aligned, in a byte.
            </summary>
            <remarks>
              <para>
                This is valid only if NumRemainingBits is less than 8;
                in other words it is valid only after a call to Flush().
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.BZip2.BitWriter.Reset">
            <summary>
              Reset the BitWriter.
            </summary>
            <remarks>
              <para>
                This is useful when the BitWriter writes into a MemoryStream, and
                is used by a BZip2Compressor, which itself is re-used for multiple
                distinct data blocks.
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.BZip2.BitWriter.WriteBits(System.Int32,System.UInt32)">
            <summary>
              Write some number of bits from the given value, into the output.
            </summary>
            <remarks>
              <para>
                The nbits value should be a max of 25, for safety. For performance
                reasons, this method does not check!
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.BZip2.BitWriter.WriteByte(System.Byte)">
            <summary>
              Write a full 8-bit byte into the output.
            </summary>
        </member>
        <member name="M:Ionic.BZip2.BitWriter.WriteInt(System.UInt32)">
            <summary>
              Write four 8-bit bytes into the output.
            </summary>
        </member>
        <member name="M:Ionic.BZip2.BitWriter.Flush">
            <summary>
              Write all available byte-aligned bytes.
            </summary>
            <remarks>
              <para>
                This method writes no new output, but flushes any accumulated
                bits. At completion, the accumulator may contain up to 7
                bits.
              </para>
              <para>
                This is necessary when re-assembling output from N independent
                compressors, one for each of N blocks. The output of any
                particular compressor will in general have some fragment of a byte
                remaining. This fragment needs to be accumulated into the
                parent BZip2OutputStream.
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.BZip2.BitWriter.FinishAndPad">
            <summary>
              Writes all available bytes, and emits padding for the final byte as
              necessary. This must be the last method invoked on an instance of
              BitWriter.
            </summary>
        </member>
        <member name="T:Ionic.BZip2.BZip2InputStream">
            <summary>
              A read-only decorator stream that performs BZip2 decompression on Read.
            </summary>
        </member>
        <member name="T:Ionic.BZip2.BZip2InputStream.CState">
            <summary>
              Compressor State
            </summary>
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.#ctor(System.IO.Stream)">
            <summary>
              Create a BZip2InputStream, wrapping it around the given input Stream.
            </summary>
            <remarks>
              <para>
                The input stream will be closed when the BZip2InputStream is closed.
              </para>
            </remarks>
            <param name='input'>The stream from which to read compressed data</param>
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.#ctor(System.IO.Stream,System.Boolean)">
             <summary>
               Create a BZip2InputStream with the given stream, and
               specifying whether to leave the wrapped stream open when
               the BZip2InputStream is closed.
             </summary>
             <param name='input'>The stream from which to read compressed data</param>
             <param name='leaveOpen'>
               Whether to leave the input stream open, when the BZip2InputStream closes.
             </param>
            
             <example>
            
               This example reads a bzip2-compressed file, decompresses it,
               and writes the decompressed data into a newly created file.
            
               <code>
               var fname = "logfile.log.bz2";
               using (var fs = File.OpenRead(fname))
               {
                   using (var decompressor = new Ionic.BZip2.BZip2InputStream(fs))
                   {
                       var outFname = fname + ".decompressed";
                       using (var output = File.Create(outFname))
                       {
                           byte[] buffer = new byte[2048];
                           int n;
                           while ((n = decompressor.Read(buffer, 0, buffer.Length)) > 0)
                           {
                               output.Write(buffer, 0, n);
                           }
                       }
                   }
               }
               </code>
             </example>
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.Read(System.Byte[],System.Int32,System.Int32)">
             <summary>
               Read data from the stream.
             </summary>
            
             <remarks>
               <para>
                 To decompress a BZip2 data stream, create a <c>BZip2InputStream</c>,
                 providing a stream that reads compressed data.  Then call Read() on
                 that <c>BZip2InputStream</c>, and the data read will be decompressed
                 as you read.
               </para>
            
               <para>
                 A <c>BZip2InputStream</c> can be used only for <c>Read()</c>, not for <c>Write()</c>.
               </para>
             </remarks>
            
             <param name="buffer">The buffer into which the read data should be placed.</param>
             <param name="offset">the offset within that data array to put the first byte read.</param>
             <param name="count">the number of bytes to read.</param>
             <returns>the number of bytes actually read</returns>
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.ReadByte">
            <summary>
              Read a single byte from the stream.
            </summary>
            <returns>the byte read from the stream, or -1 if EOF</returns>
        </member>
        <member name="P:Ionic.BZip2.BZip2InputStream.CanRead">
            <summary>
            Indicates whether the stream can be read.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports reading.
            </remarks>
        </member>
        <member name="P:Ionic.BZip2.BZip2InputStream.CanSeek">
            <summary>
            Indicates whether the stream supports Seek operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:Ionic.BZip2.BZip2InputStream.CanWrite">
            <summary>
            Indicates whether the stream can be written.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports writing.
            </remarks>
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.Flush">
            <summary>
            Flush the stream.
            </summary>
        </member>
        <member name="P:Ionic.BZip2.BZip2InputStream.Length">
            <summary>
            Reading this property always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
        </member>
        <member name="P:Ionic.BZip2.BZip2InputStream.Position">
             <summary>
             The position of the stream pointer.
             </summary>
            
             <remarks>
               Setting this property always throws a <see
               cref="T:System.NotImplementedException"/>. Reading will return the
               total number of uncompressed bytes read in.
             </remarks>
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="offset">this is irrelevant, since it will always throw!</param>
            <param name="origin">this is irrelevant, since it will always throw!</param>
            <returns>irrelevant!</returns>
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.SetLength(System.Int64)">
            <summary>
            Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="value">this is irrelevant, since it will always throw!</param>
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
              Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name='buffer'>this parameter is never used</param>
            <param name='offset'>this parameter is never used</param>
            <param name='count'>this parameter is never used</param>
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.Dispose(System.Boolean)">
            <summary>
              Dispose the stream.
            </summary>
            <param name="disposing">
              indicates whether the Dispose method was invoked by user code.
            </param>
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.Close">
            <summary>
              Close the stream.
            </summary>
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.GetBits(System.Int32)">
            <summary>
              Read n bits from input, right justifying the result.
            </summary>
            <remarks>
              <para>
                For example, if you read 1 bit, the result is either 0
                or 1.
              </para>
            </remarks>
            <param name ="n">
              The number of bits to read, always between 1 and 32.
            </param>
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.hbCreateDecodeTables(System.Int32[],System.Int32[],System.Int32[],System.Char[],System.Int32,System.Int32,System.Int32)">
            Called by createHuffmanDecodingTables() exclusively.
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.createHuffmanDecodingTables(System.Int32,System.Int32)">
            Called by recvDecodingTables() exclusively.
        </member>
        <member name="F:Ionic.BZip2.BZip2InputStream.DecompressionState.unzftab">
            Freq table collected to save a pass over the data during
            decompression.
        </member>
        <member name="M:Ionic.BZip2.BZip2InputStream.DecompressionState.initTT(System.Int32)">
             Initializes the tt array.
            
             This method is called when the required length of the array is known.
             I don't initialize it at construction time to avoid unneccessary
             memory allocation when compressing small files.
        </member>
        <member name="F:Ionic.BZip2.BZip2Compressor.increments">
            Knuth's increments seem to work better than Incerpi-Sedgewick here.
            Possibly because the number of elems to sort is usually small, typically
            &lt;= 20.
        </member>
        <member name="M:Ionic.BZip2.BZip2Compressor.#ctor(Ionic.BZip2.BitWriter)">
            <summary>
              BZip2Compressor writes its compressed data out via a BitWriter. This
              is necessary because BZip2 does byte shredding.
            </summary>
        </member>
        <member name="P:Ionic.BZip2.BZip2Compressor.UncompressedBytes">
            <summary>
              The number of uncompressed bytes being held in the buffer.
            </summary>
            <remarks>
              <para>
                I am thinking this may be useful in a Stream that uses this
                compressor class. In the Close() method on the stream it could
                check this value to see if anything has been written at all.  You
                may think the stream could easily track the number of bytes it
                wrote, which would eliminate the need for this. But, there is the
                case where the stream writes a complete block, and it is full, and
                then writes no more. In that case the stream may want to check.
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.BZip2.BZip2Compressor.Fill(System.Byte[],System.Int32,System.Int32)">
            <summary>
              Accept new bytes into the compressor data buffer
            </summary>
            <remarks>
              <para>
                This method does the first-level (cheap) run-length encoding, and
                stores the encoded data into the rle block.
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.BZip2.BZip2Compressor.write0(System.Byte)">
             <summary>
               Process one input byte into the block.
             </summary>
            
             <remarks>
               <para>
                 To "process" the byte means to do the run-length encoding.
                 There are 3 possible return values:
            
                    0 - the byte was not written, in other words, not
                        encoded into the block. This happens when the
                        byte b would require the start of a new run, and
                        the block has no more room for new runs.
            
                    1 - the byte was written, and the block is not full.
            
                    2 - the byte was written, and the block is full.
            
               </para>
             </remarks>
             <returns>0 if the byte was not written, non-zero if written.</returns>
        </member>
        <member name="M:Ionic.BZip2.BZip2Compressor.AddRunToOutputBlock(System.Boolean)">
             <summary>
               Append one run to the output block.
             </summary>
            
             <remarks>
               <para>
                 This compressor does run-length-encoding before BWT and etc. This
                 method simply appends a run to the output block. The append always
                 succeeds. The return value indicates whether the block is full:
                 false (not full) implies that at least one additional run could be
                 processed.
               </para>
             </remarks>
             <returns>true if the block is now full; otherwise false.</returns>
        </member>
        <member name="M:Ionic.BZip2.BZip2Compressor.CompressAndWrite">
            <summary>
              Compress the data that has been placed (Run-length-encoded) into the
              block. The compressed data goes into the CompressedBytes array.
            </summary>
            <remarks>
              <para>
                Side effects: 1.  fills the CompressedBytes array.  2. sets the
                AvailableBytesOut property.
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.BZip2.BZip2Compressor.mainSimpleSort(Ionic.BZip2.BZip2Compressor.CompressionState,System.Int32,System.Int32,System.Int32)">
             This is the most hammered method of this class.
            
             <p>
             This is the version using unrolled loops.
             </p>
        </member>
        <member name="M:Ionic.BZip2.BZip2Compressor.mainQSort3(Ionic.BZip2.BZip2Compressor.CompressionState,System.Int32,System.Int32,System.Int32)">
            Method "mainQSort3", file "blocksort.c", BZip2 1.0.2
        </member>
        <member name="F:Ionic.BZip2.BZip2Compressor.CompressionState.quadrant">
            Array instance identical to sfmap, both are used only
            temporarily and independently, so we do not need to allocate
            additional memory.
        </member>
        <member name="M:Ionic.BZip2.Rand.Rnums(System.Int32)">
            <summary>
              Returns the "random" number at a specific index.
            </summary>
            <param name='i'>the index</param>
            <returns>the random number</returns>
        </member>
        <member name="T:Ionic.Crc.CRC32">
            <summary>
              Computes a CRC-32. The CRC-32 algorithm is parameterized - you
              can set the polynomial and enable or disable bit
              reversal. This can be used for GZIP, BZip2, or ZIP.
            </summary>
            <remarks>
              This type is used internally by DotNetZip; it is generally not used
              directly by applications wishing to create, read, or manipulate zip
              archive files.
            </remarks>
        </member>
        <member name="P:Ionic.Crc.CRC32.TotalBytesRead">
            <summary>
              Indicates the total number of bytes applied to the CRC.
            </summary>
        </member>
        <member name="P:Ionic.Crc.CRC32.Crc32Result">
            <summary>
            Indicates the current CRC for all blocks slurped in.
            </summary>
        </member>
        <member name="M:Ionic.Crc.CRC32.GetCrc32(System.IO.Stream)">
            <summary>
            Returns the CRC32 for the specified stream.
            </summary>
            <param name="input">The stream over which to calculate the CRC32</param>
            <returns>the CRC32 calculation</returns>
        </member>
        <member name="M:Ionic.Crc.CRC32.GetCrc32AndCopy(System.IO.Stream,System.IO.Stream)">
            <summary>
            Returns the CRC32 for the specified stream, and writes the input into the
            output stream.
            </summary>
            <param name="input">The stream over which to calculate the CRC32</param>
            <param name="output">The stream into which to deflate the input</param>
            <returns>the CRC32 calculation</returns>
        </member>
        <member name="M:Ionic.Crc.CRC32.ComputeCrc32(System.Int32,System.Byte)">
            <summary>
              Get the CRC32 for the given (word,byte) combo.  This is a
              computation defined by PKzip for PKZIP 2.0 (weak) encryption.
            </summary>
            <param name="W">The word to start with.</param>
            <param name="B">The byte to combine it with.</param>
            <returns>The CRC-ized result.</returns>
        </member>
        <member name="M:Ionic.Crc.CRC32.SlurpBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the value for the running CRC32 using the given block of bytes.
            This is useful when using the CRC32() class in a Stream.
            </summary>
            <param name="block">block of bytes to slurp</param>
            <param name="offset">starting point in the block</param>
            <param name="count">how many bytes within the block to slurp</param>
        </member>
        <member name="M:Ionic.Crc.CRC32.UpdateCRC(System.Byte)">
            <summary>
              Process one byte in the CRC.
            </summary>
            <param name = "b">the byte to include into the CRC .  </param>
        </member>
        <member name="M:Ionic.Crc.CRC32.UpdateCRC(System.Byte,System.Int32)">
            <summary>
              Process a run of N identical bytes into the CRC.
            </summary>
            <remarks>
              <para>
                This method serves as an optimization for updating the CRC when a
                run of identical bytes is found. Rather than passing in a buffer of
                length n, containing all identical bytes b, this method accepts the
                byte value and the length of the (virtual) buffer - the length of
                the run.
              </para>
            </remarks>
            <param name = "b">the byte to include into the CRC.  </param>
            <param name = "n">the number of times that byte should be repeated. </param>
        </member>
        <member name="M:Ionic.Crc.CRC32.Combine(System.Int32,System.Int32)">
            <summary>
              Combines the given CRC32 value with the current running total.
            </summary>
            <remarks>
              This is useful when using a divide-and-conquer approach to
              calculating a CRC.  Multiple threads can each calculate a
              CRC32 on a segment of the data, and then combine the
              individual CRC32 values at the end.
            </remarks>
            <param name="crc">the crc value to be combined with this one</param>
            <param name="length">the length of data the CRC value was calculated on</param>
        </member>
        <member name="M:Ionic.Crc.CRC32.#ctor">
            <summary>
              Create an instance of the CRC32 class using the default settings: no
              bit reversal, and a polynomial of 0xEDB88320.
            </summary>
        </member>
        <member name="M:Ionic.Crc.CRC32.#ctor(System.Boolean)">
            <summary>
              Create an instance of the CRC32 class, specifying whether to reverse
              data bits or not.
            </summary>
            <param name='reverseBits'>
              specify true if the instance should reverse data bits.
            </param>
            <remarks>
              <para>
                In the CRC-32 used by BZip2, the bits are reversed. Therefore if you
                want a CRC32 with compatibility with BZip2, you should pass true
                here. In the CRC-32 used by GZIP and PKZIP, the bits are not
                reversed; Therefore if you want a CRC32 with compatibility with
                those, you should pass false.
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.Crc.CRC32.#ctor(System.Int32,System.Boolean)">
             <summary>
               Create an instance of the CRC32 class, specifying the polynomial and
               whether to reverse data bits or not.
             </summary>
             <param name='polynomial'>
               The polynomial to use for the CRC, expressed in the reversed (LSB)
               format: the highest ordered bit in the polynomial value is the
               coefficient of the 0th power; the second-highest order bit is the
               coefficient of the 1 power, and so on. Expressed this way, the
               polynomial for the CRC-32C used in IEEE 802.3, is 0xEDB88320.
             </param>
             <param name='reverseBits'>
               specify true if the instance should reverse data bits.
             </param>
            
             <remarks>
               <para>
                 In the CRC-32 used by BZip2, the bits are reversed. Therefore if you
                 want a CRC32 with compatibility with BZip2, you should pass true
                 here for the <c>reverseBits</c> parameter. In the CRC-32 used by
                 GZIP and PKZIP, the bits are not reversed; Therefore if you want a
                 CRC32 with compatibility with those, you should pass false for the
                 <c>reverseBits</c> parameter.
               </para>
             </remarks>
        </member>
        <member name="M:Ionic.Crc.CRC32.Reset">
            <summary>
              Reset the CRC-32 class - clear the CRC "remainder register."
            </summary>
            <remarks>
              <para>
                Use this when employing a single instance of this class to compute
                multiple, distinct CRCs on multiple, distinct data blocks.
              </para>
            </remarks>
        </member>
        <member name="T:Ionic.Crc.CrcCalculatorStream">
             <summary>
             A Stream that calculates a CRC32 (a checksum) on all bytes read,
             or on all bytes written.
             </summary>
            
             <remarks>
             <para>
             This class can be used to verify the CRC of a ZipEntry when
             reading from a stream, or to calculate a CRC when writing to a
             stream.  The stream should be used to either read, or write, but
             not both.  If you intermix reads and writes, the results are not
             defined.
             </para>
            
             <para>
             This class is intended primarily for use internally by the
             DotNetZip library.
             </para>
             </remarks>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.#ctor(System.IO.Stream)">
            <summary>
            The default constructor.
            </summary>
            <remarks>
              <para>
                Instances returned from this constructor will leave the underlying
                stream open upon Close().  The stream uses the default CRC32
                algorithm, which implies a polynomial of 0xEDB88320.
              </para>
            </remarks>
            <param name="stream">The underlying stream</param>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.#ctor(System.IO.Stream,System.Boolean)">
            <summary>
              The constructor allows the caller to specify how to handle the
              underlying stream at close.
            </summary>
            <remarks>
              <para>
                The stream uses the default CRC32 algorithm, which implies a
                polynomial of 0xEDB88320.
              </para>
            </remarks>
            <param name="stream">The underlying stream</param>
            <param name="leaveOpen">true to leave the underlying stream
            open upon close of the <c>CrcCalculatorStream</c>; false otherwise.</param>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.#ctor(System.IO.Stream,System.Int64)">
            <summary>
              A constructor allowing the specification of the length of the stream
              to read.
            </summary>
            <remarks>
              <para>
                The stream uses the default CRC32 algorithm, which implies a
                polynomial of 0xEDB88320.
              </para>
              <para>
                Instances returned from this constructor will leave the underlying
                stream open upon Close().
              </para>
            </remarks>
            <param name="stream">The underlying stream</param>
            <param name="length">The length of the stream to slurp</param>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.#ctor(System.IO.Stream,System.Int64,System.Boolean)">
            <summary>
              A constructor allowing the specification of the length of the stream
              to read, as well as whether to keep the underlying stream open upon
              Close().
            </summary>
            <remarks>
              <para>
                The stream uses the default CRC32 algorithm, which implies a
                polynomial of 0xEDB88320.
              </para>
            </remarks>
            <param name="stream">The underlying stream</param>
            <param name="length">The length of the stream to slurp</param>
            <param name="leaveOpen">true to leave the underlying stream
            open upon close of the <c>CrcCalculatorStream</c>; false otherwise.</param>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.#ctor(System.IO.Stream,System.Int64,System.Boolean,Ionic.Crc.CRC32)">
            <summary>
              A constructor allowing the specification of the length of the stream
              to read, as well as whether to keep the underlying stream open upon
              Close(), and the CRC32 instance to use.
            </summary>
            <remarks>
              <para>
                The stream uses the specified CRC32 instance, which allows the
                application to specify how the CRC gets calculated.
              </para>
            </remarks>
            <param name="stream">The underlying stream</param>
            <param name="length">The length of the stream to slurp</param>
            <param name="leaveOpen">true to leave the underlying stream
            open upon close of the <c>CrcCalculatorStream</c>; false otherwise.</param>
            <param name="crc32">the CRC32 instance to use to calculate the CRC32</param>
        </member>
        <member name="P:Ionic.Crc.CrcCalculatorStream.TotalBytesSlurped">
             <summary>
               Gets the total number of bytes run through the CRC32 calculator.
             </summary>
            
             <remarks>
               This is either the total number of bytes read, or the total number of
               bytes written, depending on the direction of this stream.
             </remarks>
        </member>
        <member name="P:Ionic.Crc.CrcCalculatorStream.Crc">
            <summary>
              Provides the current CRC for all blocks slurped in.
            </summary>
            <remarks>
              <para>
                The running total of the CRC is kept as data is written or read
                through the stream.  read this property after all reads or writes to
                get an accurate CRC for the entire stream.
              </para>
            </remarks>
        </member>
        <member name="P:Ionic.Crc.CrcCalculatorStream.LeaveOpen">
            <summary>
              Indicates whether the underlying stream will be left open when the
              <c>CrcCalculatorStream</c> is Closed.
            </summary>
            <remarks>
              <para>
                Set this at any point before calling <see cref="M:Ionic.Crc.CrcCalculatorStream.Close"/>.
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read from the stream
            </summary>
            <param name="buffer">the buffer to read</param>
            <param name="offset">the offset at which to start</param>
            <param name="count">the number of bytes to read</param>
            <returns>the number of bytes actually read</returns>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Write to the stream.
            </summary>
            <param name="buffer">the buffer from which to write</param>
            <param name="offset">the offset at which to start writing</param>
            <param name="count">the number of bytes to write</param>
        </member>
        <member name="P:Ionic.Crc.CrcCalculatorStream.CanRead">
            <summary>
            Indicates whether the stream supports reading.
            </summary>
        </member>
        <member name="P:Ionic.Crc.CrcCalculatorStream.CanSeek">
            <summary>
              Indicates whether the stream supports seeking.
            </summary>
            <remarks>
              <para>
                Always returns false.
              </para>
            </remarks>
        </member>
        <member name="P:Ionic.Crc.CrcCalculatorStream.CanWrite">
            <summary>
            Indicates whether the stream supports writing.
            </summary>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.Flush">
            <summary>
            Flush the stream.
            </summary>
        </member>
        <member name="P:Ionic.Crc.CrcCalculatorStream.Length">
            <summary>
              Returns the length of the underlying stream.
            </summary>
        </member>
        <member name="P:Ionic.Crc.CrcCalculatorStream.Position">
            <summary>
              The getter for this property returns the total bytes read.
              If you use the setter, it will throw
            <see cref="T:System.NotSupportedException"/>.
            </summary>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Seeking is not supported on this stream. This method always throws
            <see cref="T:System.NotSupportedException"/>
            </summary>
            <param name="offset">N/A</param>
            <param name="origin">N/A</param>
            <returns>N/A</returns>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.SetLength(System.Int64)">
            <summary>
            This method always throws
            <see cref="T:System.NotSupportedException"/>
            </summary>
            <param name="value">N/A</param>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.Close">
            <summary>
            Closes the stream.
            </summary>
        </member>
        <member name="T:Ionic.Zip.ComHelper">
            <summary>
            This class exposes a set of COM-accessible wrappers for static
            methods available on the ZipFile class.  You don't need this
            class unless you are using DotNetZip from a COM environment.
            </summary>
        </member>
        <member name="M:Ionic.Zip.ComHelper.IsZipFile(System.String)">
            <summary>
             A wrapper for <see cref="M:Ionic.Zip.ZipFile.IsZipFile(System.String)">ZipFile.IsZipFile(string)</see>
            </summary>
            <param name="filename">The filename to of the zip file to check.</param>
            <returns>true if the file contains a valid zip file.</returns>
        </member>
        <member name="M:Ionic.Zip.ComHelper.IsZipFileWithExtract(System.String)">
            <summary>
             A wrapper for <see cref="M:Ionic.Zip.ZipFile.IsZipFile(System.String,System.Boolean)">ZipFile.IsZipFile(string, bool)</see>
            </summary>
            <remarks>
            We cannot use "overloaded" Method names in COM interop.
            So, here, we use a unique name.
            </remarks>
            <param name="filename">The filename to of the zip file to check.</param>
            <returns>true if the file contains a valid zip file.</returns>
        </member>
        <member name="M:Ionic.Zip.ComHelper.CheckZip(System.String)">
             <summary>
              A wrapper for <see cref="M:Ionic.Zip.ZipFile.CheckZip(System.String)">ZipFile.CheckZip(string)</see>
             </summary>
             <param name="filename">The filename to of the zip file to check.</param>
            
             <returns>true if the named zip file checks OK. Otherwise, false. </returns>
        </member>
        <member name="M:Ionic.Zip.ComHelper.CheckZipPassword(System.String,System.String)">
             <summary>
              A COM-friendly wrapper for the static method <see cref="M:Ionic.Zip.ZipFile.CheckZipPassword(System.String,System.String)"/>.
             </summary>
            
             <param name="filename">The filename to of the zip file to check.</param>
            
             <param name="password">The password to check.</param>
            
             <returns>true if the named zip file checks OK. Otherwise, false. </returns>
        </member>
        <member name="M:Ionic.Zip.ComHelper.FixZipDirectory(System.String)">
            <summary>
             A wrapper for <see cref="M:Ionic.Zip.ZipFile.FixZipDirectory(System.String)">ZipFile.FixZipDirectory(string)</see>
            </summary>
            <param name="filename">The filename to of the zip file to fix.</param>
        </member>
        <member name="M:Ionic.Zip.ComHelper.GetZipLibraryVersion">
            <summary>
             A wrapper for <see cref="P:Ionic.Zip.ZipFile.LibraryVersion">ZipFile.LibraryVersion</see>
            </summary>
            <returns>
             the version number on the DotNetZip assembly, formatted as a string.
            </returns>
        </member>
        <member name="T:Ionic.Zip.EncryptionAlgorithm">
             <summary>
             An enum that provides the various encryption algorithms supported by this
             library.
             </summary>
            
             <remarks>
            
             <para>
               <c>PkzipWeak</c> implies the use of Zip 2.0 encryption, which is known to be
               weak and subvertible.
             </para>
            
             <para>
               A note on interoperability: Values of <c>PkzipWeak</c> and <c>None</c> are
               specified in <see
               href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWARE's zip
               specification</see>, and are considered to be "standard".  Zip archives
               produced using these options will be interoperable with many other zip tools
               and libraries, including Windows Explorer.
             </para>
            
             <para>
               Values of <c>WinZipAes128</c> and <c>WinZipAes256</c> are not part of the Zip
               specification, but rather imply the use of a vendor-specific extension from
               WinZip. If you want to produce interoperable Zip archives, do not use these
               values.  For example, if you produce a zip archive using WinZipAes256, you
               will be able to open it in Windows Explorer on Windows XP and Vista, but you
               will not be able to extract entries; trying this will lead to an "unspecified
               error". For this reason, some people have said that a zip archive that uses
               WinZip's AES encryption is not actually a zip archive at all.  A zip archive
               produced this way will be readable with the WinZip tool (Version 11 and
               beyond).
             </para>
            
             <para>
               There are other third-party tools and libraries, both commercial and
               otherwise, that support WinZip's AES encryption. These will be able to read
               AES-encrypted zip archives produced by DotNetZip, and conversely applications
               that use DotNetZip to read zip archives will be able to read AES-encrypted
               archives produced by those tools or libraries.  Consult the documentation for
               those other tools and libraries to find out if WinZip's AES encryption is
               supported.
             </para>
            
             <para>
               In case you care: According to <see
               href="http://www.winzip.com/aes_info.htm">the WinZip specification</see>, the
               actual AES key used is derived from the <see cref="P:Ionic.Zip.ZipEntry.Password"/> via an
               algorithm that complies with <see
               href="http://www.ietf.org/rfc/rfc2898.txt">RFC 2898</see>, using an iteration
               count of 1000.  The algorithm is sometimes referred to as PBKDF2, which stands
               for "Password Based Key Derivation Function #2".
             </para>
            
             <para>
               A word about password strength and length: The AES encryption technology is
               very good, but any system is only as secure as the weakest link.  If you want
               to secure your data, be sure to use a password that is hard to guess.  To make
               it harder to guess (increase its "entropy"), you should make it longer.  If
               you use normal characters from an ASCII keyboard, a password of length 20 will
               be strong enough that it will be impossible to guess.  For more information on
               that, I'd encourage you to read <see
               href="http://www.redkestrel.co.uk/Articles/RandomPasswordStrength.html">this
               article.</see>
             </para>
            
             <para>
               The WinZip AES algorithms are not supported with the version of DotNetZip that
               runs on the .NET Compact Framework.  This is because .NET CF lacks the
               HMACSHA1 class that is required for producing the archive.
             </para>
             </remarks>
        </member>
        <member name="F:Ionic.Zip.EncryptionAlgorithm.None">
            <summary>
            No encryption at all.
            </summary>
        </member>
        <member name="F:Ionic.Zip.EncryptionAlgorithm.PkzipWeak">
            <summary>
            Traditional or Classic pkzip encryption.
            </summary>
        </member>
        <member name="F:Ionic.Zip.EncryptionAlgorithm.Unsupported">
            <summary>
            An encryption algorithm that is not supported by DotNetZip.
            </summary>
        </member>
        <member name="T:Ionic.Zip.WriteDelegate">
             <summary>
               Delegate in which the application writes the <c>ZipEntry</c> content for the named entry.
             </summary>
            
             <param name="entryName">The name of the entry that must be written.</param>
             <param name="stream">The stream to which the entry data should be written.</param>
            
             <remarks>
               When you add an entry and specify a <c>WriteDelegate</c>, via <see
               cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,Ionic.Zip.WriteDelegate)"/>, the application
               code provides the logic that writes the entry data directly into the zip file.
             </remarks>
            
             <example>
            
             This example shows how to define a WriteDelegate that obtains a DataSet, and then
             writes the XML for the DataSet into the zip archive.  There's no need to
             save the XML to a disk file first.
            
             <code lang="C#">
             private void WriteEntry (String filename, Stream output)
             {
                 DataSet ds1 = ObtainDataSet();
                 ds1.WriteXml(output);
             }
            
             private void Run()
             {
                 using (var zip = new ZipFile())
                 {
                     zip.AddEntry(zipEntryName, WriteEntry);
                     zip.Save(zipFileName);
                 }
             }
             </code>
            
             <code lang="vb">
             Private Sub WriteEntry (ByVal filename As String, ByVal output As Stream)
                 DataSet ds1 = ObtainDataSet()
                 ds1.WriteXml(stream)
             End Sub
            
             Public Sub Run()
                 Using zip = New ZipFile
                     zip.AddEntry(zipEntryName, New WriteDelegate(AddressOf WriteEntry))
                     zip.Save(zipFileName)
                 End Using
             End Sub
             </code>
             </example>
             <seealso cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,Ionic.Zip.WriteDelegate)"/>
        </member>
        <member name="T:Ionic.Zip.OpenDelegate">
             <summary>
               Delegate in which the application opens the stream, just-in-time, for the named entry.
             </summary>
            
             <param name="entryName">
             The name of the ZipEntry that the application should open the stream for.
             </param>
            
             <remarks>
               When you add an entry via <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,Ionic.Zip.OpenDelegate,Ionic.Zip.CloseDelegate)"/>, the application code provides the logic that
               opens and closes the stream for the given ZipEntry.
             </remarks>
            
             <seealso cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,Ionic.Zip.OpenDelegate,Ionic.Zip.CloseDelegate)"/>
        </member>
        <member name="T:Ionic.Zip.CloseDelegate">
             <summary>
               Delegate in which the application closes the stream, just-in-time, for the named entry.
             </summary>
            
             <param name="entryName">
             The name of the ZipEntry that the application should close the stream for.
             </param>
            
             <param name="stream">The stream to be closed.</param>
            
             <remarks>
               When you add an entry via <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,Ionic.Zip.OpenDelegate,Ionic.Zip.CloseDelegate)"/>, the application code provides the logic that
               opens and closes the stream for the given ZipEntry.
             </remarks>
            
             <seealso cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,Ionic.Zip.OpenDelegate,Ionic.Zip.CloseDelegate)"/>
        </member>
        <member name="T:Ionic.Zip.SetCompressionCallback">
             <summary>
               Delegate for the callback by which the application tells the
               library the CompressionLevel to use for a file.
             </summary>
            
             <remarks>
             <para>
               Using this callback, the application can, for example, specify that
               previously-compressed files (.mp3, .png, .docx, etc) should use a
               <c>CompressionLevel</c> of <c>None</c>, or can set the compression level based
               on any other factor.
             </para>
             </remarks>
             <seealso cref="P:Ionic.Zip.ZipFile.SetCompression"/>
        </member>
        <member name="T:Ionic.Zip.ZipProgressEventType">
            <summary>
              In an EventArgs type, indicates which sort of progress event is being
              reported.
            </summary>
            <remarks>
              There are events for reading, events for saving, and events for
              extracting. This enumeration allows a single EventArgs type to be sued to
              describe one of multiple subevents. For example, a SaveProgress event is
              invoked before, after, and during the saving of a single entry.  The value
              of an enum with this type, specifies which event is being triggered.  The
              same applies to Extraction, Reading and Adding events.
            </remarks>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Adding_Started">
            <summary>
            Indicates that a Add() operation has started.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Adding_AfterAddEntry">
            <summary>
            Indicates that an individual entry in the archive has been added.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Adding_Completed">
            <summary>
            Indicates that a Add() operation has completed.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Reading_Started">
            <summary>
            Indicates that a Read() operation has started.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Reading_BeforeReadEntry">
            <summary>
            Indicates that an individual entry in the archive is about to be read.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Reading_AfterReadEntry">
            <summary>
            Indicates that an individual entry in the archive has just been read.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Reading_Completed">
            <summary>
            Indicates that a Read() operation has completed.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Reading_ArchiveBytesRead">
            <summary>
            The given event reports the number of bytes read so far
            during a Read() operation.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Saving_Started">
            <summary>
            Indicates that a Save() operation has started.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Saving_BeforeWriteEntry">
            <summary>
            Indicates that an individual entry in the archive is about to be written.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Saving_AfterWriteEntry">
            <summary>
            Indicates that an individual entry in the archive has just been saved.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Saving_Completed">
            <summary>
            Indicates that a Save() operation has completed.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Saving_AfterSaveTempArchive">
            <summary>
            Indicates that the zip archive has been created in a
            temporary location during a Save() operation.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Saving_BeforeRenameTempArchive">
            <summary>
            Indicates that the temporary file is about to be renamed to the final archive
            name during a Save() operation.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Saving_AfterRenameTempArchive">
            <summary>
            Indicates that the temporary file is has just been renamed to the final archive
            name during a Save() operation.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Saving_AfterCompileSelfExtractor">
            <summary>
            Indicates that the self-extracting archive has been compiled
            during a Save() operation.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Saving_EntryBytesRead">
            <summary>
            The given event is reporting the number of source bytes that have run through the compressor so far
            during a Save() operation.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Extracting_BeforeExtractEntry">
            <summary>
            Indicates that an entry is about to be extracted.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Extracting_AfterExtractEntry">
            <summary>
            Indicates that an entry has just been extracted.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Extracting_ExtractEntryWouldOverwrite">
            <summary>
              Indicates that extraction of an entry would overwrite an existing
              filesystem file. You must use
              <see cref="F:Ionic.Zip.ExtractExistingFileAction.InvokeExtractProgressEvent">
              ExtractExistingFileAction.InvokeExtractProgressEvent</see> in the call
              to <c>ZipEntry.Extract()</c> in order to receive this event.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Extracting_EntryBytesWritten">
            <summary>
              The given event is reporting the number of bytes written so far for
              the current entry during an Extract() operation.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Extracting_BeforeExtractAll">
            <summary>
            Indicates that an ExtractAll operation is about to begin.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Extracting_AfterExtractAll">
            <summary>
            Indicates that an ExtractAll operation has completed.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Error_Saving">
            <summary>
            Indicates that an error has occurred while saving a zip file.
            This generally means the file cannot be opened, because it has been
            removed, or because it is locked by another process.  It can also
            mean that the file cannot be Read, because of a range lock conflict.
            </summary>
        </member>
        <member name="T:Ionic.Zip.ZipProgressEventArgs">
            <summary>
            Provides information about the progress of a save, read, or extract operation.
            This is a base class; you will probably use one of the classes derived from this one.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipProgressEventArgs.EntriesTotal">
            <summary>
            The total number of entries to be saved or extracted.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipProgressEventArgs.CurrentEntry">
            <summary>
            The name of the last entry saved or extracted.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipProgressEventArgs.Cancel">
            <summary>
            In an event handler, set this to cancel the save or extract
            operation that is in progress.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipProgressEventArgs.EventType">
            <summary>
            The type of event being reported.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipProgressEventArgs.ArchiveName">
            <summary>
            Returns the archive name associated to this event.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipProgressEventArgs.BytesTransferred">
            <summary>
            The number of bytes read or written so far for this entry.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipProgressEventArgs.TotalBytesToTransfer">
            <summary>
            Total number of bytes that will be read or written for this entry.
            This number will be -1 if the value cannot be determined.
            </summary>
        </member>
        <member name="T:Ionic.Zip.ReadProgressEventArgs">
            <summary>
            Provides information about the progress of a Read operation.
            </summary>
        </member>
        <member name="T:Ionic.Zip.AddProgressEventArgs">
            <summary>
            Provides information about the progress of a Add operation.
            </summary>
        </member>
        <member name="T:Ionic.Zip.SaveProgressEventArgs">
            <summary>
            Provides information about the progress of a save operation.
            </summary>
        </member>
        <member name="M:Ionic.Zip.SaveProgressEventArgs.#ctor(System.String,System.Boolean,System.Int32,System.Int32,Ionic.Zip.ZipEntry)">
            <summary>
            Constructor for the SaveProgressEventArgs.
            </summary>
            <param name="archiveName">the name of the zip archive.</param>
            <param name="before">whether this is before saving the entry, or after</param>
            <param name="entriesTotal">The total number of entries in the zip archive.</param>
            <param name="entriesSaved">Number of entries that have been saved.</param>
            <param name="entry">The entry involved in the event.</param>
        </member>
        <member name="P:Ionic.Zip.SaveProgressEventArgs.EntriesSaved">
            <summary>
            Number of entries saved so far.
            </summary>
        </member>
        <member name="T:Ionic.Zip.ExtractProgressEventArgs">
            <summary>
            Provides information about the progress of the extract operation.
            </summary>
        </member>
        <member name="M:Ionic.Zip.ExtractProgressEventArgs.#ctor(System.String,System.Boolean,System.Int32,System.Int32,Ionic.Zip.ZipEntry,System.String)">
            <summary>
            Constructor for the ExtractProgressEventArgs.
            </summary>
            <param name="archiveName">the name of the zip archive.</param>
            <param name="before">whether this is before saving the entry, or after</param>
            <param name="entriesTotal">The total number of entries in the zip archive.</param>
            <param name="entriesExtracted">Number of entries that have been extracted.</param>
            <param name="entry">The entry involved in the event.</param>
            <param name="extractLocation">The location to which entries are extracted.</param>
        </member>
        <member name="P:Ionic.Zip.ExtractProgressEventArgs.EntriesExtracted">
            <summary>
            Number of entries extracted so far.  This is set only if the
            EventType is Extracting_BeforeExtractEntry or Extracting_AfterExtractEntry, and
            the Extract() is occurring witin the scope of a call to ExtractAll().
            </summary>
        </member>
        <member name="P:Ionic.Zip.ExtractProgressEventArgs.ExtractLocation">
            <summary>
            Returns the extraction target location, a filesystem path.
            </summary>
        </member>
        <member name="T:Ionic.Zip.ZipErrorEventArgs">
            <summary>
            Provides information about the an error that occurred while zipping.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipErrorEventArgs.Exception">
            <summary>
            Returns the exception that occurred, if any.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipErrorEventArgs.FileName">
            <summary>
            Returns the name of the file that caused the exception, if any.
            </summary>
        </member>
        <member name="T:Ionic.Zip.BadPasswordException">
            <summary>
            Issued when an <c>ZipEntry.ExtractWithPassword()</c> method is invoked
            with an incorrect password.
            </summary>
        </member>
        <member name="M:Ionic.Zip.BadPasswordException.#ctor">
            <summary>
            Default ctor.
            </summary>
        </member>
        <member name="M:Ionic.Zip.BadPasswordException.#ctor(System.String)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
        </member>
        <member name="M:Ionic.Zip.BadPasswordException.#ctor(System.String,System.Exception)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
            <param name="innerException">The innerException for this exception.</param>
        </member>
        <member name="M:Ionic.Zip.BadPasswordException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="info">The serialization info for the exception.</param>
            <param name="context">The streaming context from which to deserialize.</param>
        </member>
        <member name="T:Ionic.Zip.BadReadException">
            <summary>
            Indicates that a read was attempted on a stream, and bad or incomplete data was
            received.
            </summary>
        </member>
        <member name="M:Ionic.Zip.BadReadException.#ctor">
            <summary>
            Default ctor.
            </summary>
        </member>
        <member name="M:Ionic.Zip.BadReadException.#ctor(System.String)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
        </member>
        <member name="M:Ionic.Zip.BadReadException.#ctor(System.String,System.Exception)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
            <param name="innerException">The innerException for this exception.</param>
        </member>
        <member name="M:Ionic.Zip.BadReadException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="info">The serialization info for the exception.</param>
            <param name="context">The streaming context from which to deserialize.</param>
        </member>
        <member name="T:Ionic.Zip.BadCrcException">
            <summary>
            Issued when an CRC check fails upon extracting an entry from a zip archive.
            </summary>
        </member>
        <member name="M:Ionic.Zip.BadCrcException.#ctor">
            <summary>
            Default ctor.
            </summary>
        </member>
        <member name="M:Ionic.Zip.BadCrcException.#ctor(System.String)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
        </member>
        <member name="M:Ionic.Zip.BadCrcException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="info">The serialization info for the exception.</param>
            <param name="context">The streaming context from which to deserialize.</param>
        </member>
        <member name="T:Ionic.Zip.SfxGenerationException">
            <summary>
            Issued when errors occur saving a self-extracting archive.
            </summary>
        </member>
        <member name="M:Ionic.Zip.SfxGenerationException.#ctor">
            <summary>
            Default ctor.
            </summary>
        </member>
        <member name="M:Ionic.Zip.SfxGenerationException.#ctor(System.String)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
        </member>
        <member name="M:Ionic.Zip.SfxGenerationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="info">The serialization info for the exception.</param>
            <param name="context">The streaming context from which to deserialize.</param>
        </member>
        <member name="T:Ionic.Zip.BadStateException">
            <summary>
            Indicates that an operation was attempted on a ZipFile which was not possible
            given the state of the instance. For example, if you call <c>Save()</c> on a ZipFile
            which has no filename set, you can get this exception.
            </summary>
        </member>
        <member name="M:Ionic.Zip.BadStateException.#ctor">
            <summary>
            Default ctor.
            </summary>
        </member>
        <member name="M:Ionic.Zip.BadStateException.#ctor(System.String)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
        </member>
        <member name="M:Ionic.Zip.BadStateException.#ctor(System.String,System.Exception)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
            <param name="innerException">The innerException for this exception.</param>
        </member>
        <member name="M:Ionic.Zip.BadStateException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="info">The serialization info for the exception.</param>
            <param name="context">The streaming context from which to deserialize.</param>
        </member>
        <member name="T:Ionic.Zip.ZipException">
            <summary>
            Base class for all exceptions defined by and throw by the Zip library.
            </summary>
        </member>
        <member name="M:Ionic.Zip.ZipException.#ctor">
            <summary>
            Default ctor.
            </summary>
        </member>
        <member name="M:Ionic.Zip.ZipException.#ctor(System.String)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
        </member>
        <member name="M:Ionic.Zip.ZipException.#ctor(System.String,System.Exception)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
            <param name="innerException">The innerException for this exception.</param>
        </member>
        <member name="M:Ionic.Zip.ZipException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="info">The serialization info for the exception.</param>
            <param name="context">The streaming context from which to deserialize.</param>
        </member>
        <member name="T:Ionic.Zip.ExtractExistingFileAction">
             <summary>
             An enum for the options when extracting an entry would overwrite an existing file. 
             </summary>
             
             <remarks>
               <para>
                 This enum describes the actions that the library can take when an
                 <c>Extract()</c> or <c>ExtractWithPassword()</c> method is called to extract an
                 entry to a filesystem, and the extraction would overwrite an existing filesystem
                 file.
               </para>
             </remarks>
            
        </member>
        <member name="F:Ionic.Zip.ExtractExistingFileAction.Throw">
            <summary>
            Throw an exception when extraction would overwrite an existing file. (For
            COM clients, this is a 0 (zero).)
            </summary>
        </member>
        <member name="F:Ionic.Zip.ExtractExistingFileAction.OverwriteSilently">
            <summary>
            When extraction would overwrite an existing file, overwrite the file silently.
            The overwrite will happen even if the target file is marked as read-only.
            (For COM clients, this is a 1.)
            </summary>
        </member>
        <member name="F:Ionic.Zip.ExtractExistingFileAction.DoNotOverwrite">
            <summary>
            When extraction would overwrite an existing file, don't overwrite the file, silently. 
            (For COM clients, this is a 2.)
            </summary>
        </member>
        <member name="F:Ionic.Zip.ExtractExistingFileAction.InvokeExtractProgressEvent">
            <summary>
            When extraction would overwrite an existing file, invoke the ExtractProgress
            event, using an event type of <see
            cref="F:Ionic.Zip.ZipProgressEventType.Extracting_ExtractEntryWouldOverwrite"/>.  In
            this way, the application can decide, just-in-time, whether to overwrite the
            file. For example, a GUI application may wish to pop up a dialog to allow
            the user to choose. You may want to examine the <see
            cref="P:Ionic.Zip.ExtractProgressEventArgs.ExtractLocation"/> property before making
            the decision. If, after your processing in the Extract progress event, you
            want to NOT extract the file, set <see cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile"/>
            on the <c>ZipProgressEventArgs.CurrentEntry</c> to <c>DoNotOverwrite</c>.
            If you do want to extract the file, set <c>ZipEntry.ExtractExistingFile</c>
            to <c>OverwriteSilently</c>.  If you want to cancel the Extraction, set
            <c>ZipProgressEventArgs.Cancel</c> to true.  Cancelling differs from using
            DoNotOverwrite in that a cancel will not extract any further entries, if
            there are any.  (For COM clients, the value of this enum is a 3.)
            </summary>
        </member>
        <member name="T:Ionic.Zip.SharedUtilities">
            <summary>
            Collects general purpose utility methods.
            </summary>
        </member>
        <member name="M:Ionic.Zip.SharedUtilities.GetFileLength(System.String)">
            private null constructor
        </member>
        <member name="M:Ionic.Zip.SharedUtilities.NormalizePathForUseInZipFile(System.String)">
            <summary>
            Utility routine for transforming path names from filesystem format (on Windows that means backslashes) to
            a format suitable for use within zipfiles. This means trimming the volume letter and colon (if any) And
            swapping backslashes for forward slashes.
            </summary>
            <param name="pathName">source path.</param>
            <returns>transformed path</returns>
        </member>
        <member name="M:Ionic.Zip.SharedUtilities.FindSignature(System.IO.Stream,System.Int32)">
             <summary>
               Finds a signature in the zip stream. This is useful for finding
               the end of a zip entry, for example, or the beginning of the next ZipEntry.
             </summary>
            
             <remarks>
               <para>
                 Scans through 64k at a time.
               </para>
            
               <para>
                 If the method fails to find the requested signature, the stream Position
                 after completion of this method is unchanged. If the method succeeds in
                 finding the requested signature, the stream position after completion is
                 direct AFTER the signature found in the stream.
               </para>
             </remarks>
            
             <param name="stream">The stream to search</param>
             <param name="SignatureToFind">The 4-byte signature to find</param>
             <returns>The number of bytes read</returns>
        </member>
        <member name="M:Ionic.Zip.SharedUtilities.CreateAndOpenUniqueTempFile(System.String,System.IO.Stream@,System.String@)">
            <summary>
              Create a pseudo-random filename, suitable for use as a temporary
              file, and open it.
            </summary>
            <remarks>
            <para>
              The System.IO.Path.GetRandomFileName() method is not available on
              the Compact Framework, so this library provides its own substitute
              on NETCF.
            </para>
            <para>
              This method produces a filename of the form
              DotNetZip-xxxxxxxx.tmp, where xxxxxxxx is replaced by randomly
              chosen characters, and creates that file.
            </para>
            </remarks>
        </member>
        <member name="M:Ionic.Zip.SharedUtilities.ReadWithRetry(System.IO.Stream,System.Byte[],System.Int32,System.Int32,System.String)">
            <summary>
            Workitem 7889: handle ERROR_LOCK_VIOLATION during read
            </summary>
            <remarks>
            This could be gracefully handled with an extension attribute, but
            This assembly is built for .NET 2.0, so I cannot use them.
            </remarks>
        </member>
        <member name="T:Ionic.Zip.CountingStream">
            <summary>
              A decorator stream. It wraps another stream, and performs bookkeeping
              to keep track of the stream Position.
            </summary>
            <remarks>
              <para>
                In some cases, it is not possible to get the Position of a stream, let's
                say, on a write-only output stream like ASP.NET's
                <c>Response.OutputStream</c>, or on a different write-only stream
                provided as the destination for the zip by the application.  In this
                case, programmers can use this counting stream to count the bytes read
                or written.
              </para>
              <para>
                Consider the scenario of an application that saves a self-extracting
                archive (SFX), that uses a custom SFX stub.
              </para>
              <para>
                Saving to a filesystem file, the application would open the
                filesystem file (getting a <c>FileStream</c>), save the custom sfx stub
                into it, and then call <c>ZipFile.Save()</c>, specifying the same
                FileStream. <c>ZipFile.Save()</c> does the right thing for the zipentry
                offsets, by inquiring the Position of the <c>FileStream</c> before writing
                any data, and then adding that initial offset into any ZipEntry
                offsets in the zip directory. Everything works fine.
              </para>
              <para>
                Now suppose the application is an ASPNET application and it saves
                directly to <c>Response.OutputStream</c>. It's not possible for DotNetZip to
                inquire the <c>Position</c>, so the offsets for the SFX will be wrong.
              </para>
              <para>
                The workaround is for the application to use this class to wrap
                <c>HttpResponse.OutputStream</c>, then write the SFX stub and the ZipFile
                into that wrapper stream. Because <c>ZipFile.Save()</c> can inquire the
                <c>Position</c>, it will then do the right thing with the offsets.
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.Zip.CountingStream.#ctor(System.IO.Stream)">
            <summary>
            The constructor.
            </summary>
            <param name="stream">The underlying stream</param>
        </member>
        <member name="P:Ionic.Zip.CountingStream.WrappedStream">
            <summary>
              Gets the wrapped stream.
            </summary>
        </member>
        <member name="P:Ionic.Zip.CountingStream.BytesWritten">
            <summary>
              The count of bytes written out to the stream.
            </summary>
        </member>
        <member name="P:Ionic.Zip.CountingStream.BytesRead">
            <summary>
              the count of bytes that have been read from the stream.
            </summary>
        </member>
        <member name="M:Ionic.Zip.CountingStream.Adjust(System.Int64)">
             <summary>
                Adjust the byte count on the stream.
             </summary>
            
             <param name='delta'>
               the number of bytes to subtract from the count.
             </param>
            
             <remarks>
               <para>
                 Subtract delta from the count of bytes written to the stream.
                 This is necessary when seeking back, and writing additional data,
                 as happens in some cases when saving Zip files.
               </para>
             </remarks>
        </member>
        <member name="M:Ionic.Zip.CountingStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
              The read method.
            </summary>
            <param name="buffer">The buffer to hold the data read from the stream.</param>
            <param name="offset">the offset within the buffer to copy the first byte read.</param>
            <param name="count">the number of bytes to read.</param>
            <returns>the number of bytes read, after decryption and decompression.</returns>
        </member>
        <member name="M:Ionic.Zip.CountingStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
              Write data into the stream.
            </summary>
            <param name="buffer">The buffer holding data to write to the stream.</param>
            <param name="offset">the offset within that data array to find the first byte to write.</param>
            <param name="count">the number of bytes to write.</param>
        </member>
        <member name="P:Ionic.Zip.CountingStream.CanRead">
            <summary>
              Whether the stream can be read.
            </summary>
        </member>
        <member name="P:Ionic.Zip.CountingStream.CanSeek">
            <summary>
              Whether it is possible to call Seek() on the stream.
            </summary>
        </member>
        <member name="P:Ionic.Zip.CountingStream.CanWrite">
            <summary>
              Whether it is possible to call Write() on the stream.
            </summary>
        </member>
        <member name="M:Ionic.Zip.CountingStream.Flush">
            <summary>
              Flushes the underlying stream.
            </summary>
        </member>
        <member name="P:Ionic.Zip.CountingStream.Length">
            <summary>
              The length of the underlying stream.
            </summary>
        </member>
        <member name="P:Ionic.Zip.CountingStream.ComputedPosition">
            <summary>
              Returns the sum of number of bytes written, plus the initial
              offset before writing.
            </summary>
        </member>
        <member name="P:Ionic.Zip.CountingStream.Position">
            <summary>
              The Position of the stream.
            </summary>
        </member>
        <member name="M:Ionic.Zip.CountingStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
              Seek in the stream.
            </summary>
            <param name="offset">the offset point to seek to</param>
            <param name="origin">the reference point from which to seek</param>
            <returns>The new position</returns>
        </member>
        <member name="M:Ionic.Zip.CountingStream.SetLength(System.Int64)">
             <summary>
               Set the length of the underlying stream.  Be careful with this!
             </summary>
            
             <param name='value'>the length to set on the underlying stream.</param>
        </member>
        <member name="T:Ionic.Zip.ZipCrypto">
             <summary>
               This class implements the "traditional" or "classic" PKZip encryption,
               which today is considered to be weak. On the other hand it is
               ubiquitous. This class is intended for use only by the DotNetZip
               library.
             </summary>
            
             <remarks>
               Most uses of the DotNetZip library will not involve direct calls into
               the ZipCrypto class.  Instead, the ZipCrypto class is instantiated and
               used by the ZipEntry() class when encryption or decryption on an entry
               is employed.  If for some reason you really wanted to use a weak
               encryption algorithm in some other application, you might use this
               library.  But you would be much better off using one of the built-in
               strong encryption libraries in the .NET Framework, like the AES
               algorithm or SHA.
             </remarks>
        </member>
        <member name="M:Ionic.Zip.ZipCrypto.#ctor">
             <summary>
               The default constructor for ZipCrypto.
             </summary>
            
             <remarks>
               This class is intended for internal use by the library only. It's
               probably not useful to you. Seriously.  Stop reading this
               documentation.  It's a waste of your time.  Go do something else.
               Check the football scores. Go get an ice cream with a friend.
               Seriously.
             </remarks>
            
        </member>
        <member name="P:Ionic.Zip.ZipCrypto.MagicByte">
            <summary>
            From AppNote.txt:
            unsigned char decrypt_byte()
                local unsigned short temp
                temp :=- Key(2) | 2
                decrypt_byte := (temp * (temp ^ 1)) bitshift-right 8
            end decrypt_byte
            </summary>
        </member>
        <member name="M:Ionic.Zip.ZipCrypto.DecryptMessage(System.Byte[],System.Int32)">
             <summary>
               Call this method on a cipher text to render the plaintext. You must
               first initialize the cipher with a call to InitCipher.
             </summary>
            
             <example>
               <code>
                 var cipher = new ZipCrypto();
                 cipher.InitCipher(Password);
                 // Decrypt the header.  This has a side effect of "further initializing the
                 // encryption keys" in the traditional zip encryption.
                 byte[] DecryptedMessage = cipher.DecryptMessage(EncryptedMessage);
               </code>
             </example>
            
             <param name="cipherText">The encrypted buffer.</param>
             <param name="length">
               The number of bytes to encrypt.
               Should be less than or equal to CipherText.Length.
             </param>
            
             <returns>The plaintext.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipCrypto.EncryptMessage(System.Byte[],System.Int32)">
             <summary>
               This is the converse of DecryptMessage.  It encrypts the plaintext
               and produces a ciphertext.
             </summary>
            
             <param name="plainText">The plain text buffer.</param>
            
             <param name="length">
               The number of bytes to encrypt.
               Should be less than or equal to plainText.Length.
             </param>
            
             <returns>The ciphertext.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipCrypto.InitCipher(System.String)">
             <summary>
               This initializes the cipher with the given password.
               See AppNote.txt for details.
             </summary>
            
             <param name="passphrase">
               The passphrase for encrypting or decrypting with this cipher.
             </param>
            
             <remarks>
             <code>
             Step 1 - Initializing the encryption keys
             -----------------------------------------
             Start with these keys:
             Key(0) := 305419896 (0x12345678)
             Key(1) := 591751049 (0x23456789)
             Key(2) := 878082192 (0x34567890)
            
             Then, initialize the keys with a password:
            
             loop for i from 0 to length(password)-1
                 update_keys(password(i))
             end loop
            
             Where update_keys() is defined as:
            
             update_keys(char):
               Key(0) := crc32(key(0),char)
               Key(1) := Key(1) + (Key(0) bitwiseAND 000000ffH)
               Key(1) := Key(1) * 134775813 + 1
               Key(2) := crc32(key(2),key(1) rightshift 24)
             end update_keys
            
             Where crc32(old_crc,char) is a routine that given a CRC value and a
             character, returns an updated CRC value after applying the CRC-32
             algorithm described elsewhere in this document.
            
             </code>
            
             <para>
               After the keys are initialized, then you can use the cipher to
               encrypt the plaintext.
             </para>
            
             <para>
               Essentially we encrypt the password with the keys, then discard the
               ciphertext for the password. This initializes the keys for later use.
             </para>
            
             </remarks>
        </member>
        <member name="T:Ionic.Zip.ZipCipherStream">
            <summary>
              A Stream for reading and concurrently decrypting data from a zip file,
              or for writing and concurrently encrypting data to a zip file.
            </summary>
        </member>
        <member name="M:Ionic.Zip.ZipCipherStream.#ctor(System.IO.Stream,Ionic.Zip.ZipCrypto,Ionic.Zip.CryptoMode)">
            <summary>  The constructor. </summary>
            <param name="s">The underlying stream</param>
            <param name="mode">To either encrypt or decrypt.</param>
            <param name="cipher">The pre-initialized ZipCrypto object.</param>
        </member>
        <member name="T:Ionic.Zip.ZipEntry">
            <summary>
            Represents a single entry in a ZipFile. Typically, applications get a ZipEntry
            by enumerating the entries within a ZipFile, or by adding an entry to a ZipFile.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.AttributesIndicateDirectory">
            <summary>
            True if the referenced entry is a directory.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.Info">
            <summary>
            Provides a human-readable string with information about the ZipEntry.
            </summary>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.ReadDirEntry(Ionic.Zip.ZipFile,System.Collections.Generic.Dictionary{System.String,System.Object})">
             <summary>
               Reads one entry from the zip directory structure in the zip file.
             </summary>
            
             <param name="zf">
               The zipfile for which a directory entry will be read.  From this param, the
               method gets the ReadStream and the expected text encoding
               (ProvisionalAlternateEncoding) which is used if the entry is not marked
               UTF-8.
             </param>
            
             <param name="previouslySeen">
               a list of previously seen entry names; used to prevent duplicates.
             </param>
            
             <returns>the entry read from the archive.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.IsNotValidZipDirEntrySig(System.Int32)">
            <summary>
            Returns true if the passed-in value is a valid signature for a ZipDirEntry.
            </summary>
            <param name="signature">the candidate 4-byte signature value.</param>
            <returns>true, if the signature is valid according to the PKWare spec.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.#ctor">
            <summary>
            Default constructor.
            </summary>
            <remarks>
            Applications should never need to call this directly.  It is exposed to
            support COM Automation environments.
            </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.LastModified">
             <summary>
               The time and date at which the file indicated by the <c>ZipEntry</c> was
               last modified.
             </summary>
            
             <remarks>
             <para>
               The DotNetZip library sets the LastModified value for an entry, equal to
               the Last Modified time of the file in the filesystem.  If an entry is
               added from a stream, the library uses <c>System.DateTime.Now</c> for this
               value, for the given entry.
             </para>
            
             <para>
               This property allows the application to retrieve and possibly set the
               LastModified value on an entry, to an arbitrary value.  <see
               cref="T:System.DateTime"/> values with a <see cref="T:System.DateTimeKind" />
               setting of <c>DateTimeKind.Unspecified</c> are taken to be expressed as
               <c>DateTimeKind.Local</c>.
             </para>
            
             <para>
               Be aware that because of the way <see
               href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWare's
               Zip specification</see> describes how times are stored in the zip file,
               the full precision of the <c>System.DateTime</c> datatype is not stored
               for the last modified time when saving zip files.  For more information on
               how times are formatted, see the PKZip specification.
             </para>
            
             <para>
               The actual last modified time of a file can be stored in multiple ways in
               the zip file, and they are not mutually exclusive:
             </para>
            
             <list type="bullet">
               <item>
                 In the so-called "DOS" format, which has a 2-second precision. Values
                 are rounded to the nearest even second. For example, if the time on the
                 file is 12:34:43, then it will be stored as 12:34:44. This first value
                 is accessible via the <c>LastModified</c> property. This value is always
                 present in the metadata for each zip entry.  In some cases the value is
                 invalid, or zero.
               </item>
            
               <item>
                 In the so-called "Windows" or "NTFS" format, as an 8-byte integer
                 quantity expressed as the number of 1/10 milliseconds (in other words
                 the number of 100 nanosecond units) since January 1, 1601 (UTC).  This
                 format is how Windows represents file times.  This time is accessible
                 via the <c>ModifiedTime</c> property.
               </item>
            
               <item>
                 In the "Unix" format, a 4-byte quantity specifying the number of seconds since
                 January 1, 1970 UTC.
               </item>
            
               <item>
                 In an older format, now deprecated but still used by some current
                 tools. This format is also a 4-byte quantity specifying the number of
                 seconds since January 1, 1970 UTC.
               </item>
            
             </list>
            
             <para>
               Zip tools and libraries will always at least handle (read or write) the
               DOS time, and may also handle the other time formats.  Keep in mind that
               while the names refer to particular operating systems, there is nothing in
               the time formats themselves that prevents their use on other operating
               systems.
             </para>
            
             <para>
               When reading ZIP files, the DotNetZip library reads the Windows-formatted
               time, if it is stored in the entry, and sets both <c>LastModified</c> and
               <c>ModifiedTime</c> to that value. When writing ZIP files, the DotNetZip
               library by default will write both time quantities. It can also emit the
               Unix-formatted time if desired (See <see
               cref="P:Ionic.Zip.ZipEntry.EmitTimesInUnixFormatWhenSaving"/>.)
             </para>
            
             <para>
               The last modified time of the file created upon a call to
               <c>ZipEntry.Extract()</c> may be adjusted during extraction to compensate
               for differences in how the .NET Base Class Library deals with daylight
               saving time (DST) versus how the Windows filesystem deals with daylight
               saving time.  Raymond Chen <see
               href="http://blogs.msdn.com/oldnewthing/archive/2003/10/24/55413.aspx">provides
               some good context</see>.
             </para>
            
             <para>
               In a nutshell: Daylight savings time rules change regularly.  In 2007, for
               example, the inception week of DST changed.  In 1977, DST was in place all
               year round. In 1945, likewise.  And so on.  Win32 does not attempt to
               guess which time zone rules were in effect at the time in question.  It
               will render a time as "standard time" and allow the app to change to DST
               as necessary.  .NET makes a different choice.
             </para>
            
             <para>
               Compare the output of FileInfo.LastWriteTime.ToString("f") with what you
               see in the Windows Explorer property sheet for a file that was last
               written to on the other side of the DST transition. For example, suppose
               the file was last modified on October 17, 2003, during DST but DST is not
               currently in effect. Explorer's file properties reports Thursday, October
               17, 2003, 8:45:38 AM, but .NETs FileInfo reports Thursday, October 17,
               2003, 9:45 AM.
             </para>
            
             <para>
               Win32 says, "Thursday, October 17, 2002 8:45:38 AM PST". Note: Pacific
               STANDARD Time. Even though October 17 of that year occurred during Pacific
               Daylight Time, Win32 displays the time as standard time because that's
               what time it is NOW.
             </para>
            
             <para>
               .NET BCL assumes that the current DST rules were in place at the time in
               question.  So, .NET says, "Well, if the rules in effect now were also in
               effect on October 17, 2003, then that would be daylight time" so it
               displays "Thursday, October 17, 2003, 9:45 AM PDT" - daylight time.
             </para>
            
             <para>
               So .NET gives a value which is more intuitively correct, but is also
               potentially incorrect, and which is not invertible. Win32 gives a value
               which is intuitively incorrect, but is strictly correct.
             </para>
            
             <para>
               Because of this funkiness, this library adds one hour to the LastModified
               time on the extracted file, if necessary.  That is to say, if the time in
               question had occurred in what the .NET Base Class Library assumed to be
               DST. This assumption may be wrong given the constantly changing DST rules,
               but it is the best we can do.
             </para>
            
             </remarks>
            
        </member>
        <member name="P:Ionic.Zip.ZipEntry.ModifiedTime">
             <summary>
             Last Modified time for the file represented by the entry.
             </summary>
            
             <remarks>
            
             <para>
               This value corresponds to the "last modified" time in the NTFS file times
               as described in <see
               href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">the Zip
               specification</see>.  When getting this property, the value may be
               different from <see cref="P:Ionic.Zip.ZipEntry.LastModified" />.  When setting the property,
               the <see cref="P:Ionic.Zip.ZipEntry.LastModified"/> property also gets set, but with a lower
               precision.
             </para>
            
             <para>
               Let me explain. It's going to take a while, so get
               comfortable. Originally, waaaaay back in 1989 when the ZIP specification
               was originally described by the esteemed Mr. Phil Katz, the dominant
               operating system of the time was MS-DOS. MSDOS stored file times with a
               2-second precision, because, c'mon, <em>who is ever going to need better
               resolution than THAT?</em> And so ZIP files, regardless of the platform on
               which the zip file was created, store file times in exactly <see
               href="http://www.vsft.com/hal/dostime.htm">the same format that DOS used
               in 1989</see>.
             </para>
            
             <para>
               Since then, the ZIP spec has evolved, but the internal format for file
               timestamps remains the same.  Despite the fact that the way times are
               stored in a zip file is rooted in DOS heritage, any program on any
               operating system can format a time in this way, and most zip tools and
               libraries DO - they round file times to the nearest even second and store
               it just like DOS did 25+ years ago.
             </para>
            
             <para>
               PKWare extended the ZIP specification to allow a zip file to store what
               are called "NTFS Times" and "Unix(tm) times" for a file.  These are the
               <em>last write</em>, <em>last access</em>, and <em>file creation</em>
               times of a particular file. These metadata are not actually specific
               to NTFS or Unix. They are tracked for each file by NTFS and by various
               Unix filesystems, but they are also tracked by other filesystems, too.
               The key point is that the times are <em>formatted in the zip file</em>
               in the same way that NTFS formats the time (ticks since win32 epoch),
               or in the same way that Unix formats the time (seconds since Unix
               epoch). As with the DOS time, any tool or library running on any
               operating system is capable of formatting a time in one of these ways
               and embedding it into the zip file.
             </para>
            
             <para>
               These extended times are higher precision quantities than the DOS time.
               As described above, the (DOS) LastModified has a precision of 2 seconds.
               The Unix time is stored with a precision of 1 second. The NTFS time is
               stored with a precision of 0.0000001 seconds. The quantities are easily
               convertible, except for the loss of precision you may incur.
             </para>
            
             <para>
               A zip archive can store the {C,A,M} times in NTFS format, in Unix format,
               or not at all.  Often a tool running on Unix or Mac will embed the times
               in Unix format (1 second precision), while WinZip running on Windows might
               embed the times in NTFS format (precision of of 0.0000001 seconds).  When
               reading a zip file with these "extended" times, in either format,
               DotNetZip represents the values with the
               <c>ModifiedTime</c>, <c>AccessedTime</c> and <c>CreationTime</c>
               properties on the <c>ZipEntry</c>.
             </para>
            
             <para>
               While any zip application or library, regardless of the platform it
               runs on, could use any of the time formats allowed by the ZIP
               specification, not all zip tools or libraries do support all these
               formats.  Storing the higher-precision times for each entry is
               optional for zip files, and many tools and libraries don't use the
               higher precision quantities at all. The old DOS time, represented by
               <see cref="P:Ionic.Zip.ZipEntry.LastModified"/>, is guaranteed to be present, though it
               sometimes unset.
             </para>
            
             <para>
               Ok, getting back to the question about how the <c>LastModified</c>
               property relates to this <c>ModifiedTime</c>
               property... <c>LastModified</c> is always set, while
               <c>ModifiedTime</c> is not. (The other times stored in the <em>NTFS
               times extension</em>, <c>CreationTime</c> and <c>AccessedTime</c> also
               may not be set on an entry that is read from an existing zip file.)
               When reading a zip file, then <c>LastModified</c> takes the DOS time
               that is stored with the file. If the DOS time has been stored as zero
               in the zipfile, then this library will use <c>DateTime.Now</c> for the
               <c>LastModified</c> value.  If the ZIP file was created by an evolved
               tool, then there will also be higher precision NTFS or Unix times in
               the zip file.  In that case, this library will read those times, and
               set <c>LastModified</c> and <c>ModifiedTime</c> to the same value, the
               one corresponding to the last write time of the file.  If there are no
               higher precision times stored for the entry, then <c>ModifiedTime</c>
               remains unset (likewise <c>AccessedTime</c> and <c>CreationTime</c>),
               and <c>LastModified</c> keeps its DOS time.
             </para>
            
             <para>
               When creating zip files with this library, by default the extended time
               properties (<c>ModifiedTime</c>, <c>AccessedTime</c>, and
               <c>CreationTime</c>) are set on the ZipEntry instance, and these data are
               stored in the zip archive for each entry, in NTFS format. If you add an
               entry from an actual filesystem file, then the entry gets the actual file
               times for that file, to NTFS-level precision.  If you add an entry from a
               stream, or a string, then the times get the value <c>DateTime.Now</c>.  In
               this case <c>LastModified</c> and <c>ModifiedTime</c> will be identical,
               to 2 seconds of precision.  You can explicitly set the
               <c>CreationTime</c>, <c>AccessedTime</c>, and <c>ModifiedTime</c> of an
               entry using the property setters.  If you want to set all of those
               quantities, it's more efficient to use the <see
               cref="M:Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)"/> method.  Those
               changes are not made permanent in the zip file until you call <see
               cref="M:Ionic.Zip.ZipFile.Save"/> or one of its cousins.
             </para>
            
             <para>
               When creating a zip file, you can override the default behavior of
               this library for formatting times in the zip file, disabling the
               embedding of file times in NTFS format or enabling the storage of file
               times in Unix format, or both.  You may want to do this, for example,
               when creating a zip file on Windows, that will be consumed on a Mac,
               by an application that is not hip to the "NTFS times" format. To do
               this, use the <see cref="P:Ionic.Zip.ZipEntry.EmitTimesInWindowsFormatWhenSaving"/> and
               <see cref="P:Ionic.Zip.ZipEntry.EmitTimesInUnixFormatWhenSaving"/> properties.  A valid zip
               file may store the file times in both formats.  But, there are no
               guarantees that a program running on Mac or Linux will gracefully
               handle the NTFS-formatted times when Unix times are present, or that a
               non-DotNetZip-powered application running on Windows will be able to
               handle file times in Unix format. DotNetZip will always do something
               reasonable; other libraries or tools may not. When in doubt, test.
             </para>
            
             <para>
               I'll bet you didn't think one person could type so much about time, eh?
               And reading it was so enjoyable, too!  Well, in appreciation, <see
               href="http://cheeso.members.winisp.net/DotNetZipDonate.aspx">maybe you
               should donate</see>?
             </para>
             </remarks>
            
             <seealso cref="P:Ionic.Zip.ZipEntry.AccessedTime"/>
             <seealso cref="P:Ionic.Zip.ZipEntry.CreationTime"/>
             <seealso cref="P:Ionic.Zip.ZipEntry.LastModified"/>
             <seealso cref="M:Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)"/>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.AccessedTime">
            <summary>
            Last Access time for the file represented by the entry.
            </summary>
            <remarks>
            This value may or may not be meaningful.  If the <c>ZipEntry</c> was read from an existing
            Zip archive, this information may not be available. For an explanation of why, see
            <see cref="P:Ionic.Zip.ZipEntry.ModifiedTime"/>.
            </remarks>
            <seealso cref="P:Ionic.Zip.ZipEntry.ModifiedTime"/>
            <seealso cref="P:Ionic.Zip.ZipEntry.CreationTime"/>
            <seealso cref="M:Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)"/>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.CreationTime">
             <summary>
             The file creation time for the file represented by the entry.
             </summary>
            
             <remarks>
             This value may or may not be meaningful.  If the <c>ZipEntry</c> was read
             from an existing zip archive, and the creation time was not set on the entry
             when the zip file was created, then this property may be meaningless. For an
             explanation of why, see <see cref="P:Ionic.Zip.ZipEntry.ModifiedTime"/>.
             </remarks>
             <seealso cref="P:Ionic.Zip.ZipEntry.ModifiedTime"/>
             <seealso cref="P:Ionic.Zip.ZipEntry.AccessedTime"/>
             <seealso cref="M:Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)"/>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)">
             <summary>
               Sets the NTFS Creation, Access, and Modified times for the given entry.
             </summary>
            
             <remarks>
             <para>
               When adding an entry from a file or directory, the Creation, Access, and
               Modified times for the given entry are automatically set from the
               filesystem values. When adding an entry from a stream or string, the
               values are implicitly set to DateTime.Now.  The application may wish to
               set these values to some arbitrary value, before saving the archive, and
               can do so using the various setters.  If you want to set all of the times,
               this method is more efficient.
             </para>
            
             <para>
               The values you set here will be retrievable with the <see
               cref="P:Ionic.Zip.ZipEntry.ModifiedTime"/>, <see cref="P:Ionic.Zip.ZipEntry.CreationTime"/> and <see
               cref="P:Ionic.Zip.ZipEntry.AccessedTime"/> properties.
             </para>
            
             <para>
               When this method is called, if both <see
               cref="P:Ionic.Zip.ZipEntry.EmitTimesInWindowsFormatWhenSaving"/> and <see
               cref="P:Ionic.Zip.ZipEntry.EmitTimesInUnixFormatWhenSaving"/> are false, then the
               <c>EmitTimesInWindowsFormatWhenSaving</c> flag is automatically set.
             </para>
            
             <para>
               DateTime values provided here without a DateTimeKind are assumed to be Local Time.
             </para>
            
             </remarks>
             <param name="created">the creation time of the entry.</param>
             <param name="accessed">the last access time of the entry.</param>
             <param name="modified">the last modified time of the entry.</param>
            
             <seealso cref="P:Ionic.Zip.ZipEntry.EmitTimesInWindowsFormatWhenSaving" />
             <seealso cref="P:Ionic.Zip.ZipEntry.EmitTimesInUnixFormatWhenSaving" />
             <seealso cref="P:Ionic.Zip.ZipEntry.AccessedTime"/>
             <seealso cref="P:Ionic.Zip.ZipEntry.CreationTime"/>
             <seealso cref="P:Ionic.Zip.ZipEntry.ModifiedTime"/>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.EmitTimesInWindowsFormatWhenSaving">
             <summary>
               Specifies whether the Creation, Access, and Modified times for the given
               entry will be emitted in "Windows format" when the zip archive is saved.
             </summary>
            
             <remarks>
             <para>
               An application creating a zip archive can use this flag to explicitly
               specify that the file times for the entry should or should not be stored
               in the zip archive in the format used by Windows. The default value of
               this property is <c>true</c>.
             </para>
            
             <para>
               When adding an entry from a file or directory, the Creation (<see
               cref="P:Ionic.Zip.ZipEntry.CreationTime"/>), Access (<see cref="P:Ionic.Zip.ZipEntry.AccessedTime"/>), and Modified
               (<see cref="P:Ionic.Zip.ZipEntry.ModifiedTime"/>) times for the given entry are automatically
               set from the filesystem values. When adding an entry from a stream or
               string, all three values are implicitly set to DateTime.Now.  Applications
               can also explicitly set those times by calling <see
               cref="M:Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)" />.
             </para>
            
             <para>
               <see
               href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWARE's
               zip specification</see> describes multiple ways to format these times in a
               zip file. One is the format Windows applications normally use: 100ns ticks
               since Jan 1, 1601 UTC.  The other is a format Unix applications typically
               use: seconds since January 1, 1970 UTC.  Each format can be stored in an
               "extra field" in the zip entry when saving the zip archive. The former
               uses an extra field with a Header Id of 0x000A, while the latter uses a
               header ID of 0x5455.
             </para>
            
             <para>
               Not all zip tools and libraries can interpret these fields.  Windows
               compressed folders is one that can read the Windows Format timestamps,
               while I believe the <see href="http://www.info-zip.org/">Infozip</see>
               tools can read the Unix format timestamps. Although the time values are
               easily convertible, subject to a loss of precision, some tools and
               libraries may be able to read only one or the other. DotNetZip can read or
               write times in either or both formats.
             </para>
            
             <para>
               The times stored are taken from <see cref="P:Ionic.Zip.ZipEntry.ModifiedTime"/>, <see
               cref="P:Ionic.Zip.ZipEntry.AccessedTime"/>, and <see cref="P:Ionic.Zip.ZipEntry.CreationTime"/>.
             </para>
            
             <para>
               This property is not mutually exclusive from the <see
               cref="P:Ionic.Zip.ZipEntry.EmitTimesInUnixFormatWhenSaving"/> property.  It is
               possible that a zip entry can embed the timestamps in both forms, one
               form, or neither.  But, there are no guarantees that a program running on
               Mac or Linux will gracefully handle NTFS Formatted times, or that a
               non-DotNetZip-powered application running on Windows will be able to
               handle file times in Unix format. When in doubt, test.
             </para>
            
             <para>
               Normally you will use the <see
               cref="P:Ionic.Zip.ZipFile.EmitTimesInWindowsFormatWhenSaving">ZipFile.EmitTimesInWindowsFormatWhenSaving</see>
               property, to specify the behavior for all entries in a zip, rather than
               the property on each individual entry.
             </para>
            
             </remarks>
            
             <seealso cref="M:Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)"/>
             <seealso cref="P:Ionic.Zip.ZipEntry.EmitTimesInUnixFormatWhenSaving"/>
             <seealso cref="P:Ionic.Zip.ZipEntry.CreationTime"/>
             <seealso cref="P:Ionic.Zip.ZipEntry.AccessedTime"/>
             <seealso cref="P:Ionic.Zip.ZipEntry.ModifiedTime"/>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.EmitTimesInUnixFormatWhenSaving">
             <summary>
               Specifies whether the Creation, Access, and Modified times for the given
               entry will be emitted in &quot;Unix(tm) format&quot; when the zip archive is saved.
             </summary>
            
             <remarks>
             <para>
               An application creating a zip archive can use this flag to explicitly
               specify that the file times for the entry should or should not be stored
               in the zip archive in the format used by Unix. By default this flag is
               <c>false</c>, meaning the Unix-format times are not stored in the zip
               archive.
             </para>
            
             <para>
               When adding an entry from a file or directory, the Creation (<see
               cref="P:Ionic.Zip.ZipEntry.CreationTime"/>), Access (<see cref="P:Ionic.Zip.ZipEntry.AccessedTime"/>), and Modified
               (<see cref="P:Ionic.Zip.ZipEntry.ModifiedTime"/>) times for the given entry are automatically
               set from the filesystem values. When adding an entry from a stream or
               string, all three values are implicitly set to DateTime.Now.  Applications
               can also explicitly set those times by calling <see
               cref="M:Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)"/>.
             </para>
            
             <para>
               <see
               href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWARE's
               zip specification</see> describes multiple ways to format these times in a
               zip file. One is the format Windows applications normally use: 100ns ticks
               since Jan 1, 1601 UTC.  The other is a format Unix applications typically
               use: seconds since Jan 1, 1970 UTC.  Each format can be stored in an
               "extra field" in the zip entry when saving the zip archive. The former
               uses an extra field with a Header Id of 0x000A, while the latter uses a
               header ID of 0x5455.
             </para>
            
             <para>
               Not all tools and libraries can interpret these fields.  Windows
               compressed folders is one that can read the Windows Format timestamps,
               while I believe the <see href="http://www.info-zip.org/">Infozip</see>
               tools can read the Unix format timestamps. Although the time values are
               easily convertible, subject to a loss of precision, some tools and
               libraries may be able to read only one or the other. DotNetZip can read or
               write times in either or both formats.
             </para>
            
             <para>
               The times stored are taken from <see cref="P:Ionic.Zip.ZipEntry.ModifiedTime"/>, <see
               cref="P:Ionic.Zip.ZipEntry.AccessedTime"/>, and <see cref="P:Ionic.Zip.ZipEntry.CreationTime"/>.
             </para>
            
             <para>
               This property is not mutually exclusive from the <see
               cref="P:Ionic.Zip.ZipEntry.EmitTimesInWindowsFormatWhenSaving"/> property.  It is
               possible that a zip entry can embed the timestamps in both forms, one
               form, or neither.  But, there are no guarantees that a program running on
               Mac or Linux will gracefully handle NTFS Formatted times, or that a
               non-DotNetZip-powered application running on Windows will be able to
               handle file times in Unix format. When in doubt, test.
             </para>
            
             <para>
               Normally you will use the <see
               cref="P:Ionic.Zip.ZipFile.EmitTimesInUnixFormatWhenSaving">ZipFile.EmitTimesInUnixFormatWhenSaving</see>
               property, to specify the behavior for all entries, rather than the
               property on each individual entry.
             </para>
             </remarks>
            
             <seealso cref="M:Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)"/>
             <seealso cref="P:Ionic.Zip.ZipEntry.EmitTimesInWindowsFormatWhenSaving"/>
             <seealso cref="P:Ionic.Zip.ZipFile.EmitTimesInUnixFormatWhenSaving"/>
             <seealso cref="P:Ionic.Zip.ZipEntry.CreationTime"/>
             <seealso cref="P:Ionic.Zip.ZipEntry.AccessedTime"/>
             <seealso cref="P:Ionic.Zip.ZipEntry.ModifiedTime"/>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.Timestamp">
             <summary>
             The type of timestamp attached to the ZipEntry.
             </summary>
            
             <remarks>
             This property is valid only for a ZipEntry that was read from a zip archive.
             It indicates the type of timestamp attached to the entry.
             </remarks>
            
             <seealso cref="P:Ionic.Zip.ZipEntry.EmitTimesInWindowsFormatWhenSaving"/>
             <seealso cref="P:Ionic.Zip.ZipEntry.EmitTimesInUnixFormatWhenSaving"/>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.Attributes">
             <summary>
               The file attributes for the entry.
             </summary>
            
             <remarks>
            
             <para>
               The <see cref="T:System.IO.FileAttributes">attributes</see> in NTFS include
               ReadOnly, Archive, Hidden, System, and Indexed.  When adding a
               <c>ZipEntry</c> to a ZipFile, these attributes are set implicitly when
               adding an entry from the filesystem.  When adding an entry from a stream
               or string, the Attributes are not set implicitly.  Regardless of the way
               an entry was added to a <c>ZipFile</c>, you can set the attributes
               explicitly if you like.
             </para>
            
             <para>
               When reading a <c>ZipEntry</c> from a <c>ZipFile</c>, the attributes are
               set according to the data stored in the <c>ZipFile</c>. If you extract the
               entry from the archive to a filesystem file, DotNetZip will set the
               attributes on the resulting file accordingly.
             </para>
            
             <para>
               The attributes can be set explicitly by the application.  For example the
               application may wish to set the <c>FileAttributes.ReadOnly</c> bit for all
               entries added to an archive, so that on unpack, this attribute will be set
               on the extracted file.  Any changes you make to this property are made
               permanent only when you call a <c>Save()</c> method on the <c>ZipFile</c>
               instance that contains the ZipEntry.
             </para>
            
             <para>
               For example, an application may wish to zip up a directory and set the
               ReadOnly bit on every file in the archive, so that upon later extraction,
               the resulting files will be marked as ReadOnly.  Not every extraction tool
               respects these attributes, but if you unpack with DotNetZip, as for
               example in a self-extracting archive, then the attributes will be set as
               they are stored in the <c>ZipFile</c>.
             </para>
            
             <para>
               These attributes may not be interesting or useful if the resulting archive
               is extracted on a non-Windows platform.  How these attributes get used
               upon extraction depends on the platform and tool used.
             </para>
            
             <para>
               This property is only partially supported in the Silverlight version
               of the library: applications can read attributes on entries within
               ZipFiles. But extracting entries within Silverlight will not set the
               attributes on the extracted files.
             </para>
            
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.LocalFileName">
             <summary>
               The name of the filesystem file, referred to by the ZipEntry.
             </summary>
            
             <remarks>
              <para>
                This property specifies the thing-to-be-zipped on disk, and is set only
                when the <c>ZipEntry</c> is being created from a filesystem file.  If the
                <c>ZipFile</c> is instantiated by reading an existing .zip archive, then
                the LocalFileName will be <c>null</c> (<c>Nothing</c> in VB).
              </para>
            
              <para>
                When it is set, the value of this property may be different than <see
                cref="P:Ionic.Zip.ZipEntry.FileName"/>, which is the path used in the archive itself.  If you
                call <c>Zip.AddFile("foop.txt", AlternativeDirectory)</c>, then the path
                used for the <c>ZipEntry</c> within the zip archive will be different
                than this path.
              </para>
            
              <para>
               If the entry is being added from a stream, then this is null (Nothing in VB).
              </para>
            
             </remarks>
             <seealso cref="P:Ionic.Zip.ZipEntry.FileName"/>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.FileName">
             <summary>
               The name of the file contained in the ZipEntry.
             </summary>
            
             <remarks>
            
             <para>
               This is the name of the entry in the <c>ZipFile</c> itself.  When creating
               a zip archive, if the <c>ZipEntry</c> has been created from a filesystem
               file, via a call to <see cref="M:Ionic.Zip.ZipFile.AddFile(System.String,System.String)"/> or <see
               cref="M:Ionic.Zip.ZipFile.AddItem(System.String,System.String)"/>, or a related overload, the value
               of this property is derived from the name of that file. The
               <c>FileName</c> property does not include drive letters, and may include a
               different directory path, depending on the value of the
               <c>directoryPathInArchive</c> parameter used when adding the entry into
               the <c>ZipFile</c>.
             </para>
            
             <para>
               In some cases there is no related filesystem file - for example when a
               <c>ZipEntry</c> is created using <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.String)"/> or one of the similar overloads.  In this case, the value of
               this property is derived from the fileName and the directory path passed
               to that method.
             </para>
            
             <para>
               When reading a zip file, this property takes the value of the entry name
               as stored in the zip file. If you extract such an entry, the extracted
               file will take the name given by this property.
             </para>
            
             <para>
               Applications can set this property when creating new zip archives or when
               reading existing archives. When setting this property, the actual value
               that is set will replace backslashes with forward slashes, in accordance
               with <see
               href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">the Zip
               specification</see>, for compatibility with Unix(tm) and ... get
               this.... Amiga!
             </para>
            
             <para>
               If an application reads a <c>ZipFile</c> via <see
               cref="M:Ionic.Zip.ZipFile.Read(System.String)"/> or a related overload, and then explicitly
               sets the FileName on an entry contained within the <c>ZipFile</c>, and
               then calls <see cref="M:Ionic.Zip.ZipFile.Save"/>, the application will effectively
               rename the entry within the zip archive.
             </para>
            
             <para>
               If an application sets the value of <c>FileName</c>, then calls
               <c>Extract()</c> on the entry, the entry is extracted to a file using the
               newly set value as the filename.  The <c>FileName</c> value is made
               permanent in the zip archive only <em>after</em> a call to one of the
               <c>ZipFile.Save()</c> methods on the <c>ZipFile</c> that contains the
               ZipEntry.
             </para>
            
             <para>
               If an application attempts to set the <c>FileName</c> to a value that
               would result in a duplicate entry in the <c>ZipFile</c>, an exception is
               thrown.
             </para>
            
             <para>
               When a <c>ZipEntry</c> is contained within a <c>ZipFile</c>, applications
               cannot rename the entry within the context of a <c>foreach</c> (<c>For
               Each</c> in VB) loop, because of the way the <c>ZipFile</c> stores
               entries.  If you need to enumerate through all the entries and rename one
               or more of them, use <see
               cref="P:Ionic.Zip.ZipFile.EntriesSorted">ZipFile.EntriesSorted</see> as the
               collection.  See also, <see
               cref="M:Ionic.Zip.ZipFile.GetEnumerator">ZipFile.GetEnumerator()</see>.
             </para>
            
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.InputStream">
             <summary>
             The stream that provides content for the ZipEntry.
             </summary>
            
             <remarks>
            
             <para>
               The application can use this property to set the input stream for an
               entry on a just-in-time basis. Imagine a scenario where the application
               creates a <c>ZipFile</c> comprised of content obtained from hundreds of
               files, via calls to <c>AddFile()</c>. The DotNetZip library opens streams
               on these files on a just-in-time basis, only when writing the entry out to
               an external store within the scope of a <c>ZipFile.Save()</c> call.  Only
               one input stream is opened at a time, as each entry is being written out.
             </para>
            
             <para>
               Now imagine a different application that creates a <c>ZipFile</c>
               with content obtained from hundreds of streams, added through <see
               cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.IO.Stream)"/>.  Normally the
               application would supply an open stream to that call.  But when large
               numbers of streams are being added, this can mean many open streams at one
               time, unnecessarily.
             </para>
            
             <para>
               To avoid this, call <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,Ionic.Zip.OpenDelegate,Ionic.Zip.CloseDelegate)"/> and specify delegates that open and close the stream at
               the time of Save.
             </para>
            
            
             <para>
               Setting the value of this property when the entry was not added from a
               stream (for example, when the <c>ZipEntry</c> was added with <see
               cref="M:Ionic.Zip.ZipFile.AddFile(System.String)"/> or <see
               cref="M:Ionic.Zip.ZipFile.AddDirectory(System.String)"/>, or when the entry was added by
               reading an existing zip archive) will throw an exception.
             </para>
            
             </remarks>
            
        </member>
        <member name="P:Ionic.Zip.ZipEntry.InputStreamWasJitProvided">
             <summary>
               A flag indicating whether the InputStream was provided Just-in-time.
             </summary>
            
             <remarks>
            
             <para>
               When creating a zip archive, an application can obtain content for one or
               more of the <c>ZipEntry</c> instances from streams, using the <see
               cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.IO.Stream)"/> method.  At the time
               of calling that method, the application can supply null as the value of
               the stream parameter.  By doing so, the application indicates to the
               library that it will provide a stream for the entry on a just-in-time
               basis, at the time one of the <c>ZipFile.Save()</c> methods is called and
               the data for the various entries are being compressed and written out.
             </para>
            
             <para>
               In this case, the application can set the <see cref="P:Ionic.Zip.ZipEntry.InputStream"/>
               property, typically within the SaveProgress event (event type: <see
               cref="F:Ionic.Zip.ZipProgressEventType.Saving_BeforeWriteEntry"/>) for that entry.
             </para>
            
             <para>
               The application will later want to call Close() and Dispose() on that
               stream.  In the SaveProgress event, when the event type is <see
               cref="F:Ionic.Zip.ZipProgressEventType.Saving_AfterWriteEntry"/>, the application can
               do so.  This flag indicates that the stream has been provided by the
               application on a just-in-time basis and that it is the application's
               responsibility to call Close/Dispose on that stream.
             </para>
            
             </remarks>
             <seealso cref="P:Ionic.Zip.ZipEntry.InputStream"/>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.Source">
            <summary>
            An enum indicating the source of the ZipEntry.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.VersionNeeded">
             <summary>
             The version of the zip engine needed to read the ZipEntry.
             </summary>
            
             <remarks>
             <para>
               This is a readonly property, indicating the version of <a
               href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">the Zip
               specification</a> that the extracting tool or library must support to
               extract the given entry.  Generally higher versions indicate newer
               features.  Older zip engines obviously won't know about new features, and
               won't be able to extract entries that depend on those newer features.
             </para>
            
             <list type="table">
             <listheader>
             <term>value</term>
             <description>Features</description>
             </listheader>
            
             <item>
             <term>20</term>
             <description>a basic Zip Entry, potentially using PKZIP encryption.
             </description>
             </item>
            
             <item>
             <term>45</term>
             <description>The ZIP64 extension is used on the entry.
             </description>
             </item>
            
             <item>
             <term>46</term>
             <description> File is compressed using BZIP2 compression*</description>
             </item>
            
             <item>
             <term>50</term>
             <description> File is encrypted using PkWare's DES, 3DES, (broken) RC2 or RC4</description>
             </item>
            
             <item>
             <term>51</term>
             <description> File is encrypted using PKWare's AES encryption or corrected RC2 encryption.</description>
             </item>
            
             <item>
             <term>52</term>
             <description> File is encrypted using corrected RC2-64 encryption**</description>
             </item>
            
             <item>
             <term>61</term>
             <description> File is encrypted using non-OAEP key wrapping***</description>
             </item>
            
             <item>
             <term>63</term>
             <description> File is compressed using LZMA, PPMd+, Blowfish, or Twofish</description>
             </item>
            
             </list>
            
             <para>
               There are other values possible, not listed here. DotNetZip supports
               regular PKZip encryption, and ZIP64 extensions.  DotNetZip cannot extract
               entries that require a zip engine higher than 45.
             </para>
            
             <para>
               This value is set upon reading an existing zip file, or after saving a zip
               archive.
             </para>
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.Comment">
             <summary>
             The comment attached to the ZipEntry.
             </summary>
            
             <remarks>
             <para>
               Each entry in a zip file can optionally have a comment associated to
               it. The comment might be displayed by a zip tool during extraction, for
               example.
             </para>
            
             <para>
               By default, the <c>Comment</c> is encoded in IBM437 code page. You can
               specify an alternative with <see cref="P:Ionic.Zip.ZipEntry.AlternateEncoding"/> and
              <see cref="P:Ionic.Zip.ZipEntry.AlternateEncodingUsage"/>.
             </para>
             </remarks>
             <seealso cref="P:Ionic.Zip.ZipEntry.AlternateEncoding"/>
             <seealso cref="P:Ionic.Zip.ZipEntry.AlternateEncodingUsage"/>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.RequiresZip64">
             <summary>
             Indicates whether the entry requires ZIP64 extensions.
             </summary>
            
             <remarks>
            
             <para>
               This property is null (Nothing in VB) until a <c>Save()</c> method on the
               containing <see cref="T:Ionic.Zip.ZipFile"/> instance has been called. The property is
               non-null (<c>HasValue</c> is true) only after a <c>Save()</c> method has
               been called.
             </para>
            
             <para>
               After the containing <c>ZipFile</c> has been saved, the Value of this
               property is true if any of the following three conditions holds: the
               uncompressed size of the entry is larger than 0xFFFFFFFF; the compressed
               size of the entry is larger than 0xFFFFFFFF; the relative offset of the
               entry within the zip archive is larger than 0xFFFFFFFF.  These quantities
               are not known until a <c>Save()</c> is attempted on the zip archive and
               the compression is applied.
             </para>
            
             <para>
               If none of the three conditions holds, then the <c>Value</c> is false.
             </para>
            
             <para>
               A <c>Value</c> of false does not indicate that the entry, as saved in the
               zip archive, does not use ZIP64.  It merely indicates that ZIP64 is
               <em>not required</em>.  An entry may use ZIP64 even when not required if
               the <see cref="P:Ionic.Zip.ZipFile.UseZip64WhenSaving"/> property on the containing
               <c>ZipFile</c> instance is set to <see cref="F:Ionic.Zip.Zip64Option.Always"/>, or if
               the <see cref="P:Ionic.Zip.ZipFile.UseZip64WhenSaving"/> property on the containing
               <c>ZipFile</c> instance is set to <see cref="F:Ionic.Zip.Zip64Option.AsNecessary"/>
               and the output stream was not seekable.
             </para>
            
             </remarks>
             <seealso cref="P:Ionic.Zip.ZipEntry.OutputUsedZip64"/>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.OutputUsedZip64">
             <summary>
               Indicates whether the entry actually used ZIP64 extensions, as it was most
               recently written to the output file or stream.
             </summary>
            
             <remarks>
            
             <para>
               This Nullable property is null (Nothing in VB) until a <c>Save()</c>
               method on the containing <see cref="T:Ionic.Zip.ZipFile"/> instance has been
               called. <c>HasValue</c> is true only after a <c>Save()</c> method has been
               called.
             </para>
            
             <para>
               The value of this property for a particular <c>ZipEntry</c> may change
               over successive calls to <c>Save()</c> methods on the containing ZipFile,
               even if the file that corresponds to the <c>ZipEntry</c> does not. This
               may happen if other entries contained in the <c>ZipFile</c> expand,
               causing the offset for this particular entry to exceed 0xFFFFFFFF.
             </para>
             </remarks>
             <seealso cref="P:Ionic.Zip.ZipEntry.RequiresZip64"/>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.BitField">
             <summary>
               The bitfield for the entry as defined in the zip spec. You probably
               never need to look at this.
             </summary>
            
             <remarks>
             <para>
               You probably do not need to concern yourself with the contents of this
               property, but in case you do:
             </para>
            
             <list type="table">
             <listheader>
             <term>bit</term>
             <description>meaning</description>
             </listheader>
            
             <item>
             <term>0</term>
             <description>set if encryption is used.</description>
             </item>
            
             <item>
             <term>1-2</term>
             <description>
             set to determine whether normal, max, fast deflation.  DotNetZip library
             always leaves these bits unset when writing (indicating "normal"
             deflation"), but can read an entry with any value here.
             </description>
             </item>
            
             <item>
             <term>3</term>
             <description>
             Indicates that the Crc32, Compressed and Uncompressed sizes are zero in the
             local header.  This bit gets set on an entry during writing a zip file, when
             it is saved to a non-seekable output stream.
             </description>
             </item>
            
            
             <item>
             <term>4</term>
             <description>reserved for "enhanced deflating". This library doesn't do enhanced deflating.</description>
             </item>
            
             <item>
             <term>5</term>
             <description>set to indicate the zip is compressed patched data.  This library doesn't do that.</description>
             </item>
            
             <item>
             <term>6</term>
             <description>
             set if PKWare's strong encryption is used (must also set bit 1 if bit 6 is
             set). This bit is not set if WinZip's AES encryption is set.</description>
             </item>
            
             <item>
             <term>7</term>
             <description>not used</description>
             </item>
            
             <item>
             <term>8</term>
             <description>not used</description>
             </item>
            
             <item>
             <term>9</term>
             <description>not used</description>
             </item>
            
             <item>
             <term>10</term>
             <description>not used</description>
             </item>
            
             <item>
             <term>11</term>
             <description>
             Language encoding flag (EFS).  If this bit is set, the filename and comment
             fields for this file must be encoded using UTF-8. This library currently
             does not support UTF-8.
             </description>
             </item>
            
             <item>
             <term>12</term>
             <description>Reserved by PKWARE for enhanced compression.</description>
             </item>
            
             <item>
             <term>13</term>
             <description>
               Used when encrypting the Central Directory to indicate selected data
               values in the Local Header are masked to hide their actual values.  See
               the section in <a
               href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">the Zip
               specification</a> describing the Strong Encryption Specification for
               details.
             </description>
             </item>
            
             <item>
             <term>14</term>
             <description>Reserved by PKWARE.</description>
             </item>
            
             <item>
             <term>15</term>
             <description>Reserved by PKWARE.</description>
             </item>
            
             </list>
            
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.CompressionMethod">
             <summary>
               The compression method employed for this ZipEntry.
             </summary>
            
             <remarks>
            
             <para>
               <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">The
               Zip specification</see> allows a variety of compression methods.  This
               library supports just two: 0x08 = Deflate.  0x00 = Store (no compression),
               for reading or writing.
             </para>
            
             <para>
               When reading an entry from an existing zipfile, the value you retrieve
               here indicates the compression method used on the entry by the original
               creator of the zip.  When writing a zipfile, you can specify either 0x08
               (Deflate) or 0x00 (None).  If you try setting something else, you will get
               an exception.
             </para>
            
             <para>
               You may wish to set <c>CompressionMethod</c> to <c>CompressionMethod.None</c> (0)
               when zipping already-compressed data like a jpg, png, or mp3 file.
               This can save time and cpu cycles.
             </para>
            
             <para>
               When setting this property on a <c>ZipEntry</c> that is read from an
               existing zip file, calling <c>ZipFile.Save()</c> will cause the new
               CompressionMethod to be used on the entry in the newly saved zip file.
             </para>
            
             <para>
               Setting this property may have the side effect of modifying the
               <c>CompressionLevel</c> property. If you set the <c>CompressionMethod</c> to a
               value other than <c>None</c>, and <c>CompressionLevel</c> is previously
               set to <c>None</c>, then <c>CompressionLevel</c> will be set to
               <c>Default</c>.
             </para>
             </remarks>
            
             <seealso cref="P:Ionic.Zip.ZipEntry.CompressionMethod"/>
            
             <example>
               In this example, the first entry added to the zip archive uses the default
               behavior - compression is used where it makes sense.  The second entry,
               the MP3 file, is added to the archive without being compressed.
             <code>
             using (ZipFile zip = new ZipFile(ZipFileToCreate))
             {
               ZipEntry e1= zip.AddFile(@"notes\Readme.txt");
               ZipEntry e2= zip.AddFile(@"music\StopThisTrain.mp3");
               e2.CompressionMethod = CompressionMethod.None;
               zip.Save();
             }
             </code>
            
             <code lang="VB">
             Using zip As New ZipFile(ZipFileToCreate)
               zip.AddFile("notes\Readme.txt")
               Dim e2 as ZipEntry = zip.AddFile("music\StopThisTrain.mp3")
               e2.CompressionMethod = CompressionMethod.None
               zip.Save
             End Using
             </code>
             </example>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.CompressionLevel">
             <summary>
               Sets the compression level to be used for the entry when saving the zip
               archive. This applies only for CompressionMethod = DEFLATE.
             </summary>
            
             <remarks>
              <para>
                When using the DEFLATE compression method, Varying the compression
                level used on entries can affect the size-vs-speed tradeoff when
                compression and decompressing data streams or files.
              </para>
            
              <para>
                If you do not set this property, the default compression level is used,
                which normally gives a good balance of compression efficiency and
                compression speed.  In some tests, using <c>BestCompression</c> can
                double the time it takes to compress, while delivering just a small
                increase in compression efficiency.  This behavior will vary with the
                type of data you compress.  If you are in doubt, just leave this setting
                alone, and accept the default.
              </para>
            
              <para>
                When setting this property on a <c>ZipEntry</c> that is read from an
                existing zip file, calling <c>ZipFile.Save()</c> will cause the new
                <c>CompressionLevel</c> to be used on the entry in the newly saved zip file.
              </para>
            
              <para>
                Setting this property may have the side effect of modifying the
                <c>CompressionMethod</c> property. If you set the <c>CompressionLevel</c>
                to a value other than <c>None</c>, <c>CompressionMethod</c> will be set
                to <c>Deflate</c>, if it was previously <c>None</c>.
              </para>
            
              <para>
                Setting this property has no effect if the <c>CompressionMethod</c> is something
                other than <c>Deflate</c> or <c>None</c>.
              </para>
             </remarks>
            
             <seealso cref="P:Ionic.Zip.ZipEntry.CompressionMethod"/>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.CompressedSize">
             <summary>
               The compressed size of the file, in bytes, within the zip archive.
             </summary>
            
             <remarks>
               When reading a <c>ZipFile</c>, this value is read in from the existing
               zip file. When creating or updating a <c>ZipFile</c>, the compressed
               size is computed during compression.  Therefore the value on a
               <c>ZipEntry</c> is valid after a call to <c>Save()</c> (or one of its
               overloads) in that case.
             </remarks>
            
             <seealso cref="P:Ionic.Zip.ZipEntry.UncompressedSize"/>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.UncompressedSize">
             <summary>
               The size of the file, in bytes, before compression, or after extraction.
             </summary>
            
             <remarks>
               When reading a <c>ZipFile</c>, this value is read in from the existing
               zip file. When creating or updating a <c>ZipFile</c>, the uncompressed
               size is computed during compression.  Therefore the value on a
               <c>ZipEntry</c> is valid after a call to <c>Save()</c> (or one of its
               overloads) in that case.
             </remarks>
            
             <seealso cref="P:Ionic.Zip.ZipEntry.CompressedSize"/>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.CompressionRatio">
             <summary>
             The ratio of compressed size to uncompressed size of the ZipEntry.
             </summary>
            
             <remarks>
             <para>
               This is a ratio of the compressed size to the uncompressed size of the
               entry, expressed as a double in the range of 0 to 100+. A value of 100
               indicates no compression at all.  It could be higher than 100 when the
               compression algorithm actually inflates the data, as may occur for small
               files, or uncompressible data that is encrypted.
             </para>
            
             <para>
               You could format it for presentation to a user via a format string of
               "{3,5:F0}%" to see it as a percentage.
             </para>
            
             <para>
               If the size of the original uncompressed file is 0, implying a
               denominator of 0, the return value will be zero.
             </para>
            
             <para>
               This property is valid after reading in an existing zip file, or after
               saving the <c>ZipFile</c> that contains the ZipEntry. You cannot know the
               effect of a compression transform until you try it.
             </para>
            
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.Crc">
             <summary>
             The 32-bit CRC (Cyclic Redundancy Check) on the contents of the ZipEntry.
             </summary>
            
             <remarks>
            
             <para> You probably don't need to concern yourself with this. It is used
             internally by DotNetZip to verify files or streams upon extraction.  </para>
            
             <para> The value is a <see href="http://en.wikipedia.org/wiki/CRC32">32-bit
             CRC</see> using 0xEDB88320 for the polynomial. This is the same CRC-32 used in
             PNG, MPEG-2, and other protocols and formats.  It is a read-only property; when
             creating a Zip archive, the CRC for each entry is set only after a call to
             <c>Save()</c> on the containing ZipFile. When reading an existing zip file, the value
             of this property reflects the stored CRC for the entry.  </para>
            
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.IsDirectory">
            <summary>
            True if the entry is a directory (not a file).
            This is a readonly property on the entry.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.UsesEncryption">
             <summary>
             A derived property that is <c>true</c> if the entry uses encryption.
             </summary>
            
             <remarks>
             <para>
               This is a readonly property on the entry.  When reading a zip file,
               the value for the <c>ZipEntry</c> is determined by the data read
               from the zip file.  After saving a ZipFile, the value of this
               property for each <c>ZipEntry</c> indicates whether encryption was
               actually used (which will have been true if the <see
               cref="P:Ionic.Zip.ZipEntry.Password"/> was set and the <see cref="P:Ionic.Zip.ZipEntry.Encryption"/> property
               was something other than <see cref="F:Ionic.Zip.EncryptionAlgorithm.None"/>.
             </para>
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.Encryption">
             <summary>
               Set this to specify which encryption algorithm to use for the entry when
               saving it to a zip archive.
             </summary>
            
             <remarks>
            
             <para>
               Set this property in order to encrypt the entry when the <c>ZipFile</c> is
               saved. When setting this property, you must also set a <see
               cref="P:Ionic.Zip.ZipEntry.Password"/> on the entry.  If you set a value other than <see
               cref="F:Ionic.Zip.EncryptionAlgorithm.None"/> on this property and do not set a
               <c>Password</c> then the entry will not be encrypted. The <c>ZipEntry</c>
               data is encrypted as the <c>ZipFile</c> is saved, when you call <see
               cref="M:Ionic.Zip.ZipFile.Save"/> or one of its cousins on the containing
               <c>ZipFile</c> instance. You do not need to specify the <c>Encryption</c>
               when extracting entries from an archive.
             </para>
            
             <para>
               The Zip specification from PKWare defines a set of encryption algorithms,
               and the data formats for the zip archive that support them, and PKWare
               supports those algorithms in the tools it produces. Other vendors of tools
               and libraries, such as WinZip or Xceed, typically support <em>a
               subset</em> of the algorithms specified by PKWare. These tools can
               sometimes support additional different encryption algorithms and data
               formats, not specified by PKWare. The AES Encryption specified and
               supported by WinZip is the most popular example. This library supports a
               subset of the complete set of algorithms specified by PKWare and other
               vendors.
             </para>
            
             <para>
               There is no common, ubiquitous multi-vendor standard for strong encryption
               within zip files. There is broad support for so-called "traditional" Zip
               encryption, sometimes called Zip 2.0 encryption, as <see
               href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">specified
               by PKWare</see>, but this encryption is considered weak and
               breakable. This library currently supports the Zip 2.0 "weak" encryption,
               and also a stronger WinZip-compatible AES encryption, using either 128-bit
               or 256-bit key strength. If you want DotNetZip to support an algorithm
               that is not currently supported, call the author of this library and maybe
               we can talk business.
             </para>
            
             <para>
               The <see cref="T:Ionic.Zip.ZipFile"/> class also has a <see
               cref="P:Ionic.Zip.ZipFile.Encryption"/> property.  In most cases you will use
               <em>that</em> property when setting encryption. This property takes
               precedence over any <c>Encryption</c> set on the <c>ZipFile</c> itself.
               Typically, you would use the per-entry Encryption when most entries in the
               zip archive use one encryption algorithm, and a few entries use a
               different one.  If all entries in the zip file use the same Encryption,
               then it is simpler to just set this property on the ZipFile itself, when
               creating a zip archive.
             </para>
            
             <para>
               Some comments on updating archives: If you read a <c>ZipFile</c>, you can
               modify the Encryption on an encrypted entry: you can remove encryption
               from an entry that was encrypted; you can encrypt an entry that was not
               encrypted previously; or, you can change the encryption algorithm.  The
               changes in encryption are not made permanent until you call Save() on the
               <c>ZipFile</c>.  To effect changes in encryption, the entry content is
               streamed through several transformations, depending on the modification
               the application has requested. For example if the entry is not encrypted
               and the application sets <c>Encryption</c> to <c>PkzipWeak</c>, then at
               the time of <c>Save()</c>, the original entry is read and decompressed,
               then re-compressed and encrypted.  Conversely, if the original entry is
               encrypted with <c>PkzipWeak</c> encryption, and the application sets the
               <c>Encryption</c> property to <c>WinZipAes128</c>, then at the time of
               <c>Save()</c>, the original entry is decrypted via PKZIP encryption and
               decompressed, then re-compressed and re-encrypted with AES.  This all
               happens automatically within the library, but it can be time-consuming for
               large entries.
             </para>
            
             <para>
               Additionally, when updating archives, it is not possible to change the
               password when changing the encryption algorithm.  To change both the
               algorithm and the password, you need to Save() the zipfile twice.  First
               set the <c>Encryption</c> to None, then call <c>Save()</c>.  Then set the
               <c>Encryption</c> to the new value (not "None"), then call <c>Save()</c>
               once again.
             </para>
            
             <para>
               The WinZip AES encryption algorithms are not supported on the .NET Compact
               Framework.
             </para>
             </remarks>
            
             <example>
             <para>
               This example creates a zip archive that uses encryption, and then extracts
               entries from the archive.  When creating the zip archive, the ReadMe.txt
               file is zipped without using a password or encryption.  The other file
               uses encryption.
             </para>
             <code>
             // Create a zip archive with AES Encryption.
             using (ZipFile zip = new ZipFile())
             {
                 zip.AddFile("ReadMe.txt")
                 ZipEntry e1= zip.AddFile("2008-Regional-Sales-Report.pdf");
                 e1.Encryption= EncryptionAlgorithm.WinZipAes256;
                 e1.Password= "Top.Secret.No.Peeking!";
                 zip.Save("EncryptedArchive.zip");
             }
            
             // Extract a zip archive that uses AES Encryption.
             // You do not need to specify the algorithm during extraction.
             using (ZipFile zip = ZipFile.Read("EncryptedArchive.zip"))
             {
                 // Specify the password that is used during extraction, for
                 // all entries that require a password:
                 zip.Password= "Top.Secret.No.Peeking!";
                 zip.ExtractAll("extractDirectory");
             }
             </code>
            
             <code lang="VB">
             ' Create a zip that uses Encryption.
             Using zip As New ZipFile()
                 zip.AddFile("ReadMe.txt")
                 Dim e1 as ZipEntry
                 e1= zip.AddFile("2008-Regional-Sales-Report.pdf")
                 e1.Encryption= EncryptionAlgorithm.WinZipAes256
                 e1.Password= "Top.Secret.No.Peeking!"
                 zip.Save("EncryptedArchive.zip")
             End Using
            
             ' Extract a zip archive that uses AES Encryption.
             ' You do not need to specify the algorithm during extraction.
             Using (zip as ZipFile = ZipFile.Read("EncryptedArchive.zip"))
                 ' Specify the password that is used during extraction, for
                 ' all entries that require a password:
                 zip.Password= "Top.Secret.No.Peeking!"
                 zip.ExtractAll("extractDirectory")
             End Using
             </code>
            
             </example>
            
             <exception cref="T:System.InvalidOperationException">
             Thrown in the setter if EncryptionAlgorithm.Unsupported is specified.
             </exception>
            
             <seealso cref="P:Ionic.Zip.ZipEntry.Password">ZipEntry.Password</seealso>
             <seealso cref="P:Ionic.Zip.ZipFile.Encryption">ZipFile.Encryption</seealso>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.Password">
             <summary>
             The Password to be used when encrypting a <c>ZipEntry</c> upon
             <c>ZipFile.Save()</c>, or when decrypting an entry upon Extract().
             </summary>
            
             <remarks>
             <para>
               This is a write-only property on the entry. Set this to request that the
               entry be encrypted when writing the zip archive, or set it to specify the
               password to be used when extracting an existing entry that is encrypted.
             </para>
            
             <para>
               The password set here is implicitly used to encrypt the entry during the
               <see cref="M:Ionic.Zip.ZipFile.Save"/> operation, or to decrypt during the <see
               cref="M:Ionic.Zip.ZipEntry.Extract"/> or <see cref="M:Ionic.Zip.ZipEntry.OpenReader"/> operation.  If you set
               the Password on a <c>ZipEntry</c> after calling <c>Save()</c>, there is no
               effect.
             </para>
            
             <para>
               Consider setting the <see cref="P:Ionic.Zip.ZipEntry.Encryption"/> property when using a
               password. Answering concerns that the standard password protection
               supported by all zip tools is weak, WinZip has extended the ZIP
               specification with a way to use AES Encryption to protect entries in the
               Zip file. Unlike the "PKZIP 2.0" encryption specified in the PKZIP
               specification, <see href=
               "http://en.wikipedia.org/wiki/Advanced_Encryption_Standard">AES
               Encryption</see> uses a standard, strong, tested, encryption
               algorithm. DotNetZip can create zip archives that use WinZip-compatible
               AES encryption, if you set the <see cref="P:Ionic.Zip.ZipEntry.Encryption"/> property. But,
               archives created that use AES encryption may not be readable by all other
               tools and libraries. For example, Windows Explorer cannot read a
               "compressed folder" (a zip file) that uses AES encryption, though it can
               read a zip file that uses "PKZIP encryption."
             </para>
            
             <para>
               The <see cref="T:Ionic.Zip.ZipFile"/> class also has a <see cref="P:Ionic.Zip.ZipFile.Password"/>
               property.  This property takes precedence over any password set on the
               ZipFile itself.  Typically, you would use the per-entry Password when most
               entries in the zip archive use one password, and a few entries use a
               different password.  If all entries in the zip file use the same password,
               then it is simpler to just set this property on the ZipFile itself,
               whether creating a zip archive or extracting a zip archive.
             </para>
            
             <para>
               Some comments on updating archives: If you read a <c>ZipFile</c>, you
               cannot modify the password on any encrypted entry, except by extracting
               the entry with the original password (if any), removing the original entry
               via <see cref="M:Ionic.Zip.ZipFile.RemoveEntry(Ionic.Zip.ZipEntry)"/>, and then adding a new
               entry with a new Password.
             </para>
            
             <para>
               For example, suppose you read a <c>ZipFile</c>, and there is an encrypted
               entry.  Setting the Password property on that <c>ZipEntry</c> and then
               calling <c>Save()</c> on the <c>ZipFile</c> does not update the password
               on that entry in the archive.  Neither is an exception thrown. Instead,
               what happens during the <c>Save()</c> is the existing entry is copied
               through to the new zip archive, in its original encrypted form. Upon
               re-reading that archive, the entry can be decrypted with its original
               password.
             </para>
            
             <para>
               If you read a ZipFile, and there is an un-encrypted entry, you can set the
               <c>Password</c> on the entry and then call Save() on the ZipFile, and get
               encryption on that entry.
             </para>
            
             </remarks>
            
             <example>
             <para>
               This example creates a zip file with two entries, and then extracts the
               entries from the zip file.  When creating the zip file, the two files are
               added to the zip file using password protection. Each entry uses a
               different password.  During extraction, each file is extracted with the
               appropriate password.
             </para>
             <code>
             // create a file with encryption
             using (ZipFile zip = new ZipFile())
             {
                 ZipEntry entry;
                 entry= zip.AddFile("Declaration.txt");
                 entry.Password= "123456!";
                 entry = zip.AddFile("Report.xls");
                 entry.Password= "1Secret!";
                 zip.Save("EncryptedArchive.zip");
             }
            
             // extract entries that use encryption
             using (ZipFile zip = ZipFile.Read("EncryptedArchive.zip"))
             {
                 ZipEntry entry;
                 entry = zip["Declaration.txt"];
                 entry.Password = "123456!";
                 entry.Extract("extractDir");
                 entry = zip["Report.xls"];
                 entry.Password = "1Secret!";
                 entry.Extract("extractDir");
             }
            
             </code>
            
             <code lang="VB">
             Using zip As New ZipFile
                 Dim entry as ZipEntry
                 entry= zip.AddFile("Declaration.txt")
                 entry.Password= "123456!"
                 entry = zip.AddFile("Report.xls")
                 entry.Password= "1Secret!"
                 zip.Save("EncryptedArchive.zip")
             End Using
            
            
             ' extract entries that use encryption
             Using (zip as ZipFile = ZipFile.Read("EncryptedArchive.zip"))
                 Dim entry as ZipEntry
                 entry = zip("Declaration.txt")
                 entry.Password = "123456!"
                 entry.Extract("extractDir")
                 entry = zip("Report.xls")
                 entry.Password = "1Secret!"
                 entry.Extract("extractDir")
             End Using
            
             </code>
            
             </example>
            
             <seealso cref="P:Ionic.Zip.ZipEntry.Encryption"/>
             <seealso cref="P:Ionic.Zip.ZipFile.Password">ZipFile.Password</seealso>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.ExtractExistingFile">
             <summary>
             The action the library should take when extracting a file that already exists.
             </summary>
            
             <remarks>
               <para>
                 This property affects the behavior of the Extract methods (one of the
                 <c>Extract()</c> or <c>ExtractWithPassword()</c> overloads), when
                 extraction would would overwrite an existing filesystem file. If you do
                 not set this property, the library throws an exception when extracting
                 an entry would overwrite an existing file.
               </para>
            
               <para>
                 This property has no effect when extracting to a stream, or when the file to be
                 extracted does not already exist.
               </para>
            
             </remarks>
             <seealso cref="P:Ionic.Zip.ZipFile.ExtractExistingFile"/>
            
             <example>
               This example shows how to set the <c>ExtractExistingFile</c> property in
               an <c>ExtractProgress</c> event, in response to user input. The
               <c>ExtractProgress</c> event is invoked if and only if the
               <c>ExtractExistingFile</c> property was previously set to
               <c>ExtractExistingFileAction.InvokeExtractProgressEvent</c>.
             <code lang="C#">
             public static void ExtractProgress(object sender, ExtractProgressEventArgs e)
             {
                 if (e.EventType == ZipProgressEventType.Extracting_BeforeExtractEntry)
                     Console.WriteLine("extract {0} ", e.CurrentEntry.FileName);
            
                 else if (e.EventType == ZipProgressEventType.Extracting_ExtractEntryWouldOverwrite)
                 {
                     ZipEntry entry = e.CurrentEntry;
                     string response = null;
                     // Ask the user if he wants overwrite the file
                     do
                     {
                         Console.Write("Overwrite {0} in {1} ? (y/n/C) ", entry.FileName, e.ExtractLocation);
                         response = Console.ReadLine();
                         Console.WriteLine();
            
                     } while (response != null &amp;&amp; response[0]!='Y' &amp;&amp;
                              response[0]!='N' &amp;&amp; response[0]!='C');
            
                     if  (response[0]=='C')
                         e.Cancel = true;
                     else if (response[0]=='Y')
                         entry.ExtractExistingFile = ExtractExistingFileAction.OverwriteSilently;
                     else
                         entry.ExtractExistingFile= ExtractExistingFileAction.DoNotOverwrite;
                 }
             }
             </code>
             </example>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.ZipErrorAction">
             <summary>
               The action to take when an error is encountered while
               opening or reading files as they are saved into a zip archive.
             </summary>
            
             <remarks>
              <para>
                 Errors can occur within a call to <see
                 cref="M:Ionic.Zip.ZipFile.Save">ZipFile.Save</see>, as the various files contained
                 in a ZipFile are being saved into the zip archive.  During the
                 <c>Save</c>, DotNetZip will perform a <c>File.Open</c> on the file
                 associated to the ZipEntry, and then will read the entire contents of
                 the file as it is zipped. Either the open or the Read may fail, because
                 of lock conflicts or other reasons.  Using this property, you can
                 specify the action to take when such errors occur.
              </para>
            
              <para>
                 Typically you will NOT set this property on individual ZipEntry
                 instances.  Instead, you will set the <see
                 cref="P:Ionic.Zip.ZipFile.ZipErrorAction">ZipFile.ZipErrorAction</see> property on
                 the ZipFile instance, before adding any entries to the
                 <c>ZipFile</c>. If you do this, errors encountered on behalf of any of
                 the entries in the ZipFile will be handled the same way.
              </para>
            
              <para>
                 But, if you use a <see cref="E:Ionic.Zip.ZipFile.ZipError"/> handler, you will want
                 to set this property on the <c>ZipEntry</c> within the handler, to
                 communicate back to DotNetZip what you would like to do with the
                 particular error.
              </para>
            
             </remarks>
             <seealso cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>
             <seealso cref="E:Ionic.Zip.ZipFile.ZipError"/>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.IncludedInMostRecentSave">
            <summary>
            Indicates whether the entry was included in the most recent save.
            </summary>
            <remarks>
            An entry can be excluded or skipped from a save if there is an error
            opening or reading the entry.
            </remarks>
            <seealso cref="P:Ionic.Zip.ZipEntry.ZipErrorAction"/>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.SetCompression">
             <summary>
               A callback that allows the application to specify the compression to use
               for a given entry that is about to be added to the zip archive.
             </summary>
            
             <remarks>
             <para>
               See <see cref="P:Ionic.Zip.ZipFile.SetCompression" />
             </para>
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.UseUnicodeAsNecessary">
             <summary>
               Set to indicate whether to use UTF-8 encoding for filenames and comments.
             </summary>
            
             <remarks>
            
             <para>
               If this flag is set, the comment and filename for the entry will be
               encoded with UTF-8, as described in <see
               href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">the Zip
               specification</see>, if necessary. "Necessary" means, the filename or
               entry comment (if any) cannot be reflexively encoded and decoded using the
               default code page, IBM437.
             </para>
            
             <para>
               Setting this flag to true is equivalent to setting <see
               cref="P:Ionic.Zip.ZipEntry.ProvisionalAlternateEncoding"/> to <c>System.Text.Encoding.UTF8</c>.
             </para>
            
             <para>
               This flag has no effect or relation to the text encoding used within the
               file itself.
             </para>
            
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.ProvisionalAlternateEncoding">
             <summary>
               The text encoding to use for the FileName and Comment on this ZipEntry,
               when the default encoding is insufficient.
             </summary>
            
             <remarks>
            
             <para>
               Don't use this property.  See <see cref='P:Ionic.Zip.ZipEntry.AlternateEncoding'/>.
             </para>
            
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.AlternateEncoding">
            <summary>
              Specifies the alternate text encoding used by this ZipEntry
            </summary>
            <remarks>
              <para>
                The default text encoding used in Zip files for encoding filenames and
                comments is IBM437, which is something like a superset of ASCII.  In
                cases where this is insufficient, applications can specify an
                alternate encoding.
              </para>
              <para>
                When creating a zip file, the usage of the alternate encoding is
                governed by the <see cref="P:Ionic.Zip.ZipEntry.AlternateEncodingUsage"/> property.
                Typically you would set both properties to tell DotNetZip to employ an
                encoding that is not IBM437 in the zipfile you are creating.
              </para>
              <para>
                Keep in mind that because the ZIP specification states that the only
                valid encodings to use are IBM437 and UTF-8, if you use something
                other than that, then zip tools and libraries may not be able to
                successfully read the zip archive you generate.
              </para>
              <para>
                The zip specification states that applications should presume that
                IBM437 is in use, except when a special bit is set, which indicates
                UTF-8. There is no way to specify an arbitrary code page, within the
                zip file itself. When you create a zip file encoded with gb2312 or
                ibm861 or anything other than IBM437 or UTF-8, then the application
                that reads the zip file needs to "know" which code page to use. In
                some cases, the code page used when reading is chosen implicitly. For
                example, WinRar uses the ambient code page for the host desktop
                operating system. The pitfall here is that if you create a zip in
                Copenhagen and send it to Tokyo, the reader of the zipfile may not be
                able to decode successfully.
              </para>
            </remarks>
            <example>
              This example shows how to create a zipfile encoded with a
              language-specific encoding:
            <code>
              using (var zip = new ZipFile())
              {
                 zip.AlternateEnoding = System.Text.Encoding.GetEncoding("ibm861");
                 zip.AlternateEnodingUsage = ZipOption.Always;
                 zip.AddFileS(arrayOfFiles);
                 zip.Save("Myarchive-Encoded-in-IBM861.zip");
              }
            </code>
            </example>
            <seealso cref="P:Ionic.Zip.ZipFile.AlternateEncodingUsage" />
        </member>
        <member name="P:Ionic.Zip.ZipEntry.AlternateEncodingUsage">
            <summary>
              Describes if and when this instance should apply
              AlternateEncoding to encode the FileName and Comment, when
              saving.
            </summary>
            <seealso cref="P:Ionic.Zip.ZipFile.AlternateEncoding" />
        </member>
        <member name="P:Ionic.Zip.ZipEntry.IsText">
             <summary>
               Indicates whether an entry is marked as a text file. Be careful when
               using on this property. Unless you have a good reason, you should
               probably ignore this property.
             </summary>
            
             <remarks>
             <para>
               The ZIP format includes a provision for specifying whether an entry in
               the zip archive is a text or binary file.  This property exposes that
               metadata item. Be careful when using this property: It's not clear
               that this property as a firm meaning, across tools and libraries.
             </para>
            
             <para>
               To be clear, when reading a zip file, the property value may or may
               not be set, and its value may or may not be valid.  Not all entries
               that you may think of as "text" entries will be so marked, and entries
               marked as "text" are not guaranteed in any way to be text entries.
               Whether the value is set and set correctly depends entirely on the
               application that produced the zip file.
             </para>
            
             <para>
               There are many zip tools available, and when creating zip files, some
               of them "respect" the IsText metadata field, and some of them do not.
               Unfortunately, even when an application tries to do "the right thing",
               it's not always clear what "the right thing" is.
             </para>
            
             <para>
               There's no firm definition of just what it means to be "a text file",
               and the zip specification does not help in this regard. Twenty years
               ago, text was ASCII, each byte was less than 127. IsText meant, all
               bytes in the file were less than 127.  These days, it is not the case
               that all text files have all bytes less than 127.  Any unicode file
               may have bytes that are above 0x7f.  The zip specification has nothing
               to say on this topic. Therefore, it's not clear what IsText really
               means.
             </para>
            
             <para>
               This property merely tells a reading application what is stored in the
               metadata for an entry, without guaranteeing its validity or its
               meaning.
             </para>
            
             <para>
               When DotNetZip is used to create a zipfile, it attempts to set this
               field "correctly." For example, if a file ends in ".txt", this field
               will be set. Your application may override that default setting.  When
               writing a zip file, you must set the property before calling
               <c>Save()</c> on the ZipFile.
             </para>
            
             <para>
               When reading a zip file, a more general way to decide just what kind
               of file is contained in a particular entry is to use the file type
               database stored in the operating system.  The operating system stores
               a table that says, a file with .jpg extension is a JPG image file, a
               file with a .xml extension is an XML document, a file with a .txt is a
               pure ASCII text document, and so on.  To get this information on
               Windows, <see
               href="http://www.codeproject.com/KB/cs/GetFileTypeAndIcon.aspx"> you
               need to read and parse the registry.</see> </para>
             </remarks>
            
             <example>
             <code>
             using (var zip = new ZipFile())
             {
                 var e = zip.UpdateFile("Descriptions.mme", "");
                 e.IsText = true;
                 zip.Save(zipPath);
             }
             </code>
            
             <code lang="VB">
             Using zip As New ZipFile
                 Dim e2 as ZipEntry = zip.AddFile("Descriptions.mme", "")
                 e.IsText= True
                 zip.Save(zipPath)
             End Using
             </code>
             </example>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.ToString">
            <summary>Provides a string representation of the instance.</summary>
            <returns>a string representation of the instance.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.Extract">
             <summary>
               Extract the entry to the filesystem, starting at the current
               working directory.
             </summary>
            
             <overloads>
               This method has a bunch of overloads! One of them is sure to
               be the right one for you... If you don't like these, check
               out the <c>ExtractWithPassword()</c> methods.
             </overloads>
            
             <seealso cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile"/>
             <seealso cref="M:Ionic.Zip.ZipEntry.Extract(Ionic.Zip.ExtractExistingFileAction)"/>
            
             <remarks>
            
             <para>
               This method extracts an entry from a zip file into the current
               working directory.  The path of the entry as extracted is the full
               path as specified in the zip archive, relative to the current
               working directory.  After the file is extracted successfully, the
               file attributes and timestamps are set.
             </para>
            
             <para>
               The action taken when extraction an entry would overwrite an
               existing file is determined by the <see cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile"
               /> property.
             </para>
            
             <para>
               Within the call to <c>Extract()</c>, the content for the entry is
               written into a filesystem file, and then the last modified time of the
               file is set according to the <see cref="P:Ionic.Zip.ZipEntry.LastModified"/> property on
               the entry. See the remarks the <see cref="P:Ionic.Zip.ZipEntry.LastModified"/> property for
               some details about the last modified time.
             </para>
            
             </remarks>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.Extract(Ionic.Zip.ExtractExistingFileAction)">
             <summary>
               Extract the entry to a file in the filesystem, using the specified
               behavior when extraction would overwrite an existing file.
             </summary>
            
             <remarks>
             <para>
               See the remarks on the <see cref="P:Ionic.Zip.ZipEntry.LastModified"/> property, for some
               details about how the last modified time of the file is set after
               extraction.
             </para>
             </remarks>
            
             <param name="extractExistingFile">
               The action to take if extraction would overwrite an existing file.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.Extract(System.IO.Stream)">
             <summary>
               Extracts the entry to the specified stream.
             </summary>
            
             <remarks>
             <para>
               The caller can specify any write-able stream, for example a <see
               cref="T:System.IO.FileStream"/>, a <see
               cref="T:System.IO.MemoryStream"/>, or ASP.NET's
               <c>Response.OutputStream</c>.  The content will be decrypted and
               decompressed as necessary. If the entry is encrypted and no password
               is provided, this method will throw.
             </para>
             <para>
               The position on the stream is not reset by this method before it extracts.
               You may want to call stream.Seek() before calling ZipEntry.Extract().
             </para>
             </remarks>
            
             <param name="stream">
               the stream to which the entry should be extracted.
             </param>
            
        </member>
        <member name="M:Ionic.Zip.ZipEntry.Extract(System.String)">
             <summary>
               Extract the entry to the filesystem, starting at the specified base
               directory.
             </summary>
            
             <param name="baseDirectory">the pathname of the base directory</param>
            
             <seealso cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile"/>
             <seealso cref="M:Ionic.Zip.ZipEntry.Extract(System.String,Ionic.Zip.ExtractExistingFileAction)"/>
            
             <example>
             This example extracts only the entries in a zip file that are .txt files,
             into a directory called "textfiles".
             <code lang="C#">
             using (ZipFile zip = ZipFile.Read("PackedDocuments.zip"))
             {
               foreach (string s1 in zip.EntryFilenames)
               {
                 if (s1.EndsWith(".txt"))
                 {
                   zip[s1].Extract("textfiles");
                 }
               }
             }
             </code>
             <code lang="VB">
               Using zip As ZipFile = ZipFile.Read("PackedDocuments.zip")
                   Dim s1 As String
                   For Each s1 In zip.EntryFilenames
                       If s1.EndsWith(".txt") Then
                           zip(s1).Extract("textfiles")
                       End If
                   Next
               End Using
             </code>
             </example>
            
             <remarks>
            
             <para>
               Using this method, existing entries in the filesystem will not be
               overwritten. If you would like to force the overwrite of existing
               files, see the <see cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile"/> property, or call
               <see cref="M:Ionic.Zip.ZipEntry.Extract(System.String,Ionic.Zip.ExtractExistingFileAction)"/>.
             </para>
            
             <para>
               See the remarks on the <see cref="P:Ionic.Zip.ZipEntry.LastModified"/> property, for some
               details about how the last modified time of the created file is set.
             </para>
             </remarks>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.Extract(System.String,Ionic.Zip.ExtractExistingFileAction)">
             <summary>
               Extract the entry to the filesystem, starting at the specified base
               directory, and using the specified behavior when extraction would
               overwrite an existing file.
             </summary>
            
             <remarks>
             <para>
               See the remarks on the <see cref="P:Ionic.Zip.ZipEntry.LastModified"/> property, for some
               details about how the last modified time of the created file is set.
             </para>
             </remarks>
            
             <example>
             <code lang="C#">
             String sZipPath = "Airborne.zip";
             String sFilePath = "Readme.txt";
             String sRootFolder = "Digado";
             using (ZipFile zip = ZipFile.Read(sZipPath))
             {
               if (zip.EntryFileNames.Contains(sFilePath))
               {
                 // use the string indexer on the zip file
                 zip[sFileName].Extract(sRootFolder,
                                        ExtractExistingFileAction.OverwriteSilently);
               }
             }
             </code>
            
             <code lang="VB">
             Dim sZipPath as String = "Airborne.zip"
             Dim sFilePath As String = "Readme.txt"
             Dim sRootFolder As String = "Digado"
             Using zip As ZipFile = ZipFile.Read(sZipPath)
               If zip.EntryFileNames.Contains(sFilePath)
                 ' use the string indexer on the zip file
                 zip(sFilePath).Extract(sRootFolder, _
                                        ExtractExistingFileAction.OverwriteSilently)
               End If
             End Using
             </code>
             </example>
            
             <param name="baseDirectory">the pathname of the base directory</param>
             <param name="extractExistingFile">
             The action to take if extraction would overwrite an existing file.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.ExtractWithPassword(System.String)">
             <summary>
               Extract the entry to the filesystem, using the current working directory
               and the specified password.
             </summary>
            
             <overloads>
               This method has a bunch of overloads! One of them is sure to be
               the right one for you...
             </overloads>
            
             <seealso cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile"/>
             <seealso cref="M:Ionic.Zip.ZipEntry.ExtractWithPassword(Ionic.Zip.ExtractExistingFileAction,System.String)"/>
            
             <remarks>
            
             <para>
               Existing entries in the filesystem will not be overwritten. If you
               would like to force the overwrite of existing files, see the <see
               cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile"/>property, or call
               <see
               cref="M:Ionic.Zip.ZipEntry.ExtractWithPassword(Ionic.Zip.ExtractExistingFileAction,System.String)"/>.
             </para>
            
             <para>
               See the remarks on the <see cref="P:Ionic.Zip.ZipEntry.LastModified"/> property for some
               details about how the "last modified" time of the created file is
               set.
             </para>
             </remarks>
            
             <example>
               In this example, entries that use encryption are extracted using a
               particular password.
             <code>
             using (var zip = ZipFile.Read(FilePath))
             {
                 foreach (ZipEntry e in zip)
                 {
                     if (e.UsesEncryption)
                         e.ExtractWithPassword("Secret!");
                     else
                         e.Extract();
                 }
             }
             </code>
             <code lang="VB">
             Using zip As ZipFile = ZipFile.Read(FilePath)
                 Dim e As ZipEntry
                 For Each e In zip
                     If (e.UsesEncryption)
                       e.ExtractWithPassword("Secret!")
                     Else
                       e.Extract
                     End If
                 Next
             End Using
             </code>
             </example>
             <param name="password">The Password to use for decrypting the entry.</param>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.ExtractWithPassword(System.String,System.String)">
             <summary>
               Extract the entry to the filesystem, starting at the specified base
               directory, and using the specified password.
             </summary>
            
             <seealso cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile"/>
             <seealso cref="M:Ionic.Zip.ZipEntry.ExtractWithPassword(System.String,Ionic.Zip.ExtractExistingFileAction,System.String)"/>
            
             <remarks>
             <para>
               Existing entries in the filesystem will not be overwritten. If you
               would like to force the overwrite of existing files, see the <see
               cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile"/>property, or call
               <see
               cref="M:Ionic.Zip.ZipEntry.ExtractWithPassword(Ionic.Zip.ExtractExistingFileAction,System.String)"/>.
             </para>
            
             <para>
               See the remarks on the <see cref="P:Ionic.Zip.ZipEntry.LastModified"/> property, for some
               details about how the last modified time of the created file is set.
             </para>
             </remarks>
            
             <param name="baseDirectory">The pathname of the base directory.</param>
             <param name="password">The Password to use for decrypting the entry.</param>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.ExtractWithPassword(Ionic.Zip.ExtractExistingFileAction,System.String)">
             <summary>
               Extract the entry to a file in the filesystem, relative to the
               current directory, using the specified behavior when extraction
               would overwrite an existing file.
             </summary>
            
             <remarks>
             <para>
               See the remarks on the <see cref="P:Ionic.Zip.ZipEntry.LastModified"/> property, for some
               details about how the last modified time of the created file is set.
             </para>
             </remarks>
            
             <param name="password">The Password to use for decrypting the entry.</param>
            
             <param name="extractExistingFile">
             The action to take if extraction would overwrite an existing file.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.ExtractWithPassword(System.String,Ionic.Zip.ExtractExistingFileAction,System.String)">
             <summary>
               Extract the entry to the filesystem, starting at the specified base
               directory, and using the specified behavior when extraction would
               overwrite an existing file.
             </summary>
            
             <remarks>
               See the remarks on the <see cref="P:Ionic.Zip.ZipEntry.LastModified"/> property, for some
               details about how the last modified time of the created file is set.
             </remarks>
            
             <param name="baseDirectory">the pathname of the base directory</param>
            
             <param name="extractExistingFile">The action to take if extraction would
             overwrite an existing file.</param>
            
             <param name="password">The Password to use for decrypting the entry.</param>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.ExtractWithPassword(System.IO.Stream,System.String)">
             <summary>
               Extracts the entry to the specified stream, using the specified
               Password.  For example, the caller could extract to Console.Out, or
               to a MemoryStream.
             </summary>
            
             <remarks>
             <para>
               The caller can specify any write-able stream, for example a <see
               cref="T:System.IO.FileStream"/>, a <see
               cref="T:System.IO.MemoryStream"/>, or ASP.NET's
               <c>Response.OutputStream</c>.  The content will be decrypted and
               decompressed as necessary. If the entry is encrypted and no password
               is provided, this method will throw.
             </para>
             <para>
               The position on the stream is not reset by this method before it extracts.
               You may want to call stream.Seek() before calling ZipEntry.Extract().
             </para>
             </remarks>
            
            
             <param name="stream">
               the stream to which the entry should be extracted.
             </param>
             <param name="password">
               The password to use for decrypting the entry.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.OpenReader">
             <summary>
               Opens a readable stream corresponding to the zip entry in the
               archive.  The stream decompresses and decrypts as necessary, as it
               is read.
             </summary>
            
             <remarks>
            
             <para>
               DotNetZip offers a variety of ways to extract entries from a zip
               file.  This method allows an application to extract an entry by
               reading a <see cref="T:System.IO.Stream"/>.
             </para>
            
             <para>
               The return value is of type <see
               cref="T:Ionic.Crc.CrcCalculatorStream"/>.  Use it as you would any
               stream for reading.  When an application calls <see
               cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)"/> on that stream, it will
               receive data from the zip entry that is decrypted and decompressed
               as necessary.
             </para>
            
             <para>
               <c>CrcCalculatorStream</c> adds one additional feature: it keeps a
               CRC32 checksum on the bytes of the stream as it is read.  The CRC
               value is available in the <see
               cref="P:Ionic.Crc.CrcCalculatorStream.Crc"/> property on the
               <c>CrcCalculatorStream</c>.  When the read is complete, your
               application
               <em>should</em> check this CRC against the <see cref="P:Ionic.Zip.ZipEntry.Crc"/>
               property on the <c>ZipEntry</c> to validate the content of the
               ZipEntry. You don't have to validate the entry using the CRC, but
               you should, to verify integrity. Check the example for how to do
               this.
             </para>
            
             <para>
               If the entry is protected with a password, then you need to provide
               a password prior to calling <see cref="M:Ionic.Zip.ZipEntry.OpenReader"/>, either by
               setting the <see cref="P:Ionic.Zip.ZipEntry.Password"/> property on the entry, or the
               <see cref="P:Ionic.Zip.ZipFile.Password"/> property on the <c>ZipFile</c>
               itself. Or, you can use <see cref="M:Ionic.Zip.ZipEntry.OpenReader(System.String)" />, the
               overload of OpenReader that accepts a password parameter.
             </para>
            
             <para>
               If you want to extract entry data into a write-able stream that is
               already opened, like a <see cref="T:System.IO.FileStream"/>, do not
               use this method. Instead, use <see cref="M:Ionic.Zip.ZipEntry.Extract(System.IO.Stream)"/>.
             </para>
            
             <para>
               Your application may use only one stream created by OpenReader() at
               a time, and you should not call other Extract methods before
               completing your reads on a stream obtained from OpenReader().  This
               is because there is really only one source stream for the compressed
               content.  A call to OpenReader() seeks in the source stream, to the
               beginning of the compressed content.  A subsequent call to
               OpenReader() on a different entry will seek to a different position
               in the source stream, as will a call to Extract() or one of its
               overloads.  This will corrupt the state for the decompressing stream
               from the original call to OpenReader().
             </para>
            
             <para>
                The <c>OpenReader()</c> method works only when the ZipEntry is
                obtained from an instance of <c>ZipFile</c>. This method will throw
                an exception if the ZipEntry is obtained from a <see
                cref="T:Ionic.Zip.ZipInputStream"/>.
             </para>
             </remarks>
            
             <example>
               This example shows how to open a zip archive, then read in a named
               entry via a stream. After the read loop is complete, the code
               compares the calculated during the read loop with the expected CRC
               on the <c>ZipEntry</c>, to verify the extraction.
             <code>
             using (ZipFile zip = new ZipFile(ZipFileToRead))
             {
               ZipEntry e1= zip["Elevation.mp3"];
               using (Ionic.Zlib.CrcCalculatorStream s = e1.OpenReader())
               {
                 byte[] buffer = new byte[4096];
                 int n, totalBytesRead= 0;
                 do {
                   n = s.Read(buffer,0, buffer.Length);
                   totalBytesRead+=n;
                 } while (n&gt;0);
                  if (s.Crc32 != e1.Crc32)
                   throw new Exception(string.Format("The Zip Entry failed the CRC Check. (0x{0:X8}!=0x{1:X8})", s.Crc32, e1.Crc32));
                  if (totalBytesRead != e1.UncompressedSize)
                   throw new Exception(string.Format("We read an unexpected number of bytes. ({0}!={1})", totalBytesRead, e1.UncompressedSize));
               }
             }
             </code>
             <code lang="VB">
               Using zip As New ZipFile(ZipFileToRead)
                   Dim e1 As ZipEntry = zip.Item("Elevation.mp3")
                   Using s As Ionic.Zlib.CrcCalculatorStream = e1.OpenReader
                       Dim n As Integer
                       Dim buffer As Byte() = New Byte(4096) {}
                       Dim totalBytesRead As Integer = 0
                       Do
                           n = s.Read(buffer, 0, buffer.Length)
                           totalBytesRead = (totalBytesRead + n)
                       Loop While (n &gt; 0)
                       If (s.Crc32 &lt;&gt; e1.Crc32) Then
                           Throw New Exception(String.Format("The Zip Entry failed the CRC Check. (0x{0:X8}!=0x{1:X8})", s.Crc32, e1.Crc32))
                       End If
                       If (totalBytesRead &lt;&gt; e1.UncompressedSize) Then
                           Throw New Exception(String.Format("We read an unexpected number of bytes. ({0}!={1})", totalBytesRead, e1.UncompressedSize))
                       End If
                   End Using
               End Using
             </code>
             </example>
             <seealso cref="M:Ionic.Zip.ZipEntry.Extract(System.IO.Stream)"/>
             <returns>The Stream for reading.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.OpenReader(System.String)">
             <summary>
               Opens a readable stream for an encrypted zip entry in the archive.
               The stream decompresses and decrypts as necessary, as it is read.
             </summary>
            
             <remarks>
             <para>
               See the documentation on the <see cref="M:Ionic.Zip.ZipEntry.OpenReader"/> method for
               full details. This overload allows the application to specify a
               password for the <c>ZipEntry</c> to be read.
             </para>
             </remarks>
            
             <param name="password">The password to use for decrypting the entry.</param>
             <returns>The Stream for reading.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.ValidateOutput(System.String,System.IO.Stream,System.String@)">
            <summary>
            Validates that the args are consistent.
            </summary>
            <remarks>
            Only one of {baseDir, outStream} can be non-null.
            If baseDir is non-null, then the outputFile is created.
            </remarks>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.ReadEntry(Ionic.Zip.ZipContainer,System.Boolean)">
            <summary>
              Reads one <c>ZipEntry</c> from the given stream.  The content for
              the entry does not get decompressed or decrypted.  This method
              basically reads metadata, and seeks.
            </summary>
            <param name="zc">the ZipContainer this entry belongs to.</param>
            <param name="first">
              true of this is the first entry being read from the stream.
            </param>
            <returns>the <c>ZipEntry</c> read from the stream.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.FindExtraFieldSegment(System.Byte[],System.Int32,System.UInt16)">
            <summary>
              Finds a particular segment in the given extra field.
              This is used when modifying a previously-generated
              extra field, in particular when removing the AES crypto
              segment in the extra field.
            </summary>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.ProcessExtraField(System.IO.Stream,System.Int16)">
            <summary>
              At current cursor position in the stream, read the extra
              field, and set the properties on the ZipEntry instance
              appropriately.  This can be called when processing the
              Extra field in the Central Directory, or in the local
              header.
            </summary>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.GetEncodedFileNameBytes">
            <summary>
              generate and return a byte array that encodes the filename
              for the entry.
            </summary>
            <remarks>
              <para>
                side effects: generate and store into _CommentBytes the
                byte array for any comment attached to the entry. Also
                sets _actualEncoding to indicate the actual encoding
                used. The same encoding is used for both filename and
                comment.
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.PrepSourceStream">
             <summary>
               Stores the position of the entry source stream, or, if the position is
               already stored, seeks to that position.
             </summary>
            
             <remarks>
             <para>
               This method is called in prep for reading the source stream.  If PKZIP
               encryption is used, then we need to calc the CRC32 before doing the
               encryption, because the CRC is used in the 12th byte of the PKZIP
               encryption header.  So, we need to be able to seek backward in the source
               when saving the ZipEntry. This method is called from the place that
               calculates the CRC, and also from the method that does the encryption of
               the file data.
             </para>
            
             <para>
               The first time through, this method sets the _sourceStreamOriginalPosition
               field. Subsequent calls to this method seek to that position.
             </para>
             </remarks>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.CopyMetaData(Ionic.Zip.ZipEntry)">
            <summary>
            Copy metadata that may have been changed by the app.  We do this when
            resetting the zipFile instance.  If the app calls Save() on a ZipFile, then
            tries to party on that file some more, we may need to Reset() it , which
            means re-reading the entries and then copying the metadata.  I think.
            </summary>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.SetInputAndFigureFileLength(System.IO.Stream@)">
            <summary>
              Set the input stream and get its length, if possible.  The length is
              used for progress updates, AND, to allow an optimization in case of
              a stream/file of zero length. In that case we skip the Encrypt and
              compression Stream. (like DeflateStream or BZip2OutputStream)
            </summary>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.PrepOutputStream(System.IO.Stream,System.Int64,Ionic.Zip.CountingStream@,System.IO.Stream@,System.IO.Stream@,Ionic.Crc.CrcCalculatorStream@)">
            <summary>
              Prepare the given stream for output - wrap it in a CountingStream, and
              then in a CRC stream, and an encryptor and deflator as appropriate.
            </summary>
            <remarks>
              <para>
                Previously this was used in ZipEntry.Write(), but in an effort to
                introduce some efficiencies in that method I've refactored to put the
                code inline.  This method still gets called by ZipOutputStream.
              </para>
            </remarks>
        </member>
        <member name="T:Ionic.Zip.ZipEntryTimestamp">
             <summary>
               An enum that specifies the type of timestamp available on the ZipEntry.
             </summary>
            
             <remarks>
            
             <para>
               The last modified time of a file can be stored in multiple ways in
               a zip file, and they are not mutually exclusive:
             </para>
            
             <list type="bullet">
               <item>
                 In the so-called "DOS" format, which has a 2-second precision. Values
                 are rounded to the nearest even second. For example, if the time on the
                 file is 12:34:43, then it will be stored as 12:34:44. This first value
                 is accessible via the <c>LastModified</c> property. This value is always
                 present in the metadata for each zip entry.  In some cases the value is
                 invalid, or zero.
               </item>
            
               <item>
                 In the so-called "Windows" or "NTFS" format, as an 8-byte integer
                 quantity expressed as the number of 1/10 milliseconds (in other words
                 the number of 100 nanosecond units) since January 1, 1601 (UTC).  This
                 format is how Windows represents file times.  This time is accessible
                 via the <c>ModifiedTime</c> property.
               </item>
            
               <item>
                 In the "Unix" format, a 4-byte quantity specifying the number of seconds since
                 January 1, 1970 UTC.
               </item>
            
               <item>
                 In an older format, now deprecated but still used by some current
                 tools. This format is also a 4-byte quantity specifying the number of
                 seconds since January 1, 1970 UTC.
               </item>
            
             </list>
            
             <para>
               This bit field describes which of the formats were found in a <c>ZipEntry</c> that was read.
             </para>
            
             </remarks>
        </member>
        <member name="F:Ionic.Zip.ZipEntryTimestamp.None">
            <summary>
            Default value.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipEntryTimestamp.DOS">
            <summary>
            A DOS timestamp with 2-second precision.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipEntryTimestamp.Windows">
            <summary>
            A Windows timestamp with 100-ns precision.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipEntryTimestamp.Unix">
            <summary>
            A Unix timestamp with 1-second precision.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipEntryTimestamp.InfoZip1">
            <summary>
            A Unix timestamp with 1-second precision, stored in InfoZip v1 format.  This
            format is outdated and is supported for reading archives only.
            </summary>
        </member>
        <member name="T:Ionic.Zip.CompressionMethod">
             <summary>
               The method of compression to use for a particular ZipEntry.
             </summary>
            
             <remarks>
               <see
               href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWare's
               ZIP Specification</see> describes a number of distinct
               cmopression methods that can be used within a zip
               file. DotNetZip supports a subset of them.
             </remarks>
        </member>
        <member name="F:Ionic.Zip.CompressionMethod.None">
            <summary>
            No compression at all. For COM environments, the value is 0 (zero).
            </summary>
        </member>
        <member name="F:Ionic.Zip.CompressionMethod.Deflate">
            <summary>
              DEFLATE compression, as described in <see
              href="http://www.ietf.org/rfc/rfc1951.txt">IETF RFC
              1951</see>.  This is the "normal" compression used in zip
              files. For COM environments, the value is 8.
            </summary>
        </member>
        <member name="T:Ionic.Zip.ZipEntrySource">
            <summary>
            An enum that specifies the source of the ZipEntry. 
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipEntrySource.None">
            <summary>
            Default value.  Invalid on a bonafide ZipEntry.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipEntrySource.FileSystem">
            <summary>
            The entry was instantiated by calling AddFile() or another method that 
            added an entry from the filesystem.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipEntrySource.Stream">
            <summary>
            The entry was instantiated via <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.String)"/> or
            <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.IO.Stream)"/> .
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipEntrySource.ZipFile">
            <summary>
            The ZipEntry was instantiated by reading a zipfile.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipEntrySource.WriteDelegate">
            <summary>
            The content for the ZipEntry will be or was provided by the WriteDelegate.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipEntrySource.JitStream">
            <summary>
            The content for the ZipEntry will be obtained from the stream dispensed by the <c>OpenDelegate</c>.
            The entry was instantiated via <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,Ionic.Zip.OpenDelegate,Ionic.Zip.CloseDelegate)"/>.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipEntrySource.ZipOutputStream">
            <summary>
            The content for the ZipEntry will be or was obtained from a <c>ZipOutputStream</c>.
            </summary>
        </member>
        <member name="T:Ionic.Zip.ZipErrorAction">
             <summary>
             An enum providing the options when an error occurs during opening or reading
             of a file or directory that is being saved to a zip file. 
             </summary>
            
             <remarks>
              <para>
                This enum describes the actions that the library can take when an error occurs
                opening or reading a file, as it is being saved into a Zip archive. 
              </para>
            
              <para>
                 In some cases an error will occur when DotNetZip tries to open a file to be
                 added to the zip archive.  In other cases, an error might occur after the
                 file has been successfully opened, while DotNetZip is reading the file.
              </para>
             
              <para>
                The first problem might occur when calling AddDirectory() on a directory
                that contains a Clipper .dbf file; the file is locked by Clipper and
                cannot be opened by another process. An example of the second problem is
                the ERROR_LOCK_VIOLATION that results when a file is opened by another
                process, but not locked, and a range lock has been taken on the file.
                Microsoft Outlook takes range locks on .PST files.
              </para>
             </remarks>
        </member>
        <member name="F:Ionic.Zip.ZipErrorAction.Throw">
            <summary>
            Throw an exception when an error occurs while zipping.  This is the default
            behavior.  (For COM clients, this is a 0 (zero).)
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipErrorAction.Skip">
            <summary>
            When an error occurs during zipping, for example a file cannot be opened,
            skip the file causing the error, and continue zipping.  (For COM clients,
            this is a 1.)
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipErrorAction.Retry">
            <summary>
            When an error occurs during zipping, for example a file cannot be opened,
            retry the operation that caused the error. Be careful with this option. If
            the error is not temporary, the library will retry forever.  (For COM
            clients, this is a 2.)
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipErrorAction.InvokeErrorEvent">
            <summary>
            When an error occurs, invoke the zipError event.  The event type used is
            <see cref="F:Ionic.Zip.ZipProgressEventType.Error_Saving"/>.  A typical use of this option:
            a GUI application may wish to pop up a dialog to allow the user to view the
            error that occurred, and choose an appropriate action.  After your
            processing in the error event, if you want to skip the file, set <see
            cref="P:Ionic.Zip.ZipEntry.ZipErrorAction"/> on the
            <c>ZipProgressEventArgs.CurrentEntry</c> to <c>Skip</c>.  If you want the
            exception to be thrown, set <c>ZipErrorAction</c> on the <c>CurrentEntry</c>
            to <c>Throw</c>.  If you want to cancel the zip, set
            <c>ZipProgressEventArgs.Cancel</c> to true.  Cancelling differs from using
            Skip in that a cancel will not save any further entries, if there are any.
            (For COM clients, the value of this enum is a 3.)
            </summary>
        </member>
        <member name="T:Ionic.Zip.ZipFile">
             <summary>
               The ZipFile type represents a zip archive file.
             </summary>
            
             <remarks>
             <para>
               This is the main type in the DotNetZip class library. This class reads and
               writes zip files, as defined in the <see
               href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">specification
               for zip files described by PKWare</see>.  The compression for this
               implementation is provided by a managed-code version of Zlib, included with
               DotNetZip in the classes in the Ionic.Zlib namespace.
             </para>
            
             <para>
               This class provides a general purpose zip file capability.  Use it to read,
               create, or update zip files.  When you want to create zip files using a
               <c>Stream</c> type to write the zip file, you may want to consider the <see
               cref="T:Ionic.Zip.ZipOutputStream"/> class.
             </para>
            
             <para>
               Both the <c>ZipOutputStream</c> class and the <c>ZipFile</c> class can
               be used to create zip files. Both of them support many of the common zip
               features, including Unicode, different compression methods and levels,
               and ZIP64. They provide very similar performance when creating zip
               files.
             </para>
            
             <para>
               The <c>ZipFile</c> class is generally easier to use than
               <c>ZipOutputStream</c> and should be considered a higher-level interface.  For
               example, when creating a zip file via calls to the <c>PutNextEntry()</c> and
               <c>Write()</c> methods on the <c>ZipOutputStream</c> class, the caller is
               responsible for opening the file, reading the bytes from the file, writing
               those bytes into the <c>ZipOutputStream</c>, setting the attributes on the
               <c>ZipEntry</c>, and setting the created, last modified, and last accessed
               timestamps on the zip entry. All of these things are done automatically by a
               call to <see cref="M:Ionic.Zip.ZipFile.AddFile(System.String,System.String)">ZipFile.AddFile()</see>.
               For this reason, the <c>ZipOutputStream</c> is generally recommended for use
               only when your application emits arbitrary data, not necessarily data from a
               filesystem file, directly into a zip file, and does so using a <c>Stream</c>
               metaphor.
             </para>
            
             <para>
               Aside from the differences in programming model, there are other
               differences in capability between the two classes.
             </para>
            
             <list type="bullet">
               <item>
                 <c>ZipFile</c> can be used to read and extract zip files, in addition to
                 creating zip files. <c>ZipOutputStream</c> cannot read zip files. If you want
                 to use a stream to read zip files, check out the <see cref="T:Ionic.Zip.ZipInputStream"/> class.
               </item>
            
               <item>
                 <c>ZipOutputStream</c> does not support the creation of segmented or spanned
                 zip files.
               </item>
            
               <item>
                 <c>ZipOutputStream</c> cannot produce a self-extracting archive.
               </item>
             </list>
            
             <para>
               Be aware that the <c>ZipFile</c> class implements the <see
               cref="T:System.IDisposable"/> interface.  In order for <c>ZipFile</c> to
               produce a valid zip file, you use use it within a using clause (<c>Using</c>
               in VB), or call the <c>Dispose()</c> method explicitly.  See the examples
               for how to employ a using clause.
             </para>
            
             </remarks>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddItem(System.String)">
             <summary>
               Adds an item, either a file or a directory, to a zip file archive.
             </summary>
            
             <remarks>
             <para>
               This method is handy if you are adding things to zip archive and don't
               want to bother distinguishing between directories or files.  Any files are
               added as single entries.  A directory added through this method is added
               recursively: all files and subdirectories contained within the directory
               are added to the <c>ZipFile</c>.
             </para>
            
             <para>
               The name of the item may be a relative path or a fully-qualified
               path. Remember, the items contained in <c>ZipFile</c> instance get written
               to the disk only when you call <see cref="M:Ionic.Zip.ZipFile.Save"/> or a similar
               save method.
             </para>
            
             <para>
               The directory name used for the file within the archive is the same
               as the directory name (potentially a relative path) specified in the
               <paramref name="fileOrDirectoryName"/>.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, <see
               cref="P:Ionic.Zip.ZipFile.Password"/>, <see cref="P:Ionic.Zip.ZipFile.SetCompression"/>, <see
               cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to the
               <c>ZipEntry</c> added.
             </para>
            
             </remarks>
            
             <seealso cref="M:Ionic.Zip.ZipFile.AddFile(System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.AddDirectory(System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.UpdateItem(System.String)"/>
            
             <overloads>This method has two overloads.</overloads>
             <param name="fileOrDirectoryName">
             the name of the file or directory to add.</param>
            
             <returns>The <c>ZipEntry</c> added.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddItem(System.String,System.String)">
             <summary>
               Adds an item, either a file or a directory, to a zip file archive,
               explicitly specifying the directory path to be used in the archive.
             </summary>
            
             <remarks>
             <para>
               If adding a directory, the add is recursive on all files and
               subdirectories contained within it.
             </para>
             <para>
               The name of the item may be a relative path or a fully-qualified path.
               The item added by this call to the <c>ZipFile</c> is not read from the
               disk nor written to the zip file archive until the application calls
               Save() on the <c>ZipFile</c>.
             </para>
            
             <para>
               This version of the method allows the caller to explicitly specify the
               directory path to be used in the archive, which would override the
               "natural" path of the filesystem file.
             </para>
            
             <para>
               Encryption will be used on the file data if the <c>Password</c> has
               been set on the <c>ZipFile</c> object, prior to calling this method.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, <see
               cref="P:Ionic.Zip.ZipFile.Password"/>, <see cref="P:Ionic.Zip.ZipFile.SetCompression"/>, <see
               cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to the
               <c>ZipEntry</c> added.
             </para>
            
             </remarks>
            
             <exception cref="T:System.IO.FileNotFoundException">
               Thrown if the file or directory passed in does not exist.
             </exception>
            
             <param name="fileOrDirectoryName">the name of the file or directory to add.
             </param>
            
             <param name="directoryPathInArchive">
               The name of the directory path to use within the zip archive.  This path
               need not refer to an extant directory in the current filesystem.  If the
               files within the zip are later extracted, this is the path used for the
               extracted file.  Passing <c>null</c> (<c>Nothing</c> in VB) will use the
               path on the fileOrDirectoryName.  Passing the empty string ("") will
               insert the item at the root path within the archive.
             </param>
            
             <seealso cref="M:Ionic.Zip.ZipFile.AddFile(System.String,System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.AddDirectory(System.String,System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.UpdateItem(System.String,System.String)"/>
            
             <example>
               This example shows how to zip up a set of files into a flat hierarchy,
               regardless of where in the filesystem the files originated. The resulting
               zip archive will contain a toplevel directory named "flat", which itself
               will contain files Readme.txt, MyProposal.docx, and Image1.jpg.  A
               subdirectory under "flat" called SupportFiles will contain all the files
               in the "c:\SupportFiles" directory on disk.
            
             <code>
             String[] itemnames= {
               "c:\\fixedContent\\Readme.txt",
               "MyProposal.docx",
               "c:\\SupportFiles",  // a directory
               "images\\Image1.jpg"
             };
            
             try
             {
               using (ZipFile zip = new ZipFile())
               {
                 for (int i = 1; i &lt; itemnames.Length; i++)
                 {
                   // will add Files or Dirs, recurses and flattens subdirectories
                   zip.AddItem(itemnames[i],"flat");
                 }
                 zip.Save(ZipToCreate);
               }
             }
             catch (System.Exception ex1)
             {
               System.Console.Error.WriteLine("exception: {0}", ex1);
             }
             </code>
            
             <code lang="VB">
               Dim itemnames As String() = _
                 New String() { "c:\fixedContent\Readme.txt", _
                                "MyProposal.docx", _
                                "SupportFiles", _
                                "images\Image1.jpg" }
               Try
                   Using zip As New ZipFile
                       Dim i As Integer
                       For i = 1 To itemnames.Length - 1
                           ' will add Files or Dirs, recursing and flattening subdirectories.
                           zip.AddItem(itemnames(i), "flat")
                       Next i
                       zip.Save(ZipToCreate)
                   End Using
               Catch ex1 As Exception
                   Console.Error.WriteLine("exception: {0}", ex1.ToString())
               End Try
             </code>
             </example>
             <returns>The <c>ZipEntry</c> added.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddFile(System.String)">
             <summary>
               Adds a File to a Zip file archive.
             </summary>
             <remarks>
            
             <para>
               This call collects metadata for the named file in the filesystem,
               including the file attributes and the timestamp, and inserts that metadata
               into the resulting ZipEntry.  Only when the application calls Save() on
               the <c>ZipFile</c>, does DotNetZip read the file from the filesystem and
               then write the content to the zip file archive.
             </para>
            
             <para>
               This method will throw an exception if an entry with the same name already
               exists in the <c>ZipFile</c>.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, <see
               cref="P:Ionic.Zip.ZipFile.Password"/>, <see cref="P:Ionic.Zip.ZipFile.SetCompression"/>, <see
               cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to the
               <c>ZipEntry</c> added.
             </para>
            
             </remarks>
            
             <example>
             <para>
               In this example, three files are added to a Zip archive. The ReadMe.txt
               file will be placed in the root of the archive. The .png file will be
               placed in a folder within the zip called photos\personal.  The pdf file
               will be included into a folder within the zip called Desktop.
             </para>
             <code>
                try
                {
                  using (ZipFile zip = new ZipFile())
                  {
                    zip.AddFile("c:\\photos\\personal\\7440-N49th.png");
                    zip.AddFile("c:\\Desktop\\2008-Regional-Sales-Report.pdf");
                    zip.AddFile("ReadMe.txt");
            
                    zip.Save("Package.zip");
                  }
                }
                catch (System.Exception ex1)
                {
                  System.Console.Error.WriteLine("exception: " + ex1);
                }
             </code>
            
             <code lang="VB">
              Try
                   Using zip As ZipFile = New ZipFile
                       zip.AddFile("c:\photos\personal\7440-N49th.png")
                       zip.AddFile("c:\Desktop\2008-Regional-Sales-Report.pdf")
                       zip.AddFile("ReadMe.txt")
                       zip.Save("Package.zip")
                   End Using
               Catch ex1 As Exception
                   Console.Error.WriteLine("exception: {0}", ex1.ToString)
               End Try
             </code>
             </example>
            
             <overloads>This method has two overloads.</overloads>
            
             <seealso cref="M:Ionic.Zip.ZipFile.AddItem(System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.AddDirectory(System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.UpdateFile(System.String)"/>
            
             <param name="fileName">
               The name of the file to add. It should refer to a file in the filesystem.
               The name of the file may be a relative path or a fully-qualified path.
             </param>
             <returns>The <c>ZipEntry</c> corresponding to the File added.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddFile(System.String,System.String)">
             <summary>
               Adds a File to a Zip file archive, potentially overriding the path to be
               used within the zip archive.
             </summary>
            
             <remarks>
             <para>
               The file added by this call to the <c>ZipFile</c> is not written to the
               zip file archive until the application calls Save() on the <c>ZipFile</c>.
             </para>
            
             <para>
               This method will throw an exception if an entry with the same name already
               exists in the <c>ZipFile</c>.
             </para>
            
             <para>
               This version of the method allows the caller to explicitly specify the
               directory path to be used in the archive.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, <see
               cref="P:Ionic.Zip.ZipFile.Password"/>, <see cref="P:Ionic.Zip.ZipFile.SetCompression"/>, <see
               cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to the
               <c>ZipEntry</c> added.
             </para>
            
             </remarks>
            
             <example>
             <para>
               In this example, three files are added to a Zip archive. The ReadMe.txt
               file will be placed in the root of the archive. The .png file will be
               placed in a folder within the zip called images.  The pdf file will be
               included into a folder within the zip called files\docs, and will be
               encrypted with the given password.
             </para>
             <code>
             try
             {
               using (ZipFile zip = new ZipFile())
               {
                 // the following entry will be inserted at the root in the archive.
                 zip.AddFile("c:\\datafiles\\ReadMe.txt", "");
                 // this image file will be inserted into the "images" directory in the archive.
                 zip.AddFile("c:\\photos\\personal\\7440-N49th.png", "images");
                 // the following will result in a password-protected file called
                 // files\\docs\\2008-Regional-Sales-Report.pdf  in the archive.
                 zip.Password = "EncryptMe!";
                 zip.AddFile("c:\\Desktop\\2008-Regional-Sales-Report.pdf", "files\\docs");
                 zip.Save("Archive.zip");
               }
             }
             catch (System.Exception ex1)
             {
               System.Console.Error.WriteLine("exception: {0}", ex1);
             }
             </code>
            
             <code lang="VB">
               Try
                   Using zip As ZipFile = New ZipFile
                       ' the following entry will be inserted at the root in the archive.
                       zip.AddFile("c:\datafiles\ReadMe.txt", "")
                       ' this image file will be inserted into the "images" directory in the archive.
                       zip.AddFile("c:\photos\personal\7440-N49th.png", "images")
                       ' the following will result in a password-protected file called
                       ' files\\docs\\2008-Regional-Sales-Report.pdf  in the archive.
                       zip.Password = "EncryptMe!"
                       zip.AddFile("c:\Desktop\2008-Regional-Sales-Report.pdf", "files\documents")
                       zip.Save("Archive.zip")
                   End Using
               Catch ex1 As Exception
                   Console.Error.WriteLine("exception: {0}", ex1)
               End Try
             </code>
             </example>
            
             <seealso cref="M:Ionic.Zip.ZipFile.AddItem(System.String,System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.AddDirectory(System.String,System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.UpdateFile(System.String,System.String)"/>
            
             <param name="fileName">
               The name of the file to add.  The name of the file may be a relative path
               or a fully-qualified path.
             </param>
            
             <param name="directoryPathInArchive">
               Specifies a directory path to use to override any path in the fileName.
               This path may, or may not, correspond to a real directory in the current
               filesystem.  If the files within the zip are later extracted, this is the
               path used for the extracted file.  Passing <c>null</c> (<c>Nothing</c> in
               VB) will use the path on the fileName, if any.  Passing the empty string
               ("") will insert the item at the root path within the archive.
             </param>
            
             <returns>The <c>ZipEntry</c> corresponding to the file added.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.RemoveEntries(System.Collections.Generic.ICollection{Ionic.Zip.ZipEntry})">
             <summary>
               This method removes a collection of entries from the <c>ZipFile</c>.
             </summary>
            
             <param name="entriesToRemove">
               A collection of ZipEntry instances from this zip file to be removed. For
               example, you can pass in an array of ZipEntry instances; or you can call
               SelectEntries(), and then add or remove entries from that
               ICollection&lt;ZipEntry&gt; (ICollection(Of ZipEntry) in VB), and pass
               that ICollection to this method.
             </param>
            
             <seealso cref="M:Ionic.Zip.ZipFile.SelectEntries(System.String)" />
             <seealso cref="M:Ionic.Zip.ZipFile.RemoveSelectedEntries(System.String)" />
        </member>
        <member name="M:Ionic.Zip.ZipFile.RemoveEntries(System.Collections.Generic.ICollection{System.String})">
             <summary>
               This method removes a collection of entries from the <c>ZipFile</c>, by name.
             </summary>
            
             <param name="entriesToRemove">
               A collection of strings that refer to names of entries to be removed
               from the <c>ZipFile</c>.  For example, you can pass in an array or a
               List of Strings that provide the names of entries to be removed.
             </param>
            
             <seealso cref="M:Ionic.Zip.ZipFile.SelectEntries(System.String)" />
             <seealso cref="M:Ionic.Zip.ZipFile.RemoveSelectedEntries(System.String)" />
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddFiles(System.Collections.Generic.IEnumerable{System.String})">
             <summary>
               This method adds a set of files to the <c>ZipFile</c>.
             </summary>
            
             <remarks>
             <para>
               Use this method to add a set of files to the zip archive, in one call.
               For example, a list of files received from
               <c>System.IO.Directory.GetFiles()</c> can be added to a zip archive in one
               call.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, <see
               cref="P:Ionic.Zip.ZipFile.Password"/>, <see cref="P:Ionic.Zip.ZipFile.SetCompression"/>, <see
               cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to each
               ZipEntry added.
             </para>
             </remarks>
            
             <param name="fileNames">
               The collection of names of the files to add. Each string should refer to a
               file in the filesystem. The name of the file may be a relative path or a
               fully-qualified path.
             </param>
            
             <example>
               This example shows how to create a zip file, and add a few files into it.
             <code>
             String ZipFileToCreate = "archive1.zip";
             String DirectoryToZip = "c:\\reports";
             using (ZipFile zip = new ZipFile())
             {
               // Store all files found in the top level directory, into the zip archive.
               String[] filenames = System.IO.Directory.GetFiles(DirectoryToZip);
               zip.AddFiles(filenames);
               zip.Save(ZipFileToCreate);
             }
             </code>
            
             <code lang="VB">
             Dim ZipFileToCreate As String = "archive1.zip"
             Dim DirectoryToZip As String = "c:\reports"
             Using zip As ZipFile = New ZipFile
                 ' Store all files found in the top level directory, into the zip archive.
                 Dim filenames As String() = System.IO.Directory.GetFiles(DirectoryToZip)
                 zip.AddFiles(filenames)
                 zip.Save(ZipFileToCreate)
             End Using
             </code>
             </example>
            
             <seealso cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String,System.String)" />
        </member>
        <member name="M:Ionic.Zip.ZipFile.UpdateFiles(System.Collections.Generic.IEnumerable{System.String})">
             <summary>
               Adds or updates a set of files in the <c>ZipFile</c>.
             </summary>
            
             <remarks>
             <para>
               Any files that already exist in the archive are updated. Any files that
               don't yet exist in the archive are added.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, <see
               cref="P:Ionic.Zip.ZipFile.Password"/>, <see cref="P:Ionic.Zip.ZipFile.SetCompression"/>, <see
               cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to each
               ZipEntry added.
             </para>
             </remarks>
            
             <param name="fileNames">
               The collection of names of the files to update. Each string should refer to a file in
               the filesystem. The name of the file may be a relative path or a fully-qualified path.
             </param>
            
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddFiles(System.Collections.Generic.IEnumerable{System.String},System.String)">
             <summary>
               Adds a set of files to the <c>ZipFile</c>, using the
               specified directory path in the archive.
             </summary>
            
             <remarks>
             <para>
               Any directory structure that may be present in the
               filenames contained in the list is "flattened" in the
               archive.  Each file in the list is added to the archive in
               the specified top-level directory.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see
               cref="P:Ionic.Zip.ZipFile.Encryption"/>, <see cref="P:Ionic.Zip.ZipFile.Password"/>, <see
               cref="P:Ionic.Zip.ZipFile.SetCompression"/>, <see
               cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see
               cref="P:Ionic.Zip.ZipFile.ExtractExistingFile"/>, <see
               cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see
               cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, their respective values at the
               time of this call will be applied to each ZipEntry added.
             </para>
             </remarks>
            
             <param name="fileNames">
               The names of the files to add. Each string should refer to
               a file in the filesystem.  The name of the file may be a
               relative path or a fully-qualified path.
             </param>
            
             <param name="directoryPathInArchive">
               Specifies a directory path to use to override any path in the file name.
               Th is path may, or may not, correspond to a real directory in the current
               filesystem.  If the files within the zip are later extracted, this is the
               path used for the extracted file.  Passing <c>null</c> (<c>Nothing</c> in
               VB) will use the path on each of the <c>fileNames</c>, if any.  Passing
               the empty string ("") will insert the item at the root path within the
               archive.
             </param>
            
             <seealso cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String,System.String)" />
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddFiles(System.Collections.Generic.IEnumerable{System.String},System.Boolean,System.String)">
             <summary>
               Adds a set of files to the <c>ZipFile</c>, using the specified directory
               path in the archive, and preserving the full directory structure in the
               filenames.
             </summary>
            
             <remarks>
             <para>
               If preserveDirHierarchy is true, any directory structure present in the
               filenames contained in the list is preserved in the archive.  On the other
               hand, if preserveDirHierarchy is false, any directory structure that may
               be present in the filenames contained in the list is "flattened" in the
               archive; Each file in the list is added to the archive in the specified
               top-level directory.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, <see
               cref="P:Ionic.Zip.ZipFile.Password"/>, <see cref="P:Ionic.Zip.ZipFile.SetCompression"/>, <see
               cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to each
               ZipEntry added.
             </para>
            
             </remarks>
            
             <param name="fileNames">
               The names of the files to add. Each string should refer to a file in the
               filesystem.  The name of the file may be a relative path or a
               fully-qualified path.
             </param>
            
             <param name="directoryPathInArchive">
               Specifies a directory path to use to override any path in the file name.
               This path may, or may not, correspond to a real directory in the current
               filesystem.  If the files within the zip are later extracted, this is the
               path used for the extracted file.  Passing <c>null</c> (<c>Nothing</c> in
               VB) will use the path on each of the <c>fileNames</c>, if any.  Passing
               the empty string ("") will insert the item at the root path within the
               archive.
             </param>
            
             <param name="preserveDirHierarchy">
               whether the entries in the zip archive will reflect the directory
               hierarchy that is present in the various filenames.  For example, if <paramref name="fileNames"/>
               includes two paths, \Animalia\Chordata\Mammalia\Info.txt and
               \Plantae\Magnoliophyta\Dicotyledon\Info.txt, then calling this method with
               <paramref name="preserveDirHierarchy"/> = <c>false</c> will result in an
               exception because of a duplicate entry name, while calling this method
               with <paramref name="preserveDirHierarchy"/> = <c>true</c> will result in the
               full direcory paths being included in the entries added to the ZipFile.
             </param>
             <seealso cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String,System.String)" />
        </member>
        <member name="M:Ionic.Zip.ZipFile.UpdateFiles(System.Collections.Generic.IEnumerable{System.String},System.String)">
             <summary>
               Adds or updates a set of files to the <c>ZipFile</c>, using the specified
               directory path in the archive.
             </summary>
            
             <remarks>
            
             <para>
               Any files that already exist in the archive are updated. Any files that
               don't yet exist in the archive are added.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, <see
               cref="P:Ionic.Zip.ZipFile.Password"/>, <see cref="P:Ionic.Zip.ZipFile.SetCompression"/>, <see
               cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to each
               ZipEntry added.
             </para>
             </remarks>
            
             <param name="fileNames">
               The names of the files to add or update. Each string should refer to a
               file in the filesystem.  The name of the file may be a relative path or a
               fully-qualified path.
             </param>
            
             <param name="directoryPathInArchive">
               Specifies a directory path to use to override any path in the file name.
               This path may, or may not, correspond to a real directory in the current
               filesystem.  If the files within the zip are later extracted, this is the
               path used for the extracted file.  Passing <c>null</c> (<c>Nothing</c> in
               VB) will use the path on each of the <c>fileNames</c>, if any.  Passing
               the empty string ("") will insert the item at the root path within the
               archive.
             </param>
            
             <seealso cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String,System.String)" />
        </member>
        <member name="M:Ionic.Zip.ZipFile.UpdateFile(System.String)">
             <summary>
               Adds or Updates a File in a Zip file archive.
             </summary>
            
             <remarks>
             <para>
               This method adds a file to a zip archive, or, if the file already exists
               in the zip archive, this method Updates the content of that given filename
               in the zip archive.  The <c>UpdateFile</c> method might more accurately be
               called "AddOrUpdateFile".
             </para>
            
             <para>
               Upon success, there is no way for the application to learn whether the file
               was added versus updated.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, <see
               cref="P:Ionic.Zip.ZipFile.Password"/>, <see cref="P:Ionic.Zip.ZipFile.SetCompression"/>, <see
               cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to the
               <c>ZipEntry</c> added.
             </para>
             </remarks>
            
             <example>
            
               This example shows how to Update an existing entry in a zipfile. The first
               call to UpdateFile adds the file to the newly-created zip archive.  The
               second call to UpdateFile updates the content for that file in the zip
               archive.
            
             <code>
             using (ZipFile zip1 = new ZipFile())
             {
               // UpdateFile might more accurately be called "AddOrUpdateFile"
               zip1.UpdateFile("MyDocuments\\Readme.txt");
               zip1.UpdateFile("CustomerList.csv");
               zip1.Comment = "This zip archive has been created.";
               zip1.Save("Content.zip");
             }
            
             using (ZipFile zip2 = ZipFile.Read("Content.zip"))
             {
               zip2.UpdateFile("Updates\\Readme.txt");
               zip2.Comment = "This zip archive has been updated: The Readme.txt file has been changed.";
               zip2.Save();
             }
            
             </code>
             <code lang="VB">
               Using zip1 As New ZipFile
                   ' UpdateFile might more accurately be called "AddOrUpdateFile"
                   zip1.UpdateFile("MyDocuments\Readme.txt")
                   zip1.UpdateFile("CustomerList.csv")
                   zip1.Comment = "This zip archive has been created."
                   zip1.Save("Content.zip")
               End Using
            
               Using zip2 As ZipFile = ZipFile.Read("Content.zip")
                   zip2.UpdateFile("Updates\Readme.txt")
                   zip2.Comment = "This zip archive has been updated: The Readme.txt file has been changed."
                   zip2.Save
               End Using
             </code>
             </example>
            
             <seealso cref="M:Ionic.Zip.ZipFile.AddFile(System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.UpdateDirectory(System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.UpdateItem(System.String)"/>
            
             <param name="fileName">
               The name of the file to add or update. It should refer to a file in the
               filesystem.  The name of the file may be a relative path or a
               fully-qualified path.
             </param>
            
             <returns>
               The <c>ZipEntry</c> corresponding to the File that was added or updated.
             </returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.UpdateFile(System.String,System.String)">
             <summary>
               Adds or Updates a File in a Zip file archive.
             </summary>
            
             <remarks>
             <para>
               This method adds a file to a zip archive, or, if the file already exists
               in the zip archive, this method Updates the content of that given filename
               in the zip archive.
             </para>
            
             <para>
               This version of the method allows the caller to explicitly specify the
               directory path to be used in the archive.  The entry to be added or
               updated is found by using the specified directory path, combined with the
               basename of the specified filename.
             </para>
            
             <para>
               Upon success, there is no way for the application to learn if the file was
               added versus updated.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, <see
               cref="P:Ionic.Zip.ZipFile.Password"/>, <see cref="P:Ionic.Zip.ZipFile.SetCompression"/>, <see
               cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to the
               <c>ZipEntry</c> added.
             </para>
             </remarks>
            
             <seealso cref="M:Ionic.Zip.ZipFile.AddFile(System.String,System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.UpdateDirectory(System.String,System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.UpdateItem(System.String,System.String)"/>
            
             <param name="fileName">
               The name of the file to add or update. It should refer to a file in the
               filesystem.  The name of the file may be a relative path or a
               fully-qualified path.
             </param>
            
             <param name="directoryPathInArchive">
               Specifies a directory path to use to override any path in the
               <c>fileName</c>.  This path may, or may not, correspond to a real
               directory in the current filesystem.  If the files within the zip are
               later extracted, this is the path used for the extracted file.  Passing
               <c>null</c> (<c>Nothing</c> in VB) will use the path on the
               <c>fileName</c>, if any.  Passing the empty string ("") will insert the
               item at the root path within the archive.
             </param>
            
             <returns>
               The <c>ZipEntry</c> corresponding to the File that was added or updated.
             </returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.UpdateDirectory(System.String)">
             <summary>
               Add or update a directory in a zip archive.
             </summary>
            
             <remarks>
               If the specified directory does not exist in the archive, then this method
               is equivalent to calling <c>AddDirectory()</c>.  If the specified
               directory already exists in the archive, then this method updates any
               existing entries, and adds any new entries. Any entries that are in the
               zip archive but not in the specified directory, are left alone.  In other
               words, the contents of the zip file will be a union of the previous
               contents and the new files.
             </remarks>
            
             <seealso cref="M:Ionic.Zip.ZipFile.UpdateFile(System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.AddDirectory(System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.UpdateItem(System.String)"/>
            
             <param name="directoryName">
               The path to the directory to be added to the zip archive, or updated in
               the zip archive.
             </param>
            
             <returns>
             The <c>ZipEntry</c> corresponding to the Directory that was added or updated.
             </returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.UpdateDirectory(System.String,System.String)">
             <summary>
               Add or update a directory in the zip archive at the specified root
               directory in the archive.
             </summary>
            
             <remarks>
               If the specified directory does not exist in the archive, then this method
               is equivalent to calling <c>AddDirectory()</c>.  If the specified
               directory already exists in the archive, then this method updates any
               existing entries, and adds any new entries. Any entries that are in the
               zip archive but not in the specified directory, are left alone.  In other
               words, the contents of the zip file will be a union of the previous
               contents and the new files.
             </remarks>
            
             <seealso cref="M:Ionic.Zip.ZipFile.UpdateFile(System.String,System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.AddDirectory(System.String,System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.UpdateItem(System.String,System.String)"/>
            
             <param name="directoryName">
               The path to the directory to be added to the zip archive, or updated
               in the zip archive.
             </param>
            
             <param name="directoryPathInArchive">
               Specifies a directory path to use to override any path in the
               <c>directoryName</c>.  This path may, or may not, correspond to a real
               directory in the current filesystem.  If the files within the zip are
               later extracted, this is the path used for the extracted file.  Passing
               <c>null</c> (<c>Nothing</c> in VB) will use the path on the
               <c>directoryName</c>, if any.  Passing the empty string ("") will insert
               the item at the root path within the archive.
             </param>
            
             <returns>
               The <c>ZipEntry</c> corresponding to the Directory that was added or updated.
             </returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.UpdateItem(System.String)">
             <summary>
               Add or update a file or directory in the zip archive.
             </summary>
            
             <remarks>
             <para>
               This is useful when the application is not sure or does not care if the
               item to be added is a file or directory, and does not know or does not
               care if the item already exists in the <c>ZipFile</c>. Calling this method
               is equivalent to calling <c>RemoveEntry()</c> if an entry by the same name
               already exists, followed calling by <c>AddItem()</c>.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, <see
               cref="P:Ionic.Zip.ZipFile.Password"/>, <see cref="P:Ionic.Zip.ZipFile.SetCompression"/>, <see
               cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to the
               <c>ZipEntry</c> added.
             </para>
             </remarks>
            
             <seealso cref="M:Ionic.Zip.ZipFile.AddItem(System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.UpdateFile(System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.UpdateDirectory(System.String)"/>
            
             <param name="itemName">
              the path to the file or directory to be added or updated.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.UpdateItem(System.String,System.String)">
             <summary>
               Add or update a file or directory.
             </summary>
            
             <remarks>
             <para>
               This method is useful when the application is not sure or does not care if
               the item to be added is a file or directory, and does not know or does not
               care if the item already exists in the <c>ZipFile</c>. Calling this method
               is equivalent to calling <c>RemoveEntry()</c>, if an entry by that name
               exists, and then calling <c>AddItem()</c>.
             </para>
            
             <para>
               This version of the method allows the caller to explicitly specify the
               directory path to be used for the item being added to the archive.  The
               entry or entries that are added or updated will use the specified
               <c>DirectoryPathInArchive</c>. Extracting the entry from the archive will
               result in a file stored in that directory path.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, <see
               cref="P:Ionic.Zip.ZipFile.Password"/>, <see cref="P:Ionic.Zip.ZipFile.SetCompression"/>, <see
               cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to the
               <c>ZipEntry</c> added.
             </para>
             </remarks>
            
             <seealso cref="M:Ionic.Zip.ZipFile.AddItem(System.String,System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.UpdateFile(System.String,System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.UpdateDirectory(System.String,System.String)"/>
            
             <param name="itemName">
               The path for the File or Directory to be added or updated.
             </param>
             <param name="directoryPathInArchive">
               Specifies a directory path to use to override any path in the
               <c>itemName</c>.  This path may, or may not, correspond to a real
               directory in the current filesystem.  If the files within the zip are
               later extracted, this is the path used for the extracted file.  Passing
               <c>null</c> (<c>Nothing</c> in VB) will use the path on the
               <c>itemName</c>, if any.  Passing the empty string ("") will insert the
               item at the root path within the archive.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.String)">
             <summary>
               Adds a named entry into the zip archive, taking content for the entry
               from a string.
             </summary>
            
             <remarks>
               Calling this method creates an entry using the given fileName and
               directory path within the archive.  There is no need for a file by the
               given name to exist in the filesystem; the name is used within the zip
               archive only. The content for the entry is encoded using the default text
               encoding for the machine, or on Silverlight, using UTF-8.
             </remarks>
            
             <param name="content">
               The content of the file, should it be extracted from the zip.
             </param>
            
             <param name="entryName">
               The name, including any path, to use for the entry within the archive.
             </param>
            
             <returns>The <c>ZipEntry</c> added.</returns>
            
             <example>
            
             This example shows how to add an entry to the zipfile, using a string as
             content for that entry.
            
             <code lang="C#">
             string Content = "This string will be the content of the Readme.txt file in the zip archive.";
             using (ZipFile zip1 = new ZipFile())
             {
               zip1.AddFile("MyDocuments\\Resume.doc", "files");
               zip1.AddEntry("Readme.txt", Content);
               zip1.Comment = "This zip file was created at " + System.DateTime.Now.ToString("G");
               zip1.Save("Content.zip");
             }
            
             </code>
             <code lang="VB">
             Public Sub Run()
               Dim Content As String = "This string will be the content of the Readme.txt file in the zip archive."
               Using zip1 As ZipFile = New ZipFile
                 zip1.AddEntry("Readme.txt", Content)
                 zip1.AddFile("MyDocuments\Resume.doc", "files")
                 zip1.Comment = ("This zip file was created at " &amp; DateTime.Now.ToString("G"))
                 zip1.Save("Content.zip")
               End Using
             End Sub
             </code>
             </example>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.String,System.Text.Encoding)">
             <summary>
               Adds a named entry into the zip archive, taking content for the entry
               from a string, and using the specified text encoding.
             </summary>
            
             <remarks>
            
             <para>
               Calling this method creates an entry using the given fileName and
               directory path within the archive.  There is no need for a file by the
               given name to exist in the filesystem; the name is used within the zip
               archive only.
             </para>
            
             <para>
               The content for the entry, a string value, is encoded using the given
               text encoding. A BOM (byte-order-mark) is emitted into the file, if the
               Encoding parameter is set for that.
             </para>
            
             <para>
               Most Encoding classes support a constructor that accepts a boolean,
               indicating whether to emit a BOM or not. For example see <see
               cref="M:System.Text.UTF8Encoding.#ctor(System.Boolean)"/>.
             </para>
            
             </remarks>
            
             <param name="entryName">
               The name, including any path, to use within the archive for the entry.
             </param>
            
             <param name="content">
               The content of the file, should it be extracted from the zip.
             </param>
            
             <param name="encoding">
               The text encoding to use when encoding the string. Be aware: This is
               distinct from the text encoding used to encode the fileName, as specified
               in <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />.
             </param>
            
             <returns>The <c>ZipEntry</c> added.</returns>
            
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.IO.Stream)">
             <summary>
               Create an entry in the <c>ZipFile</c> using the given <c>Stream</c>
               as input.  The entry will have the given filename.
             </summary>
            
             <remarks>
            
             <para>
               The application should provide an open, readable stream; in this case it
               will be read during the call to <see cref="M:Ionic.Zip.ZipFile.Save"/> or one of
               its overloads.
             </para>
            
             <para>
               The passed stream will be read from its current position. If
               necessary, callers should set the position in the stream before
               calling AddEntry(). This might be appropriate when using this method
               with a MemoryStream, for example.
             </para>
            
             <para>
               In cases where a large number of streams will be added to the
               <c>ZipFile</c>, the application may wish to avoid maintaining all of the
               streams open simultaneously.  To handle this situation, the application
               should use the <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,Ionic.Zip.OpenDelegate,Ionic.Zip.CloseDelegate)"/>
               overload.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, <see
               cref="P:Ionic.Zip.ZipFile.Password"/>, <see cref="P:Ionic.Zip.ZipFile.SetCompression"/>, <see
               cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to the
               <c>ZipEntry</c> added.
             </para>
            
             </remarks>
            
             <example>
             <para>
               This example adds a single entry to a <c>ZipFile</c> via a <c>Stream</c>.
             </para>
            
             <code lang="C#">
             String zipToCreate = "Content.zip";
             String fileNameInArchive = "Content-From-Stream.bin";
             using (System.IO.Stream streamToRead = MyStreamOpener())
             {
               using (ZipFile zip = new ZipFile())
               {
                 ZipEntry entry= zip.AddEntry(fileNameInArchive, streamToRead);
                 zip.AddFile("Readme.txt");
                 zip.Save(zipToCreate);  // the stream is read implicitly here
               }
             }
             </code>
            
             <code lang="VB">
             Dim zipToCreate As String = "Content.zip"
             Dim fileNameInArchive As String = "Content-From-Stream.bin"
             Using streamToRead as System.IO.Stream = MyStreamOpener()
               Using zip As ZipFile = New ZipFile()
                 Dim entry as ZipEntry = zip.AddEntry(fileNameInArchive, streamToRead)
                 zip.AddFile("Readme.txt")
                 zip.Save(zipToCreate)  '' the stream is read implicitly, here
               End Using
             End Using
             </code>
             </example>
            
             <seealso cref="M:Ionic.Zip.ZipFile.UpdateEntry(System.String,System.IO.Stream)"/>
            
             <param name="entryName">
               The name, including any path, which is shown in the zip file for the added
               entry.
             </param>
             <param name="stream">
               The input stream from which to grab content for the file
             </param>
             <returns>The <c>ZipEntry</c> added.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddEntry(System.String,Ionic.Zip.WriteDelegate)">
             <summary>
               Add a ZipEntry for which content is written directly by the application.
             </summary>
            
             <remarks>
             <para>
               When the application needs to write the zip entry data, use this
               method to add the ZipEntry. For example, in the case that the
               application wishes to write the XML representation of a DataSet into
               a ZipEntry, the application can use this method to do so.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, <see
               cref="P:Ionic.Zip.ZipFile.Password"/>, <see cref="P:Ionic.Zip.ZipFile.SetCompression"/>, <see
               cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to the
               <c>ZipEntry</c> added.
             </para>
            
             <para>
               About progress events: When using the WriteDelegate, DotNetZip does
               not issue any SaveProgress events with <c>EventType</c> = <see
               cref="F:Ionic.Zip.ZipProgressEventType.Saving_EntryBytesRead">
               Saving_EntryBytesRead</see>. (This is because it is the
               application's code that runs in WriteDelegate - there's no way for
               DotNetZip to know when to issue a EntryBytesRead event.)
               Applications that want to update a progress bar or similar status
               indicator should do so from within the WriteDelegate
               itself. DotNetZip will issue the other SaveProgress events,
               including <see cref="F:Ionic.Zip.ZipProgressEventType.Saving_Started">
               Saving_Started</see>,
               <see cref="F:Ionic.Zip.ZipProgressEventType.Saving_BeforeWriteEntry">
               Saving_BeforeWriteEntry</see>, and <see
               cref="F:Ionic.Zip.ZipProgressEventType.Saving_AfterWriteEntry">
               Saving_AfterWriteEntry</see>.
             </para>
            
             <para>
               Note: When you use PKZip encryption, it's normally necessary to
               compute the CRC of the content to be encrypted, before compressing or
               encrypting it. Therefore, when using PKZip encryption with a
               WriteDelegate, the WriteDelegate CAN BE called twice: once to compute
               the CRC, and the second time to potentially compress and
               encrypt. Surprising, but true. This is because PKWARE specified that
               the encryption initialization data depends on the CRC.
               If this happens, for each call of the delegate, your
               application must stream the same entry data in its entirety. If your
               application writes different data during the second call, it will
               result in a corrupt zip file.
             </para>
            
             <para>
               The double-read behavior happens with all types of entries, not only
               those that use WriteDelegate. It happens if you add an entry from a
               filesystem file, or using a string, or a stream, or an opener/closer
               pair. But in those cases, DotNetZip takes care of reading twice; in
               the case of the WriteDelegate, the application code gets invoked
               twice. Be aware.
             </para>
            
             <para>
               As you can imagine, this can cause performance problems for large
               streams, and it can lead to correctness problems when you use a
               <c>WriteDelegate</c>. This is a pretty big pitfall.  There are two
               ways to avoid it.  First, and most preferred: don't use PKZIP
               encryption.  If you use the WinZip AES encryption, this problem
               doesn't occur, because the encryption protocol doesn't require the CRC
               up front. Second: if you do choose to use PKZIP encryption, write out
               to a non-seekable stream (like standard output, or the
               Response.OutputStream in an ASP.NET application).  In this case,
               DotNetZip will use an alternative encryption protocol that does not
               rely on the CRC of the content.  This also implies setting bit 3 in
               the zip entry, which still presents problems for some zip tools.
             </para>
            
             <para>
               In the future I may modify DotNetZip to *always* use bit 3 when PKZIP
               encryption is in use.  This seems like a win overall, but there will
               be some work involved.  If you feel strongly about it, visit the
               DotNetZip forums and vote up <see
               href="http://dotnetzip.codeplex.com/workitem/13686">the Workitem
               tracking this issue</see>.
             </para>
            
             </remarks>
            
             <param name="entryName">the name of the entry to add</param>
             <param name="writer">the delegate which will write the entry content</param>
             <returns>the ZipEntry added</returns>
            
             <example>
            
               This example shows an application filling a DataSet, then saving the
               contents of that DataSet as XML, into a ZipEntry in a ZipFile, using an
               anonymous delegate in C#. The DataSet XML is never saved to a disk file.
            
             <code lang="C#">
             var c1= new System.Data.SqlClient.SqlConnection(connstring1);
             var da = new System.Data.SqlClient.SqlDataAdapter()
                 {
                     SelectCommand=  new System.Data.SqlClient.SqlCommand(strSelect, c1)
                 };
            
             DataSet ds1 = new DataSet();
             da.Fill(ds1, "Invoices");
            
             using(Ionic.Zip.ZipFile zip = new Ionic.Zip.ZipFile())
             {
                 zip.AddEntry(zipEntryName, (name,stream) => ds1.WriteXml(stream) );
                 zip.Save(zipFileName);
             }
             </code>
             </example>
            
             <example>
            
             This example uses an anonymous method in C# as the WriteDelegate to provide
             the data for the ZipEntry. The example is a bit contrived - the
             <c>AddFile()</c> method is a simpler way to insert the contents of a file
             into an entry in a zip file. On the other hand, if there is some sort of
             processing or transformation of the file contents required before writing,
             the application could use the <c>WriteDelegate</c> to do it, in this way.
            
             <code lang="C#">
             using (var input = File.Open(filename, FileMode.Open, FileAccess.Read, FileShare.ReadWrite ))
             {
                 using(Ionic.Zip.ZipFile zip = new Ionic.Zip.ZipFile())
                 {
                     zip.AddEntry(zipEntryName, (name,output) =>
                         {
                             byte[] buffer = new byte[BufferSize];
                             int n;
                             while ((n = input.Read(buffer, 0, buffer.Length)) != 0)
                             {
                                 // could transform the data here...
                                 output.Write(buffer, 0, n);
                                 // could update a progress bar here
                             }
                         });
            
                     zip.Save(zipFileName);
                 }
             }
             </code>
             </example>
            
             <example>
            
             This example uses a named delegate in VB to write data for the given
             ZipEntry (VB9 does not have anonymous delegates). The example here is a bit
             contrived - a simpler way to add the contents of a file to a ZipEntry is to
             simply use the appropriate <c>AddFile()</c> method.  The key scenario for
             which the <c>WriteDelegate</c> makes sense is saving a DataSet, in XML
             format, to the zip file. The DataSet can write XML to a stream, and the
             WriteDelegate is the perfect place to write into the zip file.  There may be
             other data structures that can write to a stream, but cannot be read as a
             stream.  The <c>WriteDelegate</c> would be appropriate for those cases as
             well.
            
             <code lang="VB">
             Private Sub WriteEntry (ByVal name As String, ByVal output As Stream)
                 Using input As FileStream = File.Open(filename, FileMode.Open, FileAccess.Read, FileShare.ReadWrite)
                     Dim n As Integer = -1
                     Dim buffer As Byte() = New Byte(BufferSize){}
                     Do While n &lt;&gt; 0
                         n = input.Read(buffer, 0, buffer.Length)
                         output.Write(buffer, 0, n)
                     Loop
                 End Using
             End Sub
            
             Public Sub Run()
                 Using zip = New ZipFile
                     zip.AddEntry(zipEntryName, New WriteDelegate(AddressOf WriteEntry))
                     zip.Save(zipFileName)
                 End Using
             End Sub
             </code>
             </example>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddEntry(System.String,Ionic.Zip.OpenDelegate,Ionic.Zip.CloseDelegate)">
             <summary>
               Add an entry, for which the application will provide a stream,
               just-in-time.
             </summary>
            
             <remarks>
             <para>
               In cases where the application wishes to open the stream that holds
               the content for the ZipEntry, on a just-in-time basis, the application
               can use this method and provide delegates to open and close the
               stream.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, <see
               cref="P:Ionic.Zip.ZipFile.Password"/>, <see cref="P:Ionic.Zip.ZipFile.SetCompression"/>, <see
               cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to the
               <c>ZipEntry</c> added.
             </para>
            
             </remarks>
            
             <example>
            
               This example uses anonymous methods in C# to open and close the
               source stream for the content for a zip entry.  In a real
               application, the logic for the OpenDelegate would probably be more
               involved.
            
             <code lang="C#">
             using(Ionic.Zip.ZipFile zip = new Ionic.Zip.ZipFile())
             {
                 zip.AddEntry(zipEntryName,
                              (name) =>  File.Open(filename, FileMode.Open, FileAccess.Read, FileShare.ReadWrite ),
                              (name, stream) =>  stream.Close()
                              );
            
                 zip.Save(zipFileName);
             }
             </code>
            
             </example>
            
             <example>
            
               This example uses delegates in VB.NET to open and close the
               the source stream for the content for a zip entry.  VB 9.0 lacks
               support for "Sub" lambda expressions, and so the CloseDelegate must
               be an actual, named Sub.
            
             <code lang="VB">
            
             Function MyStreamOpener(ByVal entryName As String) As Stream
                 '' This simply opens a file.  You probably want to do somethinig
                 '' more involved here: open a stream to read from a database,
                 '' open a stream on an HTTP connection, and so on.
                 Return File.OpenRead(entryName)
             End Function
            
             Sub MyStreamCloser(entryName As String, stream As Stream)
                 stream.Close()
             End Sub
            
             Public Sub Run()
                 Dim dirToZip As String = "fodder"
                 Dim zipFileToCreate As String = "Archive.zip"
                 Dim opener As OpenDelegate = AddressOf MyStreamOpener
                 Dim closer As CloseDelegate = AddressOf MyStreamCloser
                 Dim numFilestoAdd As Int32 = 4
                 Using zip As ZipFile = New ZipFile
                     Dim i As Integer
                     For i = 0 To numFilesToAdd - 1
                         zip.AddEntry(String.Format("content-{0:000}.txt"), opener, closer)
                     Next i
                     zip.Save(zipFileToCreate)
                 End Using
             End Sub
            
             </code>
             </example>
            
             <param name="entryName">the name of the entry to add</param>
             <param name="opener">
              the delegate that will be invoked to open the stream
             </param>
             <param name="closer">
              the delegate that will be invoked to close the stream
             </param>
             <returns>the ZipEntry added</returns>
            
        </member>
        <member name="M:Ionic.Zip.ZipFile.UpdateEntry(System.String,System.String)">
             <summary>
               Updates the given entry in the <c>ZipFile</c>, using the given
               string as content for the <c>ZipEntry</c>.
             </summary>
            
             <remarks>
            
             <para>
               Calling this method is equivalent to removing the <c>ZipEntry</c> for
               the given file name and directory path, if it exists, and then calling
               <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.String)" />.  See the documentation for
               that method for further explanation. The string content is encoded
               using the default encoding for the machine, or on Silverlight, using
               UTF-8. This encoding is distinct from the encoding used for the
               filename itself.  See <see cref="P:Ionic.Zip.ZipFile.AlternateEncoding"/>.
             </para>
            
             </remarks>
            
             <param name="entryName">
               The name, including any path, to use within the archive for the entry.
             </param>
            
             <param name="content">
               The content of the file, should it be extracted from the zip.
             </param>
            
             <returns>The <c>ZipEntry</c> added.</returns>
            
        </member>
        <member name="M:Ionic.Zip.ZipFile.UpdateEntry(System.String,System.String,System.Text.Encoding)">
             <summary>
               Updates the given entry in the <c>ZipFile</c>, using the given string as
               content for the <c>ZipEntry</c>.
             </summary>
            
             <remarks>
               Calling this method is equivalent to removing the <c>ZipEntry</c> for the
               given file name and directory path, if it exists, and then calling <see
               cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.String,System.Text.Encoding)" />.  See the
               documentation for that method for further explanation.
             </remarks>
            
             <param name="entryName">
               The name, including any path, to use within the archive for the entry.
             </param>
            
             <param name="content">
               The content of the file, should it be extracted from the zip.
             </param>
            
             <param name="encoding">
               The text encoding to use when encoding the string. Be aware: This is
               distinct from the text encoding used to encode the filename. See <see
               cref="P:Ionic.Zip.ZipFile.AlternateEncoding" />.
             </param>
            
             <returns>The <c>ZipEntry</c> added.</returns>
            
        </member>
        <member name="M:Ionic.Zip.ZipFile.UpdateEntry(System.String,Ionic.Zip.WriteDelegate)">
             <summary>
               Updates the given entry in the <c>ZipFile</c>, using the given delegate
               as the source for content for the <c>ZipEntry</c>.
             </summary>
            
             <remarks>
               Calling this method is equivalent to removing the <c>ZipEntry</c> for the
               given file name and directory path, if it exists, and then calling <see
               cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,Ionic.Zip.WriteDelegate)" />.  See the
               documentation for that method for further explanation.
             </remarks>
            
             <param name="entryName">
               The name, including any path, to use within the archive for the entry.
             </param>
            
             <param name="writer">the delegate which will write the entry content.</param>
            
             <returns>The <c>ZipEntry</c> added.</returns>
            
        </member>
        <member name="M:Ionic.Zip.ZipFile.UpdateEntry(System.String,Ionic.Zip.OpenDelegate,Ionic.Zip.CloseDelegate)">
             <summary>
               Updates the given entry in the <c>ZipFile</c>, using the given delegates
               to open and close the stream that provides the content for the <c>ZipEntry</c>.
             </summary>
            
             <remarks>
               Calling this method is equivalent to removing the <c>ZipEntry</c> for the
               given file name and directory path, if it exists, and then calling <see
               cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,Ionic.Zip.OpenDelegate,Ionic.Zip.CloseDelegate)" />.  See the
               documentation for that method for further explanation.
             </remarks>
            
             <param name="entryName">
               The name, including any path, to use within the archive for the entry.
             </param>
            
             <param name="opener">
              the delegate that will be invoked to open the stream
             </param>
             <param name="closer">
              the delegate that will be invoked to close the stream
             </param>
            
             <returns>The <c>ZipEntry</c> added or updated.</returns>
            
        </member>
        <member name="M:Ionic.Zip.ZipFile.UpdateEntry(System.String,System.IO.Stream)">
             <summary>
               Updates the given entry in the <c>ZipFile</c>, using the given stream as
               input, and the given filename and given directory Path.
             </summary>
            
             <remarks>
             <para>
               Calling the method is equivalent to calling <c>RemoveEntry()</c> if an
               entry by the same name already exists, and then calling <c>AddEntry()</c>
               with the given <c>fileName</c> and stream.
             </para>
            
             <para>
               The stream must be open and readable during the call to
               <c>ZipFile.Save</c>.  You can dispense the stream on a just-in-time basis
               using the <see cref="P:Ionic.Zip.ZipEntry.InputStream"/> property. Check the
               documentation of that property for more information.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, <see
               cref="P:Ionic.Zip.ZipFile.Password"/>, <see cref="P:Ionic.Zip.ZipFile.SetCompression"/>, <see
               cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to the
               <c>ZipEntry</c> added.
             </para>
            
             </remarks>
            
             <seealso cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.IO.Stream)"/>
             <seealso cref="P:Ionic.Zip.ZipEntry.InputStream"/>
            
             <param name="entryName">
               The name, including any path, to use within the archive for the entry.
             </param>
            
             <param name="stream">The input stream from which to read file data.</param>
             <returns>The <c>ZipEntry</c> added.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.Byte[])">
             <summary>
               Add an entry into the zip archive using the given filename and
               directory path within the archive, and the given content for the
               file. No file is created in the filesystem.
             </summary>
            
             <param name="byteContent">The data to use for the entry.</param>
            
             <param name="entryName">
               The name, including any path, to use within the archive for the entry.
             </param>
            
             <returns>The <c>ZipEntry</c> added.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.UpdateEntry(System.String,System.Byte[])">
             <summary>
               Updates the given entry in the <c>ZipFile</c>, using the given byte
               array as content for the entry.
             </summary>
            
             <remarks>
               Calling this method is equivalent to removing the <c>ZipEntry</c>
               for the given filename and directory path, if it exists, and then
               calling <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.Byte[])" />.  See the
               documentation for that method for further explanation.
             </remarks>
            
             <param name="entryName">
               The name, including any path, to use within the archive for the entry.
             </param>
            
             <param name="byteContent">The content to use for the <c>ZipEntry</c>.</param>
            
             <returns>The <c>ZipEntry</c> added.</returns>
            
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddDirectory(System.String)">
             <summary>
               Adds the contents of a filesystem directory to a Zip file archive.
             </summary>
            
             <remarks>
            
             <para>
               The name of the directory may be a relative path or a fully-qualified
               path. Any files within the named directory are added to the archive.  Any
               subdirectories within the named directory are also added to the archive,
               recursively.
             </para>
            
             <para>
               Top-level entries in the named directory will appear as top-level entries
               in the zip archive.  Entries in subdirectories in the named directory will
               result in entries in subdirectories in the zip archive.
             </para>
            
             <para>
               If you want the entries to appear in a containing directory in the zip
               archive itself, then you should call the AddDirectory() overload that
               allows you to explicitly specify a directory path for use in the archive.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, <see
               cref="P:Ionic.Zip.ZipFile.Password"/>, <see cref="P:Ionic.Zip.ZipFile.SetCompression"/>, <see
               cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to each
               ZipEntry added.
             </para>
            
             </remarks>
            
             <seealso cref="M:Ionic.Zip.ZipFile.AddItem(System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.AddFile(System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.UpdateDirectory(System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.AddDirectory(System.String,System.String)"/>
            
             <overloads>This method has 2 overloads.</overloads>
            
             <param name="directoryName">The name of the directory to add.</param>
             <returns>The <c>ZipEntry</c> added.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddDirectory(System.String,System.String)">
             <summary>
               Adds the contents of a filesystem directory to a Zip file archive,
               overriding the path to be used for entries in the archive.
             </summary>
            
             <remarks>
             <para>
               The name of the directory may be a relative path or a fully-qualified
               path. The add operation is recursive, so that any files or subdirectories
               within the name directory are also added to the archive.
             </para>
            
             <para>
               Top-level entries in the named directory will appear as top-level entries
               in the zip archive.  Entries in subdirectories in the named directory will
               result in entries in subdirectories in the zip archive.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, <see
               cref="P:Ionic.Zip.ZipFile.Password"/>, <see cref="P:Ionic.Zip.ZipFile.SetCompression"/>, <see
               cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to each
               ZipEntry added.
             </para>
            
             </remarks>
            
             <example>
             <para>
               In this code, calling the ZipUp() method with a value of "c:\reports" for
               the directory parameter will result in a zip file structure in which all
               entries are contained in a toplevel "reports" directory.
             </para>
            
             <code lang="C#">
             public void ZipUp(string targetZip, string directory)
             {
               using (var zip = new ZipFile())
               {
                 zip.AddDirectory(directory, System.IO.Path.GetFileName(directory));
                 zip.Save(targetZip);
               }
             }
             </code>
             </example>
            
             <seealso cref="M:Ionic.Zip.ZipFile.AddItem(System.String,System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.AddFile(System.String,System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.UpdateDirectory(System.String,System.String)"/>
            
             <param name="directoryName">The name of the directory to add.</param>
            
             <param name="directoryPathInArchive">
               Specifies a directory path to use to override any path in the
               DirectoryName.  This path may, or may not, correspond to a real directory
               in the current filesystem.  If the zip is later extracted, this is the
               path used for the extracted file or directory.  Passing <c>null</c>
               (<c>Nothing</c> in VB) or the empty string ("") will insert the items at
               the root path within the archive.
             </param>
            
             <returns>The <c>ZipEntry</c> added.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddDirectoryByName(System.String)">
             <summary>
               Creates a directory in the zip archive.
             </summary>
            
             <remarks>
            
             <para>
               Use this when you want to create a directory in the archive but there is
               no corresponding filesystem representation for that directory.
             </para>
            
             <para>
               You will probably not need to do this in your code. One of the only times
               you will want to do this is if you want an empty directory in the zip
               archive.  The reason: if you add a file to a zip archive that is stored
               within a multi-level directory, all of the directory tree is implicitly
               created in the zip archive.
             </para>
            
             </remarks>
            
             <param name="directoryNameInArchive">
               The name of the directory to create in the archive.
             </param>
             <returns>The <c>ZipEntry</c> added.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.CheckZip(System.String)">
             <summary>
               Checks a zip file to see if its directory is consistent.
             </summary>
            
             <remarks>
            
             <para>
               In cases of data error, the directory within a zip file can get out
               of synch with the entries in the zip file.  This method checks the
               given zip file and returns true if this has occurred.
             </para>
            
             <para> This method may take a long time to run for large zip files.  </para>
            
             <para>
               This method is not supported in the Reduced or Compact Framework
               versions of DotNetZip.
             </para>
            
             <para>
               Developers using COM can use the <see
               cref="M:Ionic.Zip.ComHelper.CheckZip(System.String)">ComHelper.CheckZip(String)</see>
               method.
             </para>
            
             </remarks>
            
             <param name="zipFileName">The filename to of the zip file to check.</param>
            
             <returns>true if the named zip file checks OK. Otherwise, false. </returns>
            
             <seealso cref="M:Ionic.Zip.ZipFile.FixZipDirectory(System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.CheckZip(System.String,System.Boolean,System.IO.TextWriter)"/>
        </member>
        <member name="M:Ionic.Zip.ZipFile.CheckZip(System.String,System.Boolean,System.IO.TextWriter)">
             <summary>
               Checks a zip file to see if its directory is consistent,
               and optionally fixes the directory if necessary.
             </summary>
            
             <remarks>
            
             <para>
               In cases of data error, the directory within a zip file can get out of
               synch with the entries in the zip file.  This method checks the given
               zip file, and returns true if this has occurred. It also optionally
               fixes the zipfile, saving the fixed copy in <em>Name</em>_Fixed.zip.
             </para>
            
             <para>
               This method may take a long time to run for large zip files.  It
               will take even longer if the file actually needs to be fixed, and if
               <c>fixIfNecessary</c> is true.
             </para>
            
             <para>
               This method is not supported in the Reduced or Compact
               Framework versions of DotNetZip.
             </para>
            
             </remarks>
            
             <param name="zipFileName">The filename to of the zip file to check.</param>
            
             <param name="fixIfNecessary">If true, the method will fix the zip file if
                 necessary.</param>
            
             <param name="writer">
             a TextWriter in which messages generated while checking will be written.
             </param>
            
             <returns>true if the named zip is OK; false if the file needs to be fixed.</returns>
            
             <seealso cref="M:Ionic.Zip.ZipFile.CheckZip(System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.FixZipDirectory(System.String)"/>
        </member>
        <member name="M:Ionic.Zip.ZipFile.FixZipDirectory(System.String)">
             <summary>
               Rewrite the directory within a zipfile.
             </summary>
            
             <remarks>
            
             <para>
               In cases of data error, the directory in a zip file can get out of
               synch with the entries in the zip file.  This method attempts to fix
               the zip file if this has occurred.
             </para>
            
             <para> This can take a long time for large zip files. </para>
            
             <para> This won't work if the zip file uses a non-standard
             code page - neither IBM437 nor UTF-8. </para>
            
             <para>
               This method is not supported in the Reduced or Compact Framework
               versions of DotNetZip.
             </para>
            
             <para>
               Developers using COM can use the <see
               cref="M:Ionic.Zip.ComHelper.FixZipDirectory(System.String)">ComHelper.FixZipDirectory(String)</see>
               method.
             </para>
            
             </remarks>
            
             <param name="zipFileName">The filename to of the zip file to fix.</param>
            
             <seealso cref="M:Ionic.Zip.ZipFile.CheckZip(System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.CheckZip(System.String,System.Boolean,System.IO.TextWriter)"/>
        </member>
        <member name="M:Ionic.Zip.ZipFile.CheckZipPassword(System.String,System.String)">
             <summary>
               Verify the password on a zip file.
             </summary>
            
             <remarks>
               <para>
                 Keep in mind that passwords in zipfiles are applied to
                 zip entries, not to the entire zip file. So testing a
                 zipfile for a particular password doesn't work in the
                 general case. On the other hand, it's often the case
                 that a single password will be used on all entries in a
                 zip file. This method works for that case.
               </para>
               <para>
                 There is no way to check a password without doing the
                 decryption. So this code decrypts and extracts the given
                 zipfile into <see cref="F:System.IO.Stream.Null"/>
               </para>
             </remarks>
            
             <param name="zipFileName">The filename to of the zip file to fix.</param>
            
             <param name="password">The password to check.</param>
            
             <returns>a bool indicating whether the password matches.</returns>
        </member>
        <member name="P:Ionic.Zip.ZipFile.Info">
             <summary>
               Provides a human-readable string with information about the ZipFile.
             </summary>
            
             <remarks>
               <para>
                 The information string contains 10 lines or so, about each ZipEntry,
                 describing whether encryption is in use, the compressed and uncompressed
                 length of the entry, the offset of the entry, and so on. As a result the
                 information string can be very long for zip files that contain many
                 entries.
               </para>
               <para>
                 This information is mostly useful for diagnostic purposes.
               </para>
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipFile.FullScan">
             <summary>
             Indicates whether to perform a full scan of the zip file when reading it.
             </summary>
            
             <remarks>
            
             <para>
               You almost never want to use this property.
             </para>
            
             <para>
               When reading a zip file, if this flag is <c>true</c> (<c>True</c> in
               VB), the entire zip archive will be scanned and searched for entries.
               For large archives, this can take a very, long time. The much more
               efficient default behavior is to read the zip directory, which is
               stored at the end of the zip file. But, in some cases the directory is
               corrupted and you need to perform a full scan of the zip file to
               determine the contents of the zip file. This property lets you do
               that, when necessary.
             </para>
            
             <para>
               This flag is effective only when calling <see
               cref="M:Ionic.Zip.ZipFile.Initialize(System.String)"/>. Normally you would read a ZipFile with the
               static <see cref="M:Ionic.Zip.ZipFile.Read(System.String)">ZipFile.Read</see>
               method. But you can't set the <c>FullScan</c> property on the
               <c>ZipFile</c> instance when you use a static factory method like
               <c>ZipFile.Read</c>.
             </para>
            
             </remarks>
            
             <example>
            
               This example shows how to read a zip file using the full scan approach,
               and then save it, thereby producing a corrected zip file.
            
             <code lang="C#">
             using (var zip = new ZipFile())
             {
                 zip.FullScan = true;
                 zip.Initialize(zipFileName);
                 zip.Save(newName);
             }
             </code>
            
             <code lang="VB">
             Using zip As New ZipFile
                 zip.FullScan = True
                 zip.Initialize(zipFileName)
                 zip.Save(newName)
             End Using
             </code>
             </example>
            
        </member>
        <member name="P:Ionic.Zip.ZipFile.SortEntriesBeforeSaving">
             <summary>
               Whether to sort the ZipEntries before saving the file.
             </summary>
            
             <remarks>
               The default is false.  If you have a large number of zip entries, the sort
               alone can consume significant time.
             </remarks>
            
             <example>
             <code lang="C#">
             using (var zip = new ZipFile())
             {
                 zip.AddFiles(filesToAdd);
                 zip.SortEntriesBeforeSaving = true;
                 zip.Save(name);
             }
             </code>
            
             <code lang="VB">
             Using zip As New ZipFile
                 zip.AddFiles(filesToAdd)
                 zip.SortEntriesBeforeSaving = True
                 zip.Save(name)
             End Using
             </code>
             </example>
            
        </member>
        <member name="P:Ionic.Zip.ZipFile.AddDirectoryWillTraverseReparsePoints">
             <summary>
               Indicates whether NTFS Reparse Points, like junctions, should be
               traversed during calls to <c>AddDirectory()</c>.
             </summary>
            
             <remarks>
               By default, calls to AddDirectory() will traverse NTFS reparse
               points, like mounted volumes, and directory junctions.  An example
               of a junction is the "My Music" directory in Windows Vista.  In some
               cases you may not want DotNetZip to traverse those directories.  In
               that case, set this property to false.
             </remarks>
            
             <example>
             <code lang="C#">
             using (var zip = new ZipFile())
             {
                 zip.AddDirectoryWillTraverseReparsePoints = false;
                 zip.AddDirectory(dirToZip,"fodder");
                 zip.Save(zipFileToCreate);
             }
             </code>
             </example>
        </member>
        <member name="P:Ionic.Zip.ZipFile.BufferSize">
             <summary>
               Size of the IO buffer used while saving.
             </summary>
            
             <remarks>
            
             <para>
               First, let me say that you really don't need to bother with this.  It is
               here to allow for optimizations that you probably won't make! It will work
               fine if you don't set or get this property at all. Ok?
             </para>
            
             <para>
               Now that we have <em>that</em> out of the way, the fine print: This
               property affects the size of the buffer that is used for I/O for each
               entry contained in the zip file. When a file is read in to be compressed,
               it uses a buffer given by the size here.  When you update a zip file, the
               data for unmodified entries is copied from the first zip file to the
               other, through a buffer given by the size here.
             </para>
            
             <para>
               Changing the buffer size affects a few things: first, for larger buffer
               sizes, the memory used by the <c>ZipFile</c>, obviously, will be larger
               during I/O operations.  This may make operations faster for very much
               larger files.  Last, for any given entry, when you use a larger buffer
               there will be fewer progress events during I/O operations, because there's
               one progress event generated for each time the buffer is filled and then
               emptied.
             </para>
            
             <para>
               The default buffer size is 8k.  Increasing the buffer size may speed
               things up as you compress larger files.  But there are no hard-and-fast
               rules here, eh?  You won't know til you test it.  And there will be a
               limit where ever larger buffers actually slow things down.  So as I said
               in the beginning, it's probably best if you don't set or get this property
               at all.
             </para>
            
             </remarks>
            
             <example>
             This example shows how you might set a large buffer size for efficiency when
             dealing with zip entries that are larger than 1gb.
             <code lang="C#">
             using (ZipFile zip = new ZipFile())
             {
                 zip.SaveProgress += this.zip1_SaveProgress;
                 zip.AddDirectory(directoryToZip, "");
                 zip.UseZip64WhenSaving = Zip64Option.Always;
                 zip.BufferSize = 65536*8; // 65536 * 8 = 512k
                 zip.Save(ZipFileToCreate);
             }
             </code>
             </example>
        </member>
        <member name="P:Ionic.Zip.ZipFile.CodecBufferSize">
             <summary>
               Size of the work buffer to use for the ZLIB codec during compression.
             </summary>
            
             <remarks>
               <para>
                 When doing ZLIB or Deflate compression, the library fills a buffer,
                 then passes it to the compressor for compression. Then the library
                 reads out the compressed bytes. This happens repeatedly until there
                 is no more uncompressed data to compress. This property sets the
                 size of the buffer that will be used for chunk-wise compression. In
                 order for the setting to take effect, your application needs to set
                 this property before calling one of the <c>ZipFile.Save()</c>
                 overloads.
               </para>
               <para>
                 Setting this affects the performance and memory efficiency of
                 compression and decompression. For larger files, setting this to a
                 larger size may improve compression performance, but the exact
                 numbers vary depending on available memory, the size of the streams
                 you are compressing, and a bunch of other variables. I don't have
                 good firm recommendations on how to set it.  You'll have to test it
                 yourself. Or just leave it alone and accept the default.
               </para>
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipFile.FlattenFoldersOnExtract">
             <summary>
               Indicates whether extracted files should keep their paths as
               stored in the zip archive.
             </summary>
            
             <remarks>
              <para>
                This property affects Extraction.  It is not used when creating zip
                archives.
              </para>
            
              <para>
                With this property set to <c>false</c>, the default, extracting entries
                from a zip file will create files in the filesystem that have the full
                path associated to the entry within the zip file.  With this property set
                to <c>true</c>, extracting entries from the zip file results in files
                with no path: the folders are "flattened."
              </para>
            
              <para>
                An example: suppose the zip file contains entries /directory1/file1.txt and
                /directory2/file2.txt.  With <c>FlattenFoldersOnExtract</c> set to false,
                the files created will be \directory1\file1.txt and \directory2\file2.txt.
                With the property set to true, the files created are file1.txt and file2.txt.
              </para>
            
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipFile.Strategy">
             <summary>
               The compression strategy to use for all entries.
             </summary>
            
             <remarks>
               Set the Strategy used by the ZLIB-compatible compressor, when
               compressing entries using the DEFLATE method. Different compression
               strategies work better on different sorts of data. The strategy
               parameter can affect the compression ratio and the speed of
               compression but not the correctness of the compresssion.  For more
               information see <see
               cref="T:Ionic.Zlib.CompressionStrategy">Ionic.Zlib.CompressionStrategy</see>.
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipFile.Name">
             <summary>
               The name of the <c>ZipFile</c>, on disk.
             </summary>
            
             <remarks>
            
             <para>
               When the <c>ZipFile</c> instance was created by reading an archive using
               one of the <c>ZipFile.Read</c> methods, this property represents the name
               of the zip file that was read.  When the <c>ZipFile</c> instance was
               created by using the no-argument constructor, this value is <c>null</c>
               (<c>Nothing</c> in VB).
             </para>
            
             <para>
               If you use the no-argument constructor, and you then explicitly set this
               property, when you call <see cref="M:Ionic.Zip.ZipFile.Save"/>, this name will
               specify the name of the zip file created.  Doing so is equivalent to
               calling <see cref="M:Ionic.Zip.ZipFile.Save(System.String)"/>.  When instantiating a
               <c>ZipFile</c> by reading from a stream or byte array, the <c>Name</c>
               property remains <c>null</c>.  When saving to a stream, the <c>Name</c>
               property is implicitly set to <c>null</c>.
             </para>
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipFile.CompressionLevel">
             <summary>
               Sets the compression level to be used for entries subsequently added to
               the zip archive.
             </summary>
            
             <remarks>
              <para>
                Varying the compression level used on entries can affect the
                size-vs-speed tradeoff when compression and decompressing data streams
                or files.
              </para>
            
              <para>
                As with some other properties on the <c>ZipFile</c> class, like <see
                cref="P:Ionic.Zip.ZipFile.Password"/>, <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, and <see
                cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>, setting this property on a <c>ZipFile</c>
                instance will cause the specified <c>CompressionLevel</c> to be used on all
                <see cref="T:Ionic.Zip.ZipEntry"/> items that are subsequently added to the
                <c>ZipFile</c> instance. If you set this property after you have added
                items to the <c>ZipFile</c>, but before you have called <c>Save()</c>,
                those items will not use the specified compression level.
              </para>
            
              <para>
                If you do not set this property, the default compression level is used,
                which normally gives a good balance of compression efficiency and
                compression speed.  In some tests, using <c>BestCompression</c> can
                double the time it takes to compress, while delivering just a small
                increase in compression efficiency.  This behavior will vary with the
                type of data you compress.  If you are in doubt, just leave this setting
                alone, and accept the default.
              </para>
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipFile.CompressionMethod">
            <summary>
              The compression method for the zipfile.
            </summary>
            <remarks>
              <para>
                By default, the compression method is <c>CompressionMethod.Deflate.</c>
              </para>
            </remarks>
            <seealso cref="T:Ionic.Zip.CompressionMethod" />
        </member>
        <member name="P:Ionic.Zip.ZipFile.Comment">
             <summary>
               A comment attached to the zip archive.
             </summary>
            
             <remarks>
            
             <para>
               This property is read/write. It allows the application to specify a
               comment for the <c>ZipFile</c>, or read the comment for the
               <c>ZipFile</c>.  After setting this property, changes are only made
               permanent when you call a <c>Save()</c> method.
             </para>
            
             <para>
               According to <see
               href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWARE's
               zip specification</see>, the comment is not encrypted, even if there is a
               password set on the zip file.
             </para>
            
             <para>
               The specification does not describe how to indicate the encoding used
               on a comment string. Many "compliant" zip tools and libraries use
               IBM437 as the code page for comments; DotNetZip, too, follows that
               practice.  On the other hand, there are situations where you want a
               Comment to be encoded with something else, for example using code page
               950 "Big-5 Chinese". To fill that need, DotNetZip will encode the
               comment following the same procedure it follows for encoding
               filenames: (a) if <see cref="P:Ionic.Zip.ZipFile.AlternateEncodingUsage"/> is
               <c>Never</c>, it uses the default encoding (IBM437). (b) if <see
               cref="P:Ionic.Zip.ZipFile.AlternateEncodingUsage"/> is <c>Always</c>, it always uses the
               alternate encoding (<see cref="P:Ionic.Zip.ZipFile.AlternateEncoding"/>). (c) if <see
               cref="P:Ionic.Zip.ZipFile.AlternateEncodingUsage"/> is <c>AsNecessary</c>, it uses the
               alternate encoding only if the default encoding is not sufficient for
               encoding the comment - in other words if decoding the result does not
               produce the original string.  This decision is taken at the time of
               the call to <c>ZipFile.Save()</c>.
             </para>
            
             <para>
               When creating a zip archive using this library, it is possible to change
               the value of <see cref="P:Ionic.Zip.ZipFile.AlternateEncoding" /> between each
               entry you add, and between adding entries and the call to
               <c>Save()</c>. Don't do this.  It will likely result in a zip file that is
               not readable by any tool or application.  For best interoperability, leave
               <see cref="P:Ionic.Zip.ZipFile.AlternateEncoding"/> alone, or specify it only
               once, before adding any entries to the <c>ZipFile</c> instance.
             </para>
            
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipFile.EmitTimesInWindowsFormatWhenSaving">
             <summary>
               Specifies whether the Creation, Access, and Modified times for entries
               added to the zip file will be emitted in &#147;Windows format&#148;
               when the zip archive is saved.
             </summary>
            
             <remarks>
             <para>
               An application creating a zip archive can use this flag to explicitly
               specify that the file times for the entries should or should not be stored
               in the zip archive in the format used by Windows. By default this flag is
               <c>true</c>, meaning the Windows-format times are stored in the zip
               archive.
             </para>
            
             <para>
               When adding an entry from a file or directory, the Creation (<see
               cref="P:Ionic.Zip.ZipEntry.CreationTime"/>), Access (<see
               cref="P:Ionic.Zip.ZipEntry.AccessedTime"/>), and Modified (<see
               cref="P:Ionic.Zip.ZipEntry.ModifiedTime"/>) times for the given entry are
               automatically set from the filesystem values. When adding an entry from a
               stream or string, all three values are implicitly set to
               <c>DateTime.Now</c>.  Applications can also explicitly set those times by
               calling <see cref="M:Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)"/>.
             </para>
            
             <para>
               <see
               href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWARE's
               zip specification</see> describes multiple ways to format these times in a
               zip file. One is the format Windows applications normally use: 100ns ticks
               since January 1, 1601 UTC.  The other is a format Unix applications typically
               use: seconds since January 1, 1970 UTC.  Each format can be stored in an
               "extra field" in the zip entry when saving the zip archive. The former
               uses an extra field with a Header Id of 0x000A, while the latter uses a
               header ID of 0x5455, although you probably don't need to know that.
             </para>
            
             <para>
               Not all tools and libraries can interpret these fields.  Windows
               compressed folders is one that can read the Windows Format timestamps,
               while I believe <see href="http://www.info-zip.org/">the Infozip
               tools</see> can read the Unix format timestamps. Some tools and libraries
               may be able to read only one or the other. DotNetZip can read or write
               times in either or both formats.
             </para>
            
             <para>
               The times stored are taken from <see cref="P:Ionic.Zip.ZipEntry.ModifiedTime"/>, <see
               cref="P:Ionic.Zip.ZipEntry.AccessedTime"/>, and <see cref="P:Ionic.Zip.ZipEntry.CreationTime"/>.
             </para>
            
             <para>
               The value set here applies to all entries subsequently added to the
               <c>ZipFile</c>.
             </para>
            
             <para>
               This property is not mutually exclusive of the <see
               cref="P:Ionic.Zip.ZipFile.EmitTimesInUnixFormatWhenSaving" /> property. It is possible and
               legal and valid to produce a zip file that contains timestamps encoded in
               the Unix format as well as in the Windows format, in addition to the <see
               cref="P:Ionic.Zip.ZipEntry.LastModified">LastModified</see> time attached to each
               entry in the archive, a time that is always stored in "DOS format". And,
               notwithstanding the names PKWare uses for these time formats, any of them
               can be read and written by any computer, on any operating system.  But,
               there are no guarantees that a program running on Mac or Linux will
               gracefully handle a zip file with "Windows" formatted times, or that an
               application that does not use DotNetZip but runs on Windows will be able to
               handle file times in Unix format.
             </para>
            
             <para>
               When in doubt, test.  Sorry, I haven't got a complete list of tools and
               which sort of timestamps they can use and will tolerate.  If you get any
               good information and would like to pass it on, please do so and I will
               include that information in this documentation.
             </para>
             </remarks>
            
             <example>
               This example shows how to save a zip file that contains file timestamps
               in a format normally used by Unix.
             <code lang="C#">
             using (var zip = new ZipFile())
             {
                 // produce a zip file the Mac will like
                 zip.EmitTimesInWindowsFormatWhenSaving = false;
                 zip.EmitTimesInUnixFormatWhenSaving = true;
                 zip.AddDirectory(directoryToZip, "files");
                 zip.Save(outputFile);
             }
             </code>
            
             <code lang="VB">
             Using zip As New ZipFile
                 '' produce a zip file the Mac will like
                 zip.EmitTimesInWindowsFormatWhenSaving = False
                 zip.EmitTimesInUnixFormatWhenSaving = True
                 zip.AddDirectory(directoryToZip, "files")
                 zip.Save(outputFile)
             End Using
             </code>
             </example>
            
             <seealso cref="P:Ionic.Zip.ZipEntry.EmitTimesInWindowsFormatWhenSaving" />
             <seealso cref="P:Ionic.Zip.ZipFile.EmitTimesInUnixFormatWhenSaving" />
        </member>
        <member name="P:Ionic.Zip.ZipFile.EmitTimesInUnixFormatWhenSaving">
             <summary>
             Specifies whether the Creation, Access, and Modified times
             for entries added to the zip file will be emitted in "Unix(tm)
             format" when the zip archive is saved.
             </summary>
            
             <remarks>
             <para>
               An application creating a zip archive can use this flag to explicitly
               specify that the file times for the entries should or should not be stored
               in the zip archive in the format used by Unix. By default this flag is
               <c>false</c>, meaning the Unix-format times are not stored in the zip
               archive.
             </para>
            
             <para>
               When adding an entry from a file or directory, the Creation (<see
               cref="P:Ionic.Zip.ZipEntry.CreationTime"/>), Access (<see
               cref="P:Ionic.Zip.ZipEntry.AccessedTime"/>), and Modified (<see
               cref="P:Ionic.Zip.ZipEntry.ModifiedTime"/>) times for the given entry are
               automatically set from the filesystem values. When adding an entry from a
               stream or string, all three values are implicitly set to DateTime.Now.
               Applications can also explicitly set those times by calling <see
               cref="M:Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)"/>.
             </para>
            
             <para>
               <see
               href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWARE's
               zip specification</see> describes multiple ways to format these times in a
               zip file. One is the format Windows applications normally use: 100ns ticks
               since January 1, 1601 UTC.  The other is a format Unix applications
               typically use: seconds since January 1, 1970 UTC.  Each format can be
               stored in an "extra field" in the zip entry when saving the zip
               archive. The former uses an extra field with a Header Id of 0x000A, while
               the latter uses a header ID of 0x5455, although you probably don't need to
               know that.
             </para>
            
             <para>
               Not all tools and libraries can interpret these fields.  Windows
               compressed folders is one that can read the Windows Format timestamps,
               while I believe the <see href="http://www.info-zip.org/">Infozip</see>
               tools can read the Unix format timestamps. Some tools and libraries may be
               able to read only one or the other.  DotNetZip can read or write times in
               either or both formats.
             </para>
            
             <para>
               The times stored are taken from <see cref="P:Ionic.Zip.ZipEntry.ModifiedTime"/>, <see
               cref="P:Ionic.Zip.ZipEntry.AccessedTime"/>, and <see cref="P:Ionic.Zip.ZipEntry.CreationTime"/>.
             </para>
            
             <para>
               This property is not mutually exclusive of the <see
               cref="P:Ionic.Zip.ZipFile.EmitTimesInWindowsFormatWhenSaving" /> property. It is possible and
               legal and valid to produce a zip file that contains timestamps encoded in
               the Unix format as well as in the Windows format, in addition to the <see
               cref="P:Ionic.Zip.ZipEntry.LastModified">LastModified</see> time attached to each
               entry in the zip archive, a time that is always stored in "DOS
               format". And, notwithstanding the names PKWare uses for these time
               formats, any of them can be read and written by any computer, on any
               operating system.  But, there are no guarantees that a program running on
               Mac or Linux will gracefully handle a zip file with "Windows" formatted
               times, or that an application that does not use DotNetZip but runs on
               Windows will be able to handle file times in Unix format.
             </para>
            
             <para>
               When in doubt, test.  Sorry, I haven't got a complete list of tools and
               which sort of timestamps they can use and will tolerate.  If you get any
               good information and would like to pass it on, please do so and I will
               include that information in this documentation.
             </para>
             </remarks>
            
             <seealso cref="P:Ionic.Zip.ZipEntry.EmitTimesInUnixFormatWhenSaving" />
             <seealso cref="P:Ionic.Zip.ZipFile.EmitTimesInWindowsFormatWhenSaving" />
        </member>
        <member name="P:Ionic.Zip.ZipFile.Verbose">
             <summary>
               Indicates whether verbose output is sent to the <see
               cref="P:Ionic.Zip.ZipFile.StatusMessageTextWriter"/> during <c>AddXxx()</c> and
               <c>ReadXxx()</c> operations.
             </summary>
            
             <remarks>
               This is a <em>synthetic</em> property.  It returns true if the <see
               cref="P:Ionic.Zip.ZipFile.StatusMessageTextWriter"/> is non-null.
             </remarks>
        </member>
        <member name="M:Ionic.Zip.ZipFile.ContainsEntry(System.String)">
             <summary>
               Returns true if an entry by the given name exists in the ZipFile.
             </summary>
            
             <param name='name'>the name of the entry to find</param>
             <returns>true if an entry with the given name exists; otherwise false.
             </returns>
        </member>
        <member name="P:Ionic.Zip.ZipFile.CaseSensitiveRetrieval">
             <summary>
               Indicates whether to perform case-sensitive matching on the filename when
               retrieving entries in the zipfile via the string-based indexer.
             </summary>
            
             <remarks>
               The default value is <c>false</c>, which means don't do case-sensitive
               matching. In other words, retrieving zip["ReadMe.Txt"] is the same as
               zip["readme.txt"].  It really makes sense to set this to <c>true</c> only
               if you are not running on Windows, which has case-insensitive
               filenames. But since this library is not built for non-Windows platforms,
               in most cases you should just leave this property alone.
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipFile.UseUnicodeAsNecessary">
             <summary>
               Indicates whether to encode entry filenames and entry comments using Unicode
               (UTF-8).
             </summary>
            
             <remarks>
             <para>
               <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">The
               PKWare zip specification</see> provides for encoding file names and file
               comments in either the IBM437 code page, or in UTF-8.  This flag selects
               the encoding according to that specification.  By default, this flag is
               false, and filenames and comments are encoded into the zip file in the
               IBM437 codepage.  Setting this flag to true will specify that filenames
               and comments that cannot be encoded with IBM437 will be encoded with
               UTF-8.
             </para>
            
             <para>
               Zip files created with strict adherence to the PKWare specification with
               respect to UTF-8 encoding can contain entries with filenames containing
               any combination of Unicode characters, including the full range of
               characters from Chinese, Latin, Hebrew, Greek, Cyrillic, and many other
               alphabets.  However, because at this time, the UTF-8 portion of the PKWare
               specification is not broadly supported by other zip libraries and
               utilities, such zip files may not be readable by your favorite zip tool or
               archiver. In other words, interoperability will decrease if you set this
               flag to true.
             </para>
            
             <para>
               In particular, Zip files created with strict adherence to the PKWare
               specification with respect to UTF-8 encoding will not work well with
               Explorer in Windows XP or Windows Vista, because Windows compressed
               folders, as far as I know, do not support UTF-8 in zip files.  Vista can
               read the zip files, but shows the filenames incorrectly. Unpacking from
               Windows Vista Explorer will result in filenames that have rubbish
               characters in place of the high-order UTF-8 bytes.
             </para>
            
             <para>
               Also, zip files that use UTF-8 encoding will not work well with Java
               applications that use the java.util.zip classes, as of v5.0 of the Java
               runtime. The Java runtime does not correctly implement the PKWare
               specification in this regard.
             </para>
            
             <para>
               As a result, we have the unfortunate situation that "correct" behavior by
               the DotNetZip library with regard to Unicode encoding of filenames during
               zip creation will result in zip files that are readable by strictly
               compliant and current tools (for example the most recent release of the
               commercial WinZip tool); but these zip files will not be readable by
               various other tools or libraries, including Windows Explorer.
             </para>
            
             <para>
               The DotNetZip library can read and write zip files with UTF8-encoded
               entries, according to the PKware spec.  If you use DotNetZip for both
               creating and reading the zip file, and you use UTF-8, there will be no
               loss of information in the filenames. For example, using a self-extractor
               created by this library will allow you to unpack files correctly with no
               loss of information in the filenames.
             </para>
            
             <para>
               If you do not set this flag, it will remain false.  If this flag is false,
               your <c>ZipFile</c> will encode all filenames and comments using the
               IBM437 codepage.  This can cause "loss of information" on some filenames,
               but the resulting zipfile will be more interoperable with other
               utilities. As an example of the loss of information, diacritics can be
               lost.  The o-tilde character will be down-coded to plain o.  The c with a
               cedilla (Unicode 0xE7) used in Portugese will be downcoded to a c.
               Likewise, the O-stroke character (Unicode 248), used in Danish and
               Norwegian, will be down-coded to plain o. Chinese characters cannot be
               represented in codepage IBM437; when using the default encoding, Chinese
               characters in filenames will be represented as ?. These are all examples
               of "information loss".
             </para>
            
             <para>
               The loss of information associated to the use of the IBM437 encoding is
               inconvenient, and can also lead to runtime errors. For example, using
               IBM437, any sequence of 4 Chinese characters will be encoded as ????.  If
               your application creates a <c>ZipFile</c>, then adds two files, each with
               names of four Chinese characters each, this will result in a duplicate
               filename exception.  In the case where you add a single file with a name
               containing four Chinese characters, calling Extract() on the entry that
               has question marks in the filename will result in an exception, because
               the question mark is not legal for use within filenames on Windows.  These
               are just a few examples of the problems associated to loss of information.
             </para>
            
             <para>
               This flag is independent of the encoding of the content within the entries
               in the zip file. Think of the zip file as a container - it supports an
               encoding.  Within the container are other "containers" - the file entries
               themselves.  The encoding within those entries is independent of the
               encoding of the zip archive container for those entries.
             </para>
            
             <para>
               Rather than specify the encoding in a binary fashion using this flag, an
               application can specify an arbitrary encoding via the <see
               cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/> property.  Setting the encoding
               explicitly when creating zip archives will result in non-compliant zip
               files that, curiously, are fairly interoperable.  The challenge is, the
               PKWare specification does not provide for a way to specify that an entry
               in a zip archive uses a code page that is neither IBM437 nor UTF-8.
               Therefore if you set the encoding explicitly when creating a zip archive,
               you must take care upon reading the zip archive to use the same code page.
               If you get it wrong, the behavior is undefined and may result in incorrect
               filenames, exceptions, stomach upset, hair loss, and acne.
             </para>
             </remarks>
             <seealso cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>
        </member>
        <member name="P:Ionic.Zip.ZipFile.UseZip64WhenSaving">
             <summary>
               Specify whether to use ZIP64 extensions when saving a zip archive.
             </summary>
            
             <remarks>
            
             <para>
               When creating a zip file, the default value for the property is <see
               cref="F:Ionic.Zip.Zip64Option.Never"/>. <see cref="F:Ionic.Zip.Zip64Option.AsNecessary"/> is
               safest, in the sense that you will not get an Exception if a pre-ZIP64
               limit is exceeded.
             </para>
            
             <para>
               You may set the property at any time before calling Save().
             </para>
            
             <para>
               When reading a zip file via the <c>Zipfile.Read()</c> method, DotNetZip
               will properly read ZIP64-endowed zip archives, regardless of the value of
               this property.  DotNetZip will always read ZIP64 archives.  This property
               governs only whether DotNetZip will write them. Therefore, when updating
               archives, be careful about setting this property after reading an archive
               that may use ZIP64 extensions.
             </para>
            
             <para>
               An interesting question is, if you have set this property to
               <c>AsNecessary</c>, and then successfully saved, does the resulting
               archive use ZIP64 extensions or not?  To learn this, check the <see
               cref="P:Ionic.Zip.ZipFile.OutputUsedZip64"/> property, after calling <c>Save()</c>.
             </para>
            
             <para>
               Have you thought about
               <see href="http://cheeso.members.winisp.net/DotNetZipDonate.aspx">donating</see>?
             </para>
            
             </remarks>
             <seealso cref="P:Ionic.Zip.ZipFile.RequiresZip64"/>
        </member>
        <member name="P:Ionic.Zip.ZipFile.RequiresZip64">
             <summary>
               Indicates whether the archive requires ZIP64 extensions.
             </summary>
            
             <remarks>
            
             <para>
               This property is <c>null</c> (or <c>Nothing</c> in VB) if the archive has
               not been saved, and there are fewer than 65334 <c>ZipEntry</c> items
               contained in the archive.
             </para>
            
             <para>
               The <c>Value</c> is true if any of the following four conditions holds:
               the uncompressed size of any entry is larger than 0xFFFFFFFF; the
               compressed size of any entry is larger than 0xFFFFFFFF; the relative
               offset of any entry within the zip archive is larger than 0xFFFFFFFF; or
               there are more than 65534 entries in the archive.  (0xFFFFFFFF =
               4,294,967,295).  The result may not be known until a <c>Save()</c> is attempted
               on the zip archive.  The Value of this <see cref="T:System.Nullable"/>
               property may be set only AFTER one of the Save() methods has been called.
             </para>
            
             <para>
               If none of the four conditions holds, and the archive has been saved, then
               the <c>Value</c> is false.
             </para>
            
             <para>
               A <c>Value</c> of false does not indicate that the zip archive, as saved,
               does not use ZIP64.  It merely indicates that ZIP64 is not required.  An
               archive may use ZIP64 even when not required if the <see
               cref="P:Ionic.Zip.ZipFile.UseZip64WhenSaving"/> property is set to <see
               cref="F:Ionic.Zip.Zip64Option.Always"/>, or if the <see
               cref="P:Ionic.Zip.ZipFile.UseZip64WhenSaving"/> property is set to <see
               cref="F:Ionic.Zip.Zip64Option.AsNecessary"/> and the output stream was not
               seekable. Use the <see cref="P:Ionic.Zip.ZipFile.OutputUsedZip64"/> property to determine if
               the most recent <c>Save()</c> method resulted in an archive that utilized
               the ZIP64 extensions.
             </para>
            
             </remarks>
             <seealso cref="P:Ionic.Zip.ZipFile.UseZip64WhenSaving"/>
             <seealso cref="P:Ionic.Zip.ZipFile.OutputUsedZip64"/>
        </member>
        <member name="P:Ionic.Zip.ZipFile.OutputUsedZip64">
             <summary>
               Indicates whether the most recent <c>Save()</c> operation used ZIP64 extensions.
             </summary>
            
             <remarks>
             <para>
               The use of ZIP64 extensions within an archive is not always necessary, and
               for interoperability concerns, it may be desired to NOT use ZIP64 if
               possible.  The <see cref="P:Ionic.Zip.ZipFile.UseZip64WhenSaving"/> property can be
               set to use ZIP64 extensions only when necessary.  In those cases,
               Sometimes applications want to know whether a Save() actually used ZIP64
               extensions.  Applications can query this read-only property to learn
               whether ZIP64 has been used in a just-saved <c>ZipFile</c>.
             </para>
            
             <para>
               The value is <c>null</c> (or <c>Nothing</c> in VB) if the archive has not
               been saved.
             </para>
            
             <para>
               Non-null values (<c>HasValue</c> is true) indicate whether ZIP64
               extensions were used during the most recent <c>Save()</c> operation.  The
               ZIP64 extensions may have been used as required by any particular entry
               because of its uncompressed or compressed size, or because the archive is
               larger than 4294967295 bytes, or because there are more than 65534 entries
               in the archive, or because the <c>UseZip64WhenSaving</c> property was set
               to <see cref="F:Ionic.Zip.Zip64Option.Always"/>, or because the
               <c>UseZip64WhenSaving</c> property was set to <see
               cref="F:Ionic.Zip.Zip64Option.AsNecessary"/> and the output stream was not seekable.
               The value of this property does not indicate the reason the ZIP64
               extensions were used.
             </para>
            
             </remarks>
             <seealso cref="P:Ionic.Zip.ZipFile.UseZip64WhenSaving"/>
             <seealso cref="P:Ionic.Zip.ZipFile.RequiresZip64"/>
        </member>
        <member name="P:Ionic.Zip.ZipFile.InputUsesZip64">
             <summary>
               Indicates whether the most recent <c>Read()</c> operation read a zip file that uses
               ZIP64 extensions.
             </summary>
            
             <remarks>
               This property will return null (Nothing in VB) if you've added an entry after reading
               the zip file.
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding">
             <summary>
               The text encoding to use when writing new entries to the <c>ZipFile</c>,
               for those entries that cannot be encoded with the default (IBM437)
               encoding; or, the text encoding that was used when reading the entries
               from the <c>ZipFile</c>.
             </summary>
            
             <remarks>
             <para>
               In <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">its
               zip specification</see>, PKWare describes two options for encoding
               filenames and comments: using IBM437 or UTF-8.  But, some archiving tools
               or libraries do not follow the specification, and instead encode
               characters using the system default code page.  For example, WinRAR when
               run on a machine in Shanghai may encode filenames with the Big-5 Chinese
               (950) code page.  This behavior is contrary to the Zip specification, but
               it occurs anyway.
             </para>
            
             <para>
               When using DotNetZip to write zip archives that will be read by one of
               these other archivers, set this property to specify the code page to use
               when encoding the <see cref="P:Ionic.Zip.ZipEntry.FileName"/> and <see
               cref="P:Ionic.Zip.ZipEntry.Comment"/> for each <c>ZipEntry</c> in the zip file, for
               values that cannot be encoded with the default codepage for zip files,
               IBM437.  This is why this property is "provisional".  In all cases, IBM437
               is used where possible, in other words, where no loss of data would
               result. It is possible, therefore, to have a given entry with a
               <c>Comment</c> encoded in IBM437 and a <c>FileName</c> encoded with the
               specified "provisional" codepage.
             </para>
            
             <para>
               Be aware that a zip file created after you've explicitly set the <see
               cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" /> property to a value other than
               IBM437 may not be compliant to the PKWare specification, and may not be
               readable by compliant archivers.  On the other hand, many (most?)
               archivers are non-compliant and can read zip files created in arbitrary
               code pages.  The trick is to use or specify the proper codepage when
               reading the zip.
             </para>
            
             <para>
               When creating a zip archive using this library, it is possible to change
               the value of <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" /> between each
               entry you add, and between adding entries and the call to
               <c>Save()</c>. Don't do this. It will likely result in a zipfile that is
               not readable.  For best interoperability, either leave <see
               cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" /> alone, or specify it only once,
               before adding any entries to the <c>ZipFile</c> instance.  There is one
               exception to this recommendation, described later.
             </para>
            
             <para>
               When using an arbitrary, non-UTF8 code page for encoding, there is no
               standard way for the creator application - whether DotNetZip, WinZip,
               WinRar, or something else - to formally specify in the zip file which
               codepage has been used for the entries. As a result, readers of zip files
               are not able to inspect the zip file and determine the codepage that was
               used for the entries contained within it.  It is left to the application
               or user to determine the necessary codepage when reading zip files encoded
               this way.  In other words, if you explicitly specify the codepage when you
               create the zipfile, you must explicitly specify the same codepage when
               reading the zipfile.
             </para>
            
             <para>
               The way you specify the code page to use when reading a zip file varies
               depending on the tool or library you use to read the zip.  In DotNetZip,
               you use a ZipFile.Read() method that accepts an encoding parameter.  It
               isn't possible with Windows Explorer, as far as I know, to specify an
               explicit codepage to use when reading a zip.  If you use an incorrect
               codepage when reading a zipfile, you will get entries with filenames that
               are incorrect, and the incorrect filenames may even contain characters
               that are not legal for use within filenames in Windows. Extracting entries
               with illegal characters in the filenames will lead to exceptions. It's too
               bad, but this is just the way things are with code pages in zip
               files. Caveat Emptor.
             </para>
            
             <para>
               Example: Suppose you create a zipfile that contains entries with
               filenames that have Danish characters.  If you use <see
               cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" /> equal to "iso-8859-1" (cp 28591),
               the filenames will be correctly encoded in the zip.  But, to read that
               zipfile correctly, you have to specify the same codepage at the time you
               read it. If try to read that zip file with Windows Explorer or another
               application that is not flexible with respect to the codepage used to
               decode filenames in zipfiles, you will get a filename like "Inf?txt".
             </para>
            
             <para>
               When using DotNetZip to read a zip archive, and the zip archive uses an
               arbitrary code page, you must specify the encoding to use before or when
               the <c>Zipfile</c> is READ.  This means you must use a <c>ZipFile.Read()</c>
               method that allows you to specify a System.Text.Encoding parameter.  Setting
               the ProvisionalAlternateEncoding property after your application has read in
               the zip archive will not affect the entry names of entries that have already
               been read in.
             </para>
            
             <para>
               And now, the exception to the rule described above.  One strategy for
               specifying the code page for a given zip file is to describe the code page
               in a human-readable form in the Zip comment. For example, the comment may
               read "Entries in this archive are encoded in the Big5 code page".  For
               maximum interoperability, the zip comment in this case should be encoded
               in the default, IBM437 code page.  In this case, the zip comment is
               encoded using a different page than the filenames.  To do this, Specify
               <c>ProvisionalAlternateEncoding</c> to your desired region-specific code
               page, once before adding any entries, and then reset
               <c>ProvisionalAlternateEncoding</c> to IBM437 before setting the <see
               cref="P:Ionic.Zip.ZipFile.Comment"/> property and calling Save().
             </para>
             </remarks>
            
             <example>
             This example shows how to read a zip file using the Big-5 Chinese code page
             (950), and extract each entry in the zip file.  For this code to work as
             desired, the <c>Zipfile</c> must have been created using the big5 code page
             (CP950). This is typical, for example, when using WinRar on a machine with
             CP950 set as the default code page.  In that case, the names of entries
             within the Zip archive will be stored in that code page, and reading the zip
             archive must be done using that code page.  If the application did not use
             the correct code page in <c>ZipFile.Read()</c>, then names of entries within the
             zip archive would not be correctly retrieved.
             <code>
             using (var zip = ZipFile.Read(zipFileName, System.Text.Encoding.GetEncoding("big5")))
             {
                 // retrieve and extract an entry using a name encoded with CP950
                 zip[MyDesiredEntry].Extract("unpack");
             }
             </code>
            
             <code lang="VB">
             Using zip As ZipFile = ZipFile.Read(ZipToExtract, System.Text.Encoding.GetEncoding("big5"))
                 ' retrieve and extract an entry using a name encoded with CP950
                 zip(MyDesiredEntry).Extract("unpack")
             End Using
             </code>
             </example>
            
             <seealso cref="P:Ionic.Zip.ZipFile.DefaultEncoding">DefaultEncoding</seealso>
        </member>
        <member name="P:Ionic.Zip.ZipFile.AlternateEncoding">
            <summary>
              A Text Encoding to use when encoding the filenames and comments for
              all the ZipEntry items, during a ZipFile.Save() operation.
            </summary>
            <remarks>
              <para>
                Whether the encoding specified here is used during the save depends
                on <see cref="P:Ionic.Zip.ZipFile.AlternateEncodingUsage"/>.
              </para>
            </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipFile.AlternateEncodingUsage">
            <summary>
              A flag that tells if and when this instance should apply
              AlternateEncoding to encode the filenames and comments associated to
              of ZipEntry objects contained within this instance.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipFile.DefaultEncoding">
            <summary>
            The default text encoding used in zip archives.  It is numeric 437, also
            known as IBM437.
            </summary>
            <seealso cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>
        </member>
        <member name="P:Ionic.Zip.ZipFile.StatusMessageTextWriter">
             <summary>
             Gets or sets the <c>TextWriter</c> to which status messages are delivered
             for the instance.
             </summary>
            
             <remarks>
               If the TextWriter is set to a non-null value, then verbose output is sent
               to the <c>TextWriter</c> during <c>Add</c><c>, Read</c><c>, Save</c> and
               <c>Extract</c> operations.  Typically, console applications might use
               <c>Console.Out</c> and graphical or headless applications might use a
               <c>System.IO.StringWriter</c>. The output of this is suitable for viewing
               by humans.
             </remarks>
            
             <example>
             <para>
               In this example, a console application instantiates a <c>ZipFile</c>, then
               sets the <c>StatusMessageTextWriter</c> to <c>Console.Out</c>.  At that
               point, all verbose status messages for that <c>ZipFile</c> are sent to the
               console.
             </para>
            
             <code lang="C#">
             using (ZipFile zip= ZipFile.Read(FilePath))
             {
               zip.StatusMessageTextWriter= System.Console.Out;
               // messages are sent to the console during extraction
               zip.ExtractAll();
             }
             </code>
            
             <code lang="VB">
             Using zip As ZipFile = ZipFile.Read(FilePath)
               zip.StatusMessageTextWriter= System.Console.Out
               'Status Messages will be sent to the console during extraction
               zip.ExtractAll()
             End Using
             </code>
            
             <para>
               In this example, a Windows Forms application instantiates a
               <c>ZipFile</c>, then sets the <c>StatusMessageTextWriter</c> to a
               <c>StringWriter</c>.  At that point, all verbose status messages for that
               <c>ZipFile</c> are sent to the <c>StringWriter</c>.
             </para>
            
             <code lang="C#">
             var sw = new System.IO.StringWriter();
             using (ZipFile zip= ZipFile.Read(FilePath))
             {
               zip.StatusMessageTextWriter= sw;
               zip.ExtractAll();
             }
             Console.WriteLine("{0}", sw.ToString());
             </code>
            
             <code lang="VB">
             Dim sw as New System.IO.StringWriter
             Using zip As ZipFile = ZipFile.Read(FilePath)
               zip.StatusMessageTextWriter= sw
               zip.ExtractAll()
             End Using
             'Status Messages are now available in sw
            
             </code>
             </example>
        </member>
        <member name="P:Ionic.Zip.ZipFile.TempFileFolder">
             <summary>
               Gets or sets the name for the folder to store the temporary file
               this library writes when saving a zip archive.
             </summary>
            
             <remarks>
             <para>
               This library will create a temporary file when saving a Zip archive to a
               file.  This file is written when calling one of the <c>Save()</c> methods
               that does not save to a stream, or one of the <c>SaveSelfExtractor()</c>
               methods.
             </para>
            
             <para>
               By default, the library will create the temporary file in the directory
               specified for the file itself, via the <see cref="P:Ionic.Zip.ZipFile.Name"/> property or via
               the <see cref="M:Ionic.Zip.ZipFile.Save(System.String)"/> method.
             </para>
            
             <para>
               Setting this property allows applications to override this default
               behavior, so that the library will create the temporary file in the
               specified folder. For example, to have the library create the temporary
               file in the current working directory, regardless where the <c>ZipFile</c>
               is saved, specfy ".".  To revert to the default behavior, set this
               property to <c>null</c> (<c>Nothing</c> in VB).
             </para>
            
             <para>
               When setting the property to a non-null value, the folder specified must
               exist; if it does not an exception is thrown.  The application should have
               write and delete permissions on the folder.  The permissions are not
               explicitly checked ahead of time; if the application does not have the
               appropriate rights, an exception will be thrown at the time <c>Save()</c>
               is called.
             </para>
            
             <para>
               There is no temporary file created when reading a zip archive.  When
               saving to a Stream, there is no temporary file created.  For example, if
               the application is an ASP.NET application and calls <c>Save()</c>
               specifying the <c>Response.OutputStream</c> as the output stream, there is
               no temporary file created.
             </para>
             </remarks>
            
             <exception cref="T:System.IO.FileNotFoundException">
             Thrown when setting the property if the directory does not exist.
             </exception>
            
        </member>
        <member name="P:Ionic.Zip.ZipFile.Password">
             <summary>
             Sets the password to be used on the <c>ZipFile</c> instance.
             </summary>
            
             <remarks>
            
             <para>
               When writing a zip archive, this password is applied to the entries, not
               to the zip archive itself. It applies to any <c>ZipEntry</c> subsequently
               added to the <c>ZipFile</c>, using one of the <c>AddFile</c>,
               <c>AddDirectory</c>, <c>AddEntry</c>, or <c>AddItem</c> methods, etc.
               When reading a zip archive, this property applies to any entry
               subsequently extracted from the <c>ZipFile</c> using one of the Extract
               methods on the <c>ZipFile</c> class.
             </para>
            
             <para>
               When writing a zip archive, keep this in mind: though the password is set
               on the ZipFile object, according to the Zip spec, the "directory" of the
               archive - in other words the list of entries or files contained in the archive - is
               not encrypted with the password, or protected in any way.  If you set the
               Password property, the password actually applies to individual entries
               that are added to the archive, subsequent to the setting of this property.
               The list of filenames in the archive that is eventually created will
               appear in clear text, but the contents of the individual files are
               encrypted.  This is how Zip encryption works.
             </para>
            
             <para>
               One simple way around this limitation is to simply double-wrap sensitive
               filenames: Store the files in a zip file, and then store that zip file
               within a second, "outer" zip file.  If you apply a password to the outer
               zip file, then readers will be able to see that the outer zip file
               contains an inner zip file.  But readers will not be able to read the
               directory or file list of the inner zip file.
             </para>
            
             <para>
               If you set the password on the <c>ZipFile</c>, and then add a set of files
               to the archive, then each entry is encrypted with that password.  You may
               also want to change the password between adding different entries. If you
               set the password, add an entry, then set the password to <c>null</c>
               (<c>Nothing</c> in VB), and add another entry, the first entry is
               encrypted and the second is not.  If you call <c>AddFile()</c>, then set
               the <c>Password</c> property, then call <c>ZipFile.Save</c>, the file
               added will not be password-protected, and no warning will be generated.
             </para>
            
             <para>
               When setting the Password, you may also want to explicitly set the <see
               cref="P:Ionic.Zip.ZipFile.Encryption"/> property, to specify how to encrypt the entries added
               to the ZipFile.  If you set the Password to a non-null value and do not
               set <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, then PKZip 2.0 ("Weak") encryption is used.
               This encryption is relatively weak but is very interoperable. If you set
               the password to a <c>null</c> value (<c>Nothing</c> in VB), Encryption is
               reset to None.
             </para>
            
             <para>
               All of the preceding applies to writing zip archives, in other words when
               you use one of the Save methods.  To use this property when reading or an
               existing ZipFile, do the following: set the Password property on the
               <c>ZipFile</c>, then call one of the Extract() overloads on the <see
               cref="T:Ionic.Zip.ZipEntry" />. In this case, the entry is extracted using the
               <c>Password</c> that is specified on the <c>ZipFile</c> instance. If you
               have not set the <c>Password</c> property, then the password is
               <c>null</c>, and the entry is extracted with no password.
             </para>
            
             <para>
               If you set the Password property on the <c>ZipFile</c>, then call
               <c>Extract()</c> an entry that has not been encrypted with a password, the
               password is not used for that entry, and the <c>ZipEntry</c> is extracted
               as normal. In other words, the password is used only if necessary.
             </para>
            
             <para>
               The <see cref="T:Ionic.Zip.ZipEntry"/> class also has a <see
               cref="P:Ionic.Zip.ZipEntry.Password">Password</see> property.  It takes precedence
               over this property on the <c>ZipFile</c>.  Typically, you would use the
               per-entry Password when most entries in the zip archive use one password,
               and a few entries use a different password.  If all entries in the zip
               file use the same password, then it is simpler to just set this property
               on the <c>ZipFile</c> itself, whether creating a zip archive or extracting
               a zip archive.
             </para>
            
             </remarks>
            
             <example>
             <para>
               This example creates a zip file, using password protection for the
               entries, and then extracts the entries from the zip file.  When creating
               the zip file, the Readme.txt file is not protected with a password, but
               the other two are password-protected as they are saved. During extraction,
               each file is extracted with the appropriate password.
             </para>
             <code>
             // create a file with encryption
             using (ZipFile zip = new ZipFile())
             {
                 zip.AddFile("ReadMe.txt");
                 zip.Password= "!Secret1";
                 zip.AddFile("MapToTheSite-7440-N49th.png");
                 zip.AddFile("2008-Regional-Sales-Report.pdf");
                 zip.Save("EncryptedArchive.zip");
             }
            
             // extract entries that use encryption
             using (ZipFile zip = ZipFile.Read("EncryptedArchive.zip"))
             {
                 zip.Password= "!Secret1";
                 zip.ExtractAll("extractDir");
             }
            
             </code>
            
             <code lang="VB">
             Using zip As New ZipFile
                 zip.AddFile("ReadMe.txt")
                 zip.Password = "123456!"
                 zip.AddFile("MapToTheSite-7440-N49th.png")
                 zip.Password= "!Secret1";
                 zip.AddFile("2008-Regional-Sales-Report.pdf")
                 zip.Save("EncryptedArchive.zip")
             End Using
            
            
             ' extract entries that use encryption
             Using (zip as ZipFile = ZipFile.Read("EncryptedArchive.zip"))
                 zip.Password= "!Secret1"
                 zip.ExtractAll("extractDir")
             End Using
            
             </code>
            
             </example>
            
             <seealso cref="P:Ionic.Zip.ZipFile.Encryption">ZipFile.Encryption</seealso>
             <seealso cref="P:Ionic.Zip.ZipEntry.Password">ZipEntry.Password</seealso>
        </member>
        <member name="P:Ionic.Zip.ZipFile.ExtractExistingFile">
             <summary>
               The action the library should take when extracting a file that already
               exists.
             </summary>
            
             <remarks>
             <para>
               This property affects the behavior of the Extract methods (one of the
               <c>Extract()</c> or <c>ExtractWithPassword()</c> overloads), when
               extraction would would overwrite an existing filesystem file. If you do
               not set this property, the library throws an exception when extracting an
               entry would overwrite an existing file.
             </para>
            
             <para>
               This property has no effect when extracting to a stream, or when the file
               to be extracted does not already exist.
             </para>
             </remarks>
             <seealso cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile"/>
        </member>
        <member name="P:Ionic.Zip.ZipFile.ZipErrorAction">
             <summary>
               The action the library should take when an error is encountered while
               opening or reading files as they are saved into a zip archive.
             </summary>
            
             <remarks>
              <para>
                Errors can occur as a file is being saved to the zip archive.  For
                example, the File.Open may fail, or a File.Read may fail, because of
                lock conflicts or other reasons.
              </para>
            
              <para>
                The first problem might occur after having called AddDirectory() on a
                directory that contains a Clipper .dbf file; the file is locked by
                Clipper and cannot be opened for read by another process. An example of
                the second problem might occur when trying to zip a .pst file that is in
                use by Microsoft Outlook. Outlook locks a range on the file, which allows
                other processes to open the file, but not read it in its entirety.
              </para>
            
              <para>
                This property tells DotNetZip what you would like to do in the case of
                these errors.  The primary options are: <c>ZipErrorAction.Throw</c> to
                throw an exception (this is the default behavior if you don't set this
                property); <c>ZipErrorAction.Skip</c> to Skip the file for which there
                was an error and continue saving; <c>ZipErrorAction.Retry</c> to Retry
                the entry that caused the problem; or
                <c>ZipErrorAction.InvokeErrorEvent</c> to invoke an event handler.
              </para>
            
              <para>
                This property is implicitly set to <c>ZipErrorAction.InvokeErrorEvent</c>
                if you add a handler to the <see cref="E:Ionic.Zip.ZipFile.ZipError" /> event.  If you set
                this property to something other than
                <c>ZipErrorAction.InvokeErrorEvent</c>, then the <c>ZipError</c>
                event is implicitly cleared.  What it means is you can set one or the
                other (or neither), depending on what you want, but you never need to set
                both.
              </para>
            
              <para>
                As with some other properties on the <c>ZipFile</c> class, like <see
                cref="P:Ionic.Zip.ZipFile.Password"/>, <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, and <see
                cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, setting this property on a <c>ZipFile</c>
                instance will cause the specified <c>ZipErrorAction</c> to be used on all
                <see cref="T:Ionic.Zip.ZipEntry"/> items that are subsequently added to the
                <c>ZipFile</c> instance. If you set this property after you have added
                items to the <c>ZipFile</c>, but before you have called <c>Save()</c>,
                those items will not use the specified error handling action.
              </para>
            
              <para>
                If you want to handle any errors that occur with any entry in the zip
                file in the same way, then set this property once, before adding any
                entries to the zip archive.
              </para>
            
              <para>
                If you set this property to <c>ZipErrorAction.Skip</c> and you'd like to
                learn which files may have been skipped after a <c>Save()</c>, you can
                set the <see cref="P:Ionic.Zip.ZipFile.StatusMessageTextWriter" /> on the ZipFile before
                calling <c>Save()</c>. A message will be emitted into that writer for
                each skipped file, if any.
              </para>
            
             </remarks>
            
             <example>
               This example shows how to tell DotNetZip to skip any files for which an
               error is generated during the Save().
             <code lang="VB">
             Public Sub SaveZipFile()
                 Dim SourceFolder As String = "fodder"
                 Dim DestFile As String =  "eHandler.zip"
                 Dim sw as New StringWriter
                 Using zipArchive As ZipFile = New ZipFile
                     ' Tell DotNetZip to skip any files for which it encounters an error
                     zipArchive.ZipErrorAction = ZipErrorAction.Skip
                     zipArchive.StatusMessageTextWriter = sw
                     zipArchive.AddDirectory(SourceFolder)
                     zipArchive.Save(DestFile)
                 End Using
                 ' examine sw here to see any messages
             End Sub
            
             </code>
             </example>
            
             <seealso cref="P:Ionic.Zip.ZipEntry.ZipErrorAction"/>
             <seealso cref="E:Ionic.Zip.ZipFile.ZipError"/>
        </member>
        <member name="P:Ionic.Zip.ZipFile.Encryption">
             <summary>
               The Encryption to use for entries added to the <c>ZipFile</c>.
             </summary>
            
             <remarks>
             <para>
               Set this when creating a zip archive, or when updating a zip archive. The
               specified Encryption is applied to the entries subsequently added to the
               <c>ZipFile</c> instance.  Applications do not need to set the
               <c>Encryption</c> property when reading or extracting a zip archive.
             </para>
            
             <para>
               If you set this to something other than EncryptionAlgorithm.None, you
               will also need to set the <see cref="P:Ionic.Zip.ZipFile.Password"/>.
             </para>
            
             <para>
               As with some other properties on the <c>ZipFile</c> class, like <see
               cref="P:Ionic.Zip.ZipFile.Password"/> and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, setting this
               property on a <c>ZipFile</c> instance will cause the specified
               <c>EncryptionAlgorithm</c> to be used on all <see cref="T:Ionic.Zip.ZipEntry"/> items
               that are subsequently added to the <c>ZipFile</c> instance. In other
               words, if you set this property after you have added items to the
               <c>ZipFile</c>, but before you have called <c>Save()</c>, those items will
               not be encrypted or protected with a password in the resulting zip
               archive. To get a zip archive with encrypted entries, set this property,
               along with the <see cref="P:Ionic.Zip.ZipFile.Password"/> property, before calling
               <c>AddFile</c>, <c>AddItem</c>, or <c>AddDirectory</c> (etc.) on the
               <c>ZipFile</c> instance.
             </para>
            
             <para>
               If you read a <c>ZipFile</c>, you can modify the <c>Encryption</c> on an
               encrypted entry, only by setting the <c>Encryption</c> property on the
               <c>ZipEntry</c> itself.  Setting the <c>Encryption</c> property on the
               <c>ZipFile</c>, once it has been created via a call to
               <c>ZipFile.Read()</c>, does not affect entries that were previously read.
             </para>
            
             <para>
               For example, suppose you read a <c>ZipFile</c>, and there is an encrypted
               entry.  Setting the <c>Encryption</c> property on that <c>ZipFile</c> and
               then calling <c>Save()</c> on the <c>ZipFile</c> does not update the
               <c>Encryption</c> used for the entries in the archive.  Neither is an
               exception thrown. Instead, what happens during the <c>Save()</c> is that
               all previously existing entries are copied through to the new zip archive,
               with whatever encryption and password that was used when originally
               creating the zip archive. Upon re-reading that archive, to extract
               entries, applications should use the original password or passwords, if
               any.
             </para>
            
             <para>
               Suppose an application reads a <c>ZipFile</c>, and there is an encrypted
               entry.  Setting the <c>Encryption</c> property on that <c>ZipFile</c> and
               then adding new entries (via <c>AddFile()</c>, <c>AddEntry()</c>, etc)
               and then calling <c>Save()</c> on the <c>ZipFile</c> does not update the
               <c>Encryption</c> on any of the entries that had previously been in the
               <c>ZipFile</c>.  The <c>Encryption</c> property applies only to the
               newly-added entries.
             </para>
            
             </remarks>
            
             <example>
             <para>
               This example creates a zip archive that uses encryption, and then extracts
               entries from the archive.  When creating the zip archive, the ReadMe.txt
               file is zipped without using a password or encryption.  The other files
               use encryption.
             </para>
            
             <code>
             // Create a zip archive with AES Encryption.
             using (ZipFile zip = new ZipFile())
             {
                 zip.AddFile("ReadMe.txt");
                 zip.Encryption= EncryptionAlgorithm.WinZipAes256;
                 zip.Password= "Top.Secret.No.Peeking!";
                 zip.AddFile("7440-N49th.png");
                 zip.AddFile("2008-Regional-Sales-Report.pdf");
                 zip.Save("EncryptedArchive.zip");
             }
            
             // Extract a zip archive that uses AES Encryption.
             // You do not need to specify the algorithm during extraction.
             using (ZipFile zip = ZipFile.Read("EncryptedArchive.zip"))
             {
                 zip.Password= "Top.Secret.No.Peeking!";
                 zip.ExtractAll("extractDirectory");
             }
             </code>
            
             <code lang="VB">
             ' Create a zip that uses Encryption.
             Using zip As New ZipFile()
                 zip.Encryption= EncryptionAlgorithm.WinZipAes256
                 zip.Password= "Top.Secret.No.Peeking!"
                 zip.AddFile("ReadMe.txt")
                 zip.AddFile("7440-N49th.png")
                 zip.AddFile("2008-Regional-Sales-Report.pdf")
                 zip.Save("EncryptedArchive.zip")
             End Using
            
             ' Extract a zip archive that uses AES Encryption.
             ' You do not need to specify the algorithm during extraction.
             Using (zip as ZipFile = ZipFile.Read("EncryptedArchive.zip"))
                 zip.Password= "Top.Secret.No.Peeking!"
                 zip.ExtractAll("extractDirectory")
             End Using
             </code>
            
             </example>
            
             <seealso cref="P:Ionic.Zip.ZipFile.Password">ZipFile.Password</seealso>
             <seealso cref="P:Ionic.Zip.ZipEntry.Encryption">ZipEntry.Encryption</seealso>
        </member>
        <member name="P:Ionic.Zip.ZipFile.SetCompression">
             <summary>
               A callback that allows the application to specify the compression level
               to use for entries subsequently added to the zip archive.
             </summary>
            
             <remarks>
            
             <para>
               With this callback, the DotNetZip library allows the application to
               determine whether compression will be used, at the time of the
               <c>Save</c>. This may be useful if the application wants to favor
               speed over size, and wants to defer the decision until the time of
               <c>Save</c>.
             </para>
            
             <para>
               Typically applications set the <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/> property on
               the <c>ZipFile</c> or on each <c>ZipEntry</c> to determine the level of
               compression used. This is done at the time the entry is added to the
               <c>ZipFile</c>. Setting the property to
               <c>Ionic.Zlib.CompressionLevel.None</c> means no compression will be used.
             </para>
            
             <para>
               This callback allows the application to defer the decision on the
               <c>CompressionLevel</c> to use, until the time of the call to
               <c>ZipFile.Save()</c>. The callback is invoked once per <c>ZipEntry</c>,
               at the time the data for the entry is being written out as part of a
               <c>Save()</c> operation. The application can use whatever criteria it
               likes in determining the level to return.  For example, an application may
               wish that no .mp3 files should be compressed, because they are already
               compressed and the extra compression is not worth the CPU time incurred,
               and so can return <c>None</c> for all .mp3 entries.
             </para>
            
             <para>
               The library determines whether compression will be attempted for an entry
               this way: If the entry is a zero length file, or a directory, no
               compression is used.  Otherwise, if this callback is set, it is invoked
               and the <c>CompressionLevel</c> is set to the return value. If this
               callback has not been set, then the previously set value for
               <c>CompressionLevel</c> is used.
             </para>
            
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipFile.MaxOutputSegmentSize">
             <summary>
             The maximum size of an output segment, when saving a split Zip file.
             </summary>
             <remarks>
               <para>
                 Set this to a non-zero value before calling <see cref="M:Ionic.Zip.ZipFile.Save"/> or <see
                 cref="M:Ionic.Zip.ZipFile.Save(System.String)"/> to specify that the ZipFile should be saved as a
                 split archive, also sometimes called a spanned archive. Some also
                 call them multi-file archives.
               </para>
            
               <para>
                 A split zip archive is saved in a set of discrete filesystem files,
                 rather than in a single file. This is handy when transmitting the
                 archive in email or some other mechanism that has a limit to the size of
                 each file.  The first file in a split archive will be named
                 <c>basename.z01</c>, the second will be named <c>basename.z02</c>, and
                 so on. The final file is named <c>basename.zip</c>. According to the zip
                 specification from PKWare, the minimum value is 65536, for a 64k segment
                 size. The maximum number of segments allows in a split archive is 99.
               </para>
            
               <para>
                 The value of this property determines the maximum size of a split
                 segment when writing a split archive.  For example, suppose you have a
                 <c>ZipFile</c> that would save to a single file of 200k. If you set the
                 <c>MaxOutputSegmentSize</c> to 65536 before calling <c>Save()</c>, you
                 will get four distinct output files. On the other hand if you set this
                 property to 256k, then you will get a single-file archive for that
                 <c>ZipFile</c>.
               </para>
            
               <para>
                 The size of each split output file will be as large as possible, up to
                 the maximum size set here. The zip specification requires that some data
                 fields in a zip archive may not span a split boundary, and an output
                 segment may be smaller than the maximum if necessary to avoid that
                 problem. Also, obviously the final segment of the archive may be smaller
                 than the maximum segment size. Segments will never be larger than the
                 value set with this property.
               </para>
            
               <para>
                 You can save a split Zip file only when saving to a regular filesystem
                 file. It's not possible to save a split zip file as a self-extracting
                 archive, nor is it possible to save a split zip file to a stream. When
                 saving to a SFX or to a Stream, this property is ignored.
               </para>
            
               <para>
                 About interoperability: Split or spanned zip files produced by DotNetZip
                 can be read by WinZip or PKZip, and vice-versa. Segmented zip files may
                 not be readable by other tools, if those other tools don't support zip
                 spanning or splitting.  When in doubt, test.  I don't believe Windows
                 Explorer can extract a split archive.
               </para>
            
               <para>
                 This property has no effect when reading a split archive. You can read
                 a split archive in the normal way with DotNetZip.
               </para>
            
               <para>
                 When saving a zip file, if you want a regular zip file rather than a
                 split zip file, don't set this property, or set it to Zero.
               </para>
            
               <para>
                 If you read a split archive, with <see cref="M:Ionic.Zip.ZipFile.Read(System.String)"/> and
                 then subsequently call <c>ZipFile.Save()</c>, unless you set this
                 property before calling <c>Save()</c>, you will get a normal,
                 single-file archive.
               </para>
             </remarks>
            
             <seealso cref="P:Ionic.Zip.ZipFile.NumberOfSegmentsForMostRecentSave"/>
        </member>
        <member name="P:Ionic.Zip.ZipFile.NumberOfSegmentsForMostRecentSave">
            <summary>
              Returns the number of segments used in the most recent Save() operation.
            </summary>
            <remarks>
              <para>
                This is normally zero, unless you have set the <see
                cref="P:Ionic.Zip.ZipFile.MaxOutputSegmentSize"/> property.  If you have set <see
                cref="P:Ionic.Zip.ZipFile.MaxOutputSegmentSize"/>, and then you save a file, after the call to
                Save() completes, you can read this value to learn the number of segments that
                were created.
              </para>
              <para>
                If you call Save("Archive.zip"), and it creates 5 segments, then you
                will have filesystem files named Archive.z01, Archive.z02, Archive.z03,
                Archive.z04, and Archive.zip, and the value of this property will be 5.
              </para>
            </remarks>
            <seealso cref="P:Ionic.Zip.ZipFile.MaxOutputSegmentSize"/>
        </member>
        <member name="P:Ionic.Zip.ZipFile.ParallelDeflateThreshold">
             <summary>
               The size threshold for an entry, above which a parallel deflate is used.
             </summary>
            
             <remarks>
            
               <para>
                 DotNetZip will use multiple threads to compress any ZipEntry,
                 if the entry is larger than the given size.  Zero means "always
                 use parallel deflate", while -1 means "never use parallel
                 deflate". The default value for this property is 512k. Aside
                 from the special values of 0 and 1, the minimum value is 65536.
               </para>
            
               <para>
                 If the entry size cannot be known before compression, as with a
                 read-forward stream, then Parallel deflate will never be
                 performed, unless the value of this property is zero.
               </para>
            
               <para>
                 A parallel deflate operations will speed up the compression of
                 large files, on computers with multiple CPUs or multiple CPU
                 cores.  For files above 1mb, on a dual core or dual-cpu (2p)
                 machine, the time required to compress the file can be 70% of the
                 single-threaded deflate.  For very large files on 4p machines the
                 compression can be done in 30% of the normal time.  The downside
                 is that parallel deflate consumes extra memory during the deflate,
                 and the deflation is not as effective.
               </para>
            
               <para>
                 Parallel deflate tends to yield slightly less compression when
                 compared to as single-threaded deflate; this is because the original
                 data stream is split into multiple independent buffers, each of which
                 is compressed in parallel.  But because they are treated
                 independently, there is no opportunity to share compression
                 dictionaries.  For that reason, a deflated stream may be slightly
                 larger when compressed using parallel deflate, as compared to a
                 traditional single-threaded deflate. Sometimes the increase over the
                 normal deflate is as much as 5% of the total compressed size. For
                 larger files it can be as small as 0.1%.
               </para>
            
               <para>
                 Multi-threaded compression does not give as much an advantage when
                 using Encryption. This is primarily because encryption tends to slow
                 down the entire pipeline. Also, multi-threaded compression gives less
                 of an advantage when using lower compression levels, for example <see
                 cref="F:Ionic.Zlib.CompressionLevel.BestSpeed"/>.  You may have to
                 perform some tests to determine the best approach for your situation.
               </para>
            
             </remarks>
            
             <seealso cref="P:Ionic.Zip.ZipFile.ParallelDeflateMaxBufferPairs"/>
            
        </member>
        <member name="P:Ionic.Zip.ZipFile.ParallelDeflateMaxBufferPairs">
             <summary>
               The maximum number of buffer pairs to use when performing
               parallel compression.
             </summary>
            
             <remarks>
             <para>
               This property sets an upper limit on the number of memory
               buffer pairs to create when performing parallel
               compression.  The implementation of the parallel
               compression stream allocates multiple buffers to
               facilitate parallel compression.  As each buffer fills up,
               the stream uses <see
               cref="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)">
               ThreadPool.QueueUserWorkItem()</see> to compress those
               buffers in a background threadpool thread. After a buffer
               is compressed, it is re-ordered and written to the output
               stream.
             </para>
            
             <para>
               A higher number of buffer pairs enables a higher degree of
               parallelism, which tends to increase the speed of compression on
               multi-cpu computers.  On the other hand, a higher number of buffer
               pairs also implies a larger memory consumption, more active worker
               threads, and a higher cpu utilization for any compression. This
               property enables the application to limit its memory consumption and
               CPU utilization behavior depending on requirements.
             </para>
            
             <para>
               For each compression "task" that occurs in parallel, there are 2
               buffers allocated: one for input and one for output.  This property
               sets a limit for the number of pairs.  The total amount of storage
               space allocated for buffering will then be (N*S*2), where N is the
               number of buffer pairs, S is the size of each buffer (<see
               cref="P:Ionic.Zip.ZipFile.BufferSize"/>).  By default, DotNetZip allocates 4 buffer
               pairs per CPU core, so if your machine has 4 cores, and you retain
               the default buffer size of 128k, then the
               ParallelDeflateOutputStream will use 4 * 4 * 2 * 128kb of buffer
               memory in total, or 4mb, in blocks of 128kb.  If you then set this
               property to 8, then the number will be 8 * 2 * 128kb of buffer
               memory, or 2mb.
             </para>
            
             <para>
               CPU utilization will also go up with additional buffers, because a
               larger number of buffer pairs allows a larger number of background
               threads to compress in parallel. If you find that parallel
               compression is consuming too much memory or CPU, you can adjust this
               value downward.
             </para>
            
             <para>
               The default value is 16. Different values may deliver better or
               worse results, depending on your priorities and the dynamic
               performance characteristics of your storage and compute resources.
             </para>
            
             <para>
               This property is not the number of buffer pairs to use; it is an
               upper limit. An illustration: Suppose you have an application that
               uses the default value of this property (which is 16), and it runs
               on a machine with 2 CPU cores. In that case, DotNetZip will allocate
               4 buffer pairs per CPU core, for a total of 8 pairs.  The upper
               limit specified by this property has no effect.
             </para>
            
             <para>
               The application can set this value at any time
               before calling <c>ZipFile.Save()</c>.
             </para>
             </remarks>
            
             <seealso cref="P:Ionic.Zip.ZipFile.ParallelDeflateThreshold"/>
            
        </member>
        <member name="M:Ionic.Zip.ZipFile.ToString">
            <summary>Provides a string representation of the instance.</summary>
            <returns>a string representation of the instance.</returns>
        </member>
        <member name="P:Ionic.Zip.ZipFile.LibraryVersion">
             <summary>
             Returns the version number on the DotNetZip assembly.
             </summary>
            
             <remarks>
               <para>
                 This property is exposed as a convenience.  Callers could also get the
                 version value by retrieving GetName().Version on the
                 System.Reflection.Assembly object pointing to the DotNetZip
                 assembly. But sometimes it is not clear which assembly is being loaded.
                 This property makes it clear.
               </para>
               <para>
                 This static property is primarily useful for diagnostic purposes.
               </para>
             </remarks>
        </member>
        <member name="M:Ionic.Zip.ZipFile.#ctor(System.String)">
             <summary>
               Creates a new <c>ZipFile</c> instance, using the specified filename.
             </summary>
            
             <remarks>
             <para>
               Applications can use this constructor to create a new ZipFile for writing,
               or to slurp in an existing zip archive for read and update purposes.
             </para>
            
             <para>
               To create a new zip archive, an application can call this constructor,
               passing the name of a file that does not exist.  The name may be a fully
               qualified path. Then the application can add directories or files to the
               <c>ZipFile</c> via <c>AddDirectory()</c>, <c>AddFile()</c>, <c>AddItem()</c>
               and then write the zip archive to the disk by calling <c>Save()</c>. The
               zip file is not actually opened and written to the disk until the
               application calls <c>ZipFile.Save()</c>.  At that point the new zip file
               with the given name is created.
             </para>
            
             <para>
               If you won't know the name of the <c>Zipfile</c> until the time you call
               <c>ZipFile.Save()</c>, or if you plan to save to a stream (which has no
               name), then you should use the no-argument constructor.
             </para>
            
             <para>
               The application can also call this constructor to read an existing zip
               archive.  passing the name of a valid zip file that does exist. But, it's
               better form to use the static <see cref="M:Ionic.Zip.ZipFile.Read(System.String)"/> method,
               passing the name of the zip file, because using <c>ZipFile.Read()</c> in
               your code communicates very clearly what you are doing.  In either case,
               the file is then read into the <c>ZipFile</c> instance.  The app can then
               enumerate the entries or can modify the zip file, for example adding
               entries, removing entries, changing comments, and so on.
             </para>
            
             <para>
               One advantage to this parameterized constructor: it allows applications to
               use the same code to add items to a zip archive, regardless of whether the
               zip file exists.
             </para>
            
             <para>
               Instances of the <c>ZipFile</c> class are not multi-thread safe.  You may
               not party on a single instance with multiple threads.  You may have
               multiple threads that each use a distinct <c>ZipFile</c> instance, or you
               can synchronize multi-thread access to a single instance.
             </para>
            
             <para>
               By the way, since DotNetZip is so easy to use, don't you think <see
               href="http://cheeso.members.winisp.net/DotNetZipDonate.aspx">you should
               donate $5 or $10</see>?
             </para>
            
             </remarks>
            
             <exception cref="T:Ionic.Zip.ZipException">
             Thrown if name refers to an existing file that is not a valid zip file.
             </exception>
            
             <example>
             This example shows how to create a zipfile, and add a few files into it.
             <code>
             String ZipFileToCreate = "archive1.zip";
             String DirectoryToZip  = "c:\\reports";
             using (ZipFile zip = new ZipFile())
             {
               // Store all files found in the top level directory, into the zip archive.
               String[] filenames = System.IO.Directory.GetFiles(DirectoryToZip);
               zip.AddFiles(filenames, "files");
               zip.Save(ZipFileToCreate);
             }
             </code>
            
             <code lang="VB">
             Dim ZipFileToCreate As String = "archive1.zip"
             Dim DirectoryToZip As String = "c:\reports"
             Using zip As ZipFile = New ZipFile()
                 Dim filenames As String() = System.IO.Directory.GetFiles(DirectoryToZip)
                 zip.AddFiles(filenames, "files")
                 zip.Save(ZipFileToCreate)
             End Using
             </code>
             </example>
            
             <param name="fileName">The filename to use for the new zip archive.</param>
            
        </member>
        <member name="M:Ionic.Zip.ZipFile.#ctor(System.String,System.Text.Encoding)">
             <summary>
               Creates a new <c>ZipFile</c> instance, using the specified name for the
               filename, and the specified Encoding.
             </summary>
            
             <remarks>
             <para>
               See the documentation on the <see cref="M:Ionic.Zip.ZipFile.#ctor(System.String)">ZipFile
               constructor that accepts a single string argument</see> for basic
               information on all the <c>ZipFile</c> constructors.
             </para>
            
             <para>
               The Encoding is used as the default alternate encoding for entries with
               filenames or comments that cannot be encoded with the IBM437 code page.
               This is equivalent to setting the <see
               cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/> property on the <c>ZipFile</c>
               instance after construction.
             </para>
            
             <para>
               Instances of the <c>ZipFile</c> class are not multi-thread safe.  You may
               not party on a single instance with multiple threads.  You may have
               multiple threads that each use a distinct <c>ZipFile</c> instance, or you
               can synchronize multi-thread access to a single instance.
             </para>
            
             </remarks>
            
             <exception cref="T:Ionic.Zip.ZipException">
             Thrown if name refers to an existing file that is not a valid zip file.
             </exception>
            
             <param name="fileName">The filename to use for the new zip archive.</param>
             <param name="encoding">The Encoding is used as the default alternate
             encoding for entries with filenames or comments that cannot be encoded
             with the IBM437 code page. </param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.#ctor">
             <summary>
               Create a zip file, without specifying a target filename or stream to save to.
             </summary>
            
             <remarks>
             <para>
               See the documentation on the <see cref="M:Ionic.Zip.ZipFile.#ctor(System.String)">ZipFile
               constructor that accepts a single string argument</see> for basic
               information on all the <c>ZipFile</c> constructors.
             </para>
            
             <para>
               After instantiating with this constructor and adding entries to the
               archive, the application should call <see cref="M:Ionic.Zip.ZipFile.Save(System.String)"/> or
               <see cref="M:Ionic.Zip.ZipFile.Save(System.IO.Stream)"/> to save to a file or a
               stream, respectively.  The application can also set the <see cref="P:Ionic.Zip.ZipFile.Name"/>
               property and then call the no-argument <see cref="M:Ionic.Zip.ZipFile.Save"/> method.  (This
               is the preferred approach for applications that use the library through
               COM interop.)  If you call the no-argument <see cref="M:Ionic.Zip.ZipFile.Save"/> method
               without having set the <c>Name</c> of the <c>ZipFile</c>, either through
               the parameterized constructor or through the explicit property , the
               Save() will throw, because there is no place to save the file.  </para>
            
             <para>
               Instances of the <c>ZipFile</c> class are not multi-thread safe.  You may
               have multiple threads that each use a distinct <c>ZipFile</c> instance, or
               you can synchronize multi-thread access to a single instance.  </para>
            
             </remarks>
            
             <example>
             This example creates a Zip archive called Backup.zip, containing all the files
             in the directory DirectoryToZip. Files within subdirectories are not zipped up.
             <code>
             using (ZipFile zip = new ZipFile())
             {
               // Store all files found in the top level directory, into the zip archive.
               // note: this code does not recurse subdirectories!
               String[] filenames = System.IO.Directory.GetFiles(DirectoryToZip);
               zip.AddFiles(filenames, "files");
               zip.Save("Backup.zip");
             }
             </code>
            
             <code lang="VB">
             Using zip As New ZipFile
                 ' Store all files found in the top level directory, into the zip archive.
                 ' note: this code does not recurse subdirectories!
                 Dim filenames As String() = System.IO.Directory.GetFiles(DirectoryToZip)
                 zip.AddFiles(filenames, "files")
                 zip.Save("Backup.zip")
             End Using
             </code>
             </example>
        </member>
        <member name="M:Ionic.Zip.ZipFile.#ctor(System.Text.Encoding)">
             <summary>
               Create a zip file, specifying a text Encoding, but without specifying a
               target filename or stream to save to.
             </summary>
            
             <remarks>
             <para>
               See the documentation on the <see cref="M:Ionic.Zip.ZipFile.#ctor(System.String)">ZipFile
               constructor that accepts a single string argument</see> for basic
               information on all the <c>ZipFile</c> constructors.
             </para>
            
             </remarks>
            
             <param name="encoding">
             The Encoding is used as the default alternate encoding for entries with
             filenames or comments that cannot be encoded with the IBM437 code page.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.#ctor(System.String,System.IO.TextWriter)">
             <summary>
               Creates a new <c>ZipFile</c> instance, using the specified name for the
               filename, and the specified status message writer.
             </summary>
            
             <remarks>
             <para>
               See the documentation on the <see cref="M:Ionic.Zip.ZipFile.#ctor(System.String)">ZipFile
               constructor that accepts a single string argument</see> for basic
               information on all the <c>ZipFile</c> constructors.
             </para>
            
             <para>
               This version of the constructor allows the caller to pass in a TextWriter,
               to which verbose messages will be written during extraction or creation of
               the zip archive.  A console application may wish to pass
               System.Console.Out to get messages on the Console. A graphical or headless
               application may wish to capture the messages in a different
               <c>TextWriter</c>, for example, a <c>StringWriter</c>, and then display
               the messages in a TextBox, or generate an audit log of ZipFile operations.
             </para>
            
             <para>
               To encrypt the data for the files added to the <c>ZipFile</c> instance,
               set the Password property after creating the <c>ZipFile</c> instance.
             </para>
            
             <para>
               Instances of the <c>ZipFile</c> class are not multi-thread safe.  You may
               not party on a single instance with multiple threads.  You may have
               multiple threads that each use a distinct <c>ZipFile</c> instance, or you
               can synchronize multi-thread access to a single instance.
             </para>
            
             </remarks>
            
             <exception cref="T:Ionic.Zip.ZipException">
             Thrown if name refers to an existing file that is not a valid zip file.
             </exception>
            
             <example>
             <code>
             using (ZipFile zip = new ZipFile("Backup.zip", Console.Out))
             {
               // Store all files found in the top level directory, into the zip archive.
               // note: this code does not recurse subdirectories!
               // Status messages will be written to Console.Out
               String[] filenames = System.IO.Directory.GetFiles(DirectoryToZip);
               zip.AddFiles(filenames);
               zip.Save();
             }
             </code>
            
             <code lang="VB">
             Using zip As New ZipFile("Backup.zip", Console.Out)
                 ' Store all files found in the top level directory, into the zip archive.
                 ' note: this code does not recurse subdirectories!
                 ' Status messages will be written to Console.Out
                 Dim filenames As String() = System.IO.Directory.GetFiles(DirectoryToZip)
                 zip.AddFiles(filenames)
                 zip.Save()
             End Using
             </code>
             </example>
            
             <param name="fileName">The filename to use for the new zip archive.</param>
             <param name="statusMessageWriter">A TextWriter to use for writing
             verbose status messages.</param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.#ctor(System.String,System.IO.TextWriter,System.Text.Encoding)">
             <summary>
               Creates a new <c>ZipFile</c> instance, using the specified name for the
               filename, the specified status message writer, and the specified Encoding.
             </summary>
            
             <remarks>
             <para>
               This constructor works like the <see cref="M:Ionic.Zip.ZipFile.#ctor(System.String)">ZipFile
               constructor that accepts a single string argument.</see> See that
               reference for detail on what this constructor does.
             </para>
            
             <para>
               This version of the constructor allows the caller to pass in a
               <c>TextWriter</c>, and an Encoding.  The <c>TextWriter</c> will collect
               verbose messages that are generated by the library during extraction or
               creation of the zip archive.  A console application may wish to pass
               <c>System.Console.Out</c> to get messages on the Console. A graphical or
               headless application may wish to capture the messages in a different
               <c>TextWriter</c>, for example, a <c>StringWriter</c>, and then display
               the messages in a <c>TextBox</c>, or generate an audit log of
               <c>ZipFile</c> operations.
             </para>
            
             <para>
               The <c>Encoding</c> is used as the default alternate encoding for entries
               with filenames or comments that cannot be encoded with the IBM437 code
               page.  This is a equivalent to setting the <see
               cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/> property on the <c>ZipFile</c>
               instance after construction.
             </para>
            
             <para>
               To encrypt the data for the files added to the <c>ZipFile</c> instance,
               set the <c>Password</c> property after creating the <c>ZipFile</c>
               instance.
             </para>
            
             <para>
               Instances of the <c>ZipFile</c> class are not multi-thread safe.  You may
               not party on a single instance with multiple threads.  You may have
               multiple threads that each use a distinct <c>ZipFile</c> instance, or you
               can synchronize multi-thread access to a single instance.
             </para>
            
             </remarks>
            
             <exception cref="T:Ionic.Zip.ZipException">
             Thrown if <c>fileName</c> refers to an existing file that is not a valid zip file.
             </exception>
            
             <param name="fileName">The filename to use for the new zip archive.</param>
             <param name="statusMessageWriter">A TextWriter to use for writing verbose
             status messages.</param>
             <param name="encoding">
             The Encoding is used as the default alternate encoding for entries with
             filenames or comments that cannot be encoded with the IBM437 code page.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.Initialize(System.String)">
             <summary>
               Initialize a <c>ZipFile</c> instance by reading in a zip file.
             </summary>
            
             <remarks>
            
             <para>
               This method is primarily useful from COM Automation environments, when
               reading or extracting zip files. In COM, it is not possible to invoke
               parameterized constructors for a class. A COM Automation application can
               update a zip file by using the <see cref="M:Ionic.Zip.ZipFile.#ctor">default (no argument)
               constructor</see>, then calling <c>Initialize()</c> to read the contents
               of an on-disk zip archive into the <c>ZipFile</c> instance.
             </para>
            
             <para>
               .NET applications are encouraged to use the <c>ZipFile.Read()</c> methods
               for better clarity.
             </para>
            
             </remarks>
             <param name="fileName">the name of the existing zip file to read in.</param>
        </member>
        <member name="P:Ionic.Zip.ZipFile.Item(System.Int32)">
             <summary>
               This is an integer indexer into the Zip archive.
             </summary>
            
             <remarks>
             <para>
               This property is read-only.
             </para>
            
             <para>
               Internally, the <c>ZipEntry</c> instances that belong to the
               <c>ZipFile</c> are stored in a Dictionary.  When you use this
               indexer the first time, it creates a read-only
               <c>List&lt;ZipEntry&gt;</c> from the Dictionary.Values Collection.
               If at any time you modify the set of entries in the <c>ZipFile</c>,
               either by adding an entry, removing an entry, or renaming an
               entry, a new List will be created, and the numeric indexes for the
               remaining entries may be different.
             </para>
            
             <para>
               This means you cannot rename any ZipEntry from
               inside an enumeration of the zip file.
             </para>
            
             <param name="ix">
               The index value.
             </param>
            
             </remarks>
            
             <returns>
               The <c>ZipEntry</c> within the Zip archive at the specified index. If the
               entry does not exist in the archive, this indexer throws.
             </returns>
            
        </member>
        <member name="P:Ionic.Zip.ZipFile.Item(System.String)">
             <summary>
               This is a name-based indexer into the Zip archive.
             </summary>
            
             <remarks>
             <para>
               This property is read-only.
             </para>
            
             <para>
               The <see cref="P:Ionic.Zip.ZipFile.CaseSensitiveRetrieval"/> property on the <c>ZipFile</c>
               determines whether retrieval via this indexer is done via case-sensitive
               comparisons. By default, retrieval is not case sensitive.  This makes
               sense on Windows, in which filesystems are not case sensitive.
             </para>
            
             <para>
               Regardless of case-sensitivity, it is not always the case that
               <c>this[value].FileName == value</c>. In other words, the <c>FileName</c>
               property of the <c>ZipEntry</c> retrieved with this indexer, may or may
               not be equal to the index value.
             </para>
            
             <para>
               This is because DotNetZip performs a normalization of filenames passed to
               this indexer, before attempting to retrieve the item.  That normalization
               includes: removal of a volume letter and colon, swapping backward slashes
               for forward slashes.  So, <c>zip["dir1\\entry1.txt"].FileName ==
               "dir1/entry.txt"</c>.
             </para>
            
             <para>
               Directory entries in the zip file may be retrieved via this indexer only
               with names that have a trailing slash. DotNetZip automatically appends a
               trailing slash to the names of any directory entries added to a zip.
             </para>
            
             </remarks>
            
             <example>
             This example extracts only the entries in a zip file that are .txt files.
             <code>
             using (ZipFile zip = ZipFile.Read("PackedDocuments.zip"))
             {
               foreach (string s1 in zip.EntryFilenames)
               {
                 if (s1.EndsWith(".txt"))
                   zip[s1].Extract("textfiles");
               }
             }
             </code>
             <code lang="VB">
               Using zip As ZipFile = ZipFile.Read("PackedDocuments.zip")
                   Dim s1 As String
                   For Each s1 In zip.EntryFilenames
                       If s1.EndsWith(".txt") Then
                           zip(s1).Extract("textfiles")
                       End If
                   Next
               End Using
             </code>
             </example>
             <seealso cref="M:Ionic.Zip.ZipFile.RemoveEntry(System.String)"/>
            
             <exception cref="T:System.ArgumentException">
               Thrown if the caller attempts to assign a non-null value to the indexer.
             </exception>
            
             <param name="fileName">
               The name of the file, including any directory path, to retrieve from the
               zip.  The filename match is not case-sensitive by default; you can use the
               <see cref="P:Ionic.Zip.ZipFile.CaseSensitiveRetrieval"/> property to change this behavior. The
               pathname can use forward-slashes or backward slashes.
             </param>
            
             <returns>
               The <c>ZipEntry</c> within the Zip archive, given by the specified
               filename. If the named entry does not exist in the archive, this indexer
               returns <c>null</c> (<c>Nothing</c> in VB).
             </returns>
            
        </member>
        <member name="P:Ionic.Zip.ZipFile.EntryFileNames">
             <summary>
               The list of filenames for the entries contained within the zip archive.
             </summary>
            
             <remarks>
               According to the ZIP specification, the names of the entries use forward
               slashes in pathnames.  If you are scanning through the list, you may have
               to swap forward slashes for backslashes.
             </remarks>
            
             <seealso cref="P:Ionic.Zip.ZipFile.Item(System.String)"/>
            
             <example>
               This example shows one way to test if a filename is already contained
               within a zip archive.
             <code>
             String zipFileToRead= "PackedDocuments.zip";
             string candidate = "DatedMaterial.xps";
             using (ZipFile zip = new ZipFile(zipFileToRead))
             {
               if (zip.EntryFilenames.Contains(candidate))
                 Console.WriteLine("The file '{0}' exists in the zip archive '{1}'",
                                   candidate,
                                   zipFileName);
               else
                 Console.WriteLine("The file, '{0}', does not exist in the zip archive '{1}'",
                                   candidate,
                                   zipFileName);
               Console.WriteLine();
             }
             </code>
             <code lang="VB">
               Dim zipFileToRead As String = "PackedDocuments.zip"
               Dim candidate As String = "DatedMaterial.xps"
               Using zip As ZipFile.Read(ZipFileToRead)
                   If zip.EntryFilenames.Contains(candidate) Then
                       Console.WriteLine("The file '{0}' exists in the zip archive '{1}'", _
                                   candidate, _
                                   zipFileName)
                   Else
                     Console.WriteLine("The file, '{0}', does not exist in the zip archive '{1}'", _
                                   candidate, _
                                   zipFileName)
                   End If
                   Console.WriteLine
               End Using
             </code>
             </example>
            
             <returns>
               The list of strings for the filenames contained within the Zip archive.
             </returns>
            
        </member>
        <member name="P:Ionic.Zip.ZipFile.Entries">
             <summary>
               Returns the readonly collection of entries in the Zip archive.
             </summary>
            
             <remarks>
            
             <para>
               If there are no entries in the current <c>ZipFile</c>, the value returned is a
               non-null zero-element collection.  If there are entries in the zip file,
               the elements are returned in no particular order.
             </para>
             <para>
               This is the implied enumerator on the <c>ZipFile</c> class.  If you use a
               <c>ZipFile</c> instance in a context that expects an enumerator, you will
               get this collection.
             </para>
             </remarks>
             <seealso cref="P:Ionic.Zip.ZipFile.EntriesSorted"/>
        </member>
        <member name="P:Ionic.Zip.ZipFile.EntriesSorted">
             <summary>
               Returns a readonly collection of entries in the Zip archive, sorted by FileName.
             </summary>
            
             <remarks>
               If there are no entries in the current <c>ZipFile</c>, the value returned
               is a non-null zero-element collection.  If there are entries in the zip
               file, the elements are returned sorted by the name of the entry.
             </remarks>
            
             <example>
            
               This example fills a Windows Forms ListView with the entries in a zip file.
            
             <code lang="C#">
             using (ZipFile zip = ZipFile.Read(zipFile))
             {
                 foreach (ZipEntry entry in zip.EntriesSorted)
                 {
                     ListViewItem item = new ListViewItem(n.ToString());
                     n++;
                     string[] subitems = new string[] {
                         entry.FileName.Replace("/","\\"),
                         entry.LastModified.ToString("yyyy-MM-dd HH:mm:ss"),
                         entry.UncompressedSize.ToString(),
                         String.Format("{0,5:F0}%", entry.CompressionRatio),
                         entry.CompressedSize.ToString(),
                         (entry.UsesEncryption) ? "Y" : "N",
                         String.Format("{0:X8}", entry.Crc)};
            
                     foreach (String s in subitems)
                     {
                         ListViewItem.ListViewSubItem subitem = new ListViewItem.ListViewSubItem();
                         subitem.Text = s;
                         item.SubItems.Add(subitem);
                     }
            
                     this.listView1.Items.Add(item);
                 }
             }
             </code>
             </example>
            
             <seealso cref="P:Ionic.Zip.ZipFile.Entries"/>
        </member>
        <member name="P:Ionic.Zip.ZipFile.Count">
            <summary>
            Returns the number of entries in the Zip archive.
            </summary>
        </member>
        <member name="M:Ionic.Zip.ZipFile.RemoveEntry(Ionic.Zip.ZipEntry)">
             <summary>
               Removes the given <c>ZipEntry</c> from the zip archive.
             </summary>
            
             <remarks>
             <para>
               After calling <c>RemoveEntry</c>, the application must call <c>Save</c> to
               make the changes permanent.
             </para>
             </remarks>
            
             <exception cref="T:System.ArgumentException">
               Thrown if the specified <c>ZipEntry</c> does not exist in the <c>ZipFile</c>.
             </exception>
            
             <example>
               In this example, all entries in the zip archive dating from before
               December 31st, 2007, are removed from the archive.  This is actually much
               easier if you use the RemoveSelectedEntries method.  But I needed an
               example for RemoveEntry, so here it is.
             <code>
             String ZipFileToRead = "ArchiveToModify.zip";
             System.DateTime Threshold = new System.DateTime(2007,12,31);
             using (ZipFile zip = ZipFile.Read(ZipFileToRead))
             {
               var EntriesToRemove = new System.Collections.Generic.List&lt;ZipEntry&gt;();
               foreach (ZipEntry e in zip)
               {
                 if (e.LastModified &lt; Threshold)
                 {
                   // We cannot remove the entry from the list, within the context of
                   // an enumeration of said list.
                   // So we add the doomed entry to a list to be removed later.
                   EntriesToRemove.Add(e);
                 }
               }
            
               // actually remove the doomed entries.
               foreach (ZipEntry zombie in EntriesToRemove)
                 zip.RemoveEntry(zombie);
            
               zip.Comment= String.Format("This zip archive was updated at {0}.",
                                          System.DateTime.Now.ToString("G"));
            
               // save with a different name
               zip.Save("Archive-Updated.zip");
             }
             </code>
            
             <code lang="VB">
               Dim ZipFileToRead As String = "ArchiveToModify.zip"
               Dim Threshold As New DateTime(2007, 12, 31)
               Using zip As ZipFile = ZipFile.Read(ZipFileToRead)
                   Dim EntriesToRemove As New System.Collections.Generic.List(Of ZipEntry)
                   Dim e As ZipEntry
                   For Each e In zip
                       If (e.LastModified &lt; Threshold) Then
                           ' We cannot remove the entry from the list, within the context of
                           ' an enumeration of said list.
                           ' So we add the doomed entry to a list to be removed later.
                           EntriesToRemove.Add(e)
                       End If
                   Next
            
                   ' actually remove the doomed entries.
                   Dim zombie As ZipEntry
                   For Each zombie In EntriesToRemove
                       zip.RemoveEntry(zombie)
                   Next
                   zip.Comment = String.Format("This zip archive was updated at {0}.", DateTime.Now.ToString("G"))
                   'save as a different name
                   zip.Save("Archive-Updated.zip")
               End Using
             </code>
             </example>
            
             <param name="entry">
             The <c>ZipEntry</c> to remove from the zip.
             </param>
            
             <seealso cref="M:Ionic.Zip.ZipFile.RemoveSelectedEntries(System.String)"/>
            
        </member>
        <member name="M:Ionic.Zip.ZipFile.RemoveEntry(System.String)">
             <summary>
             Removes the <c>ZipEntry</c> with the given filename from the zip archive.
             </summary>
            
             <remarks>
             <para>
               After calling <c>RemoveEntry</c>, the application must call <c>Save</c> to
               make the changes permanent.
             </para>
            
             </remarks>
            
             <exception cref="T:System.InvalidOperationException">
               Thrown if the <c>ZipFile</c> is not updatable.
             </exception>
            
             <exception cref="T:System.ArgumentException">
               Thrown if a <c>ZipEntry</c> with the specified filename does not exist in
               the <c>ZipFile</c>.
             </exception>
            
             <example>
            
               This example shows one way to remove an entry with a given filename from
               an existing zip archive.
            
             <code>
             String zipFileToRead= "PackedDocuments.zip";
             string candidate = "DatedMaterial.xps";
             using (ZipFile zip = ZipFile.Read(zipFileToRead))
             {
               if (zip.EntryFilenames.Contains(candidate))
               {
                 zip.RemoveEntry(candidate);
                 zip.Comment= String.Format("The file '{0}' has been removed from this archive.",
                                            Candidate);
                 zip.Save();
               }
             }
             </code>
             <code lang="VB">
               Dim zipFileToRead As String = "PackedDocuments.zip"
               Dim candidate As String = "DatedMaterial.xps"
               Using zip As ZipFile = ZipFile.Read(zipFileToRead)
                   If zip.EntryFilenames.Contains(candidate) Then
                       zip.RemoveEntry(candidate)
                       zip.Comment = String.Format("The file '{0}' has been removed from this archive.", Candidate)
                       zip.Save
                   End If
               End Using
             </code>
             </example>
            
             <param name="fileName">
             The name of the file, including any directory path, to remove from the zip.
             The filename match is not case-sensitive by default; you can use the
             <c>CaseSensitiveRetrieval</c> property to change this behavior. The
             pathname can use forward-slashes or backward slashes.
             </param>
            
        </member>
        <member name="M:Ionic.Zip.ZipFile.Dispose">
             <summary>
               Closes the read and write streams associated
               to the <c>ZipFile</c>, if necessary.
             </summary>
            
             <remarks>
               The Dispose() method is generally employed implicitly, via a <c>using(..) {..}</c>
               statement. (<c>Using...End Using</c> in VB) If you do not employ a using
               statement, insure that your application calls Dispose() explicitly.  For
               example, in a Powershell application, or an application that uses the COM
               interop interface, you must call Dispose() explicitly.
             </remarks>
            
             <example>
             This example extracts an entry selected by name, from the Zip file to the
             Console.
             <code>
             using (ZipFile zip = ZipFile.Read(zipfile))
             {
               foreach (ZipEntry e in zip)
               {
                 if (WantThisEntry(e.FileName))
                   zip.Extract(e.FileName, Console.OpenStandardOutput());
               }
             } // Dispose() is called implicitly here.
             </code>
            
             <code lang="VB">
             Using zip As ZipFile = ZipFile.Read(zipfile)
                 Dim e As ZipEntry
                 For Each e In zip
                   If WantThisEntry(e.FileName) Then
                       zip.Extract(e.FileName, Console.OpenStandardOutput())
                   End If
                 Next
             End Using ' Dispose is implicity called here
             </code>
             </example>
        </member>
        <member name="M:Ionic.Zip.ZipFile.Dispose(System.Boolean)">
             <summary>
               Disposes any managed resources, if the flag is set, then marks the
               instance disposed.  This method is typically not called explicitly from
               application code.
             </summary>
            
             <remarks>
               Applications should call <see cref="M:Ionic.Zip.ZipFile.Dispose">the no-arg Dispose method</see>.
             </remarks>
            
             <param name="disposeManagedResources">
               indicates whether the method should dispose streams or not.
             </param>
        </member>
        <member name="F:Ionic.Zip.ZipFile.BufferSizeDefault">
            <summary>
              Default size of the buffer used for IO.
            </summary>
        </member>
        <member name="E:Ionic.Zip.ZipFile.SaveProgress">
             <summary>
               An event handler invoked when a Save() starts, before and after each
               entry has been written to the archive, when a Save() completes, and
               during other Save events.
             </summary>
            
             <remarks>
             <para>
               Depending on the particular event, different properties on the <see
               cref="T:Ionic.Zip.SaveProgressEventArgs"/> parameter are set.  The following
               table summarizes the available EventTypes and the conditions under
               which this event handler is invoked with a
               <c>SaveProgressEventArgs</c> with the given EventType.
             </para>
            
             <list type="table">
             <listheader>
             <term>value of EntryType</term>
             <description>Meaning and conditions</description>
             </listheader>
            
             <item>
             <term>ZipProgressEventType.Saving_Started</term>
             <description>Fired when ZipFile.Save() begins.
             </description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Saving_BeforeSaveEntry</term>
             <description>
               Fired within ZipFile.Save(), just before writing data for each
               particular entry.
             </description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Saving_AfterSaveEntry</term>
             <description>
               Fired within ZipFile.Save(), just after having finished writing data
               for each particular entry.
             </description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Saving_Completed</term>
             <description>Fired when ZipFile.Save() has completed.
             </description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Saving_AfterSaveTempArchive</term>
             <description>
               Fired after the temporary file has been created.  This happens only
               when saving to a disk file.  This event will not be invoked when
               saving to a stream.
             </description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Saving_BeforeRenameTempArchive</term>
             <description>
               Fired just before renaming the temporary file to the permanent
               location.  This happens only when saving to a disk file.  This event
               will not be invoked when saving to a stream.
             </description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Saving_AfterRenameTempArchive</term>
             <description>
               Fired just after renaming the temporary file to the permanent
               location.  This happens only when saving to a disk file.  This event
               will not be invoked when saving to a stream.
             </description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Saving_AfterCompileSelfExtractor</term>
             <description>
               Fired after a self-extracting archive has finished compiling.  This
               EventType is used only within SaveSelfExtractor().
             </description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Saving_BytesRead</term>
             <description>
               Set during the save of a particular entry, to update progress of the
               Save().  When this EventType is set, the BytesTransferred is the
               number of bytes that have been read from the source stream.  The
               TotalBytesToTransfer is the number of bytes in the uncompressed
               file.
             </description>
             </item>
            
             </list>
             </remarks>
            
             <example>
            
                This example uses an anonymous method to handle the
                SaveProgress event, by updating a progress bar.
            
             <code lang="C#">
             progressBar1.Value = 0;
             progressBar1.Max = listbox1.Items.Count;
             using (ZipFile zip = new ZipFile())
             {
                // listbox1 contains a list of filenames
                zip.AddFiles(listbox1.Items);
            
                // do the progress bar:
                zip.SaveProgress += (sender, e) => {
                   if (e.EventType == ZipProgressEventType.Saving_BeforeWriteEntry) {
                      progressBar1.PerformStep();
                   }
                };
            
                zip.Save(fs);
             }
             </code>
             </example>
            
             <example>
               This example uses a named method as the
               <c>SaveProgress</c> event handler, to update the user, in a
               console-based application.
            
             <code lang="C#">
             static bool justHadByteUpdate= false;
             public static void SaveProgress(object sender, SaveProgressEventArgs e)
             {
                 if (e.EventType == ZipProgressEventType.Saving_Started)
                     Console.WriteLine("Saving: {0}", e.ArchiveName);
            
                 else if (e.EventType == ZipProgressEventType.Saving_Completed)
                 {
                     justHadByteUpdate= false;
                     Console.WriteLine();
                     Console.WriteLine("Done: {0}", e.ArchiveName);
                 }
            
                 else if (e.EventType == ZipProgressEventType.Saving_BeforeWriteEntry)
                 {
                     if (justHadByteUpdate)
                         Console.WriteLine();
                     Console.WriteLine("  Writing: {0} ({1}/{2})",
                                       e.CurrentEntry.FileName, e.EntriesSaved, e.EntriesTotal);
                     justHadByteUpdate= false;
                 }
            
                 else if (e.EventType == ZipProgressEventType.Saving_EntryBytesRead)
                 {
                     if (justHadByteUpdate)
                         Console.SetCursorPosition(0, Console.CursorTop);
                      Console.Write("     {0}/{1} ({2:N0}%)", e.BytesTransferred, e.TotalBytesToTransfer,
                                   e.BytesTransferred / (0.01 * e.TotalBytesToTransfer ));
                     justHadByteUpdate= true;
                 }
             }
            
             public static ZipUp(string targetZip, string directory)
             {
               using (var zip = new ZipFile()) {
                 zip.SaveProgress += SaveProgress;
                 zip.AddDirectory(directory);
                 zip.Save(targetZip);
               }
             }
            
             </code>
            
             <code lang="VB">
             Public Sub ZipUp(ByVal targetZip As String, ByVal directory As String)
                 Using zip As ZipFile = New ZipFile
                     AddHandler zip.SaveProgress, AddressOf MySaveProgress
                     zip.AddDirectory(directory)
                     zip.Save(targetZip)
                 End Using
             End Sub
            
             Private Shared justHadByteUpdate As Boolean = False
            
             Public Shared Sub MySaveProgress(ByVal sender As Object, ByVal e As SaveProgressEventArgs)
                 If (e.EventType Is ZipProgressEventType.Saving_Started) Then
                     Console.WriteLine("Saving: {0}", e.ArchiveName)
            
                 ElseIf (e.EventType Is ZipProgressEventType.Saving_Completed) Then
                     justHadByteUpdate = False
                     Console.WriteLine
                     Console.WriteLine("Done: {0}", e.ArchiveName)
            
                 ElseIf (e.EventType Is ZipProgressEventType.Saving_BeforeWriteEntry) Then
                     If justHadByteUpdate Then
                         Console.WriteLine
                     End If
                     Console.WriteLine("  Writing: {0} ({1}/{2})", e.CurrentEntry.FileName, e.EntriesSaved, e.EntriesTotal)
                     justHadByteUpdate = False
            
                 ElseIf (e.EventType Is ZipProgressEventType.Saving_EntryBytesRead) Then
                     If justHadByteUpdate Then
                         Console.SetCursorPosition(0, Console.CursorTop)
                     End If
                     Console.Write("     {0}/{1} ({2:N0}%)", e.BytesTransferred, _
                                   e.TotalBytesToTransfer, _
                                   (CDbl(e.BytesTransferred) / (0.01 * e.TotalBytesToTransfer)))
                     justHadByteUpdate = True
                 End If
             End Sub
             </code>
             </example>
            
             <example>
            
             This is a more complete example of using the SaveProgress
             events in a Windows Forms application, with a
             Thread object.
            
             <code lang="C#">
             delegate void SaveEntryProgress(SaveProgressEventArgs e);
             delegate void ButtonClick(object sender, EventArgs e);
            
             public class WorkerOptions
             {
                 public string ZipName;
                 public string Folder;
                 public string Encoding;
                 public string Comment;
                 public int ZipFlavor;
                 public Zip64Option Zip64;
             }
            
             private int _progress2MaxFactor;
             private bool _saveCanceled;
             private long _totalBytesBeforeCompress;
             private long _totalBytesAfterCompress;
             private Thread _workerThread;
            
            
             private void btnZipup_Click(object sender, EventArgs e)
             {
                 KickoffZipup();
             }
            
             private void btnCancel_Click(object sender, EventArgs e)
             {
                 if (this.lblStatus.InvokeRequired)
                 {
                     this.lblStatus.Invoke(new ButtonClick(this.btnCancel_Click), new object[] { sender, e });
                 }
                 else
                 {
                     _saveCanceled = true;
                     lblStatus.Text = "Canceled...";
                     ResetState();
                 }
             }
            
             private void KickoffZipup()
             {
                 _folderName = tbDirName.Text;
            
                 if (_folderName == null || _folderName == "") return;
                 if (this.tbZipName.Text == null || this.tbZipName.Text == "") return;
            
                 // check for existence of the zip file:
                 if (System.IO.File.Exists(this.tbZipName.Text))
                 {
                     var dlgResult = MessageBox.Show(String.Format("The file you have specified ({0}) already exists." +
                                                                   "  Do you want to overwrite this file?", this.tbZipName.Text),
                                                     "Confirmation is Required", MessageBoxButtons.YesNo, MessageBoxIcon.Question);
                     if (dlgResult != DialogResult.Yes) return;
                     System.IO.File.Delete(this.tbZipName.Text);
                 }
            
                  _saveCanceled = false;
                 _nFilesCompleted = 0;
                 _totalBytesAfterCompress = 0;
                 _totalBytesBeforeCompress = 0;
                 this.btnOk.Enabled = false;
                 this.btnOk.Text = "Zipping...";
                 this.btnCancel.Enabled = true;
                 lblStatus.Text = "Zipping...";
            
                 var options = new WorkerOptions
                 {
                     ZipName = this.tbZipName.Text,
                     Folder = _folderName,
                     Encoding = "ibm437"
                 };
            
                 if (this.comboBox1.SelectedIndex != 0)
                 {
                     options.Encoding = this.comboBox1.SelectedItem.ToString();
                 }
            
                 if (this.radioFlavorSfxCmd.Checked)
                     options.ZipFlavor = 2;
                 else if (this.radioFlavorSfxGui.Checked)
                     options.ZipFlavor = 1;
                 else options.ZipFlavor = 0;
            
                 if (this.radioZip64AsNecessary.Checked)
                     options.Zip64 = Zip64Option.AsNecessary;
                 else if (this.radioZip64Always.Checked)
                     options.Zip64 = Zip64Option.Always;
                 else options.Zip64 = Zip64Option.Never;
            
                 options.Comment = String.Format("Encoding:{0} || Flavor:{1} || ZIP64:{2}\r\nCreated at {3} || {4}\r\n",
                             options.Encoding,
                             FlavorToString(options.ZipFlavor),
                             options.Zip64.ToString(),
                             System.DateTime.Now.ToString("yyyy-MMM-dd HH:mm:ss"),
                             this.Text);
            
                 if (this.tbComment.Text != TB_COMMENT_NOTE)
                     options.Comment += this.tbComment.Text;
            
                 _workerThread = new Thread(this.DoSave);
                 _workerThread.Name = "Zip Saver thread";
                 _workerThread.Start(options);
                 this.Cursor = Cursors.WaitCursor;
              }
            
            
             private void DoSave(Object p)
             {
                 WorkerOptions options = p as WorkerOptions;
                 try
                 {
                     using (var zip1 = new ZipFile())
                     {
                         zip1.ProvisionalAlternateEncoding = System.Text.Encoding.GetEncoding(options.Encoding);
                         zip1.Comment = options.Comment;
                         zip1.AddDirectory(options.Folder);
                         _entriesToZip = zip1.EntryFileNames.Count;
                         SetProgressBars();
                         zip1.SaveProgress += this.zip1_SaveProgress;
            
                         zip1.UseZip64WhenSaving = options.Zip64;
            
                         if (options.ZipFlavor == 1)
                             zip1.SaveSelfExtractor(options.ZipName, SelfExtractorFlavor.WinFormsApplication);
                         else if (options.ZipFlavor == 2)
                             zip1.SaveSelfExtractor(options.ZipName, SelfExtractorFlavor.ConsoleApplication);
                         else
                             zip1.Save(options.ZipName);
                     }
                 }
                 catch (System.Exception exc1)
                 {
                     MessageBox.Show(String.Format("Exception while zipping: {0}", exc1.Message));
                     btnCancel_Click(null, null);
                 }
             }
            
            
            
             void zip1_SaveProgress(object sender, SaveProgressEventArgs e)
             {
                 switch (e.EventType)
                 {
                     case ZipProgressEventType.Saving_AfterWriteEntry:
                         StepArchiveProgress(e);
                         break;
                     case ZipProgressEventType.Saving_EntryBytesRead:
                         StepEntryProgress(e);
                         break;
                     case ZipProgressEventType.Saving_Completed:
                         SaveCompleted();
                         break;
                     case ZipProgressEventType.Saving_AfterSaveTempArchive:
                         // this event only occurs when saving an SFX file
                         TempArchiveSaved();
                         break;
                 }
                 if (_saveCanceled)
                     e.Cancel = true;
             }
            
            
            
             private void StepArchiveProgress(SaveProgressEventArgs e)
             {
                 if (this.progressBar1.InvokeRequired)
                 {
                     this.progressBar1.Invoke(new SaveEntryProgress(this.StepArchiveProgress), new object[] { e });
                 }
                 else
                 {
                     if (!_saveCanceled)
                     {
                         _nFilesCompleted++;
                         this.progressBar1.PerformStep();
                         _totalBytesAfterCompress += e.CurrentEntry.CompressedSize;
                         _totalBytesBeforeCompress += e.CurrentEntry.UncompressedSize;
            
                         // reset the progress bar for the entry:
                         this.progressBar2.Value = this.progressBar2.Maximum = 1;
            
                         this.Update();
                     }
                 }
             }
            
            
             private void StepEntryProgress(SaveProgressEventArgs e)
             {
                 if (this.progressBar2.InvokeRequired)
                 {
                     this.progressBar2.Invoke(new SaveEntryProgress(this.StepEntryProgress), new object[] { e });
                 }
                 else
                 {
                     if (!_saveCanceled)
                     {
                         if (this.progressBar2.Maximum == 1)
                         {
                             // reset
                             Int64 max = e.TotalBytesToTransfer;
                             _progress2MaxFactor = 0;
                             while (max > System.Int32.MaxValue)
                             {
                                 max /= 2;
                                 _progress2MaxFactor++;
                             }
                             this.progressBar2.Maximum = (int)max;
                             lblStatus.Text = String.Format("{0} of {1} files...({2})",
                                 _nFilesCompleted + 1, _entriesToZip, e.CurrentEntry.FileName);
                         }
            
                          int xferred = e.BytesTransferred >> _progress2MaxFactor;
            
                          this.progressBar2.Value = (xferred >= this.progressBar2.Maximum)
                             ? this.progressBar2.Maximum
                             : xferred;
            
                          this.Update();
                     }
                 }
             }
            
             private void SaveCompleted()
             {
                 if (this.lblStatus.InvokeRequired)
                 {
                     this.lblStatus.Invoke(new MethodInvoker(this.SaveCompleted));
                 }
                 else
                 {
                     lblStatus.Text = String.Format("Done, Compressed {0} files, {1:N0}% of original.",
                         _nFilesCompleted, (100.00 * _totalBytesAfterCompress) / _totalBytesBeforeCompress);
                      ResetState();
                 }
             }
            
             private void ResetState()
             {
                 this.btnCancel.Enabled = false;
                 this.btnOk.Enabled = true;
                 this.btnOk.Text = "Zip it!";
                 this.progressBar1.Value = 0;
                 this.progressBar2.Value = 0;
                 this.Cursor = Cursors.Default;
                 if (!_workerThread.IsAlive)
                     _workerThread.Join();
             }
             </code>
            
             </example>
            
             <seealso cref="E:Ionic.Zip.ZipFile.ReadProgress"/>
             <seealso cref="E:Ionic.Zip.ZipFile.AddProgress"/>
             <seealso cref="E:Ionic.Zip.ZipFile.ExtractProgress"/>
        </member>
        <member name="E:Ionic.Zip.ZipFile.ReadProgress">
             <summary>
             An event handler invoked before, during, and after the reading of a zip archive.
             </summary>
            
             <remarks>
             <para>
             Depending on the particular event being signaled, different properties on the
             <see cref="T:Ionic.Zip.ReadProgressEventArgs"/> parameter are set.  The following table
             summarizes the available EventTypes and the conditions under which this
             event handler is invoked with a <c>ReadProgressEventArgs</c> with the given EventType.
             </para>
            
             <list type="table">
             <listheader>
             <term>value of EntryType</term>
             <description>Meaning and conditions</description>
             </listheader>
            
             <item>
             <term>ZipProgressEventType.Reading_Started</term>
             <description>Fired just as ZipFile.Read() begins. Meaningful properties: ArchiveName.
             </description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Reading_Completed</term>
             <description>Fired when ZipFile.Read() has completed. Meaningful properties: ArchiveName.
             </description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Reading_ArchiveBytesRead</term>
             <description>Fired while reading, updates the number of bytes read for the entire archive.
             Meaningful properties: ArchiveName, CurrentEntry, BytesTransferred, TotalBytesToTransfer.
             </description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Reading_BeforeReadEntry</term>
             <description>Indicates an entry is about to be read from the archive.
             Meaningful properties: ArchiveName, EntriesTotal.
             </description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Reading_AfterReadEntry</term>
             <description>Indicates an entry has just been read from the archive.
             Meaningful properties: ArchiveName, EntriesTotal, CurrentEntry.
             </description>
             </item>
            
             </list>
             </remarks>
            
             <seealso cref="E:Ionic.Zip.ZipFile.SaveProgress"/>
             <seealso cref="E:Ionic.Zip.ZipFile.AddProgress"/>
             <seealso cref="E:Ionic.Zip.ZipFile.ExtractProgress"/>
        </member>
        <member name="E:Ionic.Zip.ZipFile.ExtractProgress">
             <summary>
               An event handler invoked before, during, and after extraction of
               entries in the zip archive.
             </summary>
            
             <remarks>
             <para>
               Depending on the particular event, different properties on the <see
               cref="T:Ionic.Zip.ExtractProgressEventArgs"/> parameter are set.  The following
               table summarizes the available EventTypes and the conditions under
               which this event handler is invoked with a
               <c>ExtractProgressEventArgs</c> with the given EventType.
             </para>
            
             <list type="table">
             <listheader>
             <term>value of EntryType</term>
             <description>Meaning and conditions</description>
             </listheader>
            
             <item>
             <term>ZipProgressEventType.Extracting_BeforeExtractAll</term>
             <description>
               Set when ExtractAll() begins. The ArchiveName, Overwrite, and
               ExtractLocation properties are meaningful.</description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Extracting_AfterExtractAll</term>
             <description>
               Set when ExtractAll() has completed.  The ArchiveName, Overwrite,
               and ExtractLocation properties are meaningful.
             </description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Extracting_BeforeExtractEntry</term>
             <description>
               Set when an Extract() on an entry in the ZipFile has begun.
               Properties that are meaningful: ArchiveName, EntriesTotal,
               CurrentEntry, Overwrite, ExtractLocation, EntriesExtracted.
             </description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Extracting_AfterExtractEntry</term>
             <description>
               Set when an Extract() on an entry in the ZipFile has completed.
               Properties that are meaningful: ArchiveName, EntriesTotal,
               CurrentEntry, Overwrite, ExtractLocation, EntriesExtracted.
             </description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Extracting_EntryBytesWritten</term>
             <description>
               Set within a call to Extract() on an entry in the ZipFile, as data
               is extracted for the entry.  Properties that are meaningful:
               ArchiveName, CurrentEntry, BytesTransferred, TotalBytesToTransfer.
             </description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Extracting_ExtractEntryWouldOverwrite</term>
             <description>
               Set within a call to Extract() on an entry in the ZipFile, when the
               extraction would overwrite an existing file. This event type is used
               only when <c>ExtractExistingFileAction</c> on the <c>ZipFile</c> or
               <c>ZipEntry</c> is set to <c>InvokeExtractProgressEvent</c>.
             </description>
             </item>
            
             </list>
            
             </remarks>
            
             <example>
             <code>
             private static bool justHadByteUpdate = false;
             public static void ExtractProgress(object sender, ExtractProgressEventArgs e)
             {
               if(e.EventType == ZipProgressEventType.Extracting_EntryBytesWritten)
               {
                 if (justHadByteUpdate)
                   Console.SetCursorPosition(0, Console.CursorTop);
            
                 Console.Write("   {0}/{1} ({2:N0}%)", e.BytesTransferred, e.TotalBytesToTransfer,
                               e.BytesTransferred / (0.01 * e.TotalBytesToTransfer ));
                 justHadByteUpdate = true;
               }
               else if(e.EventType == ZipProgressEventType.Extracting_BeforeExtractEntry)
               {
                 if (justHadByteUpdate)
                   Console.WriteLine();
                 Console.WriteLine("Extracting: {0}", e.CurrentEntry.FileName);
                 justHadByteUpdate= false;
               }
             }
            
             public static ExtractZip(string zipToExtract, string directory)
             {
               string TargetDirectory= "extract";
               using (var zip = ZipFile.Read(zipToExtract)) {
                 zip.ExtractProgress += ExtractProgress;
                 foreach (var e in zip1)
                 {
                   e.Extract(TargetDirectory, true);
                 }
               }
             }
            
             </code>
             <code lang="VB">
             Public Shared Sub Main(ByVal args As String())
                 Dim ZipToUnpack As String = "C1P3SML.zip"
                 Dim TargetDir As String = "ExtractTest_Extract"
                 Console.WriteLine("Extracting file {0} to {1}", ZipToUnpack, TargetDir)
                 Using zip1 As ZipFile = ZipFile.Read(ZipToUnpack)
                     AddHandler zip1.ExtractProgress, AddressOf MyExtractProgress
                     Dim e As ZipEntry
                     For Each e In zip1
                         e.Extract(TargetDir, True)
                     Next
                 End Using
             End Sub
            
             Private Shared justHadByteUpdate As Boolean = False
            
             Public Shared Sub MyExtractProgress(ByVal sender As Object, ByVal e As ExtractProgressEventArgs)
                 If (e.EventType = ZipProgressEventType.Extracting_EntryBytesWritten) Then
                     If ExtractTest.justHadByteUpdate Then
                         Console.SetCursorPosition(0, Console.CursorTop)
                     End If
                     Console.Write("   {0}/{1} ({2:N0}%)", e.BytesTransferred, e.TotalBytesToTransfer, (CDbl(e.BytesTransferred) / (0.01 * e.TotalBytesToTransfer)))
                     ExtractTest.justHadByteUpdate = True
                 ElseIf (e.EventType = ZipProgressEventType.Extracting_BeforeExtractEntry) Then
                     If ExtractTest.justHadByteUpdate Then
                         Console.WriteLine
                     End If
                     Console.WriteLine("Extracting: {0}", e.CurrentEntry.FileName)
                     ExtractTest.justHadByteUpdate = False
                 End If
             End Sub
             </code>
             </example>
            
             <seealso cref="E:Ionic.Zip.ZipFile.SaveProgress"/>
             <seealso cref="E:Ionic.Zip.ZipFile.ReadProgress"/>
             <seealso cref="E:Ionic.Zip.ZipFile.AddProgress"/>
        </member>
        <member name="E:Ionic.Zip.ZipFile.AddProgress">
             <summary>
             An event handler invoked before, during, and after Adding entries to a zip archive.
             </summary>
            
             <remarks>
                 Adding a large number of entries to a zip file can take a long
                 time.  For example, when calling <see cref="M:Ionic.Zip.ZipFile.AddDirectory(System.String)"/> on a
                 directory that contains 50,000 files, it could take 3 minutes or so.
                 This event handler allws an application to track the progress of the Add
                 operation, and to optionally cancel a lengthy Add operation.
             </remarks>
            
             <example>
             <code lang="C#">
            
             int _numEntriesToAdd= 0;
             int _numEntriesAdded= 0;
             void AddProgressHandler(object sender, AddProgressEventArgs e)
             {
                 switch (e.EventType)
                 {
                     case ZipProgressEventType.Adding_Started:
                         Console.WriteLine("Adding files to the zip...");
                         break;
                     case ZipProgressEventType.Adding_AfterAddEntry:
                         _numEntriesAdded++;
                         Console.WriteLine(String.Format("Adding file {0}/{1} :: {2}",
                                                  _numEntriesAdded, _numEntriesToAdd, e.CurrentEntry.FileName));
                         break;
                     case ZipProgressEventType.Adding_Completed:
                         Console.WriteLine("Added all files");
                         break;
                 }
             }
            
             void CreateTheZip()
             {
                 using (ZipFile zip = new ZipFile())
                 {
                     zip.AddProgress += AddProgressHandler;
                     zip.AddDirectory(System.IO.Path.GetFileName(DirToZip));
                     zip.Save(ZipFileToCreate);
                 }
             }
            
             </code>
            
             <code lang="VB">
            
             Private Sub AddProgressHandler(ByVal sender As Object, ByVal e As AddProgressEventArgs)
                 Select Case e.EventType
                     Case ZipProgressEventType.Adding_Started
                         Console.WriteLine("Adding files to the zip...")
                         Exit Select
                     Case ZipProgressEventType.Adding_AfterAddEntry
                         Console.WriteLine(String.Format("Adding file {0}", e.CurrentEntry.FileName))
                         Exit Select
                     Case ZipProgressEventType.Adding_Completed
                         Console.WriteLine("Added all files")
                         Exit Select
                 End Select
             End Sub
            
             Sub CreateTheZip()
                 Using zip as ZipFile = New ZipFile
                     AddHandler zip.AddProgress, AddressOf AddProgressHandler
                     zip.AddDirectory(System.IO.Path.GetFileName(DirToZip))
                     zip.Save(ZipFileToCreate);
                 End Using
             End Sub
            
             </code>
            
             </example>
            
             <seealso cref="E:Ionic.Zip.ZipFile.SaveProgress"/>
             <seealso cref="E:Ionic.Zip.ZipFile.ReadProgress"/>
             <seealso cref="E:Ionic.Zip.ZipFile.ExtractProgress"/>
        </member>
        <member name="E:Ionic.Zip.ZipFile.ZipError">
             <summary>
             An event that is raised when an error occurs during open or read of files
             while saving a zip archive.
             </summary>
            
             <remarks>
              <para>
                 Errors can occur as a file is being saved to the zip archive.  For
                 example, the File.Open may fail, or a File.Read may fail, because of
                 lock conflicts or other reasons.  If you add a handler to this event,
                 you can handle such errors in your own code.  If you don't add a
                 handler, the library will throw an exception if it encounters an I/O
                 error during a call to <c>Save()</c>.
              </para>
            
              <para>
                Setting a handler implicitly sets <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/> to
                <c>ZipErrorAction.InvokeErrorEvent</c>.
              </para>
            
              <para>
                The handler you add applies to all <see cref="T:Ionic.Zip.ZipEntry"/> items that are
                subsequently added to the <c>ZipFile</c> instance. If you set this
                property after you have added items to the <c>ZipFile</c>, but before you
                have called <c>Save()</c>, errors that occur while saving those items
                will not cause the error handler to be invoked.
              </para>
            
              <para>
                If you want to handle any errors that occur with any entry in the zip
                file using the same error handler, then add your error handler once,
                before adding any entries to the zip archive.
              </para>
            
              <para>
                In the error handler method, you need to set the <see
                cref="P:Ionic.Zip.ZipEntry.ZipErrorAction"/> property on the
                <c>ZipErrorEventArgs.CurrentEntry</c>.  This communicates back to
                DotNetZip what you would like to do with this particular error.  Within
                an error handler, if you set the <c>ZipEntry.ZipErrorAction</c> property
                on the <c>ZipEntry</c> to <c>ZipErrorAction.InvokeErrorEvent</c> or if
                you don't set it at all, the library will throw the exception. (It is the
                same as if you had set the <c>ZipEntry.ZipErrorAction</c> property on the
                <c>ZipEntry</c> to <c>ZipErrorAction.Throw</c>.) If you set the
                <c>ZipErrorEventArgs.Cancel</c> to true, the entire <c>Save()</c> will be
                canceled.
              </para>
            
              <para>
                In the case that you use <c>ZipErrorAction.Skip</c>, implying that
                you want to skip the entry for which there's been an error, DotNetZip
                tries to seek backwards in the output stream, and truncate all bytes
                written on behalf of that particular entry. This works only if the
                output stream is seekable.  It will not work, for example, when using
                ASPNET's Response.OutputStream.
              </para>
            
             </remarks>
            
             <example>
            
             This example shows how to use an event handler to handle
             errors during save of the zip file.
             <code lang="C#">
            
             public static void MyZipError(object sender, ZipErrorEventArgs e)
             {
                 Console.WriteLine("Error saving {0}...", e.FileName);
                 Console.WriteLine("   Exception: {0}", e.exception);
                 ZipEntry entry = e.CurrentEntry;
                 string response = null;
                 // Ask the user whether he wants to skip this error or not
                 do
                 {
                     Console.Write("Retry, Skip, Throw, or Cancel ? (R/S/T/C) ");
                     response = Console.ReadLine();
                     Console.WriteLine();
            
                 } while (response != null &amp;&amp;
                          response[0]!='S' &amp;&amp; response[0]!='s' &amp;&amp;
                          response[0]!='R' &amp;&amp; response[0]!='r' &amp;&amp;
                          response[0]!='T' &amp;&amp; response[0]!='t' &amp;&amp;
                          response[0]!='C' &amp;&amp; response[0]!='c');
            
                 e.Cancel = (response[0]=='C' || response[0]=='c');
            
                 if (response[0]=='S' || response[0]=='s')
                     entry.ZipErrorAction = ZipErrorAction.Skip;
                 else if (response[0]=='R' || response[0]=='r')
                     entry.ZipErrorAction = ZipErrorAction.Retry;
                 else if (response[0]=='T' || response[0]=='t')
                     entry.ZipErrorAction = ZipErrorAction.Throw;
             }
            
             public void SaveTheFile()
             {
               string directoryToZip = "fodder";
               string directoryInArchive = "files";
               string zipFileToCreate = "Archive.zip";
               using (var zip = new ZipFile())
               {
                 // set the event handler before adding any entries
                 zip.ZipError += MyZipError;
                 zip.AddDirectory(directoryToZip, directoryInArchive);
                 zip.Save(zipFileToCreate);
               }
             }
             </code>
            
             <code lang="VB">
             Private Sub MyZipError(ByVal sender As Object, ByVal e As Ionic.Zip.ZipErrorEventArgs)
                 ' At this point, the application could prompt the user for an action to take.
                 ' But in this case, this application will simply automatically skip the file, in case of error.
                 Console.WriteLine("Zip Error,  entry {0}", e.CurrentEntry.FileName)
                 Console.WriteLine("   Exception: {0}", e.exception)
                 ' set the desired ZipErrorAction on the CurrentEntry to communicate that to DotNetZip
                 e.CurrentEntry.ZipErrorAction = Zip.ZipErrorAction.Skip
             End Sub
            
             Public Sub SaveTheFile()
                 Dim directoryToZip As String = "fodder"
                 Dim directoryInArchive As String = "files"
                 Dim zipFileToCreate as String = "Archive.zip"
                 Using zipArchive As ZipFile = New ZipFile
                     ' set the event handler before adding any entries
                     AddHandler zipArchive.ZipError, AddressOf MyZipError
                     zipArchive.AddDirectory(directoryToZip, directoryInArchive)
                     zipArchive.Save(zipFileToCreate)
                 End Using
             End Sub
            
             </code>
             </example>
            
             <seealso cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>
        </member>
        <member name="M:Ionic.Zip.ZipFile.ExtractAll(System.String)">
             <summary>
             Extracts all of the items in the zip archive, to the specified path in the
             filesystem.  The path can be relative or fully-qualified.
             </summary>
            
             <remarks>
             <para>
               This method will extract all entries in the <c>ZipFile</c> to the
               specified path.
             </para>
            
             <para>
               If an extraction of a file from the zip archive would overwrite an
               existing file in the filesystem, the action taken is dictated by the
               ExtractExistingFile property, which overrides any setting you may have
               made on individual ZipEntry instances.  By default, if you have not
               set that property on the <c>ZipFile</c> instance, the entry will not
               be extracted, the existing file will not be overwritten and an
               exception will be thrown. To change this, set the property, or use the
               <see cref="M:Ionic.Zip.ZipFile.ExtractAll(System.String,Ionic.Zip.ExtractExistingFileAction)" /> overload that allows you to
               specify an ExtractExistingFileAction parameter.
             </para>
            
             <para>
               The action to take when an extract would overwrite an existing file
               applies to all entries.  If you want to set this on a per-entry basis,
               then you must use one of the <see
               cref="M:Ionic.Zip.ZipEntry.Extract">ZipEntry.Extract</see> methods.
             </para>
            
             <para>
               This method will send verbose output messages to the <see
               cref="P:Ionic.Zip.ZipFile.StatusMessageTextWriter"/>, if it is set on the <c>ZipFile</c>
               instance.
             </para>
            
             <para>
             You may wish to take advantage of the <c>ExtractProgress</c> event.
             </para>
            
             <para>
               About timestamps: When extracting a file entry from a zip archive, the
               extracted file gets the last modified time of the entry as stored in
               the archive. The archive may also store extended file timestamp
               information, including last accessed and created times. If these are
               present in the <c>ZipEntry</c>, then the extracted file will also get
               these times.
             </para>
            
             <para>
               A Directory entry is somewhat different. It will get the times as
               described for a file entry, but, if there are file entries in the zip
               archive that, when extracted, appear in the just-created directory,
               then when those file entries are extracted, the last modified and last
               accessed times of the directory will change, as a side effect.  The
               result is that after an extraction of a directory and a number of
               files within the directory, the last modified and last accessed
               timestamps on the directory will reflect the time that the last file
               was extracted into the directory, rather than the time stored in the
               zip archive for the directory.
             </para>
            
             <para>
               To compensate, when extracting an archive with <c>ExtractAll</c>,
               DotNetZip will extract all the file and directory entries as described
               above, but it will then make a second pass on the directories, and
               reset the times on the directories to reflect what is stored in the
               zip archive.
             </para>
            
             <para>
               This compensation is performed only within the context of an
               <c>ExtractAll</c>. If you call <c>ZipEntry.Extract</c> on a directory
               entry, the timestamps on directory in the filesystem will reflect the
               times stored in the zip.  If you then call <c>ZipEntry.Extract</c> on
               a file entry, which is extracted into the directory, the timestamps on
               the directory will be updated to the current time.
             </para>
             </remarks>
            
             <example>
               This example extracts all the entries in a zip archive file, to the
               specified target directory.  The extraction will overwrite any
               existing files silently.
            
             <code>
             String TargetDirectory= "unpack";
             using(ZipFile zip= ZipFile.Read(ZipFileToExtract))
             {
                 zip.ExtractExistingFile= ExtractExistingFileAction.OverwriteSilently;
                 zip.ExtractAll(TargetDirectory);
             }
             </code>
            
             <code lang="VB">
             Dim TargetDirectory As String = "unpack"
             Using zip As ZipFile = ZipFile.Read(ZipFileToExtract)
                 zip.ExtractExistingFile= ExtractExistingFileAction.OverwriteSilently
                 zip.ExtractAll(TargetDirectory)
             End Using
             </code>
             </example>
            
             <seealso cref="E:Ionic.Zip.ZipFile.ExtractProgress"/>
             <seealso cref="P:Ionic.Zip.ZipFile.ExtractExistingFile"/>
            
             <param name="path">
               The path to which the contents of the zipfile will be extracted.
               The path can be relative or fully-qualified.
             </param>
            
        </member>
        <member name="M:Ionic.Zip.ZipFile.ExtractAll(System.String,Ionic.Zip.ExtractExistingFileAction)">
             <summary>
             Extracts all of the items in the zip archive, to the specified path in the
             filesystem, using the specified behavior when extraction would overwrite an
             existing file.
             </summary>
            
             <remarks>
            
             <para>
             This method will extract all entries in the <c>ZipFile</c> to the specified
             path.  For an extraction that would overwrite an existing file, the behavior
             is dictated by <paramref name="extractExistingFile"/>, which overrides any
             setting you may have made on individual ZipEntry instances.
             </para>
            
             <para>
             The action to take when an extract would overwrite an existing file
             applies to all entries.  If you want to set this on a per-entry basis,
             then you must use <see cref="M:Ionic.Zip.ZipEntry.Extract(System.String,Ionic.Zip.ExtractExistingFileAction)" /> or one of the similar methods.
             </para>
            
             <para>
             Calling this method is equivalent to setting the <see
             cref="P:Ionic.Zip.ZipFile.ExtractExistingFile"/> property and then calling <see
             cref="M:Ionic.Zip.ZipFile.ExtractAll(System.String)"/>.
             </para>
            
             <para>
             This method will send verbose output messages to the
             <see cref="P:Ionic.Zip.ZipFile.StatusMessageTextWriter"/>, if it is set on the <c>ZipFile</c> instance.
             </para>
             </remarks>
            
             <example>
             This example extracts all the entries in a zip archive file, to the
             specified target directory.  It does not overwrite any existing files.
             <code>
             String TargetDirectory= "c:\\unpack";
             using(ZipFile zip= ZipFile.Read(ZipFileToExtract))
             {
               zip.ExtractAll(TargetDirectory, ExtractExistingFileAction.DontOverwrite);
             }
             </code>
            
             <code lang="VB">
             Dim TargetDirectory As String = "c:\unpack"
             Using zip As ZipFile = ZipFile.Read(ZipFileToExtract)
                 zip.ExtractAll(TargetDirectory, ExtractExistingFileAction.DontOverwrite)
             End Using
             </code>
             </example>
            
             <param name="path">
             The path to which the contents of the zipfile will be extracted.
             The path can be relative or fully-qualified.
             </param>
            
             <param name="extractExistingFile">
             The action to take if extraction would overwrite an existing file.
             </param>
             <seealso cref="M:Ionic.Zip.ZipFile.ExtractSelectedEntries(System.String,Ionic.Zip.ExtractExistingFileAction)"/>
        </member>
        <member name="M:Ionic.Zip.ZipFile.Read(System.String)">
             <summary>
             Reads a zip file archive and returns the instance.
             </summary>
            
             <remarks>
             <para>
             The stream is read using the default <c>System.Text.Encoding</c>, which is the
             <c>IBM437</c> codepage.
             </para>
             </remarks>
            
             <exception cref="T:System.Exception">
             Thrown if the <c>ZipFile</c> cannot be read. The implementation of this method
             relies on <c>System.IO.File.OpenRead</c>, which can throw a variety of exceptions,
             including specific exceptions if a file is not found, an unauthorized access
             exception, exceptions for poorly formatted filenames, and so on.
             </exception>
            
             <param name="fileName">
             The name of the zip archive to open.  This can be a fully-qualified or relative
             pathname.
             </param>
            
             <seealso cref="M:Ionic.Zip.ZipFile.Read(System.String,Ionic.Zip.ReadOptions)"/>.
            
             <returns>The instance read from the zip archive.</returns>
            
        </member>
        <member name="M:Ionic.Zip.ZipFile.Read(System.String,Ionic.Zip.ReadOptions)">
             <summary>
               Reads a zip file archive from the named filesystem file using the
               specified options.
             </summary>
            
             <remarks>
             <para>
               This version of the <c>Read()</c> method allows the caller to pass
               in a <c>TextWriter</c> an <c>Encoding</c>, via an instance of the
               <c>ReadOptions</c> class.  The <c>ZipFile</c> is read in using the
               specified encoding for entries where UTF-8 encoding is not
               explicitly specified.
             </para>
             </remarks>
            
             <example>
            
             <para>
               This example shows how to read a zip file using the Big-5 Chinese
               code page (950), and extract each entry in the zip file, while
               sending status messages out to the Console.
             </para>
            
             <para>
               For this code to work as intended, the zipfile must have been
               created using the big5 code page (CP950). This is typical, for
               example, when using WinRar on a machine with CP950 set as the
               default code page.  In that case, the names of entries within the
               Zip archive will be stored in that code page, and reading the zip
               archive must be done using that code page.  If the application did
               not use the correct code page in ZipFile.Read(), then names of
               entries within the zip archive would not be correctly retrieved.
             </para>
            
             <code lang="C#">
             string zipToExtract = "MyArchive.zip";
             string extractDirectory = "extract";
             var options = new ReadOptions
             {
               StatusMessageWriter = System.Console.Out,
               Encoding = System.Text.Encoding.GetEncoding(950)
             };
             using (ZipFile zip = ZipFile.Read(zipToExtract, options))
             {
               foreach (ZipEntry e in zip)
               {
                  e.Extract(extractDirectory);
               }
             }
             </code>
            
            
             <code lang="VB">
             Dim zipToExtract as String = "MyArchive.zip"
             Dim extractDirectory as String = "extract"
             Dim options as New ReadOptions
             options.Encoding = System.Text.Encoding.GetEncoding(950)
             options.StatusMessageWriter = System.Console.Out
             Using zip As ZipFile = ZipFile.Read(zipToExtract, options)
                 Dim e As ZipEntry
                 For Each e In zip
                  e.Extract(extractDirectory)
                 Next
             End Using
             </code>
             </example>
            
            
             <example>
            
             <para>
               This example shows how to read a zip file using the default
               code page, to remove entries that have a modified date before a given threshold,
               sending status messages out to a <c>StringWriter</c>.
             </para>
            
             <code lang="C#">
             var options = new ReadOptions
             {
               StatusMessageWriter = new System.IO.StringWriter()
             };
             using (ZipFile zip =  ZipFile.Read("PackedDocuments.zip", options))
             {
               var Threshold = new DateTime(2007,7,4);
               // We cannot remove the entry from the list, within the context of
               // an enumeration of said list.
               // So we add the doomed entry to a list to be removed later.
               // pass 1: mark the entries for removal
               var MarkedEntries = new System.Collections.Generic.List&lt;ZipEntry&gt;();
               foreach (ZipEntry e in zip)
               {
                 if (e.LastModified &lt; Threshold)
                   MarkedEntries.Add(e);
               }
               // pass 2: actually remove the entry.
               foreach (ZipEntry zombie in MarkedEntries)
                  zip.RemoveEntry(zombie);
               zip.Comment = "This archive has been updated.";
               zip.Save();
             }
             // can now use contents of sw, eg store in an audit log
             </code>
            
             <code lang="VB">
             Dim options as New ReadOptions
             options.StatusMessageWriter = New System.IO.StringWriter
             Using zip As ZipFile = ZipFile.Read("PackedDocuments.zip", options)
                 Dim Threshold As New DateTime(2007, 7, 4)
                 ' We cannot remove the entry from the list, within the context of
                 ' an enumeration of said list.
                 ' So we add the doomed entry to a list to be removed later.
                 ' pass 1: mark the entries for removal
                 Dim MarkedEntries As New System.Collections.Generic.List(Of ZipEntry)
                 Dim e As ZipEntry
                 For Each e In zip
                     If (e.LastModified &lt; Threshold) Then
                         MarkedEntries.Add(e)
                     End If
                 Next
                 ' pass 2: actually remove the entry.
                 Dim zombie As ZipEntry
                 For Each zombie In MarkedEntries
                     zip.RemoveEntry(zombie)
                 Next
                 zip.Comment = "This archive has been updated."
                 zip.Save
             End Using
             ' can now use contents of sw, eg store in an audit log
             </code>
             </example>
            
             <exception cref="T:System.Exception">
               Thrown if the zipfile cannot be read. The implementation of
               this method relies on <c>System.IO.File.OpenRead</c>, which
               can throw a variety of exceptions, including specific
               exceptions if a file is not found, an unauthorized access
               exception, exceptions for poorly formatted filenames, and so
               on.
             </exception>
            
             <param name="fileName">
             The name of the zip archive to open.
             This can be a fully-qualified or relative pathname.
             </param>
            
             <param name="options">
             The set of options to use when reading the zip file.
             </param>
            
             <returns>The ZipFile instance read from the zip archive.</returns>
            
             <seealso cref="M:Ionic.Zip.ZipFile.Read(System.IO.Stream,Ionic.Zip.ReadOptions)"/>
            
        </member>
        <member name="M:Ionic.Zip.ZipFile.Read(System.String,System.IO.TextWriter,System.Text.Encoding,System.EventHandler{Ionic.Zip.ReadProgressEventArgs})">
             <summary>
             Reads a zip file archive using the specified text encoding,  the specified
             TextWriter for status messages, and the specified ReadProgress event handler,
             and returns the instance.
             </summary>
            
             <param name="fileName">
             The name of the zip archive to open.
             This can be a fully-qualified or relative pathname.
             </param>
            
             <param name="readProgress">
             An event handler for Read operations.
             </param>
            
             <param name="statusMessageWriter">
             The <c>System.IO.TextWriter</c> to use for writing verbose status messages
             during operations on the zip archive.  A console application may wish to
             pass <c>System.Console.Out</c> to get messages on the Console. A graphical
             or headless application may wish to capture the messages in a different
             <c>TextWriter</c>, such as a <c>System.IO.StringWriter</c>.
             </param>
            
             <param name="encoding">
             The <c>System.Text.Encoding</c> to use when reading in the zip archive. Be
             careful specifying the encoding.  If the value you use here is not the same
             as the Encoding used when the zip archive was created (possibly by a
             different archiver) you will get unexpected results and possibly exceptions.
             </param>
            
             <returns>The instance read from the zip archive.</returns>
            
        </member>
        <member name="M:Ionic.Zip.ZipFile.Read(System.IO.Stream)">
             <summary>
               Reads a zip archive from a stream.
             </summary>
            
             <remarks>
            
             <para>
               When reading from a file, it's probably easier to just use
               <see cref="M:Ionic.Zip.ZipFile.Read(System.String,Ionic.Zip.ReadOptions)">ZipFile.Read(String, ReadOptions)</see>.  This
               overload is useful when when the zip archive content is
               available from an already-open stream. The stream must be
               open and readable and seekable when calling this method.  The
               stream is left open when the reading is completed.
             </para>
            
             <para>
               Using this overload, the stream is read using the default
               <c>System.Text.Encoding</c>, which is the <c>IBM437</c>
               codepage. If you want to specify the encoding to use when
               reading the zipfile content, see
               <see cref="M:Ionic.Zip.ZipFile.Read(System.IO.Stream,Ionic.Zip.ReadOptions)">ZipFile.Read(Stream, ReadOptions)</see>.  This
             </para>
            
             <para>
               Reading of zip content begins at the current position in the
               stream.  This means if you have a stream that concatenates
               regular data and zip data, if you position the open, readable
               stream at the start of the zip data, you will be able to read
               the zip archive using this constructor, or any of the ZipFile
               constructors that accept a <see cref="T:System.IO.Stream" /> as
               input. Some examples of where this might be useful: the zip
               content is concatenated at the end of a regular EXE file, as
               some self-extracting archives do.  (Note: SFX files produced
               by DotNetZip do not work this way; they can be read as normal
               ZIP files). Another example might be a stream being read from
               a database, where the zip content is embedded within an
               aggregate stream of data.
             </para>
            
             </remarks>
            
             <example>
             <para>
               This example shows how to Read zip content from a stream, and
               extract one entry into a different stream. In this example,
               the filename "NameOfEntryInArchive.doc", refers only to the
               name of the entry within the zip archive.  A file by that
               name is not created in the filesystem.  The I/O is done
               strictly with the given streams.
             </para>
            
             <code>
             using (ZipFile zip = ZipFile.Read(InputStream))
             {
                zip.Extract("NameOfEntryInArchive.doc", OutputStream);
             }
             </code>
            
             <code lang="VB">
             Using zip as ZipFile = ZipFile.Read(InputStream)
                zip.Extract("NameOfEntryInArchive.doc", OutputStream)
             End Using
             </code>
             </example>
            
             <param name="zipStream">the stream containing the zip data.</param>
            
             <returns>The ZipFile instance read from the stream</returns>
            
        </member>
        <member name="M:Ionic.Zip.ZipFile.Read(System.IO.Stream,Ionic.Zip.ReadOptions)">
             <summary>
               Reads a zip file archive from the given stream using the
               specified options.
             </summary>
            
             <remarks>
            
             <para>
               When reading from a file, it's probably easier to just use
               <see cref="M:Ionic.Zip.ZipFile.Read(System.String,Ionic.Zip.ReadOptions)">ZipFile.Read(String, ReadOptions)</see>.  This
               overload is useful when when the zip archive content is
               available from an already-open stream. The stream must be
               open and readable and seekable when calling this method.  The
               stream is left open when the reading is completed.
             </para>
            
             <para>
               Reading of zip content begins at the current position in the
               stream.  This means if you have a stream that concatenates
               regular data and zip data, if you position the open, readable
               stream at the start of the zip data, you will be able to read
               the zip archive using this constructor, or any of the ZipFile
               constructors that accept a <see cref="T:System.IO.Stream" /> as
               input. Some examples of where this might be useful: the zip
               content is concatenated at the end of a regular EXE file, as
               some self-extracting archives do.  (Note: SFX files produced
               by DotNetZip do not work this way; they can be read as normal
               ZIP files). Another example might be a stream being read from
               a database, where the zip content is embedded within an
               aggregate stream of data.
             </para>
             </remarks>
            
             <param name="zipStream">the stream containing the zip data.</param>
            
             <param name="options">
               The set of options to use when reading the zip file.
             </param>
            
             <exception cref="T:System.Exception">
               Thrown if the zip archive cannot be read.
             </exception>
            
             <returns>The ZipFile instance read from the stream.</returns>
            
             <seealso cref="M:Ionic.Zip.ZipFile.Read(System.String,Ionic.Zip.ReadOptions)"/>
            
        </member>
        <member name="M:Ionic.Zip.ZipFile.Read(System.IO.Stream,System.IO.TextWriter,System.Text.Encoding,System.EventHandler{Ionic.Zip.ReadProgressEventArgs})">
             <summary>
             Reads a zip archive from a stream, using the specified text Encoding, the
             specified TextWriter for status messages,
             and the specified ReadProgress event handler.
             </summary>
            
             <remarks>
             <para>
             Reading of zip content begins at the current position in the stream.  This
             means if you have a stream that concatenates regular data and zip data, if
             you position the open, readable stream at the start of the zip data, you
             will be able to read the zip archive using this constructor, or any of the
             ZipFile constructors that accept a <see cref="T:System.IO.Stream" /> as
             input. Some examples of where this might be useful: the zip content is
             concatenated at the end of a regular EXE file, as some self-extracting
             archives do.  (Note: SFX files produced by DotNetZip do not work this
             way). Another example might be a stream being read from a database, where
             the zip content is embedded within an aggregate stream of data.
             </para>
             </remarks>
            
             <param name="zipStream">the stream containing the zip data.</param>
            
             <param name="statusMessageWriter">
             The <c>System.IO.TextWriter</c> to which verbose status messages are written
             during operations on the <c>ZipFile</c>.  For example, in a console
             application, System.Console.Out works, and will get a message for each entry
             added to the ZipFile.  If the TextWriter is <c>null</c>, no verbose messages
             are written.
             </param>
            
             <param name="encoding">
             The text encoding to use when reading entries that do not have the UTF-8
             encoding bit set.  Be careful specifying the encoding.  If the value you use
             here is not the same as the Encoding used when the zip archive was created
             (possibly by a different archiver) you will get unexpected results and
             possibly exceptions.  See the <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>
             property for more information.
             </param>
            
             <param name="readProgress">
             An event handler for Read operations.
             </param>
            
             <returns>an instance of ZipFile</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.IsZipFile(System.String)">
             <summary>
             Checks the given file to see if it appears to be a valid zip file.
             </summary>
             <remarks>
            
             <para>
               Calling this method is equivalent to calling <see cref="M:Ionic.Zip.ZipFile.IsZipFile(System.String,System.Boolean)"/> with the testExtract parameter set to false.
             </para>
             </remarks>
            
             <param name="fileName">The file to check.</param>
             <returns>true if the file appears to be a zip file.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.IsZipFile(System.String,System.Boolean)">
             <summary>
             Checks a file to see if it is a valid zip file.
             </summary>
            
             <remarks>
             <para>
               This method opens the specified zip file, reads in the zip archive,
               verifying the ZIP metadata as it reads.
             </para>
            
             <para>
               If everything succeeds, then the method returns true.  If anything fails -
               for example if an incorrect signature or CRC is found, indicating a
               corrupt file, the the method returns false.  This method also returns
               false for a file that does not exist.
             </para>
            
             <para>
               If <paramref name="testExtract"/> is true, as part of its check, this
               method reads in the content for each entry, expands it, and checks CRCs.
               This provides an additional check beyond verifying the zip header and
               directory data.
             </para>
            
             <para>
               If <paramref name="testExtract"/> is true, and if any of the zip entries
               are protected with a password, this method will return false.  If you want
               to verify a <c>ZipFile</c> that has entries which are protected with a
               password, you will need to do that manually.
             </para>
            
             </remarks>
            
             <param name="fileName">The zip file to check.</param>
             <param name="testExtract">true if the caller wants to extract each entry.</param>
             <returns>true if the file contains a valid zip file.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.IsZipFile(System.IO.Stream,System.Boolean)">
             <summary>
             Checks a stream to see if it contains a valid zip archive.
             </summary>
            
             <remarks>
             <para>
             This method reads the zip archive contained in the specified stream, verifying
             the ZIP metadata as it reads.  If testExtract is true, this method also extracts
             each entry in the archive, dumping all the bits into <see cref="F:System.IO.Stream.Null"/>.
             </para>
            
             <para>
             If everything succeeds, then the method returns true.  If anything fails -
             for example if an incorrect signature or CRC is found, indicating a corrupt
             file, the the method returns false.  This method also returns false for a
             file that does not exist.
             </para>
            
             <para>
             If <c>testExtract</c> is true, this method reads in the content for each
             entry, expands it, and checks CRCs.  This provides an additional check
             beyond verifying the zip header data.
             </para>
            
             <para>
             If <c>testExtract</c> is true, and if any of the zip entries are protected
             with a password, this method will return false.  If you want to verify a
             ZipFile that has entries which are protected with a password, you will need
             to do that manually.
             </para>
             </remarks>
            
             <seealso cref="M:Ionic.Zip.ZipFile.IsZipFile(System.String,System.Boolean)"/>
            
             <param name="stream">The stream to check.</param>
             <param name="testExtract">true if the caller wants to extract each entry.</param>
             <returns>true if the stream contains a valid zip archive.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.DeleteFileWithRetry(System.String)">
             <summary>
               Delete file with retry on UnauthorizedAccessException.
             </summary>
            
             <remarks>
               <para>
                 When calling File.Delete() on a file that has been "recently"
                 created, the call sometimes fails with
                 UnauthorizedAccessException. This method simply retries the Delete 3
                 times with a sleep between tries.
               </para>
             </remarks>
            
             <param name='filename'>the name of the file to be deleted</param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.Save">
             <summary>
               Saves the Zip archive to a file, specified by the Name property of the
               <c>ZipFile</c>.
             </summary>
            
             <remarks>
             <para>
               The <c>ZipFile</c> instance is written to storage, typically a zip file
               in a filesystem, only when the caller calls <c>Save</c>.  In the typical
               case, the Save operation writes the zip content to a temporary file, and
               then renames the temporary file to the desired name. If necessary, this
               method will delete a pre-existing file before the rename.
             </para>
            
             <para>
               The <see cref="P:Ionic.Zip.ZipFile.Name"/> property is specified either explicitly,
               or implicitly using one of the parameterized ZipFile constructors.  For
               COM Automation clients, the <c>Name</c> property must be set explicitly,
               because COM Automation clients cannot call parameterized constructors.
             </para>
            
             <para>
               When using a filesystem file for the Zip output, it is possible to call
               <c>Save</c> multiple times on the <c>ZipFile</c> instance. With each
               call the zip content is re-written to the same output file.
             </para>
            
             <para>
               Data for entries that have been added to the <c>ZipFile</c> instance is
               written to the output when the <c>Save</c> method is called. This means
               that the input streams for those entries must be available at the time
               the application calls <c>Save</c>.  If, for example, the application
               adds entries with <c>AddEntry</c> using a dynamically-allocated
               <c>MemoryStream</c>, the memory stream must not have been disposed
               before the call to <c>Save</c>. See the <see
               cref="P:Ionic.Zip.ZipEntry.InputStream"/> property for more discussion of the
               availability requirements of the input stream for an entry, and an
               approach for providing just-in-time stream lifecycle management.
             </para>
            
             </remarks>
            
             <seealso cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.IO.Stream)"/>
            
             <exception cref="T:Ionic.Zip.BadStateException">
               Thrown if you haven't specified a location or stream for saving the zip,
               either in the constructor or by setting the Name property, or if you try
               to save a regular zip archive to a filename with a .exe extension.
             </exception>
            
             <exception cref="T:System.OverflowException">
               Thrown if <see cref="P:Ionic.Zip.ZipFile.MaxOutputSegmentSize"/> is non-zero, and the number
               of segments that would be generated for the spanned zip file during the
               save operation exceeds 99.  If this happens, you need to increase the
               segment size.
             </exception>
            
        </member>
        <member name="M:Ionic.Zip.ZipFile.Save(System.String)">
             <summary>
             Save the file to a new zipfile, with the given name.
             </summary>
            
             <remarks>
             <para>
             This method allows the application to explicitly specify the name of the zip
             file when saving. Use this when creating a new zip file, or when
             updating a zip archive.
             </para>
            
             <para>
             An application can also save a zip archive in several places by calling this
             method multiple times in succession, with different filenames.
             </para>
            
             <para>
             The <c>ZipFile</c> instance is written to storage, typically a zip file in a
             filesystem, only when the caller calls <c>Save</c>.  The Save operation writes
             the zip content to a temporary file, and then renames the temporary file
             to the desired name. If necessary, this method will delete a pre-existing file
             before the rename.
             </para>
            
             </remarks>
            
             <exception cref="T:System.ArgumentException">
             Thrown if you specify a directory for the filename.
             </exception>
            
             <param name="fileName">
             The name of the zip archive to save to. Existing files will
             be overwritten with great prejudice.
             </param>
            
             <example>
             This example shows how to create and Save a zip file.
             <code>
             using (ZipFile zip = new ZipFile())
             {
               zip.AddDirectory(@"c:\reports\January");
               zip.Save("January.zip");
             }
             </code>
            
             <code lang="VB">
             Using zip As New ZipFile()
               zip.AddDirectory("c:\reports\January")
               zip.Save("January.zip")
             End Using
             </code>
            
             </example>
            
             <example>
             This example shows how to update a zip file.
             <code>
             using (ZipFile zip = ZipFile.Read("ExistingArchive.zip"))
             {
               zip.AddFile("NewData.csv");
               zip.Save("UpdatedArchive.zip");
             }
             </code>
            
             <code lang="VB">
             Using zip As ZipFile = ZipFile.Read("ExistingArchive.zip")
               zip.AddFile("NewData.csv")
               zip.Save("UpdatedArchive.zip")
             End Using
             </code>
            
             </example>
        </member>
        <member name="M:Ionic.Zip.ZipFile.Save(System.IO.Stream)">
             <summary>
               Save the zip archive to the specified stream.
             </summary>
            
             <remarks>
             <para>
               The <c>ZipFile</c> instance is written to storage - typically a zip file
               in a filesystem, but using this overload, the storage can be anything
               accessible via a writable stream - only when the caller calls <c>Save</c>.
             </para>
            
             <para>
               Use this method to save the zip content to a stream directly.  A common
               scenario is an ASP.NET application that dynamically generates a zip file
               and allows the browser to download it. The application can call
               <c>Save(Response.OutputStream)</c> to write a zipfile directly to the
               output stream, without creating a zip file on the disk on the ASP.NET
               server.
             </para>
            
             <para>
               Be careful when saving a file to a non-seekable stream, including
               <c>Response.OutputStream</c>. When DotNetZip writes to a non-seekable
               stream, the zip archive is formatted in such a way that may not be
               compatible with all zip tools on all platforms.  It's a perfectly legal
               and compliant zip file, but some people have reported problems opening
               files produced this way using the Mac OS archive utility.
             </para>
            
             </remarks>
            
             <example>
            
               This example saves the zipfile content into a MemoryStream, and
               then gets the array of bytes from that MemoryStream.
            
             <code lang="C#">
             using (var zip = new Ionic.Zip.ZipFile())
             {
                 zip.CompressionLevel= Ionic.Zlib.CompressionLevel.BestCompression;
                 zip.Password = "VerySecret.";
                 zip.Encryption = EncryptionAlgorithm.WinZipAes128;
                 zip.AddFile(sourceFileName);
                 MemoryStream output = new MemoryStream();
                 zip.Save(output);
            
                 byte[] zipbytes = output.ToArray();
             }
             </code>
             </example>
            
             <example>
             <para>
               This example shows a pitfall you should avoid. DO NOT read
               from a stream, then try to save to the same stream.  DO
               NOT DO THIS:
             </para>
            
             <code lang="C#">
             using (var fs = new FileSteeam(filename, FileMode.Open))
             {
               using (var zip = Ionic.Zip.ZipFile.Read(inputStream))
               {
                 zip.AddEntry("Name1.txt", "this is the content");
                 zip.Save(inputStream);  // NO NO NO!!
               }
             }
             </code>
            
             <para>
               Better like this:
             </para>
            
             <code lang="C#">
             using (var zip = Ionic.Zip.ZipFile.Read(filename))
             {
                 zip.AddEntry("Name1.txt", "this is the content");
                 zip.Save();  // YES!
             }
             </code>
            
             </example>
            
             <param name="outputStream">
               The <c>System.IO.Stream</c> to write to. It must be
               writable. If you created the ZipFile instanct by calling
               ZipFile.Read(), this stream must not be the same stream
               you passed to ZipFile.Read().
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.SaveSelfExtractor(System.String,Ionic.Zip.SelfExtractorFlavor)">
             <summary>
             Saves the ZipFile instance to a self-extracting zip archive.
             </summary>
            
             <remarks>
            
             <para>
             The generated exe image will execute on any machine that has the .NET
             Framework 2.0 installed on it.  The generated exe image is also a
             valid ZIP file, readable with DotNetZip or another Zip library or tool
             such as WinZip.
             </para>
            
             <para>
             There are two "flavors" of self-extracting archive.  The
             <c>WinFormsApplication</c> version will pop up a GUI and allow the
             user to select a target directory into which to extract. There's also
             a checkbox allowing the user to specify to overwrite existing files,
             and another checkbox to allow the user to request that Explorer be
             opened to see the extracted files after extraction.  The other flavor
             is <c>ConsoleApplication</c>.  A self-extractor generated with that
             flavor setting will run from the command line. It accepts command-line
             options to set the overwrite behavior, and to specify the target
             extraction directory.
             </para>
            
             <para>
             There are a few temporary files created during the saving to a
             self-extracting zip.  These files are created in the directory pointed
             to by <see cref="P:Ionic.Zip.ZipFile.TempFileFolder"/>, which defaults to <see
             cref="M:System.IO.Path.GetTempPath"/>.  These temporary files are
             removed upon successful completion of this method.
             </para>
            
             <para>
             When a user runs the WinForms SFX, the user's personal directory (<see
             cref="F:System.Environment.SpecialFolder.Personal">Environment.SpecialFolder.Personal</see>)
             will be used as the default extract location.  If you want to set the
             default extract location, you should use the other overload of
             <c>SaveSelfExtractor()</c>/ The user who runs the SFX will have the
             opportunity to change the extract directory before extracting. When
             the user runs the Command-Line SFX, the user must explicitly specify
             the directory to which to extract.  The .NET Framework 2.0 is required
             on the computer when the self-extracting archive is run.
             </para>
            
             <para>
             NB: This method is not available in the version of DotNetZip build for
             the .NET Compact Framework, nor in the "Reduced" DotNetZip library.
             </para>
            
             </remarks>
            
             <example>
             <code>
             string DirectoryPath = "c:\\Documents\\Project7";
             using (ZipFile zip = new ZipFile())
             {
                 zip.AddDirectory(DirectoryPath, System.IO.Path.GetFileName(DirectoryPath));
                 zip.Comment = "This will be embedded into a self-extracting console-based exe";
                 zip.SaveSelfExtractor("archive.exe", SelfExtractorFlavor.ConsoleApplication);
             }
             </code>
             <code lang="VB">
             Dim DirectoryPath As String = "c:\Documents\Project7"
             Using zip As New ZipFile()
                 zip.AddDirectory(DirectoryPath, System.IO.Path.GetFileName(DirectoryPath))
                 zip.Comment = "This will be embedded into a self-extracting console-based exe"
                 zip.SaveSelfExtractor("archive.exe", SelfExtractorFlavor.ConsoleApplication)
             End Using
             </code>
             </example>
            
             <param name="exeToGenerate">
               a pathname, possibly fully qualified, to be created. Typically it
               will end in an .exe extension.</param>
             <param name="flavor">
               Indicates whether a Winforms or Console self-extractor is
               desired. </param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.SaveSelfExtractor(System.String,Ionic.Zip.SelfExtractorSaveOptions)">
             <summary>
               Saves the ZipFile instance to a self-extracting zip archive, using
               the specified save options.
             </summary>
            
             <remarks>
             <para>
               This method saves a self extracting archive, using the specified save
               options. These options include the flavor of the SFX, the default extract
               directory, the icon file, and so on.  See the documentation
               for <see cref="M:Ionic.Zip.ZipFile.SaveSelfExtractor(System.String,Ionic.Zip.SelfExtractorFlavor)"/> for more
               details.
             </para>
            
             <para>
               The user who runs the SFX will have the opportunity to change the extract
               directory before extracting. If at the time of extraction, the specified
               directory does not exist, the SFX will create the directory before
               extracting the files.
             </para>
            
             </remarks>
            
             <example>
               This example saves a WinForms-based self-extracting archive EXE that
               will use c:\ExtractHere as the default extract location. The C# code
               shows syntax for .NET 3.0, which uses an object initializer for
               the SelfExtractorOptions object.
             <code>
             string DirectoryPath = "c:\\Documents\\Project7";
             using (ZipFile zip = new ZipFile())
             {
                 zip.AddDirectory(DirectoryPath, System.IO.Path.GetFileName(DirectoryPath));
                 zip.Comment = "This will be embedded into a self-extracting WinForms-based exe";
                 var options = new SelfExtractorOptions
                 {
                   Flavor = SelfExtractorFlavor.WinFormsApplication,
                   DefaultExtractDirectory = "%USERPROFILE%\\ExtractHere",
                   PostExtractCommandLine = ExeToRunAfterExtract,
                   SfxExeWindowTitle = "My Custom Window Title",
                   RemoveUnpackedFilesAfterExecute = true
                 };
                 zip.SaveSelfExtractor("archive.exe", options);
             }
             </code>
             <code lang="VB">
             Dim DirectoryPath As String = "c:\Documents\Project7"
             Using zip As New ZipFile()
                 zip.AddDirectory(DirectoryPath, System.IO.Path.GetFileName(DirectoryPath))
                 zip.Comment = "This will be embedded into a self-extracting console-based exe"
                 Dim options As New SelfExtractorOptions()
                 options.Flavor = SelfExtractorFlavor.WinFormsApplication
                 options.DefaultExtractDirectory = "%USERPROFILE%\\ExtractHere"
                 options.PostExtractCommandLine = ExeToRunAfterExtract
                 options.SfxExeWindowTitle = "My Custom Window Title"
                 options.RemoveUnpackedFilesAfterExecute = True
                 zip.SaveSelfExtractor("archive.exe", options)
             End Using
             </code>
             </example>
            
             <param name="exeToGenerate">The name of the EXE to generate.</param>
             <param name="options">provides the options for creating the
             Self-extracting archive.</param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)">
             <summary>
               Adds to the ZipFile a set of files from the current working directory on
               disk, that conform to the specified criteria.
             </summary>
            
             <remarks>
             <para>
               This method selects files from the the current working directory matching
               the specified criteria, and adds them to the ZipFile.
             </para>
            
             <para>
               Specify the criteria in statements of 3 elements: a noun, an operator, and
               a value.  Consider the string "name != *.doc" .  The noun is "name".  The
               operator is "!=", implying "Not Equal".  The value is "*.doc".  That
               criterion, in English, says "all files with a name that does not end in
               the .doc extension."
             </para>
            
             <para>
               Supported nouns include "name" (or "filename") for the filename; "atime",
               "mtime", and "ctime" for last access time, last modfied time, and created
               time of the file, respectively; "attributes" (or "attrs") for the file
               attributes; "size" (or "length") for the file length (uncompressed), and
               "type" for the type of object, either a file or a directory.  The
               "attributes", "name" and "type" nouns both support = and != as operators.
               The "size", "atime", "mtime", and "ctime" nouns support = and !=, and
               &gt;, &gt;=, &lt;, &lt;= as well. The times are taken to be expressed in
               local time.
             </para>
            
             <para>
             Specify values for the file attributes as a string with one or more of the
             characters H,R,S,A,I,L in any order, implying file attributes of Hidden,
             ReadOnly, System, Archive, NotContextIndexed, and ReparsePoint (symbolic
             link) respectively.
             </para>
            
             <para>
             To specify a time, use YYYY-MM-DD-HH:mm:ss or YYYY/MM/DD-HH:mm:ss as the
             format.  If you omit the HH:mm:ss portion, it is assumed to be 00:00:00
             (midnight).
             </para>
            
             <para>
             The value for a size criterion is expressed in integer quantities of bytes,
             kilobytes (use k or kb after the number), megabytes (m or mb), or gigabytes
             (g or gb).
             </para>
            
             <para>
             The value for a name is a pattern to match against the filename, potentially
             including wildcards.  The pattern follows CMD.exe glob rules: * implies one
             or more of any character, while ?  implies one character.  If the name
             pattern contains any slashes, it is matched to the entire filename,
             including the path; otherwise, it is matched against only the filename
             without the path.  This means a pattern of "*\*.*" matches all files one
             directory level deep, while a pattern of "*.*" matches all files in all
             directories.
             </para>
            
             <para>
             To specify a name pattern that includes spaces, use single quotes around the
             pattern.  A pattern of "'* *.*'" will match all files that have spaces in
             the filename.  The full criteria string for that would be "name = '* *.*'" .
             </para>
            
             <para>
             The value for a type criterion is either F (implying a file) or D (implying
             a directory).
             </para>
            
             <para>
             Some examples:
             </para>
            
             <list type="table">
               <listheader>
                 <term>criteria</term>
                 <description>Files retrieved</description>
               </listheader>
            
               <item>
                 <term>name != *.xls </term>
                 <description>any file with an extension that is not .xls
                 </description>
               </item>
            
               <item>
                 <term>name = *.mp3 </term>
                 <description>any file with a .mp3 extension.
                 </description>
               </item>
            
               <item>
                 <term>*.mp3</term>
                 <description>(same as above) any file with a .mp3 extension.
                 </description>
               </item>
            
               <item>
                 <term>attributes = A </term>
                 <description>all files whose attributes include the Archive bit.
                 </description>
               </item>
            
               <item>
                 <term>attributes != H </term>
                 <description>all files whose attributes do not include the Hidden bit.
                 </description>
               </item>
            
               <item>
                 <term>mtime > 2009-01-01</term>
                 <description>all files with a last modified time after January 1st, 2009.
                 </description>
               </item>
            
               <item>
                 <term>size > 2gb</term>
                 <description>all files whose uncompressed size is greater than 2gb.
                 </description>
               </item>
            
               <item>
                 <term>type = D</term>
                 <description>all directories in the filesystem. </description>
               </item>
            
             </list>
            
             <para>
             You can combine criteria with the conjunctions AND or OR. Using a string
             like "name = *.txt AND size &gt;= 100k" for the selectionCriteria retrieves
             entries whose names end in .txt, and whose uncompressed size is greater than
             or equal to 100 kilobytes.
             </para>
            
             <para>
             For more complex combinations of criteria, you can use parenthesis to group
             clauses in the boolean logic.  Without parenthesis, the precedence of the
             criterion atoms is determined by order of appearance.  Unlike the C#
             language, the AND conjunction does not take precendence over the logical OR.
             This is important only in strings that contain 3 or more criterion atoms.
             In other words, "name = *.txt and size &gt; 1000 or attributes = H" implies
             "((name = *.txt AND size &gt; 1000) OR attributes = H)" while "attributes =
             H OR name = *.txt and size &gt; 1000" evaluates to "((attributes = H OR name
             = *.txt) AND size &gt; 1000)".  When in doubt, use parenthesis.
             </para>
            
             <para>
             Using time properties requires some extra care. If you want to retrieve all
             entries that were last updated on 2009 February 14, specify a time range
             like so:"mtime &gt;= 2009-02-14 AND mtime &lt; 2009-02-15".  Read this to
             say: all files updated after 12:00am on February 14th, until 12:00am on
             February 15th.  You can use the same bracketing approach to specify any time
             period - a year, a month, a week, and so on.
             </para>
            
             <para>
             The syntax allows one special case: if you provide a string with no spaces, it is
             treated as a pattern to match for the filename.  Therefore a string like "*.xls"
             will be equivalent to specifying "name = *.xls".
             </para>
            
             <para>
             There is no logic in this method that insures that the file inclusion
             criteria are internally consistent.  For example, it's possible to specify
             criteria that says the file must have a size of less than 100 bytes, as well
             as a size that is greater than 1000 bytes. Obviously no file will ever
             satisfy such criteria, but this method does not detect such logical
             inconsistencies. The caller is responsible for insuring the criteria are
             sensible.
             </para>
            
             <para>
               Using this method, the file selection does not recurse into
               subdirectories, and the full path of the selected files is included in the
               entries added into the zip archive.  If you don't like these behaviors,
               see the other overloads of this method.
             </para>
             </remarks>
            
             <example>
             This example zips up all *.csv files in the current working directory.
             <code>
             using (ZipFile zip = new ZipFile())
             {
                 // To just match on filename wildcards,
                 // use the shorthand form of the selectionCriteria string.
                 zip.AddSelectedFiles("*.csv");
                 zip.Save(PathToZipArchive);
             }
             </code>
             <code lang="VB">
             Using zip As ZipFile = New ZipFile()
                 zip.AddSelectedFiles("*.csv")
                 zip.Save(PathToZipArchive)
             End Using
             </code>
             </example>
            
             <param name="selectionCriteria">The criteria for file selection</param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String,System.Boolean)">
             <summary>
               Adds to the ZipFile a set of files from the disk that conform to the
               specified criteria, optionally recursing into subdirectories.
             </summary>
            
             <remarks>
             <para>
               This method selects files from the the current working directory matching
               the specified criteria, and adds them to the ZipFile.  If
               <c>recurseDirectories</c> is true, files are also selected from
               subdirectories, and the directory structure in the filesystem is
               reproduced in the zip archive, rooted at the current working directory.
             </para>
            
             <para>
               Using this method, the full path of the selected files is included in the
               entries added into the zip archive.  If you don't want this behavior, use
               one of the overloads of this method that allows the specification of a
               <c>directoryInArchive</c>.
             </para>
            
             <para>
               For details on the syntax for the selectionCriteria parameter, see <see
               cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)"/>.
             </para>
            
             </remarks>
            
             <example>
            
               This example zips up all *.xml files in the current working directory, or any
               subdirectory, that are larger than 1mb.
            
             <code>
             using (ZipFile zip = new ZipFile())
             {
                 // Use a compound expression in the selectionCriteria string.
                 zip.AddSelectedFiles("name = *.xml  and  size > 1024kb", true);
                 zip.Save(PathToZipArchive);
             }
             </code>
             <code lang="VB">
             Using zip As ZipFile = New ZipFile()
                 ' Use a compound expression in the selectionCriteria string.
                 zip.AddSelectedFiles("name = *.xml  and  size > 1024kb", true)
                 zip.Save(PathToZipArchive)
             End Using
             </code>
             </example>
            
             <param name="selectionCriteria">The criteria for file selection</param>
            
             <param name="recurseDirectories">
               If true, the file selection will recurse into subdirectories.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String,System.String)">
             <summary>
               Adds to the ZipFile a set of files from a specified directory in the
               filesystem, that conform to the specified criteria.
             </summary>
            
             <remarks>
             <para>
               This method selects files that conform to the specified criteria, from the
               the specified directory on disk, and adds them to the ZipFile.  The search
               does not recurse into subdirectores.
             </para>
            
             <para>
               Using this method, the full filesystem path of the files on disk is
               reproduced on the entries added to the zip file.  If you don't want this
               behavior, use one of the other overloads of this method.
             </para>
            
             <para>
               For details on the syntax for the selectionCriteria parameter, see <see
               cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)"/>.
             </para>
            
             </remarks>
            
             <example>
            
               This example zips up all *.xml files larger than 1mb in the directory
               given by "d:\rawdata".
            
             <code>
             using (ZipFile zip = new ZipFile())
             {
                 // Use a compound expression in the selectionCriteria string.
                 zip.AddSelectedFiles("name = *.xml  and  size > 1024kb", "d:\\rawdata");
                 zip.Save(PathToZipArchive);
             }
             </code>
            
             <code lang="VB">
             Using zip As ZipFile = New ZipFile()
                 ' Use a compound expression in the selectionCriteria string.
                 zip.AddSelectedFiles("name = *.xml  and  size > 1024kb", "d:\rawdata)
                 zip.Save(PathToZipArchive)
             End Using
             </code>
             </example>
            
             <param name="selectionCriteria">The criteria for file selection</param>
            
             <param name="directoryOnDisk">
             The name of the directory on the disk from which to select files.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String,System.String,System.Boolean)">
             <summary>
               Adds to the ZipFile a set of files from the specified directory on disk,
               that conform to the specified criteria.
             </summary>
            
             <remarks>
            
             <para>
               This method selects files from the the specified disk directory matching
               the specified selection criteria, and adds them to the ZipFile.  If
               <c>recurseDirectories</c> is true, files are also selected from
               subdirectories.
             </para>
            
             <para>
               The full directory structure in the filesystem is reproduced on the
               entries added to the zip archive.  If you don't want this behavior, use
               one of the overloads of this method that allows the specification of a
               <c>directoryInArchive</c>.
             </para>
            
             <para>
               For details on the syntax for the selectionCriteria parameter, see <see
               cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)"/>.
             </para>
             </remarks>
            
             <example>
            
               This example zips up all *.csv files in the "files" directory, or any
               subdirectory, that have been saved since 2009 February 14th.
            
             <code>
             using (ZipFile zip = new ZipFile())
             {
                 // Use a compound expression in the selectionCriteria string.
                 zip.AddSelectedFiles("name = *.csv  and  mtime > 2009-02-14", "files", true);
                 zip.Save(PathToZipArchive);
             }
             </code>
             <code lang="VB">
             Using zip As ZipFile = New ZipFile()
                 ' Use a compound expression in the selectionCriteria string.
                 zip.AddSelectedFiles("name = *.csv  and  mtime > 2009-02-14", "files", true)
                 zip.Save(PathToZipArchive)
             End Using
             </code>
             </example>
            
             <example>
               This example zips up all files in the current working
               directory, and all its child directories, except those in
               the <c>excludethis</c> subdirectory.
             <code lang="VB">
             Using Zip As ZipFile = New ZipFile(zipfile)
               Zip.AddSelectedFfiles("name != 'excludethis\*.*'", datapath, True)
               Zip.Save()
             End Using
             </code>
             </example>
            
             <param name="selectionCriteria">The criteria for file selection</param>
            
             <param name="directoryOnDisk">
               The filesystem path from which to select files.
             </param>
            
             <param name="recurseDirectories">
               If true, the file selection will recurse into subdirectories.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String,System.String,System.String)">
             <summary>
               Adds to the ZipFile a selection of files from the specified directory on
               disk, that conform to the specified criteria, and using a specified root
               path for entries added to the zip archive.
             </summary>
            
             <remarks>
             <para>
               This method selects files from the specified disk directory matching the
               specified selection criteria, and adds those files to the ZipFile, using
               the specified directory path in the archive.  The search does not recurse
               into subdirectories.  For details on the syntax for the selectionCriteria
               parameter, see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)" />.
             </para>
            
             </remarks>
            
             <example>
            
               This example zips up all *.psd files in the "photos" directory that have
               been saved since 2009 February 14th, and puts them all in a zip file,
               using the directory name of "content" in the zip archive itself. When the
               zip archive is unzipped, the folder containing the .psd files will be
               named "content".
            
             <code>
             using (ZipFile zip = new ZipFile())
             {
                 // Use a compound expression in the selectionCriteria string.
                 zip.AddSelectedFiles("name = *.psd  and  mtime > 2009-02-14", "photos", "content");
                 zip.Save(PathToZipArchive);
             }
             </code>
             <code lang="VB">
             Using zip As ZipFile = New ZipFile
                 zip.AddSelectedFiles("name = *.psd  and  mtime > 2009-02-14", "photos", "content")
                 zip.Save(PathToZipArchive)
             End Using
             </code>
             </example>
            
             <param name="selectionCriteria">
               The criteria for selection of files to add to the <c>ZipFile</c>.
             </param>
            
             <param name="directoryOnDisk">
               The path to the directory in the filesystem from which to select files.
             </param>
            
             <param name="directoryPathInArchive">
               Specifies a directory path to use to in place of the
               <c>directoryOnDisk</c>.  This path may, or may not, correspond to a real
               directory in the current filesystem.  If the files within the zip are
               later extracted, this is the path used for the extracted file.  Passing
               null (nothing in VB) will use the path on the file name, if any; in other
               words it would use <c>directoryOnDisk</c>, plus any subdirectory.  Passing
               the empty string ("") will insert the item at the root path within the
               archive.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String,System.String,System.String,System.Boolean)">
             <summary>
               Adds to the ZipFile a selection of files from the specified directory on
               disk, that conform to the specified criteria, optionally recursing through
               subdirectories, and using a specified root path for entries added to the
               zip archive.
             </summary>
            
             <remarks>
               This method selects files from the specified disk directory that match the
               specified selection criteria, and adds those files to the ZipFile, using
               the specified directory path in the archive. If <c>recurseDirectories</c>
               is true, files are also selected from subdirectories, and the directory
               structure in the filesystem is reproduced in the zip archive, rooted at
               the directory specified by <c>directoryOnDisk</c>.  For details on the
               syntax for the selectionCriteria parameter, see <see
               cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)" />.
             </remarks>
            
             <example>
            
               This example zips up all files that are NOT *.pst files, in the current
               working directory and any subdirectories.
            
             <code>
             using (ZipFile zip = new ZipFile())
             {
                 zip.AddSelectedFiles("name != *.pst", SourceDirectory, "backup", true);
                 zip.Save(PathToZipArchive);
             }
             </code>
             <code lang="VB">
             Using zip As ZipFile = New ZipFile
                 zip.AddSelectedFiles("name != *.pst", SourceDirectory, "backup", true)
                 zip.Save(PathToZipArchive)
             End Using
             </code>
             </example>
            
             <param name="selectionCriteria">
               The criteria for selection of files to add to the <c>ZipFile</c>.
             </param>
            
             <param name="directoryOnDisk">
               The path to the directory in the filesystem from which to select files.
             </param>
            
             <param name="directoryPathInArchive">
               Specifies a directory path to use to in place of the
               <c>directoryOnDisk</c>.  This path may, or may not, correspond to a real
               directory in the current filesystem.  If the files within the zip are
               later extracted, this is the path used for the extracted file.  Passing
               null (nothing in VB) will use the path on the file name, if any; in other
               words it would use <c>directoryOnDisk</c>, plus any subdirectory.  Passing
               the empty string ("") will insert the item at the root path within the
               archive.
             </param>
            
             <param name="recurseDirectories">
               If true, the method also scans subdirectories for files matching the
               criteria.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.UpdateSelectedFiles(System.String,System.String,System.String,System.Boolean)">
             <summary>
               Updates the ZipFile with a selection of files from the disk that conform
               to the specified criteria.
             </summary>
            
             <remarks>
               This method selects files from the specified disk directory that match the
               specified selection criteria, and Updates the <c>ZipFile</c> with those
               files, using the specified directory path in the archive. If
               <c>recurseDirectories</c> is true, files are also selected from
               subdirectories, and the directory structure in the filesystem is
               reproduced in the zip archive, rooted at the directory specified by
               <c>directoryOnDisk</c>.  For details on the syntax for the
               selectionCriteria parameter, see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)" />.
             </remarks>
            
             <param name="selectionCriteria">
               The criteria for selection of files to add to the <c>ZipFile</c>.
             </param>
            
             <param name="directoryOnDisk">
               The path to the directory in the filesystem from which to select files.
             </param>
            
             <param name="directoryPathInArchive">
               Specifies a directory path to use to in place of the
               <c>directoryOnDisk</c>. This path may, or may not, correspond to a
               real directory in the current filesystem. If the files within the zip
               are later extracted, this is the path used for the extracted file.
               Passing null (nothing in VB) will use the path on the file name, if
               any; in other words it would use <c>directoryOnDisk</c>, plus any
               subdirectory.  Passing the empty string ("") will insert the item at
               the root path within the archive.
             </param>
            
             <param name="recurseDirectories">
               If true, the method also scans subdirectories for files matching the criteria.
             </param>
            
             <seealso cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String,System.String,System.String,System.Boolean)" />
        </member>
        <member name="M:Ionic.Zip.ZipFile.SelectEntries(System.String)">
             <summary>
             Retrieve entries from the zipfile by specified criteria.
             </summary>
            
             <remarks>
             <para>
             This method allows callers to retrieve the collection of entries from the zipfile
             that fit the specified criteria.  The criteria are described in a string format, and
             can include patterns for the filename; constraints on the size of the entry;
             constraints on the last modified, created, or last accessed time for the file
             described by the entry; or the attributes of the entry.
             </para>
            
             <para>
             For details on the syntax for the selectionCriteria parameter, see <see
             cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)"/>.
             </para>
            
             <para>
             This method is intended for use with a ZipFile that has been read from storage.
             When creating a new ZipFile, this method will work only after the ZipArchive has
             been Saved to the disk (the ZipFile class subsequently and implicitly reads the Zip
             archive from storage.)  Calling SelectEntries on a ZipFile that has not yet been
             saved will deliver undefined results.
             </para>
             </remarks>
            
             <exception cref="T:System.Exception">
             Thrown if selectionCriteria has an invalid syntax.
             </exception>
            
             <example>
             This example selects all the PhotoShop files from within an archive, and extracts them
             to the current working directory.
             <code>
             using (ZipFile zip1 = ZipFile.Read(ZipFileName))
             {
                 var PhotoShopFiles = zip1.SelectEntries("*.psd");
                 foreach (ZipEntry psd in PhotoShopFiles)
                 {
                     psd.Extract();
                 }
             }
             </code>
             <code lang="VB">
             Using zip1 As ZipFile = ZipFile.Read(ZipFileName)
                 Dim PhotoShopFiles as ICollection(Of ZipEntry)
                 PhotoShopFiles = zip1.SelectEntries("*.psd")
                 Dim psd As ZipEntry
                 For Each psd In PhotoShopFiles
                     psd.Extract
                 Next
             End Using
             </code>
             </example>
             <param name="selectionCriteria">the string that specifies which entries to select</param>
             <returns>a collection of ZipEntry objects that conform to the inclusion spec</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.SelectEntries(System.String,System.String)">
             <summary>
             Retrieve entries from the zipfile by specified criteria.
             </summary>
            
             <remarks>
             <para>
             This method allows callers to retrieve the collection of entries from the zipfile
             that fit the specified criteria.  The criteria are described in a string format, and
             can include patterns for the filename; constraints on the size of the entry;
             constraints on the last modified, created, or last accessed time for the file
             described by the entry; or the attributes of the entry.
             </para>
            
             <para>
             For details on the syntax for the selectionCriteria parameter, see <see
             cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)"/>.
             </para>
            
             <para>
             This method is intended for use with a ZipFile that has been read from storage.
             When creating a new ZipFile, this method will work only after the ZipArchive has
             been Saved to the disk (the ZipFile class subsequently and implicitly reads the Zip
             archive from storage.)  Calling SelectEntries on a ZipFile that has not yet been
             saved will deliver undefined results.
             </para>
             </remarks>
            
             <exception cref="T:System.Exception">
             Thrown if selectionCriteria has an invalid syntax.
             </exception>
            
             <example>
             <code>
             using (ZipFile zip1 = ZipFile.Read(ZipFileName))
             {
                 var UpdatedPhotoShopFiles = zip1.SelectEntries("*.psd", "UpdatedFiles");
                 foreach (ZipEntry e in UpdatedPhotoShopFiles)
                 {
                     // prompt for extract here
                     if (WantExtract(e.FileName))
                         e.Extract();
                 }
             }
             </code>
             <code lang="VB">
             Using zip1 As ZipFile = ZipFile.Read(ZipFileName)
                 Dim UpdatedPhotoShopFiles As ICollection(Of ZipEntry) = zip1.SelectEntries("*.psd", "UpdatedFiles")
                 Dim e As ZipEntry
                 For Each e In UpdatedPhotoShopFiles
                     ' prompt for extract here
                     If Me.WantExtract(e.FileName) Then
                         e.Extract
                     End If
                 Next
             End Using
             </code>
             </example>
             <param name="selectionCriteria">the string that specifies which entries to select</param>
            
             <param name="directoryPathInArchive">
             the directory in the archive from which to select entries. If null, then
             all directories in the archive are used.
             </param>
            
             <returns>a collection of ZipEntry objects that conform to the inclusion spec</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.RemoveSelectedEntries(System.String)">
             <summary>
             Remove entries from the zipfile by specified criteria.
             </summary>
            
             <remarks>
             <para>
             This method allows callers to remove the collection of entries from the zipfile
             that fit the specified criteria.  The criteria are described in a string format, and
             can include patterns for the filename; constraints on the size of the entry;
             constraints on the last modified, created, or last accessed time for the file
             described by the entry; or the attributes of the entry.
             </para>
            
             <para>
             For details on the syntax for the selectionCriteria parameter, see <see
             cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)"/>.
             </para>
            
             <para>
             This method is intended for use with a ZipFile that has been read from storage.
             When creating a new ZipFile, this method will work only after the ZipArchive has
             been Saved to the disk (the ZipFile class subsequently and implicitly reads the Zip
             archive from storage.)  Calling SelectEntries on a ZipFile that has not yet been
             saved will deliver undefined results.
             </para>
             </remarks>
            
             <exception cref="T:System.Exception">
             Thrown if selectionCriteria has an invalid syntax.
             </exception>
            
             <example>
             This example removes all entries in a zip file that were modified prior to January 1st, 2008.
             <code>
             using (ZipFile zip1 = ZipFile.Read(ZipFileName))
             {
                 // remove all entries from prior to Jan 1, 2008
                 zip1.RemoveEntries("mtime &lt; 2008-01-01");
                 // don't forget to save the archive!
                 zip1.Save();
             }
             </code>
             <code lang="VB">
             Using zip As ZipFile = ZipFile.Read(ZipFileName)
                 ' remove all entries from prior to Jan 1, 2008
                 zip1.RemoveEntries("mtime &lt; 2008-01-01")
                 ' do not forget to save the archive!
                 zip1.Save
             End Using
             </code>
             </example>
             <param name="selectionCriteria">the string that specifies which entries to select</param>
             <returns>the number of entries removed</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.RemoveSelectedEntries(System.String,System.String)">
             <summary>
             Remove entries from the zipfile by specified criteria, and within the specified
             path in the archive.
             </summary>
            
             <remarks>
             <para>
             This method allows callers to remove the collection of entries from the zipfile
             that fit the specified criteria.  The criteria are described in a string format, and
             can include patterns for the filename; constraints on the size of the entry;
             constraints on the last modified, created, or last accessed time for the file
             described by the entry; or the attributes of the entry.
             </para>
            
             <para>
             For details on the syntax for the selectionCriteria parameter, see <see
             cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)"/>.
             </para>
            
             <para>
             This method is intended for use with a ZipFile that has been read from storage.
             When creating a new ZipFile, this method will work only after the ZipArchive has
             been Saved to the disk (the ZipFile class subsequently and implicitly reads the Zip
             archive from storage.)  Calling SelectEntries on a ZipFile that has not yet been
             saved will deliver undefined results.
             </para>
             </remarks>
            
             <exception cref="T:System.Exception">
             Thrown if selectionCriteria has an invalid syntax.
             </exception>
            
             <example>
             <code>
             using (ZipFile zip1 = ZipFile.Read(ZipFileName))
             {
                 // remove all entries from prior to Jan 1, 2008
                 zip1.RemoveEntries("mtime &lt; 2008-01-01", "documents");
                 // a call to ZipFile.Save will make the modifications permanent
                 zip1.Save();
             }
             </code>
             <code lang="VB">
             Using zip As ZipFile = ZipFile.Read(ZipFileName)
                 ' remove all entries from prior to Jan 1, 2008
                 zip1.RemoveEntries("mtime &lt; 2008-01-01", "documents")
                 ' a call to ZipFile.Save will make the modifications permanent
                 zip1.Save
             End Using
             </code>
             </example>
            
             <param name="selectionCriteria">the string that specifies which entries to select</param>
             <param name="directoryPathInArchive">
             the directory in the archive from which to select entries. If null, then
             all directories in the archive are used.
             </param>
             <returns>the number of entries removed</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.ExtractSelectedEntries(System.String)">
             <summary>
             Selects and Extracts a set of Entries from the ZipFile.
             </summary>
            
             <remarks>
             <para>
             The entries are extracted into the current working directory.
             </para>
            
             <para>
             If any of the files to be extracted already exist, then the action taken is as
             specified in the <see cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile"/> property on the
             corresponding ZipEntry instance.  By default, the action taken in this case is to
             throw an exception.
             </para>
            
             <para>
             For information on the syntax of the selectionCriteria string,
             see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)" />.
             </para>
             </remarks>
            
             <example>
             This example shows how extract all XML files modified after 15 January 2009.
             <code>
             using (ZipFile zip = ZipFile.Read(zipArchiveName))
             {
               zip.ExtractSelectedEntries("name = *.xml  and  mtime &gt; 2009-01-15");
             }
             </code>
             </example>
             <param name="selectionCriteria">the selection criteria for entries to extract.</param>
            
             <seealso cref="M:Ionic.Zip.ZipFile.ExtractSelectedEntries(System.String,Ionic.Zip.ExtractExistingFileAction)"/>
        </member>
        <member name="M:Ionic.Zip.ZipFile.ExtractSelectedEntries(System.String,Ionic.Zip.ExtractExistingFileAction)">
             <summary>
             Selects and Extracts a set of Entries from the ZipFile.
             </summary>
            
             <remarks>
             <para>
             The entries are extracted into the current working directory. When extraction would would
             overwrite an existing filesystem file, the action taken is as specified in the
             <paramref name="extractExistingFile"/> parameter.
             </para>
            
             <para>
             For information on the syntax of the string describing the entry selection criteria,
             see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)" />.
             </para>
             </remarks>
            
             <example>
             This example shows how extract all XML files modified after 15 January 2009,
             overwriting any existing files.
             <code>
             using (ZipFile zip = ZipFile.Read(zipArchiveName))
             {
               zip.ExtractSelectedEntries("name = *.xml  and  mtime &gt; 2009-01-15",
                                          ExtractExistingFileAction.OverwriteSilently);
             }
             </code>
             </example>
            
             <param name="selectionCriteria">the selection criteria for entries to extract.</param>
            
             <param name="extractExistingFile">
             The action to take if extraction would overwrite an existing file.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.ExtractSelectedEntries(System.String,System.String)">
             <summary>
             Selects and Extracts a set of Entries from the ZipFile.
             </summary>
            
             <remarks>
             <para>
             The entries are selected from the specified directory within the archive, and then
             extracted into the current working directory.
             </para>
            
             <para>
             If any of the files to be extracted already exist, then the action taken is as
             specified in the <see cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile"/> property on the
             corresponding ZipEntry instance.  By default, the action taken in this case is to
             throw an exception.
             </para>
            
             <para>
             For information on the syntax of the string describing the entry selection criteria,
             see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)" />.
             </para>
             </remarks>
            
             <example>
             This example shows how extract all XML files modified after 15 January 2009,
             and writes them to the "unpack" directory.
             <code>
             using (ZipFile zip = ZipFile.Read(zipArchiveName))
             {
               zip.ExtractSelectedEntries("name = *.xml  and  mtime &gt; 2009-01-15","unpack");
             }
             </code>
             </example>
            
             <param name="selectionCriteria">the selection criteria for entries to extract.</param>
            
             <param name="directoryPathInArchive">
             the directory in the archive from which to select entries. If null, then
             all directories in the archive are used.
             </param>
            
             <seealso cref="M:Ionic.Zip.ZipFile.ExtractSelectedEntries(System.String,System.String,System.String,Ionic.Zip.ExtractExistingFileAction)"/>
        </member>
        <member name="M:Ionic.Zip.ZipFile.ExtractSelectedEntries(System.String,System.String,System.String)">
             <summary>
             Selects and Extracts a set of Entries from the ZipFile.
             </summary>
            
             <remarks>
             <para>
             The entries are extracted into the specified directory. If any of the files to be
             extracted already exist, an exception will be thrown.
             </para>
             <para>
             For information on the syntax of the string describing the entry selection criteria,
             see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)" />.
             </para>
             </remarks>
            
             <param name="selectionCriteria">the selection criteria for entries to extract.</param>
            
             <param name="directoryInArchive">
             the directory in the archive from which to select entries. If null, then
             all directories in the archive are used.
             </param>
            
             <param name="extractDirectory">
             the directory on the disk into which to extract. It will be created
             if it does not exist.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.ExtractSelectedEntries(System.String,System.String,System.String,Ionic.Zip.ExtractExistingFileAction)">
             <summary>
             Selects and Extracts a set of Entries from the ZipFile.
             </summary>
            
             <remarks>
             <para>
             The entries are extracted into the specified directory. When extraction would would
             overwrite an existing filesystem file, the action taken is as specified in the
             <paramref name="extractExistingFile"/> parameter.
             </para>
            
             <para>
             For information on the syntax of the string describing the entry selection criteria,
             see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)" />.
             </para>
             </remarks>
            
             <example>
             This example shows how extract all files  with an XML extension or with  a size larger than 100,000 bytes,
             and puts them in the unpack directory.  For any files that already exist in
             that destination directory, they will not be overwritten.
             <code>
             using (ZipFile zip = ZipFile.Read(zipArchiveName))
             {
               zip.ExtractSelectedEntries("name = *.xml  or  size &gt; 100000",
                                          null,
                                          "unpack",
                                          ExtractExistingFileAction.DontOverwrite);
             }
             </code>
             </example>
            
             <param name="selectionCriteria">the selection criteria for entries to extract.</param>
            
             <param name="extractDirectory">
             The directory on the disk into which to extract. It will be created if it does not exist.
             </param>
            
             <param name="directoryPathInArchive">
             The directory in the archive from which to select entries. If null, then
             all directories in the archive are used.
             </param>
            
             <param name="extractExistingFile">
             The action to take if extraction would overwrite an existing file.
             </param>
            
        </member>
        <member name="M:Ionic.Zip.ZipFile.GetEnumerator">
             <summary>
             Generic IEnumerator support, for use of a ZipFile in an enumeration.
             </summary>
            
             <remarks>
             You probably do not want to call <c>GetEnumerator</c> explicitly. Instead
             it is implicitly called when you use a <see langword="foreach"/> loop in C#, or a
             <c>For Each</c> loop in VB.NET.
             </remarks>
            
             <example>
             This example reads a zipfile of a given name, then enumerates the
             entries in that zip file, and displays the information about each
             entry on the Console.
             <code>
             using (ZipFile zip = ZipFile.Read(zipfile))
             {
               bool header = true;
               foreach (ZipEntry e in zip)
               {
                 if (header)
                 {
                    System.Console.WriteLine("Zipfile: {0}", zip.Name);
                    System.Console.WriteLine("Version Needed: 0x{0:X2}", e.VersionNeeded);
                    System.Console.WriteLine("BitField: 0x{0:X2}", e.BitField);
                    System.Console.WriteLine("Compression Method: 0x{0:X2}", e.CompressionMethod);
                    System.Console.WriteLine("\n{1,-22} {2,-6} {3,4}   {4,-8}  {0}",
                                 "Filename", "Modified", "Size", "Ratio", "Packed");
                    System.Console.WriteLine(new System.String('-', 72));
                    header = false;
                 }
            
                 System.Console.WriteLine("{1,-22} {2,-6} {3,4:F0}%   {4,-8}  {0}",
                             e.FileName,
                             e.LastModified.ToString("yyyy-MM-dd HH:mm:ss"),
                             e.UncompressedSize,
                             e.CompressionRatio,
                             e.CompressedSize);
            
                 e.Extract();
               }
             }
             </code>
            
             <code lang="VB">
               Dim ZipFileToExtract As String = "c:\foo.zip"
               Using zip As ZipFile = ZipFile.Read(ZipFileToExtract)
                   Dim header As Boolean = True
                   Dim e As ZipEntry
                   For Each e In zip
                       If header Then
                           Console.WriteLine("Zipfile: {0}", zip.Name)
                           Console.WriteLine("Version Needed: 0x{0:X2}", e.VersionNeeded)
                           Console.WriteLine("BitField: 0x{0:X2}", e.BitField)
                           Console.WriteLine("Compression Method: 0x{0:X2}", e.CompressionMethod)
                           Console.WriteLine(ChrW(10) &amp; "{1,-22} {2,-6} {3,4}   {4,-8}  {0}", _
                             "Filename", "Modified", "Size", "Ratio", "Packed" )
                           Console.WriteLine(New String("-"c, 72))
                           header = False
                       End If
                       Console.WriteLine("{1,-22} {2,-6} {3,4:F0}%   {4,-8}  {0}", _
                         e.FileName, _
                         e.LastModified.ToString("yyyy-MM-dd HH:mm:ss"), _
                         e.UncompressedSize, _
                         e.CompressionRatio, _
                         e.CompressedSize )
                       e.Extract
                   Next
               End Using
             </code>
             </example>
            
             <returns>A generic enumerator suitable for use  within a foreach loop.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.GetNewEnum">
             <summary>
             An IEnumerator, for use of a ZipFile in a foreach construct.
             </summary>
            
             <remarks>
             This method is included for COM support.  An application generally does not call
             this method directly.  It is called implicitly by COM clients when enumerating
             the entries in the ZipFile instance.  In VBScript, this is done with a <c>For Each</c>
             statement.  In Javascript, this is done with <c>new Enumerator(zipfile)</c>.
             </remarks>
            
             <returns>
             The IEnumerator over the entries in the ZipFile.
             </returns>
        </member>
        <member name="T:Ionic.Zip.Zip64Option">
             <summary>
               Options for using ZIP64 extensions when saving zip archives.
             </summary>
            
             <remarks>
            
             <para>
               Designed many years ago, the <see
               href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">original zip
               specification from PKWARE</see> allowed for 32-bit quantities for the
               compressed and uncompressed sizes of zip entries, as well as a 32-bit quantity
               for specifying the length of the zip archive itself, and a maximum of 65535
               entries.  These limits are now regularly exceeded in many backup and archival
               scenarios.  Recently, PKWare added extensions to the original zip spec, called
               "ZIP64 extensions", to raise those limitations.  This property governs whether
               DotNetZip will use those extensions when writing zip archives. The use of
               these extensions is optional and explicit in DotNetZip because, despite the
               status of ZIP64 as a bona fide standard, many other zip tools and libraries do
               not support ZIP64, and therefore a zip file with ZIP64 extensions may be
               unreadable by some of those other tools.
             </para>
            
             <para>
               Set this property to <see cref="F:Ionic.Zip.Zip64Option.Always"/> to always use ZIP64
               extensions when saving, regardless of whether your zip archive needs it.
               Suppose you add 5 files, each under 100k, to a ZipFile. If you specify Always
               for this flag, you will get a ZIP64 archive, though the archive does not need
               to use ZIP64 because none of the original zip limits had been exceeded.
             </para>
            
             <para>
               Set this property to <see cref="F:Ionic.Zip.Zip64Option.Never"/> to tell the DotNetZip
               library to never use ZIP64 extensions.  This is useful for maximum
               compatibility and interoperability, at the expense of the capability of
               handling large files or large archives.  NB: Windows Explorer in Windows XP
               and Windows Vista cannot currently extract files from a zip64 archive, so if
               you want to guarantee that a zip archive produced by this library will work in
               Windows Explorer, use <c>Never</c>. If you set this property to <see
               cref="F:Ionic.Zip.Zip64Option.Never"/>, and your application creates a zip that would
               exceed one of the Zip limits, the library will throw an exception while saving
               the zip file.
             </para>
            
             <para>
               Set this property to <see cref="F:Ionic.Zip.Zip64Option.AsNecessary"/> to tell the
               DotNetZip library to use the ZIP64 extensions when required by the
               entry. After the file is compressed, the original and compressed sizes are
               checked, and if they exceed the limits described above, then zip64 can be
               used. That is the general idea, but there is an additional wrinkle when saving
               to a non-seekable device, like the ASP.NET <c>Response.OutputStream</c>, or
               <c>Console.Out</c>.  When using non-seekable streams for output, the entry
               header - which indicates whether zip64 is in use - is emitted before it is
               known if zip64 is necessary.  It is only after all entries have been saved
               that it can be known if ZIP64 will be required.  On seekable output streams,
               after saving all entries, the library can seek backward and re-emit the zip
               file header to be consistent with the actual ZIP64 requirement.  But using a
               non-seekable output stream, the library cannot seek backward, so the header
               can never be changed. In other words, the archive's use of ZIP64 extensions is
               not alterable after the header is emitted.  Therefore, when saving to
               non-seekable streams, using <see cref="F:Ionic.Zip.Zip64Option.AsNecessary"/> is the same
               as using <see cref="F:Ionic.Zip.Zip64Option.Always"/>: it will always produce a zip
               archive that uses ZIP64 extensions.
             </para>
            
             </remarks>
        </member>
        <member name="F:Ionic.Zip.Zip64Option.Default">
            <summary>
            The default behavior, which is "Never".
            (For COM clients, this is a 0 (zero).)
            </summary>
        </member>
        <member name="F:Ionic.Zip.Zip64Option.Never">
            <summary>
            Do not use ZIP64 extensions when writing zip archives.
            (For COM clients, this is a 0 (zero).)
            </summary>
        </member>
        <member name="F:Ionic.Zip.Zip64Option.AsNecessary">
            <summary>
            Use ZIP64 extensions when writing zip archives, as necessary.
            For example, when a single entry exceeds 0xFFFFFFFF in size, or when the archive as a whole
            exceeds 0xFFFFFFFF in size, or when there are more than 65535 entries in an archive.
            (For COM clients, this is a 1.)
            </summary>
        </member>
        <member name="F:Ionic.Zip.Zip64Option.Always">
            <summary>
            Always use ZIP64 extensions when writing zip archives, even when unnecessary.
            (For COM clients, this is a 2.)
            </summary>
        </member>
        <member name="T:Ionic.Zip.ZipOption">
            <summary>
             An enum representing the values on a three-way toggle switch
             for various options in the library. This might be used to
             specify whether to employ a particular text encoding, or to use
             ZIP64 extensions, or some other option.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipOption.Default">
            <summary>
            The default behavior. This is the same as "Never".
            (For COM clients, this is a 0 (zero).)
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipOption.Never">
            <summary>
            Never use the associated option.
            (For COM clients, this is a 0 (zero).)
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipOption.AsNecessary">
            <summary>
            Use the associated behavior "as necessary."
            (For COM clients, this is a 1.)
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipOption.Always">
            <summary>
            Use the associated behavior Always, whether necessary or not.
            (For COM clients, this is a 2.)
            </summary>
        </member>
        <member name="T:Ionic.Zip.ReadOptions">
             <summary>
               A class for collecting the various options that can be used when
               Reading zip files for extraction or update.
             </summary>
            
             <remarks>
               <para>
                 When reading a zip file, there are several options an
                 application can set, to modify how the file is read, or what
                 the library does while reading.  This class collects those
                 options into one container.
               </para>
            
               <para>
                 Pass an instance of the <c>ReadOptions</c> class into the
                 <c>ZipFile.Read()</c> method.
               </para>
            
             <seealso cref="M:Ionic.Zip.ZipFile.Read(System.String,Ionic.Zip.ReadOptions)"/>.
             <seealso cref="M:Ionic.Zip.ZipFile.Read(System.IO.Stream,Ionic.Zip.ReadOptions)"/>.
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ReadOptions.ReadProgress">
            <summary>
            An event handler for Read operations.  When opening large zip
            archives, you may want to display a progress bar or other
            indicator of status progress while reading.  This parameter
            allows you to specify a ReadProgress Event Handler directly.
            When you call <c>Read()</c>, the progress event is invoked as
            necessary.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ReadOptions.StatusMessageWriter">
            <summary>
            The <c>System.IO.TextWriter</c> to use for writing verbose status messages
            during operations on the zip archive.  A console application may wish to
            pass <c>System.Console.Out</c> to get messages on the Console. A graphical
            or headless application may wish to capture the messages in a different
            <c>TextWriter</c>, such as a <c>System.IO.StringWriter</c>.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ReadOptions.Encoding">
             <summary>
             The <c>System.Text.Encoding</c> to use when reading in the zip archive. Be
             careful specifying the encoding.  If the value you use here is not the same
             as the Encoding used when the zip archive was created (possibly by a
             different archiver) you will get unexpected results and possibly exceptions.
             </summary>
            
             <seealso cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>
            
        </member>
        <member name="T:Ionic.Zip.SelfExtractorFlavor">
            <summary>
            An enum that provides the different self-extractor flavors
            </summary>
        </member>
        <member name="F:Ionic.Zip.SelfExtractorFlavor.ConsoleApplication">
            <summary>
            A self-extracting zip archive that runs from the console or
            command line.
            </summary>
        </member>
        <member name="F:Ionic.Zip.SelfExtractorFlavor.WinFormsApplication">
            <summary>
            A self-extracting zip archive that presents a graphical user
            interface when it is executed.
            </summary>
        </member>
        <member name="T:Ionic.Zip.SelfExtractorSaveOptions">
            <summary>
            The options for generating a self-extracting archive.
            </summary>
        </member>
        <member name="P:Ionic.Zip.SelfExtractorSaveOptions.Flavor">
            <summary>
              The type of SFX to create.
            </summary>
        </member>
        <member name="P:Ionic.Zip.SelfExtractorSaveOptions.PostExtractCommandLine">
             <summary>
               The command to run after extraction.
             </summary>
            
             <remarks>
             <para>
               This is optional. Leave it empty (<c>null</c> in C# or <c>Nothing</c> in
               VB) to run no command after extraction.
             </para>
            
             <para>
               If it is non-empty, the SFX will execute the command specified in this
               string on the user's machine, and using the extract directory as the
               working directory for the process, after unpacking the archive. The
               program to execute can include a path, if you like. If you want to execute
               a program that accepts arguments, specify the program name, followed by a
               space, and then the arguments for the program, each separated by a space,
               just as you would on a normal command line. Example: <c>program.exe arg1
               arg2</c>.  The string prior to the first space will be taken as the
               program name, and the string following the first space specifies the
               arguments to the program.
             </para>
            
             <para>
               If you want to execute a program that has a space in the name or path of
               the file, surround the program name in double-quotes. The first character
               of the command line should be a double-quote character, and there must be
               a matching double-quote following the end of the program file name. Any
               optional arguments to the program follow that, separated by
               spaces. Example: <c>"c:\project files\program name.exe" arg1 arg2</c>.
             </para>
            
             <para>
               If the flavor of the SFX is <c>SelfExtractorFlavor.ConsoleApplication</c>,
               then the SFX starts a new process, using this string as the post-extract
               command line.  The SFX waits for the process to exit.  The exit code of
               the post-extract command line is returned as the exit code of the
               command-line self-extractor exe. A non-zero exit code is typically used to
               indicated a failure by the program. In the case of an SFX, a non-zero exit
               code may indicate a failure during extraction, OR, it may indicate a
               failure of the run-after-extract program if specified, OR, it may indicate
               the run-after-extract program could not be fuond. There is no way to
               distinguish these conditions from the calling shell, aside from parsing
               the output of the SFX. If you have Quiet set to <c>true</c>, you may not
               see error messages, if a problem occurs.
             </para>
            
             <para>
               If the flavor of the SFX is
               <c>SelfExtractorFlavor.WinFormsApplication</c>, then the SFX starts a new
               process, using this string as the post-extract command line, and using the
               extract directory as the working directory for the process. The SFX does
               not wait for the command to complete, and does not check the exit code of
               the program. If the run-after-extract program cannot be fuond, a message
               box is displayed indicating that fact.
             </para>
            
             <para>
               You can specify environment variables within this string, with a format like
               <c>%NAME%</c>. The value of these variables will be expanded at the time
               the SFX is run. Example: <c>%WINDIR%\system32\xcopy.exe</c> may expand at
               runtime to <c>c:\Windows\System32\xcopy.exe</c>.
             </para>
            
             <para>
               By combining this with the <c>RemoveUnpackedFilesAfterExecute</c>
               flag, you can create an SFX that extracts itself, runs a file that
               was extracted, then deletes all the files that were extracted. If
               you want it to run "invisibly" then set <c>Flavor</c> to
               <c>SelfExtractorFlavor.ConsoleApplication</c>, and set <c>Quiet</c>
               to true.  The user running such an EXE will see a console window
               appear, then disappear quickly.  You may also want to specify the
               default extract location, with <c>DefaultExtractDirectory</c>.
             </para>
            
             <para>
               If you set <c>Flavor</c> to
               <c>SelfExtractorFlavor.WinFormsApplication</c>, and set <c>Quiet</c> to
               true, then a GUI with progressbars is displayed, but it is
               "non-interactive" - it accepts no input from the user.  Instead the SFX
               just automatically unpacks and exits.
             </para>
            
             </remarks>
        </member>
        <member name="P:Ionic.Zip.SelfExtractorSaveOptions.DefaultExtractDirectory">
             <summary>
               The default extract directory the user will see when
               running the self-extracting archive.
             </summary>
            
             <remarks>
             <para>
               Passing null (or Nothing in VB) here will cause the Self Extractor to use
               the the user's personal directory (<see
               cref="F:System.Environment.SpecialFolder.Personal"/>) for the default extract
               location.
             </para>
            
             <para>
               This is only a default location.  The actual extract location will be
               settable on the command line when the SFX is executed.
             </para>
            
             <para>
               You can specify environment variables within this string,
               with <c>%NAME%</c>. The value of these variables will be
               expanded at the time the SFX is run. Example:
               <c>%USERPROFILE%\Documents\unpack</c> may expand at runtime to
               <c>c:\users\melvin\Documents\unpack</c>.
             </para>
             </remarks>
        </member>
        <member name="P:Ionic.Zip.SelfExtractorSaveOptions.IconFile">
             <summary>
               The name of an .ico file in the filesystem to use for the application icon
               for the generated SFX.
             </summary>
            
             <remarks>
             <para>
               Normally, DotNetZip will embed an "zipped folder" icon into the generated
               SFX.  If you prefer to use a different icon, you can specify it here. It
               should be a .ico file.  This file is passed as the <c>/win32icon</c>
               option to the csc.exe compiler when constructing the SFX file.
             </para>
             </remarks>
            
        </member>
        <member name="P:Ionic.Zip.SelfExtractorSaveOptions.Quiet">
             <summary>
               Whether the ConsoleApplication SFX will be quiet during extraction.
             </summary>
            
             <remarks>
             <para>
               This option affects the way the generated SFX runs. By default it is
               false.  When you set it to true,...
             </para>
            
             <list type="table">
               <listheader>
                 <term>Flavor</term>
                 <description>Behavior</description>
               </listheader>
            
             <item>
               <term><c>ConsoleApplication</c></term>
               <description><para>no messages will be emitted during successful
                 operation.</para> <para> Double-clicking the SFX in Windows
                 Explorer or as an attachment in an email will cause a console
                 window to appear briefly, before it disappears. If you run the
                 ConsoleApplication SFX from the cmd.exe prompt, it runs as a
                 normal console app; by default, because it is quiet, it displays
                 no messages to the console.  If you pass the -v+ command line
                 argument to the Console SFX when you run it, you will get verbose
                 messages to the console. </para>
               </description>
             </item>
            
             <item>
               <term><c>WinFormsApplication</c></term>
               <description>the SFX extracts automatically when the application
                    is launched, with no additional user input.
               </description>
             </item>
            
             </list>
            
             <para>
               When you set it to false,...
             </para>
            
             <list type="table">
               <listheader>
                 <term>Flavor</term>
                 <description>Behavior</description>
               </listheader>
            
             <item>
               <term><c>ConsoleApplication</c></term>
               <description><para>the extractor will emit a
                 message to the console for each entry extracted.</para>
                 <para>
                   When double-clicking to launch the SFX, the console window will
                   remain, and the SFX will emit a message for each file as it
                   extracts. The messages fly by quickly, they won't be easily
                   readable, unless the extracted files are fairly large.
                 </para>
               </description>
             </item>
            
             <item>
               <term><c>WinFormsApplication</c></term>
               <description>the SFX presents a forms UI and allows the user to select
                 options before extracting.
               </description>
             </item>
            
             </list>
            
             </remarks>
        </member>
        <member name="P:Ionic.Zip.SelfExtractorSaveOptions.ExtractExistingFile">
            <summary>
              Specify what the self-extractor will do when extracting an entry
              would overwrite an existing file.
            </summary>
            <remarks>
            <para>
              The default behavvior is to Throw.
            </para>
            </remarks>
        </member>
        <member name="P:Ionic.Zip.SelfExtractorSaveOptions.RemoveUnpackedFilesAfterExecute">
             <summary>
               Whether to remove the files that have been unpacked, after executing the
               PostExtractCommandLine.
             </summary>
            
             <remarks>
             <para>
               If true, and if there is a <see
               cref="P:Ionic.Zip.SelfExtractorSaveOptions.PostExtractCommandLine">
               PostExtractCommandLine</see>, and if the command runs successfully,
               then the files that the SFX unpacked will be removed, afterwards.  If
               the command does not complete successfully (non-zero return code),
               that is interpreted as a failure, and the extracted files will not be
               removed.
             </para>
            
             <para>
               Setting this flag, and setting <c>Flavor</c> to
               <c>SelfExtractorFlavor.ConsoleApplication</c>, and setting <c>Quiet</c> to
               true, results in an SFX that extracts itself, runs a file that was
               extracted, then deletes all the files that were extracted, with no
               intervention by the user.  You may also want to specify the default
               extract location, with <c>DefaultExtractDirectory</c>.
             </para>
            
             </remarks>
        </member>
        <member name="P:Ionic.Zip.SelfExtractorSaveOptions.FileVersion">
             <summary>
               The file version number to embed into the generated EXE. It will show up, for
               example, during a mouseover in Windows Explorer.
             </summary>
            
        </member>
        <member name="P:Ionic.Zip.SelfExtractorSaveOptions.ProductVersion">
             <summary>
               The product version to embed into the generated EXE. It will show up, for
               example, during a mouseover in Windows Explorer.
             </summary>
            
             <remarks>
               You can use any arbitrary string, but a human-readable version number is
               recommended. For example "v1.2 alpha" or "v4.2 RC2".  If you specify nothing,
               then there is no product version embedded into the EXE.
             </remarks>
            
        </member>
        <member name="P:Ionic.Zip.SelfExtractorSaveOptions.Copyright">
             <summary>
               The copyright notice, if any, to embed into the generated EXE.
             </summary>
            
             <remarks>
               It will show up, for example, while viewing properties of the file in
               Windows Explorer.  You can use any arbitrary string, but typically you
               want something like "Copyright ?Dino Chiesa 2011".
             </remarks>
            
        </member>
        <member name="P:Ionic.Zip.SelfExtractorSaveOptions.Description">
             <summary>
               The description to embed into the generated EXE.
             </summary>
            
             <remarks>
               Use any arbitrary string.  This text will be displayed during a
               mouseover in Windows Explorer.  If you specify nothing, then the string
               "DotNetZip SFX Archive" is embedded into the EXE as the description.
             </remarks>
            
        </member>
        <member name="P:Ionic.Zip.SelfExtractorSaveOptions.ProductName">
             <summary>
               The product name to embed into the generated EXE.
             </summary>
            
             <remarks>
               Use any arbitrary string. This text will be displayed
               while viewing properties of the EXE file in
               Windows Explorer.
             </remarks>
            
        </member>
        <member name="P:Ionic.Zip.SelfExtractorSaveOptions.SfxExeWindowTitle">
             <summary>
               The title to display in the Window of a GUI SFX, while it extracts.
             </summary>
            
             <remarks>
               <para>
                 By default the title show in the GUI window of a self-extractor
                 is "DotNetZip Self-extractor (http://DotNetZip.codeplex.com/)".
                 You can change that by setting this property before saving the SFX.
               </para>
            
               <para>
                 This property has an effect only when producing a Self-extractor
                 of flavor <c>SelfExtractorFlavor.WinFormsApplication</c>.
               </para>
             </remarks>
            
        </member>
        <member name="P:Ionic.Zip.SelfExtractorSaveOptions.AdditionalCompilerSwitches">
            <summary>
              Additional options for the csc.exe compiler, when producing the SFX
              EXE.
            </summary>
            <exclude/>
        </member>
        <member name="T:Ionic.Zip.ZipInputStream">
             <summary>
               Provides a stream metaphor for reading zip files.
             </summary>
            
             <remarks>
             <para>
               This class provides an alternative programming model for reading zip files to
               the one enabled by the <see cref="T:Ionic.Zip.ZipFile"/> class.  Use this when reading zip
               files, as an alternative to the <see cref="T:Ionic.Zip.ZipFile"/> class, when you would
               like to use a Stream class to read the file.
             </para>
            
             <para>
               Some application designs require a readable stream for input. This stream can
               be used to read a zip file, and extract entries.
             </para>
            
             <para>
               Both the <c>ZipInputStream</c> class and the <c>ZipFile</c> class can be used
               to read and extract zip files.  Both of them support many of the common zip
               features, including Unicode, different compression levels, and ZIP64.  The
               programming models differ. For example, when extracting entries via calls to
               the <c>GetNextEntry()</c> and <c>Read()</c> methods on the
               <c>ZipInputStream</c> class, the caller is responsible for creating the file,
               writing the bytes into the file, setting the attributes on the file, and
               setting the created, last modified, and last accessed timestamps on the
               file. All of these things are done automatically by a call to <see
               cref="M:Ionic.Zip.ZipEntry.Extract">ZipEntry.Extract()</see>.  For this reason, the
               <c>ZipInputStream</c> is generally recommended for when your application wants
               to extract the data, without storing that data into a file.
             </para>
            
             <para>
               Aside from the obvious differences in programming model, there are some
               differences in capability between the <c>ZipFile</c> class and the
               <c>ZipInputStream</c> class.
             </para>
            
             <list type="bullet">
               <item>
                 <c>ZipFile</c> can be used to create or update zip files, or read and
                 extract zip files. <c>ZipInputStream</c> can be used only to read and
                 extract zip files. If you want to use a stream to create zip files, check
                 out the <see cref="T:Ionic.Zip.ZipOutputStream"/>.
               </item>
            
               <item>
                 <c>ZipInputStream</c> cannot read segmented or spanned
                 zip files.
               </item>
            
               <item>
                 <c>ZipInputStream</c> will not read Zip file comments.
               </item>
            
               <item>
                 When reading larger files, <c>ZipInputStream</c> will always underperform
                 <c>ZipFile</c>. This is because the <c>ZipInputStream</c> does a full scan on the
                 zip file, while the <c>ZipFile</c> class reads the central directory of the
                 zip file.
               </item>
            
             </list>
            
             </remarks>
        </member>
        <member name="M:Ionic.Zip.ZipInputStream.#ctor(System.IO.Stream)">
             <summary>
               Create a <c>ZipInputStream</c>, wrapping it around an existing stream.
             </summary>
            
             <remarks>
            
             <para>
               While the <see cref="T:Ionic.Zip.ZipFile"/> class is generally easier
               to use, this class provides an alternative to those
               applications that want to read from a zipfile directly,
               using a <see cref="T:System.IO.Stream"/>.
             </para>
            
             <para>
               Both the <c>ZipInputStream</c> class and the <c>ZipFile</c> class can be used
               to read and extract zip files.  Both of them support many of the common zip
               features, including Unicode, different compression levels, and ZIP64.  The
               programming models differ. For example, when extracting entries via calls to
               the <c>GetNextEntry()</c> and <c>Read()</c> methods on the
               <c>ZipInputStream</c> class, the caller is responsible for creating the file,
               writing the bytes into the file, setting the attributes on the file, and
               setting the created, last modified, and last accessed timestamps on the
               file. All of these things are done automatically by a call to <see
               cref="M:Ionic.Zip.ZipEntry.Extract">ZipEntry.Extract()</see>.  For this reason, the
               <c>ZipInputStream</c> is generally recommended for when your application wants
               to extract the data, without storing that data into a file.
             </para>
            
             <para>
               Aside from the obvious differences in programming model, there are some
               differences in capability between the <c>ZipFile</c> class and the
               <c>ZipInputStream</c> class.
             </para>
            
             <list type="bullet">
               <item>
               <c>ZipFile</c> can be used to create or update zip files, or read and extract
               zip files. <c>ZipInputStream</c> can be used only to read and extract zip
                 files. If you want to use a stream to create zip files, check out the <see
                 cref="T:Ionic.Zip.ZipOutputStream"/>.
               </item>
            
               <item>
                 <c>ZipInputStream</c> cannot read segmented or spanned
                 zip files.
               </item>
            
               <item>
                 <c>ZipInputStream</c> will not read Zip file comments.
               </item>
            
               <item>
                 When reading larger files, <c>ZipInputStream</c> will always underperform
                 <c>ZipFile</c>. This is because the <c>ZipInputStream</c> does a full scan on the
                 zip file, while the <c>ZipFile</c> class reads the central directory of the
                 zip file.
               </item>
            
             </list>
            
             </remarks>
            
             <param name="stream">
               The stream to read. It must be readable. This stream will be closed at
               the time the <c>ZipInputStream</c> is closed.
             </param>
            
             <example>
            
               This example shows how to read a zip file, and extract entries, using the
               <c>ZipInputStream</c> class.
            
             <code lang="C#">
             private void Unzip()
             {
                 byte[] buffer= new byte[2048];
                 int n;
                 using (var raw = File.Open(inputFileName, FileMode.Open, FileAccess.Read))
                 {
                     using (var input= new ZipInputStream(raw))
                     {
                         ZipEntry e;
                         while (( e = input.GetNextEntry()) != null)
                         {
                             if (e.IsDirectory) continue;
                             string outputPath = Path.Combine(extractDir, e.FileName);
                             using (var output = File.Open(outputPath, FileMode.Create, FileAccess.ReadWrite))
                             {
                                 while ((n= input.Read(buffer, 0, buffer.Length)) > 0)
                                 {
                                     output.Write(buffer,0,n);
                                 }
                             }
                         }
                     }
                 }
             }
             </code>
            
             <code lang="VB">
             Private Sub UnZip()
                 Dim inputFileName As String = "MyArchive.zip"
                 Dim extractDir As String = "extract"
                 Dim buffer As Byte() = New Byte(2048) {}
                 Using raw As FileStream = File.Open(inputFileName, FileMode.Open, FileAccess.Read)
                     Using input As ZipInputStream = New ZipInputStream(raw)
                         Dim e As ZipEntry
                         Do While (Not e = input.GetNextEntry Is Nothing)
                             If Not e.IsDirectory Then
                                 Using output As FileStream = File.Open(Path.Combine(extractDir, e.FileName), _
                                                                        FileMode.Create, FileAccess.ReadWrite)
                                     Dim n As Integer
                                     Do While (n = input.Read(buffer, 0, buffer.Length) > 0)
                                         output.Write(buffer, 0, n)
                                     Loop
                                 End Using
                             End If
                         Loop
                     End Using
                 End Using
             End Sub
             </code>
             </example>
        </member>
        <member name="M:Ionic.Zip.ZipInputStream.#ctor(System.String)">
             <summary>
               Create a <c>ZipInputStream</c>, given the name of an existing zip file.
             </summary>
            
             <remarks>
            
             <para>
               This constructor opens a <c>FileStream</c> for the given zipfile, and
               wraps a <c>ZipInputStream</c> around that.  See the documentation for the
               <see cref="M:Ionic.Zip.ZipInputStream.#ctor(System.IO.Stream)"/> constructor for full details.
             </para>
            
             <para>
               While the <see cref="T:Ionic.Zip.ZipFile"/> class is generally easier
               to use, this class provides an alternative to those
               applications that want to read from a zipfile directly,
               using a <see cref="T:System.IO.Stream"/>.
             </para>
            
             </remarks>
            
             <param name="fileName">
               The name of the filesystem file to read.
             </param>
            
             <example>
            
               This example shows how to read a zip file, and extract entries, using the
               <c>ZipInputStream</c> class.
            
             <code lang="C#">
             private void Unzip()
             {
                 byte[] buffer= new byte[2048];
                 int n;
                 using (var input= new ZipInputStream(inputFileName))
                 {
                     ZipEntry e;
                     while (( e = input.GetNextEntry()) != null)
                     {
                         if (e.IsDirectory) continue;
                         string outputPath = Path.Combine(extractDir, e.FileName);
                         using (var output = File.Open(outputPath, FileMode.Create, FileAccess.ReadWrite))
                         {
                             while ((n= input.Read(buffer, 0, buffer.Length)) > 0)
                             {
                                 output.Write(buffer,0,n);
                             }
                         }
                     }
                 }
             }
             </code>
            
             <code lang="VB">
             Private Sub UnZip()
                 Dim inputFileName As String = "MyArchive.zip"
                 Dim extractDir As String = "extract"
                 Dim buffer As Byte() = New Byte(2048) {}
                 Using input As ZipInputStream = New ZipInputStream(inputFileName)
                     Dim e As ZipEntry
                     Do While (Not e = input.GetNextEntry Is Nothing)
                         If Not e.IsDirectory Then
                             Using output As FileStream = File.Open(Path.Combine(extractDir, e.FileName), _
                                                                    FileMode.Create, FileAccess.ReadWrite)
                                 Dim n As Integer
                                 Do While (n = input.Read(buffer, 0, buffer.Length) > 0)
                                     output.Write(buffer, 0, n)
                                 Loop
                             End Using
                         End If
                     Loop
                 End Using
             End Sub
             </code>
             </example>
        </member>
        <member name="M:Ionic.Zip.ZipInputStream.#ctor(System.IO.Stream,System.Boolean)">
             <summary>
               Create a <c>ZipInputStream</c>, explicitly specifying whether to
               keep the underlying stream open.
             </summary>
            
             <remarks>
               See the documentation for the <see
               cref="M:Ionic.Zip.ZipInputStream.#ctor(System.IO.Stream)">ZipInputStream(Stream)</see>
               constructor for a discussion of the class, and an example of how to use the class.
             </remarks>
            
             <param name="stream">
               The stream to read from. It must be readable.
             </param>
            
             <param name="leaveOpen">
               true if the application would like the stream
               to remain open after the <c>ZipInputStream</c> has been closed.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipInputStream.ToString">
            <summary>Provides a string representation of the instance.</summary>
            <remarks>
              <para>
                This can be useful for debugging purposes.
              </para>
            </remarks>
            <returns>a string representation of the instance.</returns>
        </member>
        <member name="P:Ionic.Zip.ZipInputStream.ProvisionalAlternateEncoding">
             <summary>
               The text encoding to use when reading entries into the zip archive, for
               those entries whose filenames or comments cannot be encoded with the
               default (IBM437) encoding.
             </summary>
            
             <remarks>
             <para>
               In <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">its
               zip specification</see>, PKWare describes two options for encoding
               filenames and comments: using IBM437 or UTF-8.  But, some archiving tools
               or libraries do not follow the specification, and instead encode
               characters using the system default code page.  For example, WinRAR when
               run on a machine in Shanghai may encode filenames with the Big-5 Chinese
               (950) code page.  This behavior is contrary to the Zip specification, but
               it occurs anyway.
             </para>
            
             <para>
               When using DotNetZip to read zip archives that use something other than
               UTF-8 or IBM437, set this property to specify the code page to use when
               reading encoded filenames and comments for each <c>ZipEntry</c> in the zip
               file.
             </para>
            
             <para>
               This property is "provisional". When the entry in the zip archive is not
               explicitly marked as using UTF-8, then IBM437 is used to decode filenames
               and comments. If a loss of data would result from using IBM436 -
               specifically when encoding and decoding is not reflexive - the codepage
               specified here is used. It is possible, therefore, to have a given entry
               with a <c>Comment</c> encoded in IBM437 and a <c>FileName</c> encoded with
               the specified "provisional" codepage.
             </para>
            
             <para>
               When a zip file uses an arbitrary, non-UTF8 code page for encoding, there
               is no standard way for the reader application - whether DotNetZip, WinZip,
               WinRar, or something else - to know which codepage has been used for the
               entries. Readers of zip files are not able to inspect the zip file and
               determine the codepage that was used for the entries contained within it.
               It is left to the application or user to determine the necessary codepage
               when reading zip files encoded this way.  If you use an incorrect codepage
               when reading a zipfile, you will get entries with filenames that are
               incorrect, and the incorrect filenames may even contain characters that
               are not legal for use within filenames in Windows. Extracting entries with
               illegal characters in the filenames will lead to exceptions. It's too bad,
               but this is just the way things are with code pages in zip files. Caveat
               Emptor.
             </para>
            
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipInputStream.CodecBufferSize">
             <summary>
               Size of the work buffer to use for the ZLIB codec during decompression.
             </summary>
            
             <remarks>
               Setting this affects the performance and memory efficiency of compression
               and decompression.  For larger files, setting this to a larger size may
               improve performance, but the exact numbers vary depending on available
               memory, and a bunch of other variables. I don't have good firm
               recommendations on how to set it.  You'll have to test it yourself. Or
               just leave it alone and accept the default.
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipInputStream.Password">
             <summary>
               Sets the password to be used on the <c>ZipInputStream</c> instance.
             </summary>
            
             <remarks>
            
             <para>
               When reading a zip archive, this password is used to read and decrypt the
               entries that are encrypted within the zip file. When entries within a zip
               file use different passwords, set the appropriate password for the entry
               before the first call to <c>Read()</c> for each entry.
             </para>
            
             <para>
               When reading an entry that is not encrypted, the value of this property is
               ignored.
             </para>
            
             </remarks>
            
             <example>
            
               This example uses the ZipInputStream to read and extract entries from a
               zip file, using a potentially different password for each entry.
            
             <code lang="C#">
             byte[] buffer= new byte[2048];
             int n;
             using (var raw = File.Open(_inputFileName, FileMode.Open, FileAccess.Read ))
             {
                 using (var input= new ZipInputStream(raw))
                 {
                     ZipEntry e;
                     while (( e = input.GetNextEntry()) != null)
                     {
                         input.Password = PasswordForEntry(e.FileName);
                         if (e.IsDirectory) continue;
                         string outputPath = Path.Combine(_extractDir, e.FileName);
                         using (var output = File.Open(outputPath, FileMode.Create, FileAccess.ReadWrite))
                         {
                             while ((n= input.Read(buffer,0,buffer.Length)) > 0)
                             {
                                 output.Write(buffer,0,n);
                             }
                         }
                     }
                 }
             }
            
             </code>
             </example>
        </member>
        <member name="M:Ionic.Zip.ZipInputStream.Read(System.Byte[],System.Int32,System.Int32)">
             <summary>
               Read the data from the stream into the buffer.
             </summary>
            
             <remarks>
             <para>
               The data for the zipentry will be decrypted and uncompressed, as
               necessary, before being copied into the buffer.
             </para>
            
             <para>
               You must set the <see cref="P:Ionic.Zip.ZipInputStream.Password"/> property before calling
               <c>Read()</c> the first time for an encrypted entry.  To determine if an
               entry is encrypted and requires a password, check the <see
               cref="P:Ionic.Zip.ZipEntry.Encryption">ZipEntry.Encryption</see> property.
             </para>
             </remarks>
            
             <param name="buffer">The buffer to hold the data read from the stream.</param>
             <param name="offset">the offset within the buffer to copy the first byte read.</param>
             <param name="count">the number of bytes to read.</param>
             <returns>the number of bytes read, after decryption and decompression.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipInputStream.GetNextEntry">
             <summary>
               Read the next entry from the zip file.
             </summary>
            
             <remarks>
             <para>
               Call this method just before calling <see cref="M:Ionic.Zip.ZipInputStream.Read(System.Byte[],System.Int32,System.Int32)"/>,
               to position the pointer in the zip file to the next entry that can be
               read.  Subsequent calls to <c>Read()</c>, will decrypt and decompress the
               data in the zip file, until <c>Read()</c> returns 0.
             </para>
            
             <para>
               Each time you call <c>GetNextEntry()</c>, the pointer in the wrapped
               stream is moved to the next entry in the zip file.  If you call <see
               cref="M:Ionic.Zip.ZipInputStream.Seek(System.Int64,System.IO.SeekOrigin)"/>, and thus re-position the pointer within
               the file, you will need to call <c>GetNextEntry()</c> again, to insure
               that the file pointer is positioned at the beginning of a zip entry.
             </para>
            
             <para>
               This method returns the <c>ZipEntry</c>. Using a stream approach, you will
               read the raw bytes for an entry in a zip file via calls to <c>Read()</c>.
               Alternatively, you can extract an entry into a file, or a stream, by
               calling <see cref="M:Ionic.Zip.ZipEntry.Extract"/>, or one of its siblings.
             </para>
            
             </remarks>
            
             <returns>
               The <c>ZipEntry</c> read. Returns null (or Nothing in VB) if there are no more
               entries in the zip file.
             </returns>
            
        </member>
        <member name="M:Ionic.Zip.ZipInputStream.Dispose(System.Boolean)">
             <summary>
               Dispose the stream.
             </summary>
            
             <remarks>
             <para>
               This method disposes the ZipInputStream.  It may also close the
               underlying stream, depending on which constructor was used.
             </para>
            
             <para>
               Typically the application will call <c>Dispose()</c> implicitly, via
               a <c>using</c> statement in C#, or a <c>Using</c> statement in VB.
             </para>
            
               <para>
                 Application code won't call this code directly.  This method may
                 be invoked in two distinct scenarios.  If disposing == true, the
                 method has been called directly or indirectly by a user's code,
                 for example via the public Dispose() method. In this case, both
                 managed and unmanaged resources can be referenced and disposed.
                 If disposing == false, the method has been called by the runtime
                 from inside the object finalizer and this method should not
                 reference other objects; in that case only unmanaged resources
                 must be referenced or disposed.
               </para>
             </remarks>
            
             <param name="disposing">
               true if the Dispose method was invoked by user code.
             </param>
        </member>
        <member name="P:Ionic.Zip.ZipInputStream.CanRead">
            <summary>
            Always returns true.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipInputStream.CanSeek">
            <summary>
            Returns the value of <c>CanSeek</c> for the underlying (wrapped) stream.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipInputStream.CanWrite">
            <summary>
            Always returns false.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipInputStream.Length">
            <summary>
            Returns the length of the underlying stream.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipInputStream.Position">
            <summary>
            Gets or sets the position of the underlying stream.
            </summary>
            <remarks>
            Setting the position is equivalent to calling <c>Seek(value, SeekOrigin.Begin)</c>.
            </remarks>
        </member>
        <member name="M:Ionic.Zip.ZipInputStream.Flush">
            <summary>
            This is a no-op.
            </summary>
        </member>
        <member name="M:Ionic.Zip.ZipInputStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            This method always throws a NotSupportedException.
            </summary>
            <param name="buffer">ignored</param>
            <param name="offset">ignored</param>
            <param name="count">ignored</param>
        </member>
        <member name="M:Ionic.Zip.ZipInputStream.Seek(System.Int64,System.IO.SeekOrigin)">
             <summary>
               This method seeks in the underlying stream.
             </summary>
            
             <remarks>
             <para>
               Call this method if you want to seek around within the zip file for random access.
             </para>
            
             <para>
               Applications can intermix calls to <c>Seek()</c> with calls to <see
               cref="M:Ionic.Zip.ZipInputStream.GetNextEntry"/>.  After a call to <c>Seek()</c>,
               <c>GetNextEntry()</c> will get the next <c>ZipEntry</c> that falls after
               the current position in the input stream. You're on your own for finding
               out just where to seek in the stream, to get to the various entries.
             </para>
            
             </remarks>
            
             <param name="offset">the offset point to seek to</param>
             <param name="origin">the reference point from which to seek</param>
             <returns>The new position</returns>
        </member>
        <member name="M:Ionic.Zip.ZipInputStream.SetLength(System.Int64)">
            <summary>
            This method always throws a NotSupportedException.
            </summary>
            <param name="value">ignored</param>
        </member>
        <member name="T:Ionic.Zip.ZipOutputStream">
             <summary>
               Provides a stream metaphor for generating zip files.
             </summary>
            
             <remarks>
             <para>
               This class writes zip files, as defined in the <see
               href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">specification
               for zip files described by PKWare</see>.  The compression for this
               implementation is provided by a managed-code version of Zlib, included with
               DotNetZip in the classes in the Ionic.Zlib namespace.
             </para>
            
             <para>
               This class provides an alternative programming model to the one enabled by the
               <see cref="T:Ionic.Zip.ZipFile"/> class. Use this when creating zip files, as an
               alternative to the <see cref="T:Ionic.Zip.ZipFile"/> class, when you would like to use a
               <c>Stream</c> type to write the zip file.
             </para>
            
             <para>
               Both the <c>ZipOutputStream</c> class and the <c>ZipFile</c> class can be used
               to create zip files. Both of them support many of the common zip features,
               including Unicode, different compression levels, and ZIP64.   They provide
               very similar performance when creating zip files.
             </para>
            
             <para>
               The <c>ZipFile</c> class is generally easier to use than
               <c>ZipOutputStream</c> and should be considered a higher-level interface.  For
               example, when creating a zip file via calls to the <c>PutNextEntry()</c> and
               <c>Write()</c> methods on the <c>ZipOutputStream</c> class, the caller is
               responsible for opening the file, reading the bytes from the file, writing
               those bytes into the <c>ZipOutputStream</c>, setting the attributes on the
               <c>ZipEntry</c>, and setting the created, last modified, and last accessed
               timestamps on the zip entry. All of these things are done automatically by a
               call to <see cref="M:Ionic.Zip.ZipFile.AddFile(System.String,System.String)">ZipFile.AddFile()</see>.
               For this reason, the <c>ZipOutputStream</c> is generally recommended for use
               only when your application emits arbitrary data, not necessarily data from a
               filesystem file, directly into a zip file, and does so using a <c>Stream</c>
               metaphor.
             </para>
            
             <para>
               Aside from the differences in programming model, there are other
               differences in capability between the two classes.
             </para>
            
             <list type="bullet">
               <item>
                 <c>ZipFile</c> can be used to read and extract zip files, in addition to
                 creating zip files. <c>ZipOutputStream</c> cannot read zip files. If you want
                 to use a stream to read zip files, check out the <see cref="T:Ionic.Zip.ZipInputStream"/> class.
               </item>
            
               <item>
                 <c>ZipOutputStream</c> does not support the creation of segmented or spanned
                 zip files.
               </item>
            
               <item>
                 <c>ZipOutputStream</c> cannot produce a self-extracting archive.
               </item>
             </list>
            
             <para>
               Be aware that the <c>ZipOutputStream</c> class implements the <see
               cref="T:System.IDisposable"/> interface.  In order for
               <c>ZipOutputStream</c> to produce a valid zip file, you use use it within
               a using clause (<c>Using</c> in VB), or call the <c>Dispose()</c> method
               explicitly.  See the examples for how to employ a using clause.
             </para>
            
             <para>
               Also, a note regarding compression performance: On the desktop .NET
               Framework, DotNetZip can use a multi-threaded compression implementation
               that provides significant speed increases on large files, over 300k or so,
               at the cost of increased memory use at runtime.  (The output of the
               compression is almost exactly the same size).  But, the multi-threaded
               approach incurs a performance hit on smaller files. There's no way for the
               ZipOutputStream to know whether parallel compression will be beneficial,
               because the ZipOutputStream does not know how much data you will write
               through the stream.  You may wish to set the <see
               cref="P:Ionic.Zip.ZipOutputStream.ParallelDeflateThreshold"/> property to zero, if you are compressing
               large files through <c>ZipOutputStream</c>.  This will cause parallel
               compression to be used, always.
             </para>
             </remarks>
        </member>
        <member name="M:Ionic.Zip.ZipOutputStream.#ctor(System.IO.Stream)">
             <summary>
               Create a ZipOutputStream, wrapping an existing stream.
             </summary>
            
             <remarks>
             <para>
               The <see cref="T:Ionic.Zip.ZipFile"/> class is generally easier to use when creating
               zip files. The ZipOutputStream offers a different metaphor for creating a
               zip file, based on the <see cref="T:System.IO.Stream"/> class.
             </para>
            
             </remarks>
            
             <param name="stream">
             The stream to wrap. It must be writable. This stream will be closed at
             the time the ZipOutputStream is closed.
             </param>
            
             <example>
            
               This example shows how to create a zip file, using the
               ZipOutputStream class.
            
             <code lang="C#">
             private void Zipup()
             {
                 if (filesToZip.Count == 0)
                 {
                     System.Console.WriteLine("Nothing to do.");
                     return;
                 }
            
                 using (var raw = File.Open(_outputFileName, FileMode.Create, FileAccess.ReadWrite ))
                 {
                     using (var output= new ZipOutputStream(raw))
                     {
                         output.Password = "VerySecret!";
                         output.Encryption = EncryptionAlgorithm.WinZipAes256;
            
                         foreach (string inputFileName in filesToZip)
                         {
                             System.Console.WriteLine("file: {0}", inputFileName);
            
                             output.PutNextEntry(inputFileName);
                             using (var input = File.Open(inputFileName, FileMode.Open, FileAccess.Read, FileShare.Read | FileShare.Write ))
                             {
                                 byte[] buffer= new byte[2048];
                                 int n;
                                 while ((n= input.Read(buffer,0,buffer.Length)) > 0)
                                 {
                                     output.Write(buffer,0,n);
                                 }
                             }
                         }
                     }
                 }
             }
             </code>
            
             <code lang="VB">
             Private Sub Zipup()
                 Dim outputFileName As String = "XmlData.zip"
                 Dim filesToZip As String() = Directory.GetFiles(".", "*.xml")
                 If (filesToZip.Length = 0) Then
                     Console.WriteLine("Nothing to do.")
                 Else
                     Using raw As FileStream = File.Open(outputFileName, FileMode.Create, FileAccess.ReadWrite)
                         Using output As ZipOutputStream = New ZipOutputStream(raw)
                             output.Password = "VerySecret!"
                             output.Encryption = EncryptionAlgorithm.WinZipAes256
                             Dim inputFileName As String
                             For Each inputFileName In filesToZip
                                 Console.WriteLine("file: {0}", inputFileName)
                                 output.PutNextEntry(inputFileName)
                                 Using input As FileStream = File.Open(inputFileName, FileMode.Open, FileAccess.Read, FileShare.ReadWrite)
                                     Dim n As Integer
                                     Dim buffer As Byte() = New Byte(2048) {}
                                     Do While (n = input.Read(buffer, 0, buffer.Length) > 0)
                                         output.Write(buffer, 0, n)
                                     Loop
                                 End Using
                             Next
                         End Using
                     End Using
                 End If
             End Sub
             </code>
             </example>
        </member>
        <member name="M:Ionic.Zip.ZipOutputStream.#ctor(System.String)">
             <summary>
               Create a ZipOutputStream that writes to a filesystem file.
             </summary>
            
             <remarks>
               The <see cref="T:Ionic.Zip.ZipFile"/> class is generally easier to use when creating
               zip files. The ZipOutputStream offers a different metaphor for creating a
               zip file, based on the <see cref="T:System.IO.Stream"/> class.
             </remarks>
            
             <param name="fileName">
               The name of the zip file to create.
             </param>
            
             <example>
            
               This example shows how to create a zip file, using the
               ZipOutputStream class.
            
             <code lang="C#">
             private void Zipup()
             {
                 if (filesToZip.Count == 0)
                 {
                     System.Console.WriteLine("Nothing to do.");
                     return;
                 }
            
                 using (var output= new ZipOutputStream(outputFileName))
                 {
                     output.Password = "VerySecret!";
                     output.Encryption = EncryptionAlgorithm.WinZipAes256;
            
                     foreach (string inputFileName in filesToZip)
                     {
                         System.Console.WriteLine("file: {0}", inputFileName);
            
                         output.PutNextEntry(inputFileName);
                         using (var input = File.Open(inputFileName, FileMode.Open, FileAccess.Read,
                                                      FileShare.Read | FileShare.Write ))
                         {
                             byte[] buffer= new byte[2048];
                             int n;
                             while ((n= input.Read(buffer,0,buffer.Length)) > 0)
                             {
                                 output.Write(buffer,0,n);
                             }
                         }
                     }
                 }
             }
             </code>
            
             <code lang="VB">
             Private Sub Zipup()
                 Dim outputFileName As String = "XmlData.zip"
                 Dim filesToZip As String() = Directory.GetFiles(".", "*.xml")
                 If (filesToZip.Length = 0) Then
                     Console.WriteLine("Nothing to do.")
                 Else
                     Using output As ZipOutputStream = New ZipOutputStream(outputFileName)
                         output.Password = "VerySecret!"
                         output.Encryption = EncryptionAlgorithm.WinZipAes256
                         Dim inputFileName As String
                         For Each inputFileName In filesToZip
                             Console.WriteLine("file: {0}", inputFileName)
                             output.PutNextEntry(inputFileName)
                             Using input As FileStream = File.Open(inputFileName, FileMode.Open, FileAccess.Read, FileShare.ReadWrite)
                                 Dim n As Integer
                                 Dim buffer As Byte() = New Byte(2048) {}
                                 Do While (n = input.Read(buffer, 0, buffer.Length) > 0)
                                     output.Write(buffer, 0, n)
                                 Loop
                             End Using
                         Next
                     End Using
                 End If
             End Sub
             </code>
             </example>
        </member>
        <member name="M:Ionic.Zip.ZipOutputStream.#ctor(System.IO.Stream,System.Boolean)">
             <summary>
               Create a ZipOutputStream.
             </summary>
            
             <remarks>
               See the documentation for the <see
               cref="M:Ionic.Zip.ZipOutputStream.#ctor(System.IO.Stream)">ZipOutputStream(Stream)</see>
               constructor for an example.
             </remarks>
            
             <param name="stream">
               The stream to wrap. It must be writable.
             </param>
            
             <param name="leaveOpen">
               true if the application would like the stream
               to remain open after the <c>ZipOutputStream</c> has been closed.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipOutputStream.ToString">
            <summary>Provides a string representation of the instance.</summary>
            <remarks>
              <para>
                This can be useful for debugging purposes.
              </para>
            </remarks>
            <returns>a string representation of the instance.</returns>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.Password">
             <summary>
               Sets the password to be used on the <c>ZipOutputStream</c> instance.
             </summary>
            
             <remarks>
            
             <para>
               When writing a zip archive, this password is applied to the entries, not
               to the zip archive itself. It applies to any <c>ZipEntry</c> subsequently
               written to the <c>ZipOutputStream</c>.
             </para>
            
             <para>
               Using a password does not encrypt or protect the "directory" of the
               archive - the list of entries contained in the archive.  If you set the
               <c>Password</c> property, the password actually applies to individual
               entries that are added to the archive, subsequent to the setting of this
               property.  The list of filenames in the archive that is eventually created
               will appear in clear text, but the contents of the individual files are
               encrypted.  This is how Zip encryption works.
             </para>
            
             <para>
               If you set this property, and then add a set of entries to the archive via
               calls to <c>PutNextEntry</c>, then each entry is encrypted with that
               password.  You may also want to change the password between adding
               different entries. If you set the password, add an entry, then set the
               password to <c>null</c> (<c>Nothing</c> in VB), and add another entry, the
               first entry is encrypted and the second is not.
             </para>
            
             <para>
               When setting the <c>Password</c>, you may also want to explicitly set the <see
               cref="P:Ionic.Zip.ZipOutputStream.Encryption"/> property, to specify how to encrypt the entries added
               to the ZipFile.  If you set the <c>Password</c> to a non-null value and do not
               set <see cref="P:Ionic.Zip.ZipOutputStream.Encryption"/>, then PKZip 2.0 ("Weak") encryption is used.
               This encryption is relatively weak but is very interoperable. If
               you set the password to a <c>null</c> value (<c>Nothing</c> in VB),
               <c>Encryption</c> is reset to None.
             </para>
            
             <para>
               Special case: if you wrap a ZipOutputStream around a non-seekable stream,
               and use encryption, and emit an entry of zero bytes, the <c>Close()</c> or
               <c>PutNextEntry()</c> following the entry will throw an exception.
             </para>
            
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.Encryption">
             <summary>
               The Encryption to use for entries added to the <c>ZipOutputStream</c>.
             </summary>
            
             <remarks>
             <para>
               The specified Encryption is applied to the entries subsequently
               written to the <c>ZipOutputStream</c> instance.
             </para>
            
             <para>
               If you set this to something other than
               EncryptionAlgorithm.None, you will also need to set the
               <see cref="P:Ionic.Zip.ZipOutputStream.Password"/> to a non-null, non-empty value in
               order to actually get encryption on the entry.
             </para>
            
             </remarks>
            
             <seealso cref="P:Ionic.Zip.ZipOutputStream.Password">ZipOutputStream.Password</seealso>
             <seealso cref="P:Ionic.Zip.ZipEntry.Encryption">ZipEntry.Encryption</seealso>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.CodecBufferSize">
             <summary>
               Size of the work buffer to use for the ZLIB codec during compression.
             </summary>
            
             <remarks>
               Setting this may affect performance.  For larger files, setting this to a
               larger size may improve performance, but I'm not sure.  Sorry, I don't
               currently have good recommendations on how to set it.  You can test it if
               you like.
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.Strategy">
             <summary>
               The compression strategy to use for all entries.
             </summary>
            
             <remarks>
               Set the Strategy used by the ZLIB-compatible compressor, when compressing
               data for the entries in the zip archive. Different compression strategies
               work better on different sorts of data. The strategy parameter can affect
               the compression ratio and the speed of compression but not the correctness
               of the compresssion.  For more information see <see
               cref="T:Ionic.Zlib.CompressionStrategy"/>.
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.Timestamp">
             <summary>
               The type of timestamp attached to the ZipEntry.
             </summary>
            
             <remarks>
               Set this in order to specify the kind of timestamp that should be emitted
               into the zip file for each entry.
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.CompressionLevel">
             <summary>
               Sets the compression level to be used for entries subsequently added to
               the zip archive.
             </summary>
            
             <remarks>
              <para>
                Varying the compression level used on entries can affect the
                size-vs-speed tradeoff when compression and decompressing data streams
                or files.
              </para>
            
              <para>
                As with some other properties on the <c>ZipOutputStream</c> class, like <see
                cref="P:Ionic.Zip.ZipOutputStream.Password"/>, and <see cref="P:Ionic.Zip.ZipOutputStream.Encryption"/>,
                setting this property on a <c>ZipOutputStream</c>
                instance will cause the specified <c>CompressionLevel</c> to be used on all
                <see cref="T:Ionic.Zip.ZipEntry"/> items that are subsequently added to the
                <c>ZipOutputStream</c> instance.
              </para>
            
              <para>
                If you do not set this property, the default compression level is used,
                which normally gives a good balance of compression efficiency and
                compression speed.  In some tests, using <c>BestCompression</c> can
                double the time it takes to compress, while delivering just a small
                increase in compression efficiency.  This behavior will vary with the
                type of data you compress.  If you are in doubt, just leave this setting
                alone, and accept the default.
              </para>
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.CompressionMethod">
            <summary>
              The compression method used on each entry added to the ZipOutputStream.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.Comment">
             <summary>
               A comment attached to the zip archive.
             </summary>
            
             <remarks>
            
             <para>
               The application sets this property to specify a comment to be embedded
               into the generated zip archive.
             </para>
            
             <para>
               According to <see
               href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWARE's
               zip specification</see>, the comment is not encrypted, even if there is a
               password set on the zip file.
             </para>
            
             <para>
               The specification does not describe how to indicate the encoding used
               on a comment string. Many "compliant" zip tools and libraries use
               IBM437 as the code page for comments; DotNetZip, too, follows that
               practice.  On the other hand, there are situations where you want a
               Comment to be encoded with something else, for example using code page
               950 "Big-5 Chinese". To fill that need, DotNetZip will encode the
               comment following the same procedure it follows for encoding
               filenames: (a) if <see cref="P:Ionic.Zip.ZipOutputStream.AlternateEncodingUsage"/> is
               <c>Never</c>, it uses the default encoding (IBM437). (b) if <see
               cref="P:Ionic.Zip.ZipOutputStream.AlternateEncodingUsage"/> is <c>Always</c>, it always uses the
               alternate encoding (<see cref="P:Ionic.Zip.ZipOutputStream.AlternateEncoding"/>). (c) if <see
               cref="P:Ionic.Zip.ZipOutputStream.AlternateEncodingUsage"/> is <c>AsNecessary</c>, it uses the
               alternate encoding only if the default encoding is not sufficient for
               encoding the comment - in other words if decoding the result does not
               produce the original string.  This decision is taken at the time of
               the call to <c>ZipFile.Save()</c>.
             </para>
            
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.EnableZip64">
             <summary>
               Specify whether to use ZIP64 extensions when saving a zip archive.
             </summary>
            
             <remarks>
             <para>
               The default value for the property is <see
               cref="F:Ionic.Zip.Zip64Option.Never"/>. <see cref="F:Ionic.Zip.Zip64Option.AsNecessary"/> is
               safest, in the sense that you will not get an Exception if a
               pre-ZIP64 limit is exceeded.
             </para>
            
             <para>
               You must set this property before calling <c>Write()</c>.
             </para>
            
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.OutputUsedZip64">
             <summary>
               Indicates whether ZIP64 extensions were used when saving the zip archive.
             </summary>
            
             <remarks>
               The value is defined only after the <c>ZipOutputStream</c> has been closed.
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.IgnoreCase">
             <summary>
               Whether the ZipOutputStream should use case-insensitive comparisons when
               checking for uniqueness of zip entries.
             </summary>
            
             <remarks>
               <para>
               Though the zip specification doesn't prohibit zipfiles with duplicate
               entries, Sane zip files have no duplicates, and the DotNetZip library
               cannot create zip files with duplicate entries. If an application attempts
               to call <see cref="M:Ionic.Zip.ZipOutputStream.PutNextEntry(System.String)"/> with a name that duplicates one
               already used within the archive, the library will throw an Exception.
               </para>
               <para>
               This property allows the application to specify whether the
               ZipOutputStream instance considers ordinal case when checking for
               uniqueness of zip entries.
               </para>
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.UseUnicodeAsNecessary">
             <summary>
               Indicates whether to encode entry filenames and entry comments using
               Unicode (UTF-8).
             </summary>
            
             <remarks>
             <para>
               <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">The
               PKWare zip specification</see> provides for encoding file names and file
               comments in either the IBM437 code page, or in UTF-8.  This flag selects
               the encoding according to that specification.  By default, this flag is
               false, and filenames and comments are encoded into the zip file in the
               IBM437 codepage.  Setting this flag to true will specify that filenames
               and comments that cannot be encoded with IBM437 will be encoded with
               UTF-8.
             </para>
            
             <para>
               Zip files created with strict adherence to the PKWare specification with
               respect to UTF-8 encoding can contain entries with filenames containing
               any combination of Unicode characters, including the full range of
               characters from Chinese, Latin, Hebrew, Greek, Cyrillic, and many other
               alphabets.  However, because at this time, the UTF-8 portion of the PKWare
               specification is not broadly supported by other zip libraries and
               utilities, such zip files may not be readable by your favorite zip tool or
               archiver. In other words, interoperability will decrease if you set this
               flag to true.
             </para>
            
             <para>
               In particular, Zip files created with strict adherence to the PKWare
               specification with respect to UTF-8 encoding will not work well with
               Explorer in Windows XP or Windows Vista, because Windows compressed
               folders, as far as I know, do not support UTF-8 in zip files.  Vista can
               read the zip files, but shows the filenames incorrectly. Unpacking from
               Windows Vista Explorer will result in filenames that have rubbish
               characters in place of the high-order UTF-8 bytes.
             </para>
            
             <para>
               Also, zip files that use UTF-8 encoding will not work well with Java
               applications that use the java.util.zip classes, as of v5.0 of the Java
               runtime. The Java runtime does not correctly implement the PKWare
               specification in this regard.
             </para>
            
             <para>
               As a result, we have the unfortunate situation that "correct" behavior by
               the DotNetZip library with regard to Unicode encoding of filenames during
               zip creation will result in zip files that are readable by strictly
               compliant and current tools (for example the most recent release of the
               commercial WinZip tool); but these zip files will not be readable by
               various other tools or libraries, including Windows Explorer.
             </para>
            
             <para>
               The DotNetZip library can read and write zip files with UTF8-encoded
               entries, according to the PKware spec.  If you use DotNetZip for both
               creating and reading the zip file, and you use UTF-8, there will be no
               loss of information in the filenames. For example, using a self-extractor
               created by this library will allow you to unpack files correctly with no
               loss of information in the filenames.
             </para>
            
             <para>
               If you do not set this flag, it will remain false.  If this flag is false,
               the <c>ZipOutputStream</c> will encode all filenames and comments using
               the IBM437 codepage.  This can cause "loss of information" on some
               filenames, but the resulting zipfile will be more interoperable with other
               utilities. As an example of the loss of information, diacritics can be
               lost.  The o-tilde character will be down-coded to plain o.  The c with a
               cedilla (Unicode 0xE7) used in Portugese will be downcoded to a c.
               Likewise, the O-stroke character (Unicode 248), used in Danish and
               Norwegian, will be down-coded to plain o. Chinese characters cannot be
               represented in codepage IBM437; when using the default encoding, Chinese
               characters in filenames will be represented as ?. These are all examples
               of "information loss".
             </para>
            
             <para>
               The loss of information associated to the use of the IBM437 encoding is
               inconvenient, and can also lead to runtime errors. For example, using
               IBM437, any sequence of 4 Chinese characters will be encoded as ????.  If
               your application creates a <c>ZipOutputStream</c>, does not set the
               encoding, then adds two files, each with names of four Chinese characters
               each, this will result in a duplicate filename exception.  In the case
               where you add a single file with a name containing four Chinese
               characters, the zipfile will save properly, but extracting that file
               later, with any zip tool, will result in an error, because the question
               mark is not legal for use within filenames on Windows.  These are just a
               few examples of the problems associated to loss of information.
             </para>
            
             <para>
               This flag is independent of the encoding of the content within the entries
               in the zip file. Think of the zip file as a container - it supports an
               encoding.  Within the container are other "containers" - the file entries
               themselves.  The encoding within those entries is independent of the
               encoding of the zip archive container for those entries.
             </para>
            
             <para>
               Rather than specify the encoding in a binary fashion using this flag, an
               application can specify an arbitrary encoding via the <see
               cref="P:Ionic.Zip.ZipOutputStream.ProvisionalAlternateEncoding"/> property.  Setting the encoding
               explicitly when creating zip archives will result in non-compliant zip
               files that, curiously, are fairly interoperable.  The challenge is, the
               PKWare specification does not provide for a way to specify that an entry
               in a zip archive uses a code page that is neither IBM437 nor UTF-8.
               Therefore if you set the encoding explicitly when creating a zip archive,
               you must take care upon reading the zip archive to use the same code page.
               If you get it wrong, the behavior is undefined and may result in incorrect
               filenames, exceptions, stomach upset, hair loss, and acne.
             </para>
             </remarks>
             <seealso cref="P:Ionic.Zip.ZipOutputStream.ProvisionalAlternateEncoding"/>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.ProvisionalAlternateEncoding">
             <summary>
               The text encoding to use when emitting entries into the zip archive, for
               those entries whose filenames or comments cannot be encoded with the
               default (IBM437) encoding.
             </summary>
            
             <remarks>
             <para>
               In <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">its
               zip specification</see>, PKWare describes two options for encoding
               filenames and comments: using IBM437 or UTF-8.  But, some archiving tools
               or libraries do not follow the specification, and instead encode
               characters using the system default code page.  For example, WinRAR when
               run on a machine in Shanghai may encode filenames with the Big-5 Chinese
               (950) code page.  This behavior is contrary to the Zip specification, but
               it occurs anyway.
             </para>
            
             <para>
               When using DotNetZip to write zip archives that will be read by one of
               these other archivers, set this property to specify the code page to use
               when encoding the <see cref="P:Ionic.Zip.ZipEntry.FileName"/> and <see
               cref="P:Ionic.Zip.ZipEntry.Comment"/> for each <c>ZipEntry</c> in the zip file, for
               values that cannot be encoded with the default codepage for zip files,
               IBM437.  This is why this property is "provisional".  In all cases, IBM437
               is used where possible, in other words, where no loss of data would
               result. It is possible, therefore, to have a given entry with a
               <c>Comment</c> encoded in IBM437 and a <c>FileName</c> encoded with the
               specified "provisional" codepage.
             </para>
            
             <para>
               Be aware that a zip file created after you've explicitly set the
               <c>ProvisionalAlternateEncoding</c> property to a value other than
               IBM437 may not be compliant to the PKWare specification, and may not be
               readable by compliant archivers.  On the other hand, many (most?)
               archivers are non-compliant and can read zip files created in arbitrary
               code pages.  The trick is to use or specify the proper codepage when
               reading the zip.
             </para>
            
             <para>
               When creating a zip archive using this library, it is possible to change
               the value of <c>ProvisionalAlternateEncoding</c> between each entry you
               add, and between adding entries and the call to <c>Close()</c>. Don't do
               this. It will likely result in a zipfile that is not readable.  For best
               interoperability, either leave <c>ProvisionalAlternateEncoding</c>
               alone, or specify it only once, before adding any entries to the
               <c>ZipOutputStream</c> instance.  There is one exception to this
               recommendation, described later.
             </para>
            
             <para>
               When using an arbitrary, non-UTF8 code page for encoding, there is no
               standard way for the creator application - whether DotNetZip, WinZip,
               WinRar, or something else - to formally specify in the zip file which
               codepage has been used for the entries. As a result, readers of zip files
               are not able to inspect the zip file and determine the codepage that was
               used for the entries contained within it.  It is left to the application
               or user to determine the necessary codepage when reading zip files encoded
               this way.  If you use an incorrect codepage when reading a zipfile, you
               will get entries with filenames that are incorrect, and the incorrect
               filenames may even contain characters that are not legal for use within
               filenames in Windows. Extracting entries with illegal characters in the
               filenames will lead to exceptions. It's too bad, but this is just the way
               things are with code pages in zip files. Caveat Emptor.
             </para>
            
             <para>
               One possible approach for specifying the code page for a given zip file is
               to describe the code page in a human-readable form in the Zip comment. For
               example, the comment may read "Entries in this archive are encoded in the
               Big5 code page".  For maximum interoperability, the zip comment in this
               case should be encoded in the default, IBM437 code page.  In this case,
               the zip comment is encoded using a different page than the filenames.  To
               do this, Specify <c>ProvisionalAlternateEncoding</c> to your desired
               region-specific code page, once before adding any entries, and then set
               the <see cref="P:Ionic.Zip.ZipOutputStream.Comment"/> property and reset
               <c>ProvisionalAlternateEncoding</c> to IBM437 before calling <c>Close()</c>.
             </para>
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.AlternateEncoding">
            <summary>
              A Text Encoding to use when encoding the filenames and comments for
              all the ZipEntry items, during a ZipFile.Save() operation.
            </summary>
            <remarks>
              <para>
                Whether the encoding specified here is used during the save depends
                on <see cref="P:Ionic.Zip.ZipOutputStream.AlternateEncodingUsage"/>.
              </para>
            </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.AlternateEncodingUsage">
            <summary>
              A flag that tells if and when this instance should apply
              AlternateEncoding to encode the filenames and comments associated to
              of ZipEntry objects contained within this instance.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.DefaultEncoding">
            <summary>
            The default text encoding used in zip archives.  It is numeric 437, also
            known as IBM437.
            </summary>
            <seealso cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.ParallelDeflateThreshold">
             <summary>
               The size threshold for an entry, above which a parallel deflate is used.
             </summary>
            
             <remarks>
            
               <para>
                 DotNetZip will use multiple threads to compress any ZipEntry, when
                 the <c>CompressionMethod</c> is Deflate, and if the entry is
                 larger than the given size.  Zero means "always use parallel
                 deflate", while -1 means "never use parallel deflate".
               </para>
            
               <para>
                 If the entry size cannot be known before compression, as with any entry
                 added via a ZipOutputStream, then Parallel deflate will never be
                 performed, unless the value of this property is zero.
               </para>
            
               <para>
                 A parallel deflate operations will speed up the compression of
                 large files, on computers with multiple CPUs or multiple CPU
                 cores.  For files above 1mb, on a dual core or dual-cpu (2p)
                 machine, the time required to compress the file can be 70% of the
                 single-threaded deflate.  For very large files on 4p machines the
                 compression can be done in 30% of the normal time.  The downside
                 is that parallel deflate consumes extra memory during the deflate,
                 and the deflation is slightly less effective.
               </para>
            
               <para>
                 Parallel deflate tends to not be as effective as single-threaded deflate
                 because the original data stream is split into multiple independent
                 buffers, each of which is compressed in parallel.  But because they are
                 treated independently, there is no opportunity to share compression
                 dictionaries, and additional framing bytes must be added to the output
                 stream.  For that reason, a deflated stream may be slightly larger when
                 compressed using parallel deflate, as compared to a traditional
                 single-threaded deflate. For files of about 512k, the increase over the
                 normal deflate is as much as 5% of the total compressed size. For larger
                 files, the difference can be as small as 0.1%.
               </para>
            
               <para>
                 Multi-threaded compression does not give as much an advantage when using
                 Encryption. This is primarily because encryption tends to slow down
                 the entire pipeline. Also, multi-threaded compression gives less of an
                 advantage when using lower compression levels, for example <see
                 cref="F:Ionic.Zlib.CompressionLevel.BestSpeed"/>.  You may have to perform
                 some tests to determine the best approach for your situation.
               </para>
            
               <para>
                 The default value for this property is -1, which means parallel
                 compression will not be performed unless you set it to zero.
               </para>
            
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.ParallelDeflateMaxBufferPairs">
             <summary>
               The maximum number of buffer pairs to use when performing
               parallel compression.
             </summary>
            
             <remarks>
             <para>
               This property sets an upper limit on the number of memory
               buffer pairs to create when performing parallel
               compression.  The implementation of the parallel
               compression stream allocates multiple buffers to
               facilitate parallel compression.  As each buffer fills up,
               the stream uses <see
               cref="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)">
               ThreadPool.QueueUserWorkItem()</see> to compress those
               buffers in a background threadpool thread. After a buffer
               is compressed, it is re-ordered and written to the output
               stream.
             </para>
            
             <para>
               A higher number of buffer pairs enables a higher degree of
               parallelism, which tends to increase the speed of compression on
               multi-cpu computers.  On the other hand, a higher number of buffer
               pairs also implies a larger memory consumption, more active worker
               threads, and a higher cpu utilization for any compression. This
               property enables the application to limit its memory consumption and
               CPU utilization behavior depending on requirements.
             </para>
            
             <para>
               For each compression "task" that occurs in parallel, there are 2
               buffers allocated: one for input and one for output.  This property
               sets a limit for the number of pairs.  The total amount of storage
               space allocated for buffering will then be (N*S*2), where N is the
               number of buffer pairs, S is the size of each buffer (<see
               cref="P:Ionic.Zip.ZipOutputStream.CodecBufferSize"/>).  By default, DotNetZip allocates 4 buffer
               pairs per CPU core, so if your machine has 4 cores, and you retain
               the default buffer size of 128k, then the
               ParallelDeflateOutputStream will use 4 * 4 * 2 * 128kb of buffer
               memory in total, or 4mb, in blocks of 128kb.  If you then set this
               property to 8, then the number will be 8 * 2 * 128kb of buffer
               memory, or 2mb.
             </para>
            
             <para>
               CPU utilization will also go up with additional buffers, because a
               larger number of buffer pairs allows a larger number of background
               threads to compress in parallel. If you find that parallel
               compression is consuming too much memory or CPU, you can adjust this
               value downward.
             </para>
            
             <para>
               The default value is 16. Different values may deliver better or
               worse results, depending on your priorities and the dynamic
               performance characteristics of your storage and compute resources.
             </para>
            
             <para>
               This property is not the number of buffer pairs to use; it is an
               upper limit. An illustration: Suppose you have an application that
               uses the default value of this property (which is 16), and it runs
               on a machine with 2 CPU cores. In that case, DotNetZip will allocate
               4 buffer pairs per CPU core, for a total of 8 pairs.  The upper
               limit specified by this property has no effect.
             </para>
            
             <para>
               The application can set this value at any time, but it is
               effective only if set before calling
               <c>ZipOutputStream.Write()</c> for the first time.
             </para>
             </remarks>
            
             <seealso cref="P:Ionic.Zip.ZipOutputStream.ParallelDeflateThreshold"/>
            
        </member>
        <member name="M:Ionic.Zip.ZipOutputStream.ContainsEntry(System.String)">
             <summary>
               Returns true if an entry by the given name has already been written
               to the ZipOutputStream.
             </summary>
            
             <param name="name">
               The name of the entry to scan for.
             </param>
            
             <returns>
             true if an entry by the given name has already been written.
             </returns>
        </member>
        <member name="M:Ionic.Zip.ZipOutputStream.Write(System.Byte[],System.Int32,System.Int32)">
             <summary>
               Write the data from the buffer to the stream.
             </summary>
            
             <remarks>
               As the application writes data into this stream, the data may be
               compressed and encrypted before being written out to the underlying
               stream, depending on the settings of the <see cref="P:Ionic.Zip.ZipOutputStream.CompressionLevel"/>
               and the <see cref="P:Ionic.Zip.ZipOutputStream.Encryption"/> properties.
             </remarks>
            
             <param name="buffer">The buffer holding data to write to the stream.</param>
             <param name="offset">the offset within that data array to find the first byte to write.</param>
             <param name="count">the number of bytes to write.</param>
        </member>
        <member name="M:Ionic.Zip.ZipOutputStream.PutNextEntry(System.String)">
             <summary>
               Specify the name of the next entry that will be written to the zip file.
             </summary>
            
             <remarks>
             <para>
               Call this method just before calling <see cref="M:Ionic.Zip.ZipOutputStream.Write(System.Byte[],System.Int32,System.Int32)"/>, to
               specify the name of the entry that the next set of bytes written to
               the <c>ZipOutputStream</c> belongs to. All subsequent calls to <c>Write</c>,
               until the next call to <c>PutNextEntry</c>,
               will be inserted into the named entry in the zip file.
             </para>
            
             <para>
               If the <paramref name="entryName"/> used in <c>PutNextEntry()</c> ends in
               a slash, then the entry added is marked as a directory. Because directory
               entries do not contain data, a call to <c>Write()</c>, before an
               intervening additional call to <c>PutNextEntry()</c>, will throw an
               exception.
             </para>
            
             <para>
               If you don't call <c>Write()</c> between two calls to
               <c>PutNextEntry()</c>, the first entry is inserted into the zip file as a
               file of zero size.  This may be what you want.
             </para>
            
             <para>
               Because <c>PutNextEntry()</c> closes out the prior entry, if any, this
               method may throw if there is a problem with the prior entry.
             </para>
            
             <para>
               This method returns the <c>ZipEntry</c>.  You can modify public properties
               on the <c>ZipEntry</c>, such as <see cref="P:Ionic.Zip.ZipEntry.Encryption"/>, <see
               cref="P:Ionic.Zip.ZipEntry.Password"/>, and so on, until the first call to
               <c>ZipOutputStream.Write()</c>, or until the next call to
               <c>PutNextEntry()</c>.  If you modify the <c>ZipEntry</c> <em>after</em>
               having called <c>Write()</c>, you may get a runtime exception, or you may
               silently get an invalid zip archive.
             </para>
            
             </remarks>
            
             <example>
            
               This example shows how to create a zip file, using the
               <c>ZipOutputStream</c> class.
            
             <code>
             private void Zipup()
             {
                 using (FileStream fs raw = File.Open(_outputFileName, FileMode.Create, FileAccess.ReadWrite ))
                 {
                     using (var output= new ZipOutputStream(fs))
                     {
                         output.Password = "VerySecret!";
                         output.Encryption = EncryptionAlgorithm.WinZipAes256;
                         output.PutNextEntry("entry1.txt");
                         byte[] buffer= System.Text.Encoding.ASCII.GetBytes("This is the content for entry #1.");
                         output.Write(buffer,0,buffer.Length);
                         output.PutNextEntry("entry2.txt");  // this will be zero length
                         output.PutNextEntry("entry3.txt");
                         buffer= System.Text.Encoding.ASCII.GetBytes("This is the content for entry #3.");
                         output.Write(buffer,0,buffer.Length);
                     }
                 }
             }
             </code>
             </example>
            
             <param name="entryName">
               The name of the entry to be added, including any path to be used
               within the zip file.
             </param>
            
             <returns>
               The ZipEntry created.
             </returns>
            
        </member>
        <member name="M:Ionic.Zip.ZipOutputStream.Dispose(System.Boolean)">
             <summary>
             Dispose the stream
             </summary>
            
             <remarks>
             <para>
               This method writes the Zip Central directory, then closes the stream.  The
               application must call Dispose() (or Close) in order to produce a valid zip file.
             </para>
            
             <para>
               Typically the application will call <c>Dispose()</c> implicitly, via a <c>using</c>
               statement in C#, or a <c>Using</c> statement in VB.
             </para>
            
             </remarks>
            
             <param name="disposing">set this to true, always.</param>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.CanRead">
            <summary>
            Always returns false.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.CanSeek">
            <summary>
            Always returns false.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.CanWrite">
            <summary>
            Always returns true.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.Length">
            <summary>
            Always returns a NotSupportedException.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.Position">
            <summary>
            Setting this property always returns a NotSupportedException. Getting it
            returns the value of the Position on the underlying stream.
            </summary>
        </member>
        <member name="M:Ionic.Zip.ZipOutputStream.Flush">
            <summary>
            This is a no-op.
            </summary>
        </member>
        <member name="M:Ionic.Zip.ZipOutputStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            This method always throws a NotSupportedException.
            </summary>
            <param name="buffer">ignored</param>
            <param name="offset">ignored</param>
            <param name="count">ignored</param>
            <returns>nothing</returns>
        </member>
        <member name="M:Ionic.Zip.ZipOutputStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            This method always throws a NotSupportedException.
            </summary>
            <param name="offset">ignored</param>
            <param name="origin">ignored</param>
            <returns>nothing</returns>
        </member>
        <member name="M:Ionic.Zip.ZipOutputStream.SetLength(System.Int64)">
            <summary>
            This method always throws a NotSupportedException.
            </summary>
            <param name="value">ignored</param>
        </member>
        <member name="M:Ionic.Zip.ZipSegmentedStream.ForUpdate(System.String,System.UInt32)">
            <summary>
              Sort-of like a factory method, ForUpdate is used only when
              the application needs to update the zip entry metadata for
              a segmented zip file, when the starting segment is earlier
              than the ending segment, for a particular entry.
            </summary>
            <remarks>
              <para>
                The update is always contiguous, never rolls over.  As a
                result, this method doesn't need to return a ZSS; it can
                simply return a FileStream.  That's why it's "sort of"
                like a Factory method.
              </para>
              <para>
                Caller must Close/Dispose the stream object returned by
                this method.
              </para>
            </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipSegmentedStream.CurrentName">
            <summary>
              Name of the filesystem file corresponding to the current segment.
            </summary>
            <remarks>
              <para>
                The name is not always the name currently being used in the
                filesystem.  When rwMode is RwMode.Write, the filesystem file has a
                temporary name until the stream is closed or until the next segment is
                started.
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.Zip.ZipSegmentedStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read from the stream
            </summary>
            <param name="buffer">the buffer to read</param>
            <param name="offset">the offset at which to start</param>
            <param name="count">the number of bytes to read</param>
            <returns>the number of bytes actually read</returns>
        </member>
        <member name="M:Ionic.Zip.ZipSegmentedStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Write to the stream.
            </summary>
            <param name="buffer">the buffer from which to write</param>
            <param name="offset">the offset at which to start writing</param>
            <param name="count">the number of bytes to write</param>
        </member>
        <member name="F:Ionic.Zip.Forms.PasswordDialog.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:Ionic.Zip.Forms.PasswordDialog.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:Ionic.Zip.Forms.PasswordDialog.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="F:Ionic.Zip.Forms.ZipContentsDialog.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:Ionic.Zip.Forms.ZipContentsDialog.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:Ionic.Zip.Forms.ZipContentsDialog.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="F:Ionic.Zip.WinFormsSelfExtractorStub.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:Ionic.Zip.WinFormsSelfExtractorStub.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:Ionic.Zip.WinFormsSelfExtractorStub.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="F:Ionic.Zip.UnzipStatusReport.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:Ionic.Zip.UnzipStatusReport.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="T:Ionic.LogicalConjunction">
            <summary>
            Enumerates the options for a logical conjunction. This enum is intended for use
            internally by the FileSelector class.
            </summary>
        </member>
        <member name="T:Ionic.FileSelector">
             <summary>
               FileSelector encapsulates logic that selects files from a source - a zip file
               or the filesystem - based on a set of criteria.  This class is used internally
               by the DotNetZip library, in particular for the AddSelectedFiles() methods.
               This class can also be used independently of the zip capability in DotNetZip.
             </summary>
            
             <remarks>
            
             <para>
               The FileSelector class is used internally by the ZipFile class for selecting
               files for inclusion into the ZipFile, when the <see
               cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String,System.String)"/> method, or one of
               its overloads, is called.  It's also used for the <see
               cref="M:Ionic.Zip.ZipFile.ExtractSelectedEntries(System.String)"/> methods.  Typically, an
               application that creates or manipulates Zip archives will not directly
               interact with the FileSelector class.
             </para>
            
             <para>
               Some applications may wish to use the FileSelector class directly, to
               select files from disk volumes based on a set of criteria, without creating or
               querying Zip archives.  The file selection criteria include: a pattern to
               match the filename; the last modified, created, or last accessed time of the
               file; the size of the file; and the attributes of the file.
             </para>
            
             <para>
               Consult the documentation for <see cref="P:Ionic.FileSelector.SelectionCriteria"/>
               for more information on specifying the selection criteria.
             </para>
            
             </remarks>
        </member>
        <member name="M:Ionic.FileSelector.#ctor(System.String)">
             <summary>
               Constructor that allows the caller to specify file selection criteria.
             </summary>
            
             <remarks>
             <para>
               This constructor allows the caller to specify a set of criteria for
               selection of files.
             </para>
            
             <para>
               See <see cref="P:Ionic.FileSelector.SelectionCriteria"/> for a description of
               the syntax of the selectionCriteria string.
             </para>
            
             <para>
               By default the FileSelector will traverse NTFS Reparse Points.  To
               change this, use <see cref="M:Ionic.FileSelector.#ctor(System.String,System.Boolean)">FileSelector(String, bool)</see>.
             </para>
             </remarks>
            
             <param name="selectionCriteria">The criteria for file selection.</param>
        </member>
        <member name="M:Ionic.FileSelector.#ctor(System.String,System.Boolean)">
             <summary>
               Constructor that allows the caller to specify file selection criteria.
             </summary>
            
             <remarks>
             <para>
               This constructor allows the caller to specify a set of criteria for
               selection of files.
             </para>
            
             <para>
               See <see cref="P:Ionic.FileSelector.SelectionCriteria"/> for a description of
               the syntax of the selectionCriteria string.
             </para>
             </remarks>
            
             <param name="selectionCriteria">The criteria for file selection.</param>
             <param name="traverseDirectoryReparsePoints">
             whether to traverse NTFS reparse points (junctions).
             </param>
        </member>
        <member name="P:Ionic.FileSelector.SelectionCriteria">
             <summary>
               The string specifying which files to include when retrieving.
             </summary>
             <remarks>
            
             <para>
               Specify the criteria in statements of 3 elements: a noun, an operator,
               and a value.  Consider the string "name != *.doc" .  The noun is
               "name".  The operator is "!=", implying "Not Equal".  The value is
               "*.doc".  That criterion, in English, says "all files with a name that
               does not end in the .doc extension."
             </para>
            
             <para>
               Supported nouns include "name" (or "filename") for the filename;
               "atime", "mtime", and "ctime" for last access time, last modfied time,
               and created time of the file, respectively; "attributes" (or "attrs")
               for the file attributes; "size" (or "length") for the file length
               (uncompressed); and "type" for the type of object, either a file or a
               directory.  The "attributes", "type", and "name" nouns all support =
               and != as operators.  The "size", "atime", "mtime", and "ctime" nouns
               support = and !=, and &gt;, &gt;=, &lt;, &lt;= as well.  The times are
               taken to be expressed in local time.
             </para>
            
             <para>
               Specify values for the file attributes as a string with one or more of
               the characters H,R,S,A,I,L in any order, implying file attributes of
               Hidden, ReadOnly, System, Archive, NotContextIndexed, and ReparsePoint
               (symbolic link) respectively.
             </para>
            
             <para>
               To specify a time, use YYYY-MM-DD-HH:mm:ss or YYYY/MM/DD-HH:mm:ss as
               the format.  If you omit the HH:mm:ss portion, it is assumed to be
               00:00:00 (midnight).
             </para>
            
             <para>
               The value for a size criterion is expressed in integer quantities of
               bytes, kilobytes (use k or kb after the number), megabytes (m or mb),
               or gigabytes (g or gb).
             </para>
            
             <para>
               The value for a name is a pattern to match against the filename,
               potentially including wildcards.  The pattern follows CMD.exe glob
               rules: * implies one or more of any character, while ?  implies one
               character.  If the name pattern contains any slashes, it is matched to
               the entire filename, including the path; otherwise, it is matched
               against only the filename without the path.  This means a pattern of
               "*\*.*" matches all files one directory level deep, while a pattern of
               "*.*" matches all files in all directories.
             </para>
            
             <para>
               To specify a name pattern that includes spaces, use single quotes
               around the pattern.  A pattern of "'* *.*'" will match all files that
               have spaces in the filename.  The full criteria string for that would
               be "name = '* *.*'" .
             </para>
            
             <para>
               The value for a type criterion is either F (implying a file) or D
               (implying a directory).
             </para>
            
             <para>
               Some examples:
             </para>
            
             <list type="table">
               <listheader>
                 <term>criteria</term>
                 <description>Files retrieved</description>
               </listheader>
            
               <item>
                 <term>name != *.xls </term>
                 <description>any file with an extension that is not .xls
                 </description>
               </item>
            
               <item>
                 <term>name = *.mp3 </term>
                 <description>any file with a .mp3 extension.
                 </description>
               </item>
            
               <item>
                 <term>*.mp3</term>
                 <description>(same as above) any file with a .mp3 extension.
                 </description>
               </item>
            
               <item>
                 <term>attributes = A </term>
                 <description>all files whose attributes include the Archive bit.
                 </description>
               </item>
            
               <item>
                 <term>attributes != H </term>
                 <description>all files whose attributes do not include the Hidden bit.
                 </description>
               </item>
            
               <item>
                 <term>mtime > 2009-01-01</term>
                 <description>all files with a last modified time after January 1st, 2009.
                 </description>
               </item>
            
               <item>
                 <term>ctime > 2009/01/01-03:00:00</term>
                 <description>all files with a created time after 3am (local time),
                 on January 1st, 2009.
                 </description>
               </item>
            
               <item>
                 <term>size > 2gb</term>
                 <description>all files whose uncompressed size is greater than 2gb.
                 </description>
               </item>
            
               <item>
                 <term>type = D</term>
                 <description>all directories in the filesystem. </description>
               </item>
            
             </list>
            
             <para>
               You can combine criteria with the conjunctions AND, OR, and XOR. Using
               a string like "name = *.txt AND size &gt;= 100k" for the
               selectionCriteria retrieves entries whose names end in .txt, and whose
               uncompressed size is greater than or equal to 100 kilobytes.
             </para>
            
             <para>
               For more complex combinations of criteria, you can use parenthesis to
               group clauses in the boolean logic.  Absent parenthesis, the
               precedence of the criterion atoms is determined by order of
               appearance.  Unlike the C# language, the AND conjunction does not take
               precendence over the logical OR.  This is important only in strings
               that contain 3 or more criterion atoms.  In other words, "name = *.txt
               and size &gt; 1000 or attributes = H" implies "((name = *.txt AND size
               &gt; 1000) OR attributes = H)" while "attributes = H OR name = *.txt
               and size &gt; 1000" evaluates to "((attributes = H OR name = *.txt)
               AND size &gt; 1000)".  When in doubt, use parenthesis.
             </para>
            
             <para>
               Using time properties requires some extra care. If you want to
               retrieve all entries that were last updated on 2009 February 14,
               specify "mtime &gt;= 2009-02-14 AND mtime &lt; 2009-02-15".  Read this
               to say: all files updated after 12:00am on February 14th, until
               12:00am on February 15th.  You can use the same bracketing approach to
               specify any time period - a year, a month, a week, and so on.
             </para>
            
             <para>
               The syntax allows one special case: if you provide a string with no
               spaces, it is treated as a pattern to match for the filename.
               Therefore a string like "*.xls" will be equivalent to specifying "name
               = *.xls".  This "shorthand" notation does not work with compound
               criteria.
             </para>
            
             <para>
               There is no logic in this class that insures that the inclusion
               criteria are internally consistent.  For example, it's possible to
               specify criteria that says the file must have a size of less than 100
               bytes, as well as a size that is greater than 1000 bytes.  Obviously
               no file will ever satisfy such criteria, but this class does not check
               for or detect such inconsistencies.
             </para>
            
             </remarks>
            
             <exception cref="T:System.Exception">
               Thrown in the setter if the value has an invalid syntax.
             </exception>
        </member>
        <member name="P:Ionic.FileSelector.TraverseReparsePoints">
            <summary>
             Indicates whether searches will traverse NTFS reparse points, like Junctions.
            </summary>
        </member>
        <member name="M:Ionic.FileSelector.ToString">
            <summary>
            Returns a string representation of the FileSelector object.
            </summary>
            <returns>The string representation of the boolean logic statement of the file
            selection criteria for this instance. </returns>
        </member>
        <member name="M:Ionic.FileSelector.SelectFiles(System.String)">
             <summary>
               Returns the names of the files in the specified directory
               that fit the selection criteria specified in the FileSelector.
             </summary>
            
             <remarks>
               This is equivalent to calling <see cref="M:Ionic.FileSelector.SelectFiles(System.String,System.Boolean)"/>
               with recurseDirectories = false.
             </remarks>
            
             <param name="directory">
               The name of the directory over which to apply the FileSelector
               criteria.
             </param>
            
             <returns>
               A collection of strings containing fully-qualified pathnames of files
               that match the criteria specified in the FileSelector instance.
             </returns>
        </member>
        <member name="M:Ionic.FileSelector.SelectFiles(System.String,System.Boolean)">
             <summary>
               Returns the names of the files in the specified directory that fit the
               selection criteria specified in the FileSelector, optionally recursing
               through subdirectories.
             </summary>
            
             <remarks>
               This method applies the file selection criteria contained in the
               FileSelector to the files contained in the given directory, and
               returns the names of files that conform to the criteria.
             </remarks>
            
             <param name="directory">
               The name of the directory over which to apply the FileSelector
               criteria.
             </param>
            
             <param name="recurseDirectories">
               Whether to recurse through subdirectories when applying the file
               selection criteria.
             </param>
            
             <returns>
               A collection of strings containing fully-qualified pathnames of files
               that match the criteria specified in the FileSelector instance.
             </returns>
        </member>
        <member name="M:Ionic.FileSelector.SelectEntries(Ionic.Zip.ZipFile)">
             <summary>
             Retrieve the ZipEntry items in the ZipFile that conform to the specified criteria.
             </summary>
             <remarks>
            
             <para>
             This method applies the criteria set in the FileSelector instance (as described in
             the <see cref="P:Ionic.FileSelector.SelectionCriteria"/>) to the specified ZipFile.  Using this
             method, for example, you can retrieve all entries from the given ZipFile that
             have filenames ending in .txt.
             </para>
            
             <para>
             Normally, applications would not call this method directly.  This method is used
             by the ZipFile class.
             </para>
            
             <para>
             Using the appropriate SelectionCriteria, you can retrieve entries based on size,
             time, and attributes. See <see cref="P:Ionic.FileSelector.SelectionCriteria"/> for a
             description of the syntax of the SelectionCriteria string.
             </para>
            
             </remarks>
            
             <param name="zip">The ZipFile from which to retrieve entries.</param>
            
             <returns>a collection of ZipEntry objects that conform to the criteria.</returns>
        </member>
        <member name="M:Ionic.FileSelector.SelectEntries(Ionic.Zip.ZipFile,System.String)">
             <summary>
             Retrieve the ZipEntry items in the ZipFile that conform to the specified criteria.
             </summary>
             <remarks>
            
             <para>
             This method applies the criteria set in the FileSelector instance (as described in
             the <see cref="P:Ionic.FileSelector.SelectionCriteria"/>) to the specified ZipFile.  Using this
             method, for example, you can retrieve all entries from the given ZipFile that
             have filenames ending in .txt.
             </para>
            
             <para>
             Normally, applications would not call this method directly.  This method is used
             by the ZipFile class.
             </para>
            
             <para>
             This overload allows the selection of ZipEntry instances from the ZipFile to be restricted
             to entries contained within a particular directory in the ZipFile.
             </para>
            
             <para>
             Using the appropriate SelectionCriteria, you can retrieve entries based on size,
             time, and attributes. See <see cref="P:Ionic.FileSelector.SelectionCriteria"/> for a
             description of the syntax of the SelectionCriteria string.
             </para>
            
             </remarks>
            
             <param name="zip">The ZipFile from which to retrieve entries.</param>
            
             <param name="directoryPathInArchive">
             the directory in the archive from which to select entries. If null, then
             all directories in the archive are used.
             </param>
            
             <returns>a collection of ZipEntry objects that conform to the criteria.</returns>
        </member>
        <member name="T:Ionic.EnumUtil">
            <summary>
            Summary description for EnumUtil.
            </summary>
        </member>
        <member name="M:Ionic.EnumUtil.GetDescription(System.Enum)">
            <summary>
              Returns the value of the DescriptionAttribute if the specified Enum
              value has one.  If not, returns the ToString() representation of the
              Enum value.
            </summary>
            <param name="value">The Enum to get the description for</param>
            <returns></returns>
        </member>
        <member name="M:Ionic.EnumUtil.Parse(System.Type,System.String)">
            <summary>
              Converts the string representation of the name or numeric value of one
              or more enumerated constants to an equivalent enumerated object.
              Note: use the DescriptionAttribute on enum values to enable this.
            </summary>
            <param name="enumType">The System.Type of the enumeration.</param>
            <param name="stringRepresentation">
              A string containing the name or value to convert.
            </param>
            <returns></returns>
        </member>
        <member name="M:Ionic.EnumUtil.Parse(System.Type,System.String,System.Boolean)">
            <summary>
              Converts the string representation of the name or numeric value of one
              or more enumerated constants to an equivalent enumerated object.  A
              parameter specified whether the operation is case-sensitive.  Note:
              use the DescriptionAttribute on enum values to enable this.
            </summary>
            <param name="enumType">The System.Type of the enumeration.</param>
            <param name="stringRepresentation">
              A string containing the name or value to convert.
            </param>
            <param name="ignoreCase">
              Whether the operation is case-sensitive or not.</param>
            <returns></returns>
        </member>
        <member name="P:Ionic.Utils.FolderBrowserDialogEx.Description">
            <summary>
            This description appears near the top of the dialog box, providing direction to the user.
            </summary>
        </member>
        <member name="P:Ionic.Utils.FolderBrowserDialogEx.SelectedPath">
            <summary>
            Set or get the selected path.  
            </summary>
        </member>
        <member name="P:Ionic.Utils.FolderBrowserDialogEx.ShowNewFolderButton">
            <summary>
            Enable or disable the "New Folder" button in the browser dialog.
            </summary>
        </member>
        <member name="P:Ionic.Utils.FolderBrowserDialogEx.ShowEditBox">
            <summary>
            Show an "edit box" in the folder browser.
            </summary>
            <remarks>
            The "edit box" normally shows the name of the selected folder.  
            The user may also type a pathname directly into the edit box.  
            </remarks>
            <seealso cref="P:Ionic.Utils.FolderBrowserDialogEx.ShowFullPathInEditBox"/>
        </member>
        <member name="P:Ionic.Utils.FolderBrowserDialogEx.NewStyle">
            <summary>
            Set whether to use the New Folder Browser dialog style.
            </summary>
            <remarks>
            The new style is resizable and includes a "New Folder" button.
            </remarks>
        </member>
        <member name="P:Ionic.Utils.FolderBrowserDialogEx.ShowFullPathInEditBox">
            <summary>
            Show the full path in the edit box as the user selects it. 
            </summary>
            <remarks>
            This works only if ShowEditBox is also set to true. 
            </remarks>
        </member>
        <member name="T:Ionic.Zlib.DeflateStream">
             <summary>
             A class for compressing and decompressing streams using the Deflate algorithm.
             </summary>
            
             <remarks>
            
             <para>
               The DeflateStream is a <see
               href="http://en.wikipedia.org/wiki/Decorator_pattern">Decorator</see> on a <see
               cref="T:System.IO.Stream"/>.  It adds DEFLATE compression or decompression to any
               stream.
             </para>
            
             <para>
               Using this stream, applications can compress or decompress data via stream
               <c>Read</c> and <c>Write</c> operations.  Either compresssion or decompression
               can occur through either reading or writing. The compression format used is
               DEFLATE, which is documented in <see
               href="http://www.ietf.org/rfc/rfc1951.txt">IETF RFC 1951</see>, "DEFLATE
               Compressed Data Format Specification version 1.3.".
             </para>
            
             <para>
               This class is similar to <see cref="T:Ionic.Zlib.ZlibStream"/>, except that
               <c>ZlibStream</c> adds the <see href="http://www.ietf.org/rfc/rfc1950.txt">RFC
               1950 - ZLIB</see> framing bytes to a compressed stream when compressing, or
               expects the RFC1950 framing bytes when decompressing. The <c>DeflateStream</c>
               does not.
             </para>
            
             </remarks>
            
             <seealso cref="T:Ionic.Zlib.ZlibStream" />
             <seealso cref="T:Ionic.Zlib.GZipStream" />
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode)">
             <summary>
               Create a DeflateStream using the specified CompressionMode.
             </summary>
            
             <remarks>
               When mode is <c>CompressionMode.Compress</c>, the DeflateStream will use
               the default compression level. The "captive" stream will be closed when
               the DeflateStream is closed.
             </remarks>
            
             <example>
             This example uses a DeflateStream to compress data from a file, and writes
             the compressed data to another file.
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(fileToCompress + ".deflated"))
                 {
                     using (Stream compressor = new DeflateStream(raw, CompressionMode.Compress))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
            
             <code lang="VB">
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(fileToCompress &amp; ".deflated")
                     Using compressor As Stream = New DeflateStream(raw, CompressionMode.Compress)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
             End Using
             </code>
             </example>
             <param name="stream">The stream which will be read or written.</param>
             <param name="mode">Indicates whether the DeflateStream will compress or decompress.</param>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,Ionic.Zlib.CompressionLevel)">
             <summary>
             Create a DeflateStream using the specified CompressionMode and the specified CompressionLevel.
             </summary>
            
             <remarks>
            
             <para>
               When mode is <c>CompressionMode.Decompress</c>, the level parameter is
               ignored.  The "captive" stream will be closed when the DeflateStream is
               closed.
             </para>
            
             </remarks>
            
             <example>
            
               This example uses a DeflateStream to compress data from a file, and writes
               the compressed data to another file.
            
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(fileToCompress + ".deflated"))
                 {
                     using (Stream compressor = new DeflateStream(raw,
                                                                  CompressionMode.Compress,
                                                                  CompressionLevel.BestCompression))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n= -1;
                         while (n != 0)
                         {
                             if (n &gt; 0)
                                 compressor.Write(buffer, 0, n);
                             n= input.Read(buffer, 0, buffer.Length);
                         }
                     }
                 }
             }
             </code>
            
             <code lang="VB">
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(fileToCompress &amp; ".deflated")
                     Using compressor As Stream = New DeflateStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
             End Using
             </code>
             </example>
             <param name="stream">The stream to be read or written while deflating or inflating.</param>
             <param name="mode">Indicates whether the <c>DeflateStream</c> will compress or decompress.</param>
             <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,System.Boolean)">
             <summary>
               Create a <c>DeflateStream</c> using the specified
               <c>CompressionMode</c>, and explicitly specify whether the
               stream should be left open after Deflation or Inflation.
             </summary>
            
             <remarks>
            
             <para>
               This constructor allows the application to request that the captive stream
               remain open after the deflation or inflation occurs.  By default, after
               <c>Close()</c> is called on the stream, the captive stream is also
               closed. In some cases this is not desired, for example if the stream is a
               memory stream that will be re-read after compression.  Specify true for
               the <paramref name="leaveOpen"/> parameter to leave the stream open.
             </para>
            
             <para>
               The <c>DeflateStream</c> will use the default compression level.
             </para>
            
             <para>
               See the other overloads of this constructor for example code.
             </para>
             </remarks>
            
             <param name="stream">
               The stream which will be read or written. This is called the
               "captive" stream in other places in this documentation.
             </param>
            
             <param name="mode">
               Indicates whether the <c>DeflateStream</c> will compress or decompress.
             </param>
            
             <param name="leaveOpen">true if the application would like the stream to
             remain open after inflation/deflation.</param>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,Ionic.Zlib.CompressionLevel,System.Boolean)">
             <summary>
               Create a <c>DeflateStream</c> using the specified <c>CompressionMode</c>
               and the specified <c>CompressionLevel</c>, and explicitly specify whether
               the stream should be left open after Deflation or Inflation.
             </summary>
            
             <remarks>
            
             <para>
               When mode is <c>CompressionMode.Decompress</c>, the level parameter is ignored.
             </para>
            
             <para>
               This constructor allows the application to request that the captive stream
               remain open after the deflation or inflation occurs.  By default, after
               <c>Close()</c> is called on the stream, the captive stream is also
               closed. In some cases this is not desired, for example if the stream is a
               <see cref="T:System.IO.MemoryStream"/> that will be re-read after
               compression.  Specify true for the <paramref name="leaveOpen"/> parameter
               to leave the stream open.
             </para>
            
             </remarks>
            
             <example>
            
               This example shows how to use a <c>DeflateStream</c> to compress data from
               a file, and store the compressed data into another file.
            
             <code>
             using (var output = System.IO.File.Create(fileToCompress + ".deflated"))
             {
                 using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
                 {
                     using (Stream compressor = new DeflateStream(output, CompressionMode.Compress, CompressionLevel.BestCompression, true))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n= -1;
                         while (n != 0)
                         {
                             if (n &gt; 0)
                                 compressor.Write(buffer, 0, n);
                             n= input.Read(buffer, 0, buffer.Length);
                         }
                     }
                 }
                 // can write additional data to the output stream here
             }
             </code>
            
             <code lang="VB">
             Using output As FileStream = File.Create(fileToCompress &amp; ".deflated")
                 Using input As Stream = File.OpenRead(fileToCompress)
                     Using compressor As Stream = New DeflateStream(output, CompressionMode.Compress, CompressionLevel.BestCompression, True)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
                 ' can write additional data to the output stream here.
             End Using
             </code>
             </example>
             <param name="stream">The stream which will be read or written.</param>
             <param name="mode">Indicates whether the DeflateStream will compress or decompress.</param>
             <param name="leaveOpen">true if the application would like the stream to remain open after inflation/deflation.</param>
             <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="P:Ionic.Zlib.DeflateStream.FlushMode">
            <summary>
            This property sets the flush behavior on the stream.
            </summary>
            <remarks> See the ZLIB documentation for the meaning of the flush behavior.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.DeflateStream.BufferSize">
             <summary>
               The size of the working buffer for the compression codec.
             </summary>
            
             <remarks>
             <para>
               The working buffer is used for all stream operations.  The default size is
               1024 bytes.  The minimum size is 128 bytes. You may get better performance
               with a larger buffer.  Then again, you might not.  You would have to test
               it.
             </para>
            
             <para>
               Set this before the first call to <c>Read()</c> or <c>Write()</c> on the
               stream. If you try to set it afterwards, it will throw.
             </para>
             </remarks>
        </member>
        <member name="P:Ionic.Zlib.DeflateStream.Strategy">
             <summary>
               The ZLIB strategy to be used during compression.
             </summary>
            
             <remarks>
               By tweaking this parameter, you may be able to optimize the compression for
               data with particular characteristics.
             </remarks>
        </member>
        <member name="P:Ionic.Zlib.DeflateStream.TotalIn">
            <summary> Returns the total number of bytes input so far.</summary>
        </member>
        <member name="P:Ionic.Zlib.DeflateStream.TotalOut">
            <summary> Returns the total number of bytes output so far.</summary>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.Dispose(System.Boolean)">
            <summary>
              Dispose the stream.
            </summary>
            <remarks>
              <para>
                This may or may not result in a <c>Close()</c> call on the captive
                stream.  See the constructors that have a <c>leaveOpen</c> parameter
                for more information.
              </para>
              <para>
                Application code won't call this code directly.  This method may be
                invoked in two distinct scenarios.  If disposing == true, the method
                has been called directly or indirectly by a user's code, for example
                via the public Dispose() method. In this case, both managed and
                unmanaged resources can be referenced and disposed.  If disposing ==
                false, the method has been called by the runtime from inside the
                object finalizer and this method should not reference other objects;
                in that case only unmanaged resources must be referenced or
                disposed.
              </para>
            </remarks>
            <param name="disposing">
              true if the Dispose method was invoked by user code.
            </param>
        </member>
        <member name="P:Ionic.Zlib.DeflateStream.CanRead">
            <summary>
            Indicates whether the stream can be read.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports reading.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.DeflateStream.CanSeek">
            <summary>
            Indicates whether the stream supports Seek operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.DeflateStream.CanWrite">
            <summary>
            Indicates whether the stream can be written.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports writing.
            </remarks>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.Flush">
            <summary>
            Flush the stream.
            </summary>
        </member>
        <member name="P:Ionic.Zlib.DeflateStream.Length">
            <summary>
            Reading this property always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
        </member>
        <member name="P:Ionic.Zlib.DeflateStream.Position">
             <summary>
             The position of the stream pointer.
             </summary>
            
             <remarks>
               Setting this property always throws a <see
               cref="T:System.NotImplementedException"/>. Reading will return the total bytes
               written out, if used in writing, or the total bytes read in, if used in
               reading.  The count may refer to compressed bytes or uncompressed bytes,
               depending on how you've used the stream.
             </remarks>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.Read(System.Byte[],System.Int32,System.Int32)">
             <summary>
             Read data from the stream.
             </summary>
             <remarks>
            
             <para>
               If you wish to use the <c>DeflateStream</c> to compress data while
               reading, you can create a <c>DeflateStream</c> with
               <c>CompressionMode.Compress</c>, providing an uncompressed data stream.
               Then call Read() on that <c>DeflateStream</c>, and the data read will be
               compressed as you read.  If you wish to use the <c>DeflateStream</c> to
               decompress data while reading, you can create a <c>DeflateStream</c> with
               <c>CompressionMode.Decompress</c>, providing a readable compressed data
               stream.  Then call Read() on that <c>DeflateStream</c>, and the data read
               will be decompressed as you read.
             </para>
            
             <para>
               A <c>DeflateStream</c> can be used for <c>Read()</c> or <c>Write()</c>, but not both.
             </para>
            
             </remarks>
             <param name="buffer">The buffer into which the read data should be placed.</param>
             <param name="offset">the offset within that data array to put the first byte read.</param>
             <param name="count">the number of bytes to read.</param>
             <returns>the number of bytes actually read</returns>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="offset">this is irrelevant, since it will always throw!</param>
            <param name="origin">this is irrelevant, since it will always throw!</param>
            <returns>irrelevant!</returns>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.SetLength(System.Int64)">
            <summary>
            Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="value">this is irrelevant, since it will always throw!</param>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.Write(System.Byte[],System.Int32,System.Int32)">
             <summary>
               Write data to the stream.
             </summary>
             <remarks>
            
             <para>
               If you wish to use the <c>DeflateStream</c> to compress data while
               writing, you can create a <c>DeflateStream</c> with
               <c>CompressionMode.Compress</c>, and a writable output stream.  Then call
               <c>Write()</c> on that <c>DeflateStream</c>, providing uncompressed data
               as input.  The data sent to the output stream will be the compressed form
               of the data written.  If you wish to use the <c>DeflateStream</c> to
               decompress data while writing, you can create a <c>DeflateStream</c> with
               <c>CompressionMode.Decompress</c>, and a writable output stream.  Then
               call <c>Write()</c> on that stream, providing previously compressed
               data. The data sent to the output stream will be the decompressed form of
               the data written.
             </para>
            
             <para>
               A <c>DeflateStream</c> can be used for <c>Read()</c> or <c>Write()</c>,
               but not both.
             </para>
            
             </remarks>
            
             <param name="buffer">The buffer holding data to write to the stream.</param>
             <param name="offset">the offset within that data array to find the first byte to write.</param>
             <param name="count">the number of bytes to write.</param>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.CompressString(System.String)">
             <summary>
               Compress a string into a byte array using DEFLATE (RFC 1951).
             </summary>
            
             <remarks>
               Uncompress it with <see cref="M:Ionic.Zlib.DeflateStream.UncompressString(System.Byte[])"/>.
             </remarks>
            
             <seealso cref="M:Ionic.Zlib.DeflateStream.UncompressString(System.Byte[])">DeflateStream.UncompressString(byte[])</seealso>
             <seealso cref="M:Ionic.Zlib.DeflateStream.CompressBuffer(System.Byte[])">DeflateStream.CompressBuffer(byte[])</seealso>
             <seealso cref="M:Ionic.Zlib.GZipStream.CompressString(System.String)">GZipStream.CompressString(string)</seealso>
             <seealso cref="M:Ionic.Zlib.ZlibStream.CompressString(System.String)">ZlibStream.CompressString(string)</seealso>
            
             <param name="s">
               A string to compress. The string will first be encoded
               using UTF8, then compressed.
             </param>
            
             <returns>The string in compressed form</returns>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.CompressBuffer(System.Byte[])">
             <summary>
               Compress a byte array into a new byte array using DEFLATE.
             </summary>
            
             <remarks>
               Uncompress it with <see cref="M:Ionic.Zlib.DeflateStream.UncompressBuffer(System.Byte[])"/>.
             </remarks>
            
             <seealso cref="M:Ionic.Zlib.DeflateStream.CompressString(System.String)">DeflateStream.CompressString(string)</seealso>
             <seealso cref="M:Ionic.Zlib.DeflateStream.UncompressBuffer(System.Byte[])">DeflateStream.UncompressBuffer(byte[])</seealso>
             <seealso cref="M:Ionic.Zlib.GZipStream.CompressBuffer(System.Byte[])">GZipStream.CompressBuffer(byte[])</seealso>
             <seealso cref="M:Ionic.Zlib.ZlibStream.CompressBuffer(System.Byte[])">ZlibStream.CompressBuffer(byte[])</seealso>
            
             <param name="b">
               A buffer to compress.
             </param>
            
             <returns>The data in compressed form</returns>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.UncompressString(System.Byte[])">
             <summary>
               Uncompress a DEFLATE'd byte array into a single string.
             </summary>
            
             <seealso cref="M:Ionic.Zlib.DeflateStream.CompressString(System.String)">DeflateStream.CompressString(String)</seealso>
             <seealso cref="M:Ionic.Zlib.DeflateStream.UncompressBuffer(System.Byte[])">DeflateStream.UncompressBuffer(byte[])</seealso>
             <seealso cref="M:Ionic.Zlib.GZipStream.UncompressString(System.Byte[])">GZipStream.UncompressString(byte[])</seealso>
             <seealso cref="M:Ionic.Zlib.ZlibStream.UncompressString(System.Byte[])">ZlibStream.UncompressString(byte[])</seealso>
            
             <param name="compressed">
               A buffer containing DEFLATE-compressed data.
             </param>
            
             <returns>The uncompressed string</returns>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.UncompressBuffer(System.Byte[])">
             <summary>
               Uncompress a DEFLATE'd byte array into a byte array.
             </summary>
            
             <seealso cref="M:Ionic.Zlib.DeflateStream.CompressBuffer(System.Byte[])">DeflateStream.CompressBuffer(byte[])</seealso>
             <seealso cref="M:Ionic.Zlib.DeflateStream.UncompressString(System.Byte[])">DeflateStream.UncompressString(byte[])</seealso>
             <seealso cref="M:Ionic.Zlib.GZipStream.UncompressBuffer(System.Byte[])">GZipStream.UncompressBuffer(byte[])</seealso>
             <seealso cref="M:Ionic.Zlib.ZlibStream.UncompressBuffer(System.Byte[])">ZlibStream.UncompressBuffer(byte[])</seealso>
            
             <param name="compressed">
               A buffer containing data that has been compressed with DEFLATE.
             </param>
            
             <returns>The data in uncompressed form</returns>
        </member>
        <member name="T:Ionic.Zlib.GZipStream">
             <summary>
               A class for compressing and decompressing GZIP streams.
             </summary>
             <remarks>
            
             <para>
               The <c>GZipStream</c> is a <see
               href="http://en.wikipedia.org/wiki/Decorator_pattern">Decorator</see> on a
               <see cref="T:System.IO.Stream"/>. It adds GZIP compression or decompression to any
               stream.
             </para>
            
             <para>
               Like the <c>System.IO.Compression.GZipStream</c> in the .NET Base Class Library, the
               <c>Ionic.Zlib.GZipStream</c> can compress while writing, or decompress while
               reading, but not vice versa.  The compression method used is GZIP, which is
               documented in <see href="http://www.ietf.org/rfc/rfc1952.txt">IETF RFC
               1952</see>, "GZIP file format specification version 4.3".</para>
            
             <para>
               A <c>GZipStream</c> can be used to decompress data (through <c>Read()</c>) or
               to compress data (through <c>Write()</c>), but not both.
             </para>
            
             <para>
               If you wish to use the <c>GZipStream</c> to compress data, you must wrap it
               around a write-able stream. As you call <c>Write()</c> on the <c>GZipStream</c>, the
               data will be compressed into the GZIP format.  If you want to decompress data,
               you must wrap the <c>GZipStream</c> around a readable stream that contains an
               IETF RFC 1952-compliant stream.  The data will be decompressed as you call
               <c>Read()</c> on the <c>GZipStream</c>.
             </para>
            
             <para>
               Though the GZIP format allows data from multiple files to be concatenated
               together, this stream handles only a single segment of GZIP format, typically
               representing a single file.
             </para>
            
             <para>
               This class is similar to <see cref="T:Ionic.Zlib.ZlibStream"/> and <see cref="T:Ionic.Zlib.DeflateStream"/>.
               <c>ZlibStream</c> handles RFC1950-compliant streams.  <see cref="T:Ionic.Zlib.DeflateStream"/>
               handles RFC1951-compliant streams. This class handles RFC1952-compliant streams.
             </para>
            
             </remarks>
            
             <seealso cref="T:Ionic.Zlib.DeflateStream" />
             <seealso cref="T:Ionic.Zlib.ZlibStream" />
        </member>
        <member name="P:Ionic.Zlib.GZipStream.Comment">
             <summary>
               The comment on the GZIP stream.
             </summary>
            
             <remarks>
             <para>
               The GZIP format allows for each file to optionally have an associated
               comment stored with the file.  The comment is encoded with the ISO-8859-1
               code page.  To include a comment in a GZIP stream you create, set this
               property before calling <c>Write()</c> for the first time on the
               <c>GZipStream</c>.
             </para>
            
             <para>
               When using <c>GZipStream</c> to decompress, you can retrieve this property
               after the first call to <c>Read()</c>.  If no comment has been set in the
               GZIP bytestream, the Comment property will return <c>null</c>
               (<c>Nothing</c> in VB).
             </para>
             </remarks>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.FileName">
             <summary>
               The FileName for the GZIP stream.
             </summary>
            
             <remarks>
            
             <para>
               The GZIP format optionally allows each file to have an associated
               filename.  When compressing data (through <c>Write()</c>), set this
               FileName before calling <c>Write()</c> the first time on the <c>GZipStream</c>.
               The actual filename is encoded into the GZIP bytestream with the
               ISO-8859-1 code page, according to RFC 1952. It is the application's
               responsibility to insure that the FileName can be encoded and decoded
               correctly with this code page.
             </para>
            
             <para>
               When decompressing (through <c>Read()</c>), you can retrieve this value
               any time after the first <c>Read()</c>.  In the case where there was no filename
               encoded into the GZIP bytestream, the property will return <c>null</c> (<c>Nothing</c>
               in VB).
             </para>
             </remarks>
        </member>
        <member name="F:Ionic.Zlib.GZipStream.LastModified">
             <summary>
               The last modified time for the GZIP stream.
             </summary>
            
             <remarks>
               GZIP allows the storage of a last modified time with each GZIP entry.
               When compressing data, you can set this before the first call to
               <c>Write()</c>.  When decompressing, you can retrieve this value any time
               after the first call to <c>Read()</c>.
             </remarks>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.Crc32">
            <summary>
            The CRC on the GZIP stream.
            </summary>
            <remarks>
            This is used for internal error checking. You probably don't need to look at this property.
            </remarks>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode)">
             <summary>
               Create a <c>GZipStream</c> using the specified <c>CompressionMode</c>.
             </summary>
             <remarks>
            
             <para>
               When mode is <c>CompressionMode.Compress</c>, the <c>GZipStream</c> will use the
               default compression level.
             </para>
            
             <para>
               As noted in the class documentation, the <c>CompressionMode</c> (Compress
               or Decompress) also establishes the "direction" of the stream.  A
               <c>GZipStream</c> with <c>CompressionMode.Compress</c> works only through
               <c>Write()</c>.  A <c>GZipStream</c> with
               <c>CompressionMode.Decompress</c> works only through <c>Read()</c>.
             </para>
            
             </remarks>
            
             <example>
               This example shows how to use a GZipStream to compress data.
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(outputFile))
                 {
                     using (Stream compressor = new GZipStream(raw, CompressionMode.Compress))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
             <code lang="VB">
             Dim outputFile As String = (fileToCompress &amp; ".compressed")
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(outputFile)
                 Using compressor As Stream = New GZipStream(raw, CompressionMode.Compress)
                     Dim buffer As Byte() = New Byte(4096) {}
                     Dim n As Integer = -1
                     Do While (n &lt;&gt; 0)
                         If (n &gt; 0) Then
                             compressor.Write(buffer, 0, n)
                         End If
                         n = input.Read(buffer, 0, buffer.Length)
                     Loop
                 End Using
                 End Using
             End Using
             </code>
             </example>
            
             <example>
             This example shows how to use a GZipStream to uncompress a file.
             <code>
             private void GunZipFile(string filename)
             {
                 if (!filename.EndsWith(".gz))
                     throw new ArgumentException("filename");
                 var DecompressedFile = filename.Substring(0,filename.Length-3);
                 byte[] working = new byte[WORKING_BUFFER_SIZE];
                 int n= 1;
                 using (System.IO.Stream input = System.IO.File.OpenRead(filename))
                 {
                     using (Stream decompressor= new Ionic.Zlib.GZipStream(input, CompressionMode.Decompress, true))
                     {
                         using (var output = System.IO.File.Create(DecompressedFile))
                         {
                             while (n !=0)
                             {
                                 n= decompressor.Read(working, 0, working.Length);
                                 if (n > 0)
                                 {
                                     output.Write(working, 0, n);
                                 }
                             }
                         }
                     }
                 }
             }
             </code>
            
             <code lang="VB">
             Private Sub GunZipFile(ByVal filename as String)
                 If Not (filename.EndsWith(".gz)) Then
                     Throw New ArgumentException("filename")
                 End If
                 Dim DecompressedFile as String = filename.Substring(0,filename.Length-3)
                 Dim working(WORKING_BUFFER_SIZE) as Byte
                 Dim n As Integer = 1
                 Using input As Stream = File.OpenRead(filename)
                     Using decompressor As Stream = new Ionic.Zlib.GZipStream(input, CompressionMode.Decompress, True)
                         Using output As Stream = File.Create(UncompressedFile)
                             Do
                                 n= decompressor.Read(working, 0, working.Length)
                                 If n > 0 Then
                                     output.Write(working, 0, n)
                                 End IF
                             Loop While (n  > 0)
                         End Using
                     End Using
                 End Using
             End Sub
             </code>
             </example>
            
             <param name="stream">The stream which will be read or written.</param>
             <param name="mode">Indicates whether the GZipStream will compress or decompress.</param>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,Ionic.Zlib.CompressionLevel)">
             <summary>
               Create a <c>GZipStream</c> using the specified <c>CompressionMode</c> and
               the specified <c>CompressionLevel</c>.
             </summary>
             <remarks>
            
             <para>
               The <c>CompressionMode</c> (Compress or Decompress) also establishes the
               "direction" of the stream.  A <c>GZipStream</c> with
               <c>CompressionMode.Compress</c> works only through <c>Write()</c>.  A
               <c>GZipStream</c> with <c>CompressionMode.Decompress</c> works only
               through <c>Read()</c>.
             </para>
            
             </remarks>
            
             <example>
            
             This example shows how to use a <c>GZipStream</c> to compress a file into a .gz file.
            
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(fileToCompress + ".gz"))
                 {
                     using (Stream compressor = new GZipStream(raw,
                                                               CompressionMode.Compress,
                                                               CompressionLevel.BestCompression))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
            
             <code lang="VB">
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(fileToCompress &amp; ".gz")
                     Using compressor As Stream = New GZipStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
             End Using
             </code>
             </example>
             <param name="stream">The stream to be read or written while deflating or inflating.</param>
             <param name="mode">Indicates whether the <c>GZipStream</c> will compress or decompress.</param>
             <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,System.Boolean)">
             <summary>
               Create a <c>GZipStream</c> using the specified <c>CompressionMode</c>, and
               explicitly specify whether the stream should be left open after Deflation
               or Inflation.
             </summary>
            
             <remarks>
             <para>
               This constructor allows the application to request that the captive stream
               remain open after the deflation or inflation occurs.  By default, after
               <c>Close()</c> is called on the stream, the captive stream is also
               closed. In some cases this is not desired, for example if the stream is a
               memory stream that will be re-read after compressed data has been written
               to it.  Specify true for the <paramref name="leaveOpen"/> parameter to leave
               the stream open.
             </para>
            
             <para>
               The <see cref="T:Ionic.Zlib.CompressionMode"/> (Compress or Decompress) also
               establishes the "direction" of the stream.  A <c>GZipStream</c> with
               <c>CompressionMode.Compress</c> works only through <c>Write()</c>.  A <c>GZipStream</c>
               with <c>CompressionMode.Decompress</c> works only through <c>Read()</c>.
             </para>
            
             <para>
               The <c>GZipStream</c> will use the default compression level. If you want
               to specify the compression level, see <see cref="M:Ionic.Zlib.GZipStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,Ionic.Zlib.CompressionLevel,System.Boolean)"/>.
             </para>
            
             <para>
               See the other overloads of this constructor for example code.
             </para>
            
             </remarks>
            
             <param name="stream">
               The stream which will be read or written. This is called the "captive"
               stream in other places in this documentation.
             </param>
            
             <param name="mode">Indicates whether the GZipStream will compress or decompress.
             </param>
            
             <param name="leaveOpen">
               true if the application would like the base stream to remain open after
               inflation/deflation.
             </param>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,Ionic.Zlib.CompressionLevel,System.Boolean)">
             <summary>
               Create a <c>GZipStream</c> using the specified <c>CompressionMode</c> and the
               specified <c>CompressionLevel</c>, and explicitly specify whether the
               stream should be left open after Deflation or Inflation.
             </summary>
            
             <remarks>
            
             <para>
               This constructor allows the application to request that the captive stream
               remain open after the deflation or inflation occurs.  By default, after
               <c>Close()</c> is called on the stream, the captive stream is also
               closed. In some cases this is not desired, for example if the stream is a
               memory stream that will be re-read after compressed data has been written
               to it.  Specify true for the <paramref name="leaveOpen"/> parameter to
               leave the stream open.
             </para>
            
             <para>
               As noted in the class documentation, the <c>CompressionMode</c> (Compress
               or Decompress) also establishes the "direction" of the stream.  A
               <c>GZipStream</c> with <c>CompressionMode.Compress</c> works only through
               <c>Write()</c>.  A <c>GZipStream</c> with <c>CompressionMode.Decompress</c> works only
               through <c>Read()</c>.
             </para>
            
             </remarks>
            
             <example>
               This example shows how to use a <c>GZipStream</c> to compress data.
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(outputFile))
                 {
                     using (Stream compressor = new GZipStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression, true))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
             <code lang="VB">
             Dim outputFile As String = (fileToCompress &amp; ".compressed")
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(outputFile)
                 Using compressor As Stream = New GZipStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression, True)
                     Dim buffer As Byte() = New Byte(4096) {}
                     Dim n As Integer = -1
                     Do While (n &lt;&gt; 0)
                         If (n &gt; 0) Then
                             compressor.Write(buffer, 0, n)
                         End If
                         n = input.Read(buffer, 0, buffer.Length)
                     Loop
                 End Using
                 End Using
             End Using
             </code>
             </example>
             <param name="stream">The stream which will be read or written.</param>
             <param name="mode">Indicates whether the GZipStream will compress or decompress.</param>
             <param name="leaveOpen">true if the application would like the stream to remain open after inflation/deflation.</param>
             <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.FlushMode">
            <summary>
            This property sets the flush behavior on the stream.
            </summary>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.BufferSize">
             <summary>
               The size of the working buffer for the compression codec.
             </summary>
            
             <remarks>
             <para>
               The working buffer is used for all stream operations.  The default size is
               1024 bytes.  The minimum size is 128 bytes. You may get better performance
               with a larger buffer.  Then again, you might not.  You would have to test
               it.
             </para>
            
             <para>
               Set this before the first call to <c>Read()</c> or <c>Write()</c> on the
               stream. If you try to set it afterwards, it will throw.
             </para>
             </remarks>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.TotalIn">
            <summary> Returns the total number of bytes input so far.</summary>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.TotalOut">
            <summary> Returns the total number of bytes output so far.</summary>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.Dispose(System.Boolean)">
            <summary>
              Dispose the stream.
            </summary>
            <remarks>
              <para>
                This may or may not result in a <c>Close()</c> call on the captive
                stream.  See the constructors that have a <c>leaveOpen</c> parameter
                for more information.
              </para>
              <para>
                This method may be invoked in two distinct scenarios.  If disposing
                == true, the method has been called directly or indirectly by a
                user's code, for example via the public Dispose() method. In this
                case, both managed and unmanaged resources can be referenced and
                disposed.  If disposing == false, the method has been called by the
                runtime from inside the object finalizer and this method should not
                reference other objects; in that case only unmanaged resources must
                be referenced or disposed.
              </para>
            </remarks>
            <param name="disposing">
              indicates whether the Dispose method was invoked by user code.
            </param>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.CanRead">
            <summary>
            Indicates whether the stream can be read.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports reading.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.CanSeek">
            <summary>
            Indicates whether the stream supports Seek operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.CanWrite">
            <summary>
            Indicates whether the stream can be written.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports writing.
            </remarks>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.Flush">
            <summary>
            Flush the stream.
            </summary>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.Length">
            <summary>
            Reading this property always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.Position">
             <summary>
               The position of the stream pointer.
             </summary>
            
             <remarks>
               Setting this property always throws a <see
               cref="T:System.NotImplementedException"/>. Reading will return the total bytes
               written out, if used in writing, or the total bytes read in, if used in
               reading.  The count may refer to compressed bytes or uncompressed bytes,
               depending on how you've used the stream.
             </remarks>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.Read(System.Byte[],System.Int32,System.Int32)">
             <summary>
               Read and decompress data from the source stream.
             </summary>
            
             <remarks>
               With a <c>GZipStream</c>, decompression is done through reading.
             </remarks>
            
             <example>
             <code>
             byte[] working = new byte[WORKING_BUFFER_SIZE];
             using (System.IO.Stream input = System.IO.File.OpenRead(_CompressedFile))
             {
                 using (Stream decompressor= new Ionic.Zlib.GZipStream(input, CompressionMode.Decompress, true))
                 {
                     using (var output = System.IO.File.Create(_DecompressedFile))
                     {
                         int n;
                         while ((n= decompressor.Read(working, 0, working.Length)) !=0)
                         {
                             output.Write(working, 0, n);
                         }
                     }
                 }
             }
             </code>
             </example>
             <param name="buffer">The buffer into which the decompressed data should be placed.</param>
             <param name="offset">the offset within that data array to put the first byte read.</param>
             <param name="count">the number of bytes to read.</param>
             <returns>the number of bytes actually read</returns>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
              Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="offset">irrelevant; it will always throw!</param>
            <param name="origin">irrelevant; it will always throw!</param>
            <returns>irrelevant!</returns>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.SetLength(System.Int64)">
            <summary>
              Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="value">irrelevant; this method will always throw!</param>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.Write(System.Byte[],System.Int32,System.Int32)">
             <summary>
               Write data to the stream.
             </summary>
            
             <remarks>
             <para>
               If you wish to use the <c>GZipStream</c> to compress data while writing,
               you can create a <c>GZipStream</c> with <c>CompressionMode.Compress</c>, and a
               writable output stream.  Then call <c>Write()</c> on that <c>GZipStream</c>,
               providing uncompressed data as input.  The data sent to the output stream
               will be the compressed form of the data written.
             </para>
            
             <para>
               A <c>GZipStream</c> can be used for <c>Read()</c> or <c>Write()</c>, but not
               both. Writing implies compression.  Reading implies decompression.
             </para>
            
             </remarks>
             <param name="buffer">The buffer holding data to write to the stream.</param>
             <param name="offset">the offset within that data array to find the first byte to write.</param>
             <param name="count">the number of bytes to write.</param>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.CompressString(System.String)">
             <summary>
               Compress a string into a byte array using GZip.
             </summary>
            
             <remarks>
               Uncompress it with <see cref="M:Ionic.Zlib.GZipStream.UncompressString(System.Byte[])"/>.
             </remarks>
            
             <seealso cref="M:Ionic.Zlib.GZipStream.UncompressString(System.Byte[])"/>
             <seealso cref="M:Ionic.Zlib.GZipStream.CompressBuffer(System.Byte[])"/>
            
             <param name="s">
               A string to compress. The string will first be encoded
               using UTF8, then compressed.
             </param>
            
             <returns>The string in compressed form</returns>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.CompressBuffer(System.Byte[])">
             <summary>
               Compress a byte array into a new byte array using GZip.
             </summary>
            
             <remarks>
               Uncompress it with <see cref="M:Ionic.Zlib.GZipStream.UncompressBuffer(System.Byte[])"/>.
             </remarks>
            
             <seealso cref="M:Ionic.Zlib.GZipStream.CompressString(System.String)"/>
             <seealso cref="M:Ionic.Zlib.GZipStream.UncompressBuffer(System.Byte[])"/>
            
             <param name="b">
               A buffer to compress.
             </param>
            
             <returns>The data in compressed form</returns>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.UncompressString(System.Byte[])">
             <summary>
               Uncompress a GZip'ed byte array into a single string.
             </summary>
            
             <seealso cref="M:Ionic.Zlib.GZipStream.CompressString(System.String)"/>
             <seealso cref="M:Ionic.Zlib.GZipStream.UncompressBuffer(System.Byte[])"/>
            
             <param name="compressed">
               A buffer containing GZIP-compressed data.
             </param>
            
             <returns>The uncompressed string</returns>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.UncompressBuffer(System.Byte[])">
             <summary>
               Uncompress a GZip'ed byte array into a byte array.
             </summary>
            
             <seealso cref="M:Ionic.Zlib.GZipStream.CompressBuffer(System.Byte[])"/>
             <seealso cref="M:Ionic.Zlib.GZipStream.UncompressString(System.Byte[])"/>
            
             <param name="compressed">
               A buffer containing data that has been compressed with GZip.
             </param>
            
             <returns>The data in uncompressed form</returns>
        </member>
        <member name="T:Ionic.Zlib.ParallelDeflateOutputStream">
             <summary>
               A class for compressing streams using the
               Deflate algorithm with multiple threads.
             </summary>
            
             <remarks>
             <para>
               This class performs DEFLATE compression through writing.  For
               more information on the Deflate algorithm, see IETF RFC 1951,
               "DEFLATE Compressed Data Format Specification version 1.3."
             </para>
            
             <para>
               This class is similar to <see cref="T:Ionic.Zlib.DeflateStream"/>, except
               that this class is for compression only, and this implementation uses an
               approach that employs multiple worker threads to perform the DEFLATE.  On
               a multi-cpu or multi-core computer, the performance of this class can be
               significantly higher than the single-threaded DeflateStream, particularly
               for larger streams.  How large?  Anything over 10mb is a good candidate
               for parallel compression.
             </para>
            
             <para>
               The tradeoff is that this class uses more memory and more CPU than the
               vanilla DeflateStream, and also is less efficient as a compressor. For
               large files the size of the compressed data stream can be less than 1%
               larger than the size of a compressed data stream from the vanialla
               DeflateStream.  For smaller files the difference can be larger.  The
               difference will also be larger if you set the BufferSize to be lower than
               the default value.  Your mileage may vary. Finally, for small files, the
               ParallelDeflateOutputStream can be much slower than the vanilla
               DeflateStream, because of the overhead associated to using the thread
               pool.
             </para>
            
             </remarks>
             <seealso cref="T:Ionic.Zlib.DeflateStream" />
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.#ctor(System.IO.Stream)">
             <summary>
             Create a ParallelDeflateOutputStream.
             </summary>
             <remarks>
            
             <para>
               This stream compresses data written into it via the DEFLATE
               algorithm (see RFC 1951), and writes out the compressed byte stream.
             </para>
            
             <para>
               The instance will use the default compression level, the default
               buffer sizes and the default number of threads and buffers per
               thread.
             </para>
            
             <para>
               This class is similar to <see cref="T:Ionic.Zlib.DeflateStream"/>,
               except that this implementation uses an approach that employs
               multiple worker threads to perform the DEFLATE.  On a multi-cpu or
               multi-core computer, the performance of this class can be
               significantly higher than the single-threaded DeflateStream,
               particularly for larger streams.  How large?  Anything over 10mb is
               a good candidate for parallel compression.
             </para>
            
             </remarks>
            
             <example>
            
             This example shows how to use a ParallelDeflateOutputStream to compress
             data.  It reads a file, compresses it, and writes the compressed data to
             a second, output file.
            
             <code>
             byte[] buffer = new byte[WORKING_BUFFER_SIZE];
             int n= -1;
             String outputFile = fileToCompress + ".compressed";
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(outputFile))
                 {
                     using (Stream compressor = new ParallelDeflateOutputStream(raw))
                     {
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
             <code lang="VB">
             Dim buffer As Byte() = New Byte(4096) {}
             Dim n As Integer = -1
             Dim outputFile As String = (fileToCompress &amp; ".compressed")
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(outputFile)
                     Using compressor As Stream = New ParallelDeflateOutputStream(raw)
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
             End Using
             </code>
             </example>
             <param name="stream">The stream to which compressed data will be written.</param>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionLevel)">
            <summary>
              Create a ParallelDeflateOutputStream using the specified CompressionLevel.
            </summary>
            <remarks>
              See the <see cref="M:Ionic.Zlib.ParallelDeflateOutputStream.#ctor(System.IO.Stream)"/>
              constructor for example code.
            </remarks>
            <param name="stream">The stream to which compressed data will be written.</param>
            <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.#ctor(System.IO.Stream,System.Boolean)">
            <summary>
            Create a ParallelDeflateOutputStream and specify whether to leave the captive stream open
            when the ParallelDeflateOutputStream is closed.
            </summary>
            <remarks>
              See the <see cref="M:Ionic.Zlib.ParallelDeflateOutputStream.#ctor(System.IO.Stream)"/>
              constructor for example code.
            </remarks>
            <param name="stream">The stream to which compressed data will be written.</param>
            <param name="leaveOpen">
               true if the application would like the stream to remain open after inflation/deflation.
            </param>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionLevel,System.Boolean)">
            <summary>
            Create a ParallelDeflateOutputStream and specify whether to leave the captive stream open
            when the ParallelDeflateOutputStream is closed.
            </summary>
            <remarks>
              See the <see cref="M:Ionic.Zlib.ParallelDeflateOutputStream.#ctor(System.IO.Stream)"/>
              constructor for example code.
            </remarks>
            <param name="stream">The stream to which compressed data will be written.</param>
            <param name="level">A tuning knob to trade speed for effectiveness.</param>
            <param name="leaveOpen">
               true if the application would like the stream to remain open after inflation/deflation.
            </param>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionLevel,Ionic.Zlib.CompressionStrategy,System.Boolean)">
            <summary>
            Create a ParallelDeflateOutputStream using the specified
            CompressionLevel and CompressionStrategy, and specifying whether to
            leave the captive stream open when the ParallelDeflateOutputStream is
            closed.
            </summary>
            <remarks>
              See the <see cref="M:Ionic.Zlib.ParallelDeflateOutputStream.#ctor(System.IO.Stream)"/>
              constructor for example code.
            </remarks>
            <param name="stream">The stream to which compressed data will be written.</param>
            <param name="level">A tuning knob to trade speed for effectiveness.</param>
            <param name="strategy">
              By tweaking this parameter, you may be able to optimize the compression for
              data with particular characteristics.
            </param>
            <param name="leaveOpen">
               true if the application would like the stream to remain open after inflation/deflation.
            </param>
        </member>
        <member name="P:Ionic.Zlib.ParallelDeflateOutputStream.Strategy">
             <summary>
               The ZLIB strategy to be used during compression.
             </summary>
            
        </member>
        <member name="P:Ionic.Zlib.ParallelDeflateOutputStream.MaxBufferPairs">
             <summary>
               The maximum number of buffer pairs to use.
             </summary>
            
             <remarks>
             <para>
               This property sets an upper limit on the number of memory buffer
               pairs to create.  The implementation of this stream allocates
               multiple buffers to facilitate parallel compression.  As each buffer
               fills up, this stream uses <see
               cref="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)">
               ThreadPool.QueueUserWorkItem()</see>
               to compress those buffers in a background threadpool thread. After a
               buffer is compressed, it is re-ordered and written to the output
               stream.
             </para>
            
             <para>
               A higher number of buffer pairs enables a higher degree of
               parallelism, which tends to increase the speed of compression on
               multi-cpu computers.  On the other hand, a higher number of buffer
               pairs also implies a larger memory consumption, more active worker
               threads, and a higher cpu utilization for any compression. This
               property enables the application to limit its memory consumption and
               CPU utilization behavior depending on requirements.
             </para>
            
             <para>
               For each compression "task" that occurs in parallel, there are 2
               buffers allocated: one for input and one for output.  This property
               sets a limit for the number of pairs.  The total amount of storage
               space allocated for buffering will then be (N*S*2), where N is the
               number of buffer pairs, S is the size of each buffer (<see
               cref="P:Ionic.Zlib.ParallelDeflateOutputStream.BufferSize"/>).  By default, DotNetZip allocates 4 buffer
               pairs per CPU core, so if your machine has 4 cores, and you retain
               the default buffer size of 128k, then the
               ParallelDeflateOutputStream will use 4 * 4 * 2 * 128kb of buffer
               memory in total, or 4mb, in blocks of 128kb.  If you then set this
               property to 8, then the number will be 8 * 2 * 128kb of buffer
               memory, or 2mb.
             </para>
            
             <para>
               CPU utilization will also go up with additional buffers, because a
               larger number of buffer pairs allows a larger number of background
               threads to compress in parallel. If you find that parallel
               compression is consuming too much memory or CPU, you can adjust this
               value downward.
             </para>
            
             <para>
               The default value is 16. Different values may deliver better or
               worse results, depending on your priorities and the dynamic
               performance characteristics of your storage and compute resources.
             </para>
            
             <para>
               This property is not the number of buffer pairs to use; it is an
               upper limit. An illustration: Suppose you have an application that
               uses the default value of this property (which is 16), and it runs
               on a machine with 2 CPU cores. In that case, DotNetZip will allocate
               4 buffer pairs per CPU core, for a total of 8 pairs.  The upper
               limit specified by this property has no effect.
             </para>
            
             <para>
               The application can set this value at any time, but it is effective
               only before the first call to Write(), which is when the buffers are
               allocated.
             </para>
             </remarks>
        </member>
        <member name="P:Ionic.Zlib.ParallelDeflateOutputStream.BufferSize">
             <summary>
               The size of the buffers used by the compressor threads.
             </summary>
             <remarks>
            
             <para>
               The default buffer size is 128k. The application can set this value
               at any time, but it is effective only before the first Write().
             </para>
            
             <para>
               Larger buffer sizes implies larger memory consumption but allows
               more efficient compression. Using smaller buffer sizes consumes less
               memory but may result in less effective compression.  For example,
               using the default buffer size of 128k, the compression delivered is
               within 1% of the compression delivered by the single-threaded <see
               cref="T:Ionic.Zlib.DeflateStream"/>.  On the other hand, using a
               BufferSize of 8k can result in a compressed data stream that is 5%
               larger than that delivered by the single-threaded
               <c>DeflateStream</c>.  Excessively small buffer sizes can also cause
               the speed of the ParallelDeflateOutputStream to drop, because of
               larger thread scheduling overhead dealing with many many small
               buffers.
             </para>
            
             <para>
               The total amount of storage space allocated for buffering will be
               (N*S*2), where N is the number of buffer pairs, and S is the size of
               each buffer (this property). There are 2 buffers used by the
               compressor, one for input and one for output.  By default, DotNetZip
               allocates 4 buffer pairs per CPU core, so if your machine has 4
               cores, then the number of buffer pairs used will be 16. If you
               accept the default value of this property, 128k, then the
               ParallelDeflateOutputStream will use 16 * 2 * 128kb of buffer memory
               in total, or 4mb, in blocks of 128kb.  If you set this property to
               64kb, then the number will be 16 * 2 * 64kb of buffer memory, or
               2mb.
             </para>
            
             </remarks>
        </member>
        <member name="P:Ionic.Zlib.ParallelDeflateOutputStream.Crc32">
            <summary>
            The CRC32 for the data that was written out, prior to compression.
            </summary>
            <remarks>
            This value is meaningful only after a call to Close().
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.ParallelDeflateOutputStream.BytesProcessed">
            <summary>
            The total number of uncompressed bytes processed by the ParallelDeflateOutputStream.
            </summary>
            <remarks>
            This value is meaningful only after a call to Close().
            </remarks>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.Write(System.Byte[],System.Int32,System.Int32)">
             <summary>
               Write data to the stream.
             </summary>
            
             <remarks>
            
             <para>
               To use the ParallelDeflateOutputStream to compress data, create a
               ParallelDeflateOutputStream with CompressionMode.Compress, passing a
               writable output stream.  Then call Write() on that
               ParallelDeflateOutputStream, providing uncompressed data as input.  The
               data sent to the output stream will be the compressed form of the data
               written.
             </para>
            
             <para>
               To decompress data, use the <see cref="T:Ionic.Zlib.DeflateStream"/> class.
             </para>
            
             </remarks>
             <param name="buffer">The buffer holding data to write to the stream.</param>
             <param name="offset">the offset within that data array to find the first byte to write.</param>
             <param name="count">the number of bytes to write.</param>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.Flush">
            <summary>
            Flush the stream.
            </summary>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.Close">
            <summary>
            Close the stream.
            </summary>
            <remarks>
            You must call Close on the stream to guarantee that all of the data written in has
            been compressed, and the compressed data has been written out.
            </remarks>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.Dispose">
            <summary>Dispose the object</summary>
            <remarks>
              <para>
                Because ParallelDeflateOutputStream is IDisposable, the
                application must call this method when finished using the instance.
              </para>
              <para>
                This method is generally called implicitly upon exit from
                a <c>using</c> scope in C# (<c>Using</c> in VB).
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.Dispose(System.Boolean)">
            <summary>The Dispose method</summary>
            <param name="disposing">
              indicates whether the Dispose method was invoked by user code.
            </param>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.Reset(System.IO.Stream)">
             <summary>
               Resets the stream for use with another stream.
             </summary>
             <remarks>
               Because the ParallelDeflateOutputStream is expensive to create, it
               has been designed so that it can be recycled and re-used.  You have
               to call Close() on the stream first, then you can call Reset() on
               it, to use it again on another stream.
             </remarks>
            
             <param name="stream">
               The new output stream for this era.
             </param>
            
             <example>
             <code>
             ParallelDeflateOutputStream deflater = null;
             foreach (var inputFile in listOfFiles)
             {
                 string outputFile = inputFile + ".compressed";
                 using (System.IO.Stream input = System.IO.File.OpenRead(inputFile))
                 {
                     using (var outStream = System.IO.File.Create(outputFile))
                     {
                         if (deflater == null)
                             deflater = new ParallelDeflateOutputStream(outStream,
                                                                        CompressionLevel.Best,
                                                                        CompressionStrategy.Default,
                                                                        true);
                         deflater.Reset(outStream);
            
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             deflater.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
             </example>
        </member>
        <member name="P:Ionic.Zlib.ParallelDeflateOutputStream.CanSeek">
            <summary>
            Indicates whether the stream supports Seek operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.ParallelDeflateOutputStream.CanRead">
            <summary>
            Indicates whether the stream supports Read operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.ParallelDeflateOutputStream.CanWrite">
            <summary>
            Indicates whether the stream supports Write operations.
            </summary>
            <remarks>
            Returns true if the provided stream is writable.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.ParallelDeflateOutputStream.Length">
            <summary>
            Reading this property always throws a NotSupportedException.
            </summary>
        </member>
        <member name="P:Ionic.Zlib.ParallelDeflateOutputStream.Position">
            <summary>
            Returns the current position of the output stream.
            </summary>
            <remarks>
              <para>
                Because the output gets written by a background thread,
                the value may change asynchronously.  Setting this
                property always throws a NotSupportedException.
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            This method always throws a NotSupportedException.
            </summary>
            <param name="buffer">
              The buffer into which data would be read, IF THIS METHOD
              ACTUALLY DID ANYTHING.
            </param>
            <param name="offset">
              The offset within that data array at which to insert the
              data that is read, IF THIS METHOD ACTUALLY DID
              ANYTHING.
            </param>
            <param name="count">
              The number of bytes to write, IF THIS METHOD ACTUALLY DID
              ANYTHING.
            </param>
            <returns>nothing.</returns>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            This method always throws a NotSupportedException.
            </summary>
            <param name="offset">
              The offset to seek to....
              IF THIS METHOD ACTUALLY DID ANYTHING.
            </param>
            <param name="origin">
              The reference specifying how to apply the offset....  IF
              THIS METHOD ACTUALLY DID ANYTHING.
            </param>
            <returns>nothing. It always throws.</returns>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.SetLength(System.Int64)">
            <summary>
            This method always throws a NotSupportedException.
            </summary>
            <param name="value">
              The new value for the stream length....  IF
              THIS METHOD ACTUALLY DID ANYTHING.
            </param>
        </member>
        <member name="M:Ionic.Zlib.Tree.DistanceCode(System.Int32)">
            <summary>
            Map from a distance to a distance code.
            </summary>
            <remarks> 
            No side effects. _dist_code[256] and _dist_code[257] are never used.
            </remarks>
        </member>
        <member name="T:Ionic.Zlib.FlushType">
            <summary>
            Describes how to flush the current deflate operation.
            </summary>
            <remarks>
            The different FlushType values are useful when using a Deflate in a streaming application.
            </remarks>
        </member>
        <member name="F:Ionic.Zlib.FlushType.None">
            <summary>No flush at all.</summary>
        </member>
        <member name="F:Ionic.Zlib.FlushType.Partial">
            <summary>Closes the current block, but doesn't flush it to
            the output. Used internally only in hypothetical
            scenarios.  This was supposed to be removed by Zlib, but it is
            still in use in some edge cases.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.FlushType.Sync">
            <summary>
            Use this during compression to specify that all pending output should be
            flushed to the output buffer and the output should be aligned on a byte
            boundary.  You might use this in a streaming communication scenario, so that
            the decompressor can get all input data available so far.  When using this
            with a ZlibCodec, <c>AvailableBytesIn</c> will be zero after the call if
            enough output space has been provided before the call.  Flushing will
            degrade compression and so it should be used only when necessary.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.FlushType.Full">
            <summary>
            Use this during compression to specify that all output should be flushed, as
            with <c>FlushType.Sync</c>, but also, the compression state should be reset
            so that decompression can restart from this point if previous compressed
            data has been damaged or if random access is desired.  Using
            <c>FlushType.Full</c> too often can significantly degrade the compression.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.FlushType.Finish">
            <summary>Signals the end of the compression/decompression stream.</summary>
        </member>
        <member name="T:Ionic.Zlib.CompressionLevel">
            <summary>
            The compression level to be used when using a DeflateStream or ZlibStream with CompressionMode.Compress.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.None">
            <summary>
            None means that the data will be simply stored, with no change at all.
            If you are producing ZIPs for use on Mac OSX, be aware that archives produced with CompressionLevel.None
            cannot be opened with the default zip reader. Use a different CompressionLevel.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level0">
            <summary>
            Same as None.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.BestSpeed">
            <summary>
            The fastest but least effective compression.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level1">
            <summary>
            A synonym for BestSpeed.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level2">
            <summary>
            A little slower, but better, than level 1.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level3">
            <summary>
            A little slower, but better, than level 2.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level4">
            <summary>
            A little slower, but better, than level 3.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level5">
            <summary>
            A little slower than level 4, but with better compression.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Default">
            <summary>
            The default compression level, with a good balance of speed and compression efficiency.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level6">
            <summary>
            A synonym for Default.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level7">
            <summary>
            Pretty good compression!
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level8">
            <summary>
             Better compression than Level7!
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.BestCompression">
            <summary>
            The "best" compression, where best means greatest reduction in size of the input data stream.
            This is also the slowest compression.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level9">
            <summary>
            A synonym for BestCompression.
            </summary>
        </member>
        <member name="T:Ionic.Zlib.CompressionStrategy">
            <summary>
            Describes options for how the compression algorithm is executed.  Different strategies
            work better on different sorts of data.  The strategy parameter can affect the compression
            ratio and the speed of compression but not the correctness of the compresssion.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionStrategy.Default">
            <summary>
            The default strategy is probably the best for normal data.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionStrategy.Filtered">
            <summary>
            The <c>Filtered</c> strategy is intended to be used most effectively with data produced by a
            filter or predictor.  By this definition, filtered data consists mostly of small
            values with a somewhat random distribution.  In this case, the compression algorithm
            is tuned to compress them better.  The effect of <c>Filtered</c> is to force more Huffman
            coding and less string matching; it is a half-step between <c>Default</c> and <c>HuffmanOnly</c>.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionStrategy.HuffmanOnly">
            <summary>
            Using <c>HuffmanOnly</c> will force the compressor to do Huffman encoding only, with no
            string matching.
            </summary>
        </member>
        <member name="T:Ionic.Zlib.CompressionMode">
            <summary>
            An enum to specify the direction of transcoding - whether to compress or decompress.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionMode.Compress">
            <summary>
            Used to specify that the stream should compress the data.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionMode.Decompress">
            <summary>
            Used to specify that the stream should decompress the data.
            </summary>
        </member>
        <member name="T:Ionic.Zlib.ZlibException">
            <summary>
            A general purpose exception class for exceptions in the Zlib library.
            </summary>
        </member>
        <member name="M:Ionic.Zlib.ZlibException.#ctor">
            <summary>
            The ZlibException class captures exception information generated
            by the Zlib library.
            </summary>
        </member>
        <member name="M:Ionic.Zlib.ZlibException.#ctor(System.String)">
            <summary>
            This ctor collects a message attached to the exception.
            </summary>
            <param name="s">the message for the exception.</param>
        </member>
        <member name="M:Ionic.Zlib.SharedUtils.URShift(System.Int32,System.Int32)">
            <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
            <param name="number">Number to operate on</param>
            <param name="bits">Ammount of bits to shift</param>
            <returns>The resulting number from the shift operation</returns>
        </member>
        <member name="M:Ionic.Zlib.SharedUtils.ReadInput(System.IO.TextReader,System.Byte[],System.Int32,System.Int32)">
             <summary>
               Reads a number of characters from the current source TextReader and writes
               the data to the target array at the specified index.
             </summary>
            
             <param name="sourceTextReader">The source TextReader to read from</param>
             <param name="target">Contains the array of characteres read from the source TextReader.</param>
             <param name="start">The starting index of the target array.</param>
             <param name="count">The maximum number of characters to read from the source TextReader.</param>
            
             <returns>
               The number of characters read. The number will be less than or equal to
               count depending on the data available in the source TextReader. Returns -1
               if the end of the stream is reached.
             </returns>
        </member>
        <member name="T:Ionic.Zlib.Adler">
             <summary>
             Computes an Adler-32 checksum.
             </summary>
             <remarks>
             The Adler checksum is similar to a CRC checksum, but faster to compute, though less
             reliable.  It is used in producing RFC1950 compressed streams.  The Adler checksum
             is a required part of the "ZLIB" standard.  Applications will almost never need to
             use this class directly.
             </remarks>
            
             <exclude/>
        </member>
        <member name="M:Ionic.Zlib.Adler.Adler32(System.UInt32,System.Byte[],System.Int32,System.Int32)">
            <summary>
              Calculates the Adler32 checksum.
            </summary>
            <remarks>
              <para>
                This is used within ZLIB.  You probably don't need to use this directly.
              </para>
            </remarks>
            <example>
               To compute an Adler32 checksum on a byte array:
             <code>
               var adler = Adler.Adler32(0, null, 0, 0);
               adler = Adler.Adler32(adler, buffer, index, length);
             </code>
            </example>
        </member>
        <member name="T:Ionic.Zlib.ZlibCodec">
             <summary>
             Encoder and Decoder for ZLIB and DEFLATE (IETF RFC1950 and RFC1951).
             </summary>
            
             <remarks>
             This class compresses and decompresses data according to the Deflate algorithm
             and optionally, the ZLIB format, as documented in <see
             href="http://www.ietf.org/rfc/rfc1950.txt">RFC 1950 - ZLIB</see> and <see
             href="http://www.ietf.org/rfc/rfc1951.txt">RFC 1951 - DEFLATE</see>.
             </remarks>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.InputBuffer">
            <summary>
            The buffer from which data is taken.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.NextIn">
            <summary>
            An index into the InputBuffer array, indicating where to start reading. 
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.AvailableBytesIn">
            <summary>
            The number of bytes available in the InputBuffer, starting at NextIn. 
            </summary>
            <remarks>
            Generally you should set this to InputBuffer.Length before the first Inflate() or Deflate() call. 
            The class will update this number as calls to Inflate/Deflate are made.
            </remarks>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.TotalBytesIn">
            <summary>
            Total number of bytes read so far, through all calls to Inflate()/Deflate().
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.OutputBuffer">
            <summary>
            Buffer to store output data.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.NextOut">
            <summary>
            An index into the OutputBuffer array, indicating where to start writing. 
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.AvailableBytesOut">
            <summary>
            The number of bytes available in the OutputBuffer, starting at NextOut. 
            </summary>
            <remarks>
            Generally you should set this to OutputBuffer.Length before the first Inflate() or Deflate() call. 
            The class will update this number as calls to Inflate/Deflate are made.
            </remarks>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.TotalBytesOut">
            <summary>
            Total number of bytes written to the output so far, through all calls to Inflate()/Deflate().
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.Message">
            <summary>
            used for diagnostics, when something goes wrong!
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.CompressLevel">
            <summary>
            The compression level to use in this codec.  Useful only in compression mode.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.WindowBits">
            <summary>
            The number of Window Bits to use.  
            </summary>
            <remarks>
            This gauges the size of the sliding window, and hence the 
            compression effectiveness as well as memory consumption. It's best to just leave this 
            setting alone if you don't know what it is.  The maximum value is 15 bits, which implies
            a 32k window.  
            </remarks>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.Strategy">
            <summary>
            The compression strategy to use.
            </summary>
            <remarks>
            This is only effective in compression.  The theory offered by ZLIB is that different
            strategies could potentially produce significant differences in compression behavior
            for different data sets.  Unfortunately I don't have any good recommendations for how
            to set it differently.  When I tested changing the strategy I got minimally different
            compression performance. It's best to leave this property alone if you don't have a
            good feel for it.  Or, you may want to produce a test harness that runs through the
            different strategy options and evaluates them on different file types. If you do that,
            let me know your results.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.ZlibCodec.Adler32">
            <summary>
            The Adler32 checksum on the data transferred through the codec so far. You probably don't need to look at this.
            </summary>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.#ctor">
            <summary>
            Create a ZlibCodec.
            </summary>
            <remarks>
            If you use this default constructor, you will later have to explicitly call 
            InitializeInflate() or InitializeDeflate() before using the ZlibCodec to compress 
            or decompress. 
            </remarks>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.#ctor(Ionic.Zlib.CompressionMode)">
            <summary>
            Create a ZlibCodec that either compresses or decompresses.
            </summary>
            <param name="mode">
            Indicates whether the codec should compress (deflate) or decompress (inflate).
            </param>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.InitializeInflate">
            <summary>
            Initialize the inflation state. 
            </summary>
            <remarks>
            It is not necessary to call this before using the ZlibCodec to inflate data; 
            It is implicitly called when you call the constructor.
            </remarks>
            <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.InitializeInflate(System.Boolean)">
             <summary>
             Initialize the inflation state with an explicit flag to
             govern the handling of RFC1950 header bytes.
             </summary>
            
             <remarks>
             By default, the ZLIB header defined in <see
             href="http://www.ietf.org/rfc/rfc1950.txt">RFC 1950</see> is expected.  If
             you want to read a zlib stream you should specify true for
             expectRfc1950Header.  If you have a deflate stream, you will want to specify
             false. It is only necessary to invoke this initializer explicitly if you
             want to specify false.
             </remarks>
            
             <param name="expectRfc1950Header">whether to expect an RFC1950 header byte
             pair when reading the stream of data to be inflated.</param>
            
             <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.InitializeInflate(System.Int32)">
            <summary>
            Initialize the ZlibCodec for inflation, with the specified number of window bits. 
            </summary>
            <param name="windowBits">The number of window bits to use. If you need to ask what that is, 
            then you shouldn't be calling this initializer.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.InitializeInflate(System.Int32,System.Boolean)">
             <summary>
             Initialize the inflation state with an explicit flag to govern the handling of
             RFC1950 header bytes. 
             </summary>
            
             <remarks>
             If you want to read a zlib stream you should specify true for
             expectRfc1950Header. In this case, the library will expect to find a ZLIB
             header, as defined in <see href="http://www.ietf.org/rfc/rfc1950.txt">RFC
             1950</see>, in the compressed stream.  If you will be reading a DEFLATE or
             GZIP stream, which does not have such a header, you will want to specify
             false.
             </remarks>
            
             <param name="expectRfc1950Header">whether to expect an RFC1950 header byte pair when reading 
             the stream of data to be inflated.</param>
             <param name="windowBits">The number of window bits to use. If you need to ask what that is, 
             then you shouldn't be calling this initializer.</param>
             <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.Inflate(Ionic.Zlib.FlushType)">
             <summary>
             Inflate the data in the InputBuffer, placing the result in the OutputBuffer.
             </summary>
             <remarks>
             You must have set InputBuffer and OutputBuffer, NextIn and NextOut, and AvailableBytesIn and 
             AvailableBytesOut  before calling this method.
             </remarks>
             <example>
             <code>
             private void InflateBuffer()
             {
                 int bufferSize = 1024;
                 byte[] buffer = new byte[bufferSize];
                 ZlibCodec decompressor = new ZlibCodec();
             
                 Console.WriteLine("\n============================================");
                 Console.WriteLine("Size of Buffer to Inflate: {0} bytes.", CompressedBytes.Length);
                 MemoryStream ms = new MemoryStream(DecompressedBytes);
             
                 int rc = decompressor.InitializeInflate();
             
                 decompressor.InputBuffer = CompressedBytes;
                 decompressor.NextIn = 0;
                 decompressor.AvailableBytesIn = CompressedBytes.Length;
             
                 decompressor.OutputBuffer = buffer;
             
                 // pass 1: inflate 
                 do
                 {
                     decompressor.NextOut = 0;
                     decompressor.AvailableBytesOut = buffer.Length;
                     rc = decompressor.Inflate(FlushType.None);
             
                     if (rc != ZlibConstants.Z_OK &amp;&amp; rc != ZlibConstants.Z_STREAM_END)
                         throw new Exception("inflating: " + decompressor.Message);
             
                     ms.Write(decompressor.OutputBuffer, 0, buffer.Length - decompressor.AvailableBytesOut);
                 }
                 while (decompressor.AvailableBytesIn &gt; 0 || decompressor.AvailableBytesOut == 0);
             
                 // pass 2: finish and flush
                 do
                 {
                     decompressor.NextOut = 0;
                     decompressor.AvailableBytesOut = buffer.Length;
                     rc = decompressor.Inflate(FlushType.Finish);
             
                     if (rc != ZlibConstants.Z_STREAM_END &amp;&amp; rc != ZlibConstants.Z_OK)
                         throw new Exception("inflating: " + decompressor.Message);
             
                     if (buffer.Length - decompressor.AvailableBytesOut &gt; 0)
                         ms.Write(buffer, 0, buffer.Length - decompressor.AvailableBytesOut);
                 }
                 while (decompressor.AvailableBytesIn &gt; 0 || decompressor.AvailableBytesOut == 0);
             
                 decompressor.EndInflate();
             }
            
             </code>
             </example>
             <param name="flush">The flush to use when inflating.</param>
             <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.EndInflate">
            <summary>
            Ends an inflation session. 
            </summary>
            <remarks>
            Call this after successively calling Inflate().  This will cause all buffers to be flushed. 
            After calling this you cannot call Inflate() without a intervening call to one of the
            InitializeInflate() overloads.
            </remarks>
            <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.SyncInflate">
            <summary>
            I don't know what this does!
            </summary>
            <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.InitializeDeflate">
            <summary>
            Initialize the ZlibCodec for deflation operation.
            </summary>
            <remarks>
            The codec will use the MAX window bits and the default level of compression.
            </remarks>
            <example>
            <code>
             int bufferSize = 40000;
             byte[] CompressedBytes = new byte[bufferSize];
             byte[] DecompressedBytes = new byte[bufferSize];
             
             ZlibCodec compressor = new ZlibCodec();
             
             compressor.InitializeDeflate(CompressionLevel.Default);
             
             compressor.InputBuffer = System.Text.ASCIIEncoding.ASCII.GetBytes(TextToCompress);
             compressor.NextIn = 0;
             compressor.AvailableBytesIn = compressor.InputBuffer.Length;
             
             compressor.OutputBuffer = CompressedBytes;
             compressor.NextOut = 0;
             compressor.AvailableBytesOut = CompressedBytes.Length;
             
             while (compressor.TotalBytesIn != TextToCompress.Length &amp;&amp; compressor.TotalBytesOut &lt; bufferSize)
             {
               compressor.Deflate(FlushType.None);
             }
             
             while (true)
             {
               int rc= compressor.Deflate(FlushType.Finish);
               if (rc == ZlibConstants.Z_STREAM_END) break;
             }
             
             compressor.EndDeflate();
              
            </code>
            </example>
            <returns>Z_OK if all goes well. You generally don't need to check the return code.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.InitializeDeflate(Ionic.Zlib.CompressionLevel)">
            <summary>
            Initialize the ZlibCodec for deflation operation, using the specified CompressionLevel.
            </summary>
            <remarks>
            The codec will use the maximum window bits (15) and the specified
            CompressionLevel.  It will emit a ZLIB stream as it compresses.
            </remarks>
            <param name="level">The compression level for the codec.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.InitializeDeflate(Ionic.Zlib.CompressionLevel,System.Boolean)">
            <summary>
            Initialize the ZlibCodec for deflation operation, using the specified CompressionLevel, 
            and the explicit flag governing whether to emit an RFC1950 header byte pair.
            </summary>
            <remarks>
            The codec will use the maximum window bits (15) and the specified CompressionLevel.
            If you want to generate a zlib stream, you should specify true for
            wantRfc1950Header. In this case, the library will emit a ZLIB
            header, as defined in <see href="http://www.ietf.org/rfc/rfc1950.txt">RFC
            1950</see>, in the compressed stream.  
            </remarks>
            <param name="level">The compression level for the codec.</param>
            <param name="wantRfc1950Header">whether to emit an initial RFC1950 byte pair in the compressed stream.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.InitializeDeflate(Ionic.Zlib.CompressionLevel,System.Int32)">
            <summary>
            Initialize the ZlibCodec for deflation operation, using the specified CompressionLevel, 
            and the specified number of window bits. 
            </summary>
            <remarks>
            The codec will use the specified number of window bits and the specified CompressionLevel.
            </remarks>
            <param name="level">The compression level for the codec.</param>
            <param name="bits">the number of window bits to use.  If you don't know what this means, don't use this method.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.InitializeDeflate(Ionic.Zlib.CompressionLevel,System.Int32,System.Boolean)">
             <summary>
             Initialize the ZlibCodec for deflation operation, using the specified
             CompressionLevel, the specified number of window bits, and the explicit flag
             governing whether to emit an RFC1950 header byte pair.
             </summary>
            
             <param name="level">The compression level for the codec.</param>
             <param name="wantRfc1950Header">whether to emit an initial RFC1950 byte pair in the compressed stream.</param>
             <param name="bits">the number of window bits to use.  If you don't know what this means, don't use this method.</param>
             <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.Deflate(Ionic.Zlib.FlushType)">
            <summary>
            Deflate one batch of data.
            </summary>
            <remarks>
            You must have set InputBuffer and OutputBuffer before calling this method.
            </remarks>
            <example>
            <code>
            private void DeflateBuffer(CompressionLevel level)
            {
                int bufferSize = 1024;
                byte[] buffer = new byte[bufferSize];
                ZlibCodec compressor = new ZlibCodec();
            
                Console.WriteLine("\n============================================");
                Console.WriteLine("Size of Buffer to Deflate: {0} bytes.", UncompressedBytes.Length);
                MemoryStream ms = new MemoryStream();
            
                int rc = compressor.InitializeDeflate(level);
            
                compressor.InputBuffer = UncompressedBytes;
                compressor.NextIn = 0;
                compressor.AvailableBytesIn = UncompressedBytes.Length;
            
                compressor.OutputBuffer = buffer;
            
                // pass 1: deflate 
                do
                {
                    compressor.NextOut = 0;
                    compressor.AvailableBytesOut = buffer.Length;
                    rc = compressor.Deflate(FlushType.None);
            
                    if (rc != ZlibConstants.Z_OK &amp;&amp; rc != ZlibConstants.Z_STREAM_END)
                        throw new Exception("deflating: " + compressor.Message);
            
                    ms.Write(compressor.OutputBuffer, 0, buffer.Length - compressor.AvailableBytesOut);
                }
                while (compressor.AvailableBytesIn &gt; 0 || compressor.AvailableBytesOut == 0);
            
                // pass 2: finish and flush
                do
                {
                    compressor.NextOut = 0;
                    compressor.AvailableBytesOut = buffer.Length;
                    rc = compressor.Deflate(FlushType.Finish);
            
                    if (rc != ZlibConstants.Z_STREAM_END &amp;&amp; rc != ZlibConstants.Z_OK)
                        throw new Exception("deflating: " + compressor.Message);
            
                    if (buffer.Length - compressor.AvailableBytesOut &gt; 0)
                        ms.Write(buffer, 0, buffer.Length - compressor.AvailableBytesOut);
                }
                while (compressor.AvailableBytesIn &gt; 0 || compressor.AvailableBytesOut == 0);
            
                compressor.EndDeflate();
            
                ms.Seek(0, SeekOrigin.Begin);
                CompressedBytes = new byte[compressor.TotalBytesOut];
                ms.Read(CompressedBytes, 0, CompressedBytes.Length);
            }
            </code>
            </example>
            <param name="flush">whether to flush all data as you deflate. Generally you will want to 
            use Z_NO_FLUSH here, in a series of calls to Deflate(), and then call EndDeflate() to 
            flush everything. 
            </param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.EndDeflate">
            <summary>
            End a deflation session.
            </summary>
            <remarks>
            Call this after making a series of one or more calls to Deflate(). All buffers are flushed.
            </remarks>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.ResetDeflate">
            <summary>
            Reset a codec for another deflation session.
            </summary>
            <remarks>
            Call this to reset the deflation state.  For example if a thread is deflating
            non-consecutive blocks, you can call Reset() after the Deflate(Sync) of the first
            block and before the next Deflate(None) of the second block.
            </remarks>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.SetDeflateParams(Ionic.Zlib.CompressionLevel,Ionic.Zlib.CompressionStrategy)">
            <summary>
            Set the CompressionStrategy and CompressionLevel for a deflation session.
            </summary>
            <param name="level">the level of compression to use.</param>
            <param name="strategy">the strategy to use for compression.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.SetDictionary(System.Byte[])">
            <summary>
            Set the dictionary to be used for either Inflation or Deflation.
            </summary>
            <param name="dictionary">The dictionary bytes to use.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="T:Ionic.Zlib.ZlibConstants">
            <summary>
            A bunch of constants used in the Zlib interface.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.WindowBitsMax">
            <summary>
            The maximum number of window bits for the Deflate algorithm.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.WindowBitsDefault">
            <summary>
            The default number of window bits for the Deflate algorithm.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.Z_OK">
            <summary>
            indicates everything is A-OK
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.Z_STREAM_END">
            <summary>
            Indicates that the last operation reached the end of the stream.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.Z_NEED_DICT">
            <summary>
            The operation ended in need of a dictionary. 
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.Z_STREAM_ERROR">
            <summary>
            There was an error with the stream - not enough data, not open and readable, etc.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.Z_DATA_ERROR">
            <summary>
            There was an error with the data - not enough data, bad data, etc.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.Z_BUF_ERROR">
            <summary>
            There was an error with the working buffer.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.WorkingBufferSizeDefault">
            <summary>
            The size of the working buffer used in the ZlibCodec class. Defaults to 8192 bytes.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.WorkingBufferSizeMin">
            <summary>
            The minimum size of the working buffer used in the ZlibCodec class.  Currently it is 128 bytes.
            </summary>
        </member>
        <member name="T:Ionic.Zlib.ZlibStream">
             <summary>
             Represents a Zlib stream for compression or decompression.
             </summary>
             <remarks>
            
             <para>
             The ZlibStream is a <see
             href="http://en.wikipedia.org/wiki/Decorator_pattern">Decorator</see> on a <see
             cref="T:System.IO.Stream"/>.  It adds ZLIB compression or decompression to any
             stream.
             </para>
            
             <para> Using this stream, applications can compress or decompress data via
             stream <c>Read()</c> and <c>Write()</c> operations.  Either compresssion or
             decompression can occur through either reading or writing. The compression
             format used is ZLIB, which is documented in <see
             href="http://www.ietf.org/rfc/rfc1950.txt">IETF RFC 1950</see>, "ZLIB Compressed
             Data Format Specification version 3.3". This implementation of ZLIB always uses
             DEFLATE as the compression method.  (see <see
             href="http://www.ietf.org/rfc/rfc1951.txt">IETF RFC 1951</see>, "DEFLATE
             Compressed Data Format Specification version 1.3.") </para>
            
             <para>
             The ZLIB format allows for varying compression methods, window sizes, and dictionaries.
             This implementation always uses the DEFLATE compression method, a preset dictionary,
             and 15 window bits by default.
             </para>
            
             <para>
             This class is similar to <see cref="T:Ionic.Zlib.DeflateStream"/>, except that it adds the
             RFC1950 header and trailer bytes to a compressed stream when compressing, or expects
             the RFC1950 header and trailer bytes when decompressing.  It is also similar to the
             <see cref="T:Ionic.Zlib.GZipStream"/>.
             </para>
             </remarks>
             <seealso cref="T:Ionic.Zlib.DeflateStream" />
             <seealso cref="T:Ionic.Zlib.GZipStream" />
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode)">
             <summary>
             Create a <c>ZlibStream</c> using the specified <c>CompressionMode</c>.
             </summary>
             <remarks>
            
             <para>
               When mode is <c>CompressionMode.Compress</c>, the <c>ZlibStream</c>
               will use the default compression level. The "captive" stream will be
               closed when the <c>ZlibStream</c> is closed.
             </para>
            
             </remarks>
            
             <example>
             This example uses a <c>ZlibStream</c> to compress a file, and writes the
             compressed data to another file.
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(fileToCompress + ".zlib"))
                 {
                     using (Stream compressor = new ZlibStream(raw, CompressionMode.Compress))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
             <code lang="VB">
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(fileToCompress &amp; ".zlib")
                 Using compressor As Stream = New ZlibStream(raw, CompressionMode.Compress)
                     Dim buffer As Byte() = New Byte(4096) {}
                     Dim n As Integer = -1
                     Do While (n &lt;&gt; 0)
                         If (n &gt; 0) Then
                             compressor.Write(buffer, 0, n)
                         End If
                         n = input.Read(buffer, 0, buffer.Length)
                     Loop
                 End Using
                 End Using
             End Using
             </code>
             </example>
            
             <param name="stream">The stream which will be read or written.</param>
             <param name="mode">Indicates whether the ZlibStream will compress or decompress.</param>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,Ionic.Zlib.CompressionLevel)">
             <summary>
               Create a <c>ZlibStream</c> using the specified <c>CompressionMode</c> and
               the specified <c>CompressionLevel</c>.
             </summary>
            
             <remarks>
            
             <para>
               When mode is <c>CompressionMode.Decompress</c>, the level parameter is ignored.
               The "captive" stream will be closed when the <c>ZlibStream</c> is closed.
             </para>
            
             </remarks>
            
             <example>
               This example uses a <c>ZlibStream</c> to compress data from a file, and writes the
               compressed data to another file.
            
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(fileToCompress + ".zlib"))
                 {
                     using (Stream compressor = new ZlibStream(raw,
                                                               CompressionMode.Compress,
                                                               CompressionLevel.BestCompression))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
            
             <code lang="VB">
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(fileToCompress &amp; ".zlib")
                     Using compressor As Stream = New ZlibStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
             End Using
             </code>
             </example>
            
             <param name="stream">The stream to be read or written while deflating or inflating.</param>
             <param name="mode">Indicates whether the ZlibStream will compress or decompress.</param>
             <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,System.Boolean)">
             <summary>
               Create a <c>ZlibStream</c> using the specified <c>CompressionMode</c>, and
               explicitly specify whether the captive stream should be left open after
               Deflation or Inflation.
             </summary>
            
             <remarks>
            
             <para>
               When mode is <c>CompressionMode.Compress</c>, the <c>ZlibStream</c> will use
               the default compression level.
             </para>
            
             <para>
               This constructor allows the application to request that the captive stream
               remain open after the deflation or inflation occurs.  By default, after
               <c>Close()</c> is called on the stream, the captive stream is also
               closed. In some cases this is not desired, for example if the stream is a
               <see cref="T:System.IO.MemoryStream"/> that will be re-read after
               compression.  Specify true for the <paramref name="leaveOpen"/> parameter to leave the stream
               open.
             </para>
            
             <para>
             See the other overloads of this constructor for example code.
             </para>
            
             </remarks>
            
             <param name="stream">The stream which will be read or written. This is called the
             "captive" stream in other places in this documentation.</param>
             <param name="mode">Indicates whether the ZlibStream will compress or decompress.</param>
             <param name="leaveOpen">true if the application would like the stream to remain
             open after inflation/deflation.</param>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,Ionic.Zlib.CompressionLevel,System.Boolean)">
             <summary>
               Create a <c>ZlibStream</c> using the specified <c>CompressionMode</c>
               and the specified <c>CompressionLevel</c>, and explicitly specify
               whether the stream should be left open after Deflation or Inflation.
             </summary>
            
             <remarks>
            
             <para>
               This constructor allows the application to request that the captive
               stream remain open after the deflation or inflation occurs.  By
               default, after <c>Close()</c> is called on the stream, the captive
               stream is also closed. In some cases this is not desired, for example
               if the stream is a <see cref="T:System.IO.MemoryStream"/> that will be
               re-read after compression.  Specify true for the <paramref
               name="leaveOpen"/> parameter to leave the stream open.
             </para>
            
             <para>
               When mode is <c>CompressionMode.Decompress</c>, the level parameter is
               ignored.
             </para>
            
             </remarks>
            
             <example>
            
             This example shows how to use a ZlibStream to compress the data from a file,
             and store the result into another file. The filestream remains open to allow
             additional data to be written to it.
            
             <code>
             using (var output = System.IO.File.Create(fileToCompress + ".zlib"))
             {
                 using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
                 {
                     using (Stream compressor = new ZlibStream(output, CompressionMode.Compress, CompressionLevel.BestCompression, true))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
                 // can write additional data to the output stream here
             }
             </code>
             <code lang="VB">
             Using output As FileStream = File.Create(fileToCompress &amp; ".zlib")
                 Using input As Stream = File.OpenRead(fileToCompress)
                     Using compressor As Stream = New ZlibStream(output, CompressionMode.Compress, CompressionLevel.BestCompression, True)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
                 ' can write additional data to the output stream here.
             End Using
             </code>
             </example>
            
             <param name="stream">The stream which will be read or written.</param>
            
             <param name="mode">Indicates whether the ZlibStream will compress or decompress.</param>
            
             <param name="leaveOpen">
             true if the application would like the stream to remain open after
             inflation/deflation.
             </param>
            
             <param name="level">
             A tuning knob to trade speed for effectiveness. This parameter is
             effective only when mode is <c>CompressionMode.Compress</c>.
             </param>
        </member>
        <member name="P:Ionic.Zlib.ZlibStream.FlushMode">
            <summary>
            This property sets the flush behavior on the stream.
            Sorry, though, not sure exactly how to describe all the various settings.
            </summary>
        </member>
        <member name="P:Ionic.Zlib.ZlibStream.BufferSize">
             <summary>
               The size of the working buffer for the compression codec.
             </summary>
            
             <remarks>
             <para>
               The working buffer is used for all stream operations.  The default size is
               1024 bytes. The minimum size is 128 bytes. You may get better performance
               with a larger buffer.  Then again, you might not.  You would have to test
               it.
             </para>
            
             <para>
               Set this before the first call to <c>Read()</c> or <c>Write()</c> on the
               stream. If you try to set it afterwards, it will throw.
             </para>
             </remarks>
        </member>
        <member name="P:Ionic.Zlib.ZlibStream.TotalIn">
            <summary> Returns the total number of bytes input so far.</summary>
        </member>
        <member name="P:Ionic.Zlib.ZlibStream.TotalOut">
            <summary> Returns the total number of bytes output so far.</summary>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.Dispose(System.Boolean)">
            <summary>
              Dispose the stream.
            </summary>
            <remarks>
              <para>
                This may or may not result in a <c>Close()</c> call on the captive
                stream.  See the constructors that have a <c>leaveOpen</c> parameter
                for more information.
              </para>
              <para>
                This method may be invoked in two distinct scenarios.  If disposing
                == true, the method has been called directly or indirectly by a
                user's code, for example via the public Dispose() method. In this
                case, both managed and unmanaged resources can be referenced and
                disposed.  If disposing == false, the method has been called by the
                runtime from inside the object finalizer and this method should not
                reference other objects; in that case only unmanaged resources must
                be referenced or disposed.
              </para>
            </remarks>
            <param name="disposing">
              indicates whether the Dispose method was invoked by user code.
            </param>
        </member>
        <member name="P:Ionic.Zlib.ZlibStream.CanRead">
            <summary>
            Indicates whether the stream can be read.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports reading.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.ZlibStream.CanSeek">
            <summary>
            Indicates whether the stream supports Seek operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.ZlibStream.CanWrite">
            <summary>
            Indicates whether the stream can be written.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports writing.
            </remarks>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.Flush">
            <summary>
            Flush the stream.
            </summary>
        </member>
        <member name="P:Ionic.Zlib.ZlibStream.Length">
            <summary>
            Reading this property always throws a <see cref="T:System.NotSupportedException"/>.
            </summary>
        </member>
        <member name="P:Ionic.Zlib.ZlibStream.Position">
             <summary>
               The position of the stream pointer.
             </summary>
            
             <remarks>
               Setting this property always throws a <see
               cref="T:System.NotSupportedException"/>. Reading will return the total bytes
               written out, if used in writing, or the total bytes read in, if used in
               reading.  The count may refer to compressed bytes or uncompressed bytes,
               depending on how you've used the stream.
             </remarks>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.Read(System.Byte[],System.Int32,System.Int32)">
             <summary>
             Read data from the stream.
             </summary>
            
             <remarks>
            
             <para>
               If you wish to use the <c>ZlibStream</c> to compress data while reading,
               you can create a <c>ZlibStream</c> with <c>CompressionMode.Compress</c>,
               providing an uncompressed data stream.  Then call <c>Read()</c> on that
               <c>ZlibStream</c>, and the data read will be compressed.  If you wish to
               use the <c>ZlibStream</c> to decompress data while reading, you can create
               a <c>ZlibStream</c> with <c>CompressionMode.Decompress</c>, providing a
               readable compressed data stream.  Then call <c>Read()</c> on that
               <c>ZlibStream</c>, and the data will be decompressed as it is read.
             </para>
            
             <para>
               A <c>ZlibStream</c> can be used for <c>Read()</c> or <c>Write()</c>, but
               not both.
             </para>
            
             </remarks>
            
             <param name="buffer">
             The buffer into which the read data should be placed.</param>
            
             <param name="offset">
             the offset within that data array to put the first byte read.</param>
            
             <param name="count">the number of bytes to read.</param>
            
             <returns>the number of bytes read</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.Seek(System.Int64,System.IO.SeekOrigin)">
             <summary>
             Calling this method always throws a <see cref="T:System.NotSupportedException"/>.
             </summary>
             <param name="offset">
               The offset to seek to....
               IF THIS METHOD ACTUALLY DID ANYTHING.
             </param>
             <param name="origin">
               The reference specifying how to apply the offset....  IF
               THIS METHOD ACTUALLY DID ANYTHING.
             </param>
            
             <returns>nothing. This method always throws.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.SetLength(System.Int64)">
            <summary>
            Calling this method always throws a <see cref="T:System.NotSupportedException"/>.
            </summary>
            <param name="value">
              The new value for the stream length....  IF
              THIS METHOD ACTUALLY DID ANYTHING.
            </param>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.Write(System.Byte[],System.Int32,System.Int32)">
             <summary>
             Write data to the stream.
             </summary>
            
             <remarks>
            
             <para>
               If you wish to use the <c>ZlibStream</c> to compress data while writing,
               you can create a <c>ZlibStream</c> with <c>CompressionMode.Compress</c>,
               and a writable output stream.  Then call <c>Write()</c> on that
               <c>ZlibStream</c>, providing uncompressed data as input.  The data sent to
               the output stream will be the compressed form of the data written.  If you
               wish to use the <c>ZlibStream</c> to decompress data while writing, you
               can create a <c>ZlibStream</c> with <c>CompressionMode.Decompress</c>, and a
               writable output stream.  Then call <c>Write()</c> on that stream,
               providing previously compressed data. The data sent to the output stream
               will be the decompressed form of the data written.
             </para>
            
             <para>
               A <c>ZlibStream</c> can be used for <c>Read()</c> or <c>Write()</c>, but not both.
             </para>
             </remarks>
             <param name="buffer">The buffer holding data to write to the stream.</param>
             <param name="offset">the offset within that data array to find the first byte to write.</param>
             <param name="count">the number of bytes to write.</param>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.CompressString(System.String)">
             <summary>
               Compress a string into a byte array using ZLIB.
             </summary>
            
             <remarks>
               Uncompress it with <see cref="M:Ionic.Zlib.ZlibStream.UncompressString(System.Byte[])"/>.
             </remarks>
            
             <seealso cref="M:Ionic.Zlib.ZlibStream.UncompressString(System.Byte[])"/>
             <seealso cref="M:Ionic.Zlib.ZlibStream.CompressBuffer(System.Byte[])"/>
             <seealso cref="M:Ionic.Zlib.GZipStream.CompressString(System.String)"/>
            
             <param name="s">
               A string to compress.  The string will first be encoded
               using UTF8, then compressed.
             </param>
            
             <returns>The string in compressed form</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.CompressBuffer(System.Byte[])">
             <summary>
               Compress a byte array into a new byte array using ZLIB.
             </summary>
            
             <remarks>
               Uncompress it with <see cref="M:Ionic.Zlib.ZlibStream.UncompressBuffer(System.Byte[])"/>.
             </remarks>
            
             <seealso cref="M:Ionic.Zlib.ZlibStream.CompressString(System.String)"/>
             <seealso cref="M:Ionic.Zlib.ZlibStream.UncompressBuffer(System.Byte[])"/>
            
             <param name="b">
             A buffer to compress.
             </param>
            
             <returns>The data in compressed form</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.UncompressString(System.Byte[])">
             <summary>
               Uncompress a ZLIB-compressed byte array into a single string.
             </summary>
            
             <seealso cref="M:Ionic.Zlib.ZlibStream.CompressString(System.String)"/>
             <seealso cref="M:Ionic.Zlib.ZlibStream.UncompressBuffer(System.Byte[])"/>
            
             <param name="compressed">
               A buffer containing ZLIB-compressed data.
             </param>
            
             <returns>The uncompressed string</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.UncompressBuffer(System.Byte[])">
             <summary>
               Uncompress a ZLIB-compressed byte array into a byte array.
             </summary>
            
             <seealso cref="M:Ionic.Zlib.ZlibStream.CompressBuffer(System.Byte[])"/>
             <seealso cref="M:Ionic.Zlib.ZlibStream.UncompressString(System.Byte[])"/>
            
             <param name="compressed">
               A buffer containing ZLIB-compressed data.
             </param>
            
             <returns>The data in uncompressed form</returns>
        </member>
        <member name="T:Newtonsoft.Json.Bson.BsonObjectId">
            <summary>
            Represents a BSON Oid (object id).
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.Bson.BsonObjectId.Value">
            <summary>
            Gets or sets the value of the Oid.
            </summary>
            <value>The value of the Oid.</value>
        </member>
        <member name="M:Newtonsoft.Json.Bson.BsonObjectId.#ctor(System.Byte[])">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Bson.BsonObjectId"/> class.
            </summary>
            <param name="value">The Oid value.</param>
        </member>
        <member name="T:Newtonsoft.Json.Bson.BsonReader">
            <summary>
            Represents a reader that provides fast, non-cached, forward-only access to serialized Json data.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.Bson.BsonReader.JsonNet35BinaryCompatibility">
            <summary>
            Gets or sets a value indicating whether binary data reading should compatible with incorrect Json.NET 3.5 written binary.
            </summary>
            <value>
            	<c>true</c> if binary data reading will be compatible with incorrect Json.NET 3.5 written binary; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Newtonsoft.Json.Bson.BsonReader.ReadRootValueAsArray">
            <summary>
            Gets or sets a value indicating whether the root object will be read as a JSON array.
            </summary>
            <value>
            	<c>true</c> if the root object will be read as a JSON array; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Newtonsoft.Json.Bson.BsonReader.DateTimeKindHandling">
            <summary>
            Gets or sets the <see cref="T:System.DateTimeKind" /> used when reading <see cref="T:System.DateTime"/> values from BSON.
            </summary>
            <value>The <see cref="T:System.DateTimeKind" /> used when reading <see cref="T:System.DateTime"/> values from BSON.</value>
        </member>
        <member name="M:Newtonsoft.Json.Bson.BsonReader.#ctor(System.IO.Stream)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Bson.BsonReader"/> class.
            </summary>
            <param name="stream">The stream.</param>
        </member>
        <member name="M:Newtonsoft.Json.Bson.BsonReader.#ctor(System.IO.BinaryReader)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Bson.BsonReader"/> class.
            </summary>
            <param name="reader">The reader.</param>
        </member>
        <member name="M:Newtonsoft.Json.Bson.BsonReader.#ctor(System.IO.Stream,System.Boolean,System.DateTimeKind)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Bson.BsonReader"/> class.
            </summary>
            <param name="stream">The stream.</param>
            <param name="readRootValueAsArray">if set to <c>true</c> the root object will be read as a JSON array.</param>
            <param name="dateTimeKindHandling">The <see cref="T:System.DateTimeKind" /> used when reading <see cref="T:System.DateTime"/> values from BSON.</param>
        </member>
        <member name="M:Newtonsoft.Json.Bson.BsonReader.#ctor(System.IO.BinaryReader,System.Boolean,System.DateTimeKind)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Bson.BsonReader"/> class.
            </summary>
            <param name="reader">The reader.</param>
            <param name="readRootValueAsArray">if set to <c>true</c> the root object will be read as a JSON array.</param>
            <param name="dateTimeKindHandling">The <see cref="T:System.DateTimeKind" /> used when reading <see cref="T:System.DateTime"/> values from BSON.</param>
        </member>
        <member name="M:Newtonsoft.Json.Bson.BsonReader.ReadAsBytes">
            <summary>
            Reads the next JSON token from the stream as a <see cref="T:Byte[]"/>.
            </summary>
            <returns>
            A <see cref="T:Byte[]"/> or a null reference if the next JSON token is null. This method will return <c>null</c> at the end of an array.
            </returns>
        </member>
        <member name="M:Newtonsoft.Json.Bson.BsonReader.ReadAsDecimal">
            <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1"/>.
            </summary>
            <returns>A <see cref="T:System.Nullable`1"/>. This method will return <c>null</c> at the end of an array.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Bson.BsonReader.ReadAsInt32">
            <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1"/>.
            </summary>
            <returns>A <see cref="T:System.Nullable`1"/>. This method will return <c>null</c> at the end of an array.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Bson.BsonReader.ReadAsString">
            <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.String"/>.
            </summary>
            <returns>A <see cref="T:System.String"/>. This method will return <c>null</c> at the end of an array.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Bson.BsonReader.ReadAsDateTime">
            <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1"/>.
            </summary>
            <returns>A <see cref="T:System.String"/>. This method will return <c>null</c> at the end of an array.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Bson.BsonReader.ReadAsDateTimeOffset">
            <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1"/>.
            </summary>
            <returns>
            A <see cref="T:System.Nullable`1"/>. This method will return <c>null</c> at the end of an array.
            </returns>
        </member>
        <member name="M:Newtonsoft.Json.Bson.BsonReader.Read">
            <summary>
            Reads the next JSON token from the stream.
            </summary>
            <returns>
            true if the next token was read successfully; false if there are no more tokens to read.
            </returns>
        </member>
        <member name="M:Newtonsoft.Json.Bson.BsonReader.Close">
            <summary>
            Changes the <see cref="T:Newtonsoft.Json.JsonReader.State"/> to Closed.
            </summary>
        </member>
        <member name="T:Newtonsoft.Json.Bson.BsonWriter">
            <summary>
            Represents a writer that provides a fast, non-cached, forward-only way of generating JSON data.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.Bson.BsonWriter.DateTimeKindHandling">
            <summary>
            Gets or sets the <see cref="T:System.DateTimeKind" /> used when writing <see cref="T:System.DateTime"/> values to BSON.
            When set to <see cref="F:System.DateTimeKind.Unspecified" /> no conversion will occur.
            </summary>
            <value>The <see cref="T:System.DateTimeKind" /> used when writing <see cref="T:System.DateTime"/> values to BSON.</value>
        </member>
        <member name="M:Newtonsoft.Json.Bson.BsonWriter.#ctor(System.IO.Stream)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Bson.BsonWriter"/> class.
            </summary>
            <param name="stream">The stream.</param>
        </member>
        <member name="M:Newtonsoft.Json.Bson.BsonWriter.#ctor(System.IO.BinaryWriter)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Bson.BsonWriter"/> class.
            </summary>
            <param name="writer">The writer.</param>
        </member>
        <member name="M:Newtonsoft.Json.Bson.BsonWriter.Flush">
            <summary>
            Flushes whatever is in the buffer to the underlying streams and also flushes the underlying stream.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteEnd(Newtonsoft.Json.JsonToken)">
            <summary>
            Writes the end.
            </summary>
            <param name="token">The token.</param>
        </member>
        <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteComment(System.String)">
            <summary>
            Writes out a comment <code>/*...*/</code> containing the specified text.
            </summary>
            <param name="text">Text to place inside the comment.</param>
        </member>
        <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteStartConstructor(System.String)">
            <summary>
            Writes the start of a constructor with the given name.
            </summary>
            <param name="name">The name of the constructor.</param>
        </member>
        <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteRaw(System.String)">
            <summary>
            Writes raw JSON.
            </summary>
            <param name="json">The raw JSON to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteRawValue(System.String)">
            <summary>
            Writes raw JSON where a value is expected and updates the writer's state.
            </summary>
            <param name="json">The raw JSON to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteStartArray">
            <summary>
            Writes the beginning of a Json array.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteStartObject">
            <summary>
            Writes the beginning of a Json object.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.Bson.BsonWriter.WritePropertyName(System.String)">
            <summary>
            Writes the property name of a name/value pair on a Json object.
            </summary>
            <param name="name">The name of the property.</param>
        </member>
        <member name="M:Newtonsoft.Json.Bson.BsonWriter.Close">
            <summary>
            Closes this stream and the underlying stream.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.Object)">
            <summary>
            Writes a <see cref="T:System.Object"/> value.
            An error will raised if the value cannot be written as a single JSON token.
            </summary>
            <param name="value">The <see cref="T:System.Object"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteNull">
            <summary>
            Writes a null value.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteUndefined">
            <summary>
            Writes an undefined value.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.String)">
            <summary>
            Writes a <see cref="T:System.String"/> value.
            </summary>
            <param name="value">The <see cref="T:System.String"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.Int32)">
            <summary>
            Writes a <see cref="T:System.Int32"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Int32"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.UInt32)">
            <summary>
            Writes a <see cref="T:System.UInt32"/> value.
            </summary>
            <param name="value">The <see cref="T:System.UInt32"/> value to write.</param> 
        </member>
        <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.Int64)">
            <summary>
            Writes a <see cref="T:System.Int64"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Int64"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.UInt64)">
            <summary>
            Writes a <see cref="T:System.UInt64"/> value.
            </summary>
            <param name="value">The <see cref="T:System.UInt64"/> value to write.</param> 
        </member>
        <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.Single)">
            <summary>
            Writes a <see cref="T:System.Single"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Single"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.Double)">
            <summary>
            Writes a <see cref="T:System.Double"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Double"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.Boolean)">
            <summary>
            Writes a <see cref="T:System.Boolean"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Boolean"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.Int16)">
            <summary>
            Writes a <see cref="T:System.Int16"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Int16"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.UInt16)">
            <summary>
            Writes a <see cref="T:System.UInt16"/> value.
            </summary>
            <param name="value">The <see cref="T:System.UInt16"/> value to write.</param> 
        </member>
        <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.Char)">
            <summary>
            Writes a <see cref="T:System.Char"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Char"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.Byte)">
            <summary>
            Writes a <see cref="T:System.Byte"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Byte"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.SByte)">
            <summary>
            Writes a <see cref="T:System.SByte"/> value.
            </summary>
            <param name="value">The <see cref="T:System.SByte"/> value to write.</param> 
        </member>
        <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.Decimal)">
            <summary>
            Writes a <see cref="T:System.Decimal"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Decimal"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.DateTime)">
            <summary>
            Writes a <see cref="T:System.DateTime"/> value.
            </summary>
            <param name="value">The <see cref="T:System.DateTime"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.DateTimeOffset)">
            <summary>
            Writes a <see cref="T:System.DateTimeOffset"/> value.
            </summary>
            <param name="value">The <see cref="T:System.DateTimeOffset"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.Byte[])">
            <summary>
            Writes a <see cref="T:Byte[]"/> value.
            </summary>
            <param name="value">The <see cref="T:Byte[]"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.Guid)">
            <summary>
            Writes a <see cref="T:System.Guid"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Guid"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.TimeSpan)">
            <summary>
            Writes a <see cref="T:System.TimeSpan"/> value.
            </summary>
            <param name="value">The <see cref="T:System.TimeSpan"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.Uri)">
            <summary>
            Writes a <see cref="T:System.Uri"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Uri"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteObjectId(System.Byte[])">
            <summary>
            Writes a <see cref="T:Byte[]"/> value that represents a BSON object id.
            </summary>
            <param name="value">The Object ID value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteRegex(System.String,System.String)">
            <summary>
            Writes a BSON regex.
            </summary>
            <param name="pattern">The regex pattern.</param>
            <param name="options">The regex options.</param>
        </member>
        <member name="T:Newtonsoft.Json.ConstructorHandling">
            <summary>
            Specifies how constructors are used when initializing objects during deserialization by the <see cref="T:Newtonsoft.Json.JsonSerializer"/>.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.ConstructorHandling.Default">
            <summary>
            First attempt to use the public default constructor, then fall back to single paramatized constructor, then the non-public default constructor.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.ConstructorHandling.AllowNonPublicDefaultConstructor">
            <summary>
            Json.NET will use a non-public default constructor before falling back to a paramatized constructor.
            </summary>
        </member>
        <member name="T:Newtonsoft.Json.Converters.BinaryConverter">
            <summary>
            Converts a binary value to and from a base 64 string value.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.Converters.BinaryConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Writes the JSON representation of the object.
            </summary>
            <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter"/> to write to.</param>
            <param name="value">The value.</param>
            <param name="serializer">The calling serializer.</param>
        </member>
        <member name="M:Newtonsoft.Json.Converters.BinaryConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Reads the JSON representation of the object.
            </summary>
            <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader"/> to read from.</param>
            <param name="objectType">Type of the object.</param>
            <param name="existingValue">The existing value of object being read.</param>
            <param name="serializer">The calling serializer.</param>
            <returns>The object value.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Converters.BinaryConverter.CanConvert(System.Type)">
            <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
            <param name="objectType">Type of the object.</param>
            <returns>
            	<c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:Newtonsoft.Json.Converters.BsonObjectIdConverter">
            <summary>
            Converts a <see cref="T:Newtonsoft.Json.Bson.BsonObjectId"/> to and from JSON and BSON.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.Converters.BsonObjectIdConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Writes the JSON representation of the object.
            </summary>
            <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter"/> to write to.</param>
            <param name="value">The value.</param>
            <param name="serializer">The calling serializer.</param>
        </member>
        <member name="M:Newtonsoft.Json.Converters.BsonObjectIdConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Reads the JSON representation of the object.
            </summary>
            <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader"/> to read from.</param>
            <param name="objectType">Type of the object.</param>
            <param name="existingValue">The existing value of object being read.</param>
            <param name="serializer">The calling serializer.</param>
            <returns>The object value.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Converters.BsonObjectIdConverter.CanConvert(System.Type)">
            <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
            <param name="objectType">Type of the object.</param>
            <returns>
            	<c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:Newtonsoft.Json.Converters.CustomCreationConverter`1">
            <summary>
            Create a custom object
            </summary>
            <typeparam name="T">The object type to convert.</typeparam>
        </member>
        <member name="M:Newtonsoft.Json.Converters.CustomCreationConverter`1.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Writes the JSON representation of the object.
            </summary>
            <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter"/> to write to.</param>
            <param name="value">The value.</param>
            <param name="serializer">The calling serializer.</param>
        </member>
        <member name="M:Newtonsoft.Json.Converters.CustomCreationConverter`1.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Reads the JSON representation of the object.
            </summary>
            <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader"/> to read from.</param>
            <param name="objectType">Type of the object.</param>
            <param name="existingValue">The existing value of object being read.</param>
            <param name="serializer">The calling serializer.</param>
            <returns>The object value.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Converters.CustomCreationConverter`1.Create(System.Type)">
            <summary>
            Creates an object which will then be populated by the serializer.
            </summary>
            <param name="objectType">Type of the object.</param>
            <returns>The created object.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Converters.CustomCreationConverter`1.CanConvert(System.Type)">
            <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
            <param name="objectType">Type of the object.</param>
            <returns>
            	<c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="P:Newtonsoft.Json.Converters.CustomCreationConverter`1.CanWrite">
            <summary>
            Gets a value indicating whether this <see cref="T:Newtonsoft.Json.JsonConverter"/> can write JSON.
            </summary>
            <value>
            	<c>true</c> if this <see cref="T:Newtonsoft.Json.JsonConverter"/> can write JSON; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="T:Newtonsoft.Json.Converters.DataSetConverter">
            <summary>
            Converts a <see cref="T:System.Data.DataSet"/> to and from JSON.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.Converters.DataSetConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Writes the JSON representation of the object.
            </summary>
            <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter"/> to write to.</param>
            <param name="value">The value.</param>
            <param name="serializer">The calling serializer.</param>
        </member>
        <member name="M:Newtonsoft.Json.Converters.DataSetConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Reads the JSON representation of the object.
            </summary>
            <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader"/> to read from.</param>
            <param name="objectType">Type of the object.</param>
            <param name="existingValue">The existing value of object being read.</param>
            <param name="serializer">The calling serializer.</param>
            <returns>The object value.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Converters.DataSetConverter.CanConvert(System.Type)">
            <summary>
            Determines whether this instance can convert the specified value type.
            </summary>
            <param name="valueType">Type of the value.</param>
            <returns>
            	<c>true</c> if this instance can convert the specified value type; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:Newtonsoft.Json.Converters.DataTableConverter">
            <summary>
            Converts a <see cref="T:System.Data.DataTable"/> to and from JSON.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.Converters.DataTableConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Writes the JSON representation of the object.
            </summary>
            <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter"/> to write to.</param>
            <param name="value">The value.</param>
            <param name="serializer">The calling serializer.</param>
        </member>
        <member name="M:Newtonsoft.Json.Converters.DataTableConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Reads the JSON representation of the object.
            </summary>
            <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader"/> to read from.</param>
            <param name="objectType">Type of the object.</param>
            <param name="existingValue">The existing value of object being read.</param>
            <param name="serializer">The calling serializer.</param>
            <returns>The object value.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Converters.DataTableConverter.CanConvert(System.Type)">
            <summary>
            Determines whether this instance can convert the specified value type.
            </summary>
            <param name="valueType">Type of the value.</param>
            <returns>
            	<c>true</c> if this instance can convert the specified value type; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:Newtonsoft.Json.Converters.DateTimeConverterBase">
            <summary>
            Provides a base class for converting a <see cref="T:System.DateTime"/> to and from JSON.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.Converters.DateTimeConverterBase.CanConvert(System.Type)">
            <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
            <param name="objectType">Type of the object.</param>
            <returns>
            	<c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:Newtonsoft.Json.Converters.DiscriminatedUnionConverter">
            <summary>
            Converts a F# discriminated union type to and from JSON.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.Converters.DiscriminatedUnionConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Writes the JSON representation of the object.
            </summary>
            <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter"/> to write to.</param>
            <param name="value">The value.</param>
            <param name="serializer">The calling serializer.</param>
        </member>
        <member name="M:Newtonsoft.Json.Converters.DiscriminatedUnionConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Reads the JSON representation of the object.
            </summary>
            <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader"/> to read from.</param>
            <param name="objectType">Type of the object.</param>
            <param name="existingValue">The existing value of object being read.</param>
            <param name="serializer">The calling serializer.</param>
            <returns>The object value.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Converters.DiscriminatedUnionConverter.CanConvert(System.Type)">
            <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
            <param name="objectType">Type of the object.</param>
            <returns>
            	<c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:Newtonsoft.Json.Converters.EntityKeyMemberConverter">
            <summary>
            Converts an Entity Framework EntityKey to and from JSON.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.Converters.EntityKeyMemberConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Writes the JSON representation of the object.
            </summary>
            <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter"/> to write to.</param>
            <param name="value">The value.</param>
            <param name="serializer">The calling serializer.</param>
        </member>
        <member name="M:Newtonsoft.Json.Converters.EntityKeyMemberConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Reads the JSON representation of the object.
            </summary>
            <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader"/> to read from.</param>
            <param name="objectType">Type of the object.</param>
            <param name="existingValue">The existing value of object being read.</param>
            <param name="serializer">The calling serializer.</param>
            <returns>The object value.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Converters.EntityKeyMemberConverter.CanConvert(System.Type)">
            <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
            <param name="objectType">Type of the object.</param>
            <returns>
            	<c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:Newtonsoft.Json.Converters.IsoDateTimeConverter">
            <summary>
            Converts a <see cref="T:System.DateTime"/> to and from the ISO 8601 date format (e.g. 2008-04-12T12:53Z).
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.Converters.IsoDateTimeConverter.DateTimeStyles">
            <summary>
            Gets or sets the date time styles used when converting a date to and from JSON.
            </summary>
            <value>The date time styles used when converting a date to and from JSON.</value>
        </member>
        <member name="P:Newtonsoft.Json.Converters.IsoDateTimeConverter.DateTimeFormat">
            <summary>
            Gets or sets the date time format used when converting a date to and from JSON.
            </summary>
            <value>The date time format used when converting a date to and from JSON.</value>
        </member>
        <member name="P:Newtonsoft.Json.Converters.IsoDateTimeConverter.Culture">
            <summary>
            Gets or sets the culture used when converting a date to and from JSON.
            </summary>
            <value>The culture used when converting a date to and from JSON.</value>
        </member>
        <member name="M:Newtonsoft.Json.Converters.IsoDateTimeConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Writes the JSON representation of the object.
            </summary>
            <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter"/> to write to.</param>
            <param name="value">The value.</param>
            <param name="serializer">The calling serializer.</param>
        </member>
        <member name="M:Newtonsoft.Json.Converters.IsoDateTimeConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Reads the JSON representation of the object.
            </summary>
            <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader"/> to read from.</param>
            <param name="objectType">Type of the object.</param>
            <param name="existingValue">The existing value of object being read.</param>
            <param name="serializer">The calling serializer.</param>
            <returns>The object value.</returns>
        </member>
        <member name="T:Newtonsoft.Json.Converters.JavaScriptDateTimeConverter">
            <summary>
            Converts a <see cref="T:System.DateTime"/> to and from a JavaScript date constructor (e.g. new Date(52231943)).
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.Converters.JavaScriptDateTimeConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Writes the JSON representation of the object.
            </summary>
            <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter"/> to write to.</param>
            <param name="value">The value.</param>
            <param name="serializer">The calling serializer.</param>
        </member>
        <member name="M:Newtonsoft.Json.Converters.JavaScriptDateTimeConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Reads the JSON representation of the object.
            </summary>
            <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader"/> to read from.</param>
            <param name="objectType">Type of the object.</param>
            <param name="existingValue">The existing property value of the JSON that is being converted.</param>
            <param name="serializer">The calling serializer.</param>
            <returns>The object value.</returns>
        </member>
        <member name="T:Newtonsoft.Json.Converters.KeyValuePairConverter">
            <summary>
            Converts a <see cref="T:System.Collections.Generic.KeyValuePair`2"/> to and from JSON.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.Converters.KeyValuePairConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Writes the JSON representation of the object.
            </summary>
            <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter"/> to write to.</param>
            <param name="value">The value.</param>
            <param name="serializer">The calling serializer.</param>
        </member>
        <member name="M:Newtonsoft.Json.Converters.KeyValuePairConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Reads the JSON representation of the object.
            </summary>
            <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader"/> to read from.</param>
            <param name="objectType">Type of the object.</param>
            <param name="existingValue">The existing value of object being read.</param>
            <param name="serializer">The calling serializer.</param>
            <returns>The object value.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Converters.KeyValuePairConverter.CanConvert(System.Type)">
            <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
            <param name="objectType">Type of the object.</param>
            <returns>
            	<c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:Newtonsoft.Json.Converters.RegexConverter">
            <summary>
            Converts a <see cref="T:System.Text.RegularExpressions.Regex"/> to and from JSON and BSON.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.Converters.RegexConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Writes the JSON representation of the object.
            </summary>
            <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter"/> to write to.</param>
            <param name="value">The value.</param>
            <param name="serializer">The calling serializer.</param>
        </member>
        <member name="M:Newtonsoft.Json.Converters.RegexConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Reads the JSON representation of the object.
            </summary>
            <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader"/> to read from.</param>
            <param name="objectType">Type of the object.</param>
            <param name="existingValue">The existing value of object being read.</param>
            <param name="serializer">The calling serializer.</param>
            <returns>The object value.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Converters.RegexConverter.CanConvert(System.Type)">
            <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
            <param name="objectType">Type of the object.</param>
            <returns>
            	<c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:Newtonsoft.Json.Converters.StringEnumConverter">
            <summary>
            Converts an <see cref="T:System.Enum"/> to and from its name string value.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.Converters.StringEnumConverter.CamelCaseText">
            <summary>
            Gets or sets a value indicating whether the written enum text should be camel case.
            </summary>
            <value><c>true</c> if the written enum text will be camel case; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Newtonsoft.Json.Converters.StringEnumConverter.AllowIntegerValues">
            <summary>
            Gets or sets a value indicating whether integer values are allowed.
            </summary>
            <value><c>true</c> if integers are allowed; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:Newtonsoft.Json.Converters.StringEnumConverter.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Converters.StringEnumConverter"/> class.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.Converters.StringEnumConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Writes the JSON representation of the object.
            </summary>
            <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter"/> to write to.</param>
            <param name="value">The value.</param>
            <param name="serializer">The calling serializer.</param>
        </member>
        <member name="M:Newtonsoft.Json.Converters.StringEnumConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Reads the JSON representation of the object.
            </summary>
            <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader"/> to read from.</param>
            <param name="objectType">Type of the object.</param>
            <param name="existingValue">The existing value of object being read.</param>
            <param name="serializer">The calling serializer.</param>
            <returns>The object value.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Converters.StringEnumConverter.CanConvert(System.Type)">
            <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
            <param name="objectType">Type of the object.</param>
            <returns>
            <c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:Newtonsoft.Json.Converters.VersionConverter">
            <summary>
            Converts a <see cref="T:System.Version"/> to and from a string (e.g. "1.2.3.4").
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.Converters.VersionConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Writes the JSON representation of the object.
            </summary>
            <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter"/> to write to.</param>
            <param name="value">The value.</param>
            <param name="serializer">The calling serializer.</param>
        </member>
        <member name="M:Newtonsoft.Json.Converters.VersionConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Reads the JSON representation of the object.
            </summary>
            <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader"/> to read from.</param>
            <param name="objectType">Type of the object.</param>
            <param name="existingValue">The existing property value of the JSON that is being converted.</param>
            <param name="serializer">The calling serializer.</param>
            <returns>The object value.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Converters.VersionConverter.CanConvert(System.Type)">
            <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
            <param name="objectType">Type of the object.</param>
            <returns>
            	<c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:Newtonsoft.Json.Converters.XmlNodeConverter">
            <summary>
            Converts XML to and from JSON.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.Converters.XmlNodeConverter.DeserializeRootElementName">
            <summary>
            Gets or sets the name of the root element to insert when deserializing to XML if the JSON structure has produces multiple root elements.
            </summary>
            <value>The name of the deserialize root element.</value>
        </member>
        <member name="P:Newtonsoft.Json.Converters.XmlNodeConverter.WriteArrayAttribute">
            <summary>
            Gets or sets a flag to indicate whether to write the Json.NET array attribute.
            This attribute helps preserve arrays when converting the written XML back to JSON.
            </summary>
            <value><c>true</c> if the array attibute is written to the XML; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Newtonsoft.Json.Converters.XmlNodeConverter.OmitRootObject">
            <summary>
            Gets or sets a value indicating whether to write the root JSON object.
            </summary>
            <value><c>true</c> if the JSON root object is omitted; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:Newtonsoft.Json.Converters.XmlNodeConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Writes the JSON representation of the object.
            </summary>
            <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter"/> to write to.</param>
            <param name="serializer">The calling serializer.</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:Newtonsoft.Json.Converters.XmlNodeConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Reads the JSON representation of the object.
            </summary>
            <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader"/> to read from.</param>
            <param name="objectType">Type of the object.</param>
            <param name="existingValue">The existing value of object being read.</param>
            <param name="serializer">The calling serializer.</param>
            <returns>The object value.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Converters.XmlNodeConverter.IsNamespaceAttribute(System.String,System.String@)">
            <summary>
            Checks if the attributeName is a namespace attribute.
            </summary>
            <param name="attributeName">Attribute name to test.</param>
            <param name="prefix">The attribute name prefix if it has one, otherwise an empty string.</param>
            <returns>True if attribute name is for a namespace attribute, otherwise false.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Converters.XmlNodeConverter.CanConvert(System.Type)">
            <summary>
            Determines whether this instance can convert the specified value type.
            </summary>
            <param name="valueType">Type of the value.</param>
            <returns>
            	<c>true</c> if this instance can convert the specified value type; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:Newtonsoft.Json.DateFormatHandling">
            <summary>
            Specifies how dates are formatted when writing JSON text.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.DateFormatHandling.IsoDateFormat">
            <summary>
            Dates are written in the ISO 8601 format, e.g. "2012-03-21T05:40Z".
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.DateFormatHandling.MicrosoftDateFormat">
            <summary>
            Dates are written in the Microsoft JSON format, e.g. "\/Date(1198908717056)\/".
            </summary>
        </member>
        <member name="T:Newtonsoft.Json.DateParseHandling">
            <summary>
            Specifies how date formatted strings, e.g. "\/Date(1198908717056)\/" and "2012-03-21T05:40Z", are parsed when reading JSON text.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.DateParseHandling.None">
            <summary>
            Date formatted strings are not parsed to a date type and are read as strings.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.DateParseHandling.DateTime">
            <summary>
            Date formatted strings, e.g. "\/Date(1198908717056)\/" and "2012-03-21T05:40Z", are parsed to <see cref="F:Newtonsoft.Json.DateParseHandling.DateTime"/>.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.DateParseHandling.DateTimeOffset">
            <summary>
            Date formatted strings, e.g. "\/Date(1198908717056)\/" and "2012-03-21T05:40Z", are parsed to <see cref="F:Newtonsoft.Json.DateParseHandling.DateTimeOffset"/>.
            </summary>
        </member>
        <member name="T:Newtonsoft.Json.DateTimeZoneHandling">
            <summary>
            Specifies how to treat the time value when converting between string and <see cref="T:System.DateTime"/>.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.DateTimeZoneHandling.Local">
            <summary>
            Treat as local time. If the <see cref="T:System.DateTime"/> object represents a Coordinated Universal Time (UTC), it is converted to the local time.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.DateTimeZoneHandling.Utc">
            <summary>
            Treat as a UTC. If the <see cref="T:System.DateTime"/> object represents a local time, it is converted to a UTC.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.DateTimeZoneHandling.Unspecified">
            <summary>
            Treat as a local time if a <see cref="T:System.DateTime"/> is being converted to a string.
            If a string is being converted to <see cref="T:System.DateTime"/>, convert to a local time if a time zone is specified.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.DateTimeZoneHandling.RoundtripKind">
            <summary>
            Time zone information should be preserved when converting.
            </summary>
        </member>
        <member name="T:Newtonsoft.Json.DefaultValueHandling">
            <summary>
            Specifies default value handling options for the <see cref="T:Newtonsoft.Json.JsonSerializer"/>.
            </summary>
            <example>
              <code lang="cs" source="..\Src\Newtonsoft.Json.Tests\Documentation\SerializationTests.cs" region="ReducingSerializedJsonSizeDefaultValueHandlingObject" title="DefaultValueHandling Class" />
              <code lang="cs" source="..\Src\Newtonsoft.Json.Tests\Documentation\SerializationTests.cs" region="ReducingSerializedJsonSizeDefaultValueHandlingExample" title="DefaultValueHandling Ignore Example" />
            </example>
        </member>
        <member name="F:Newtonsoft.Json.DefaultValueHandling.Include">
            <summary>
            Include members where the member value is the same as the member's default value when serializing objects.
            Included members are written to JSON. Has no effect when deserializing.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.DefaultValueHandling.Ignore">
            <summary>
            Ignore members where the member value is the same as the member's default value when serializing objects
            so that is is not written to JSON.
            This option will ignore all default values (e.g. <c>null</c> for objects and nullable typesl; <c>0</c> for integers,
            decimals and floating point numbers; and <c>false</c> for booleans). The default value ignored can be changed by
            placing the <see cref="T:System.ComponentModel.DefaultValueAttribute"/> on the property.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.DefaultValueHandling.Populate">
            <summary>
            Members with a default value but no JSON will be set to their default value when deserializing.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.DefaultValueHandling.IgnoreAndPopulate">
            <summary>
            Ignore members where the member value is the same as the member's default value when serializing objects
            and sets members to their default value when deserializing.
            </summary>
        </member>
        <member name="T:Newtonsoft.Json.FloatFormatHandling">
            <summary>
            Specifies float format handling options when writing special floating point numbers, e.g. <see cref="F:System.Double.NaN"/>,
            <see cref="F:System.Double.PositiveInfinity"/> and <see cref="F:System.Double.NegativeInfinity"/> with <see cref="T:Newtonsoft.Json.JsonWriter"/>.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.FloatFormatHandling.String">
            <summary>
            Write special floating point values as strings in JSON, e.g. "NaN", "Infinity", "-Infinity".
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.FloatFormatHandling.Symbol">
            <summary>
            Write special floating point values as symbols in JSON, e.g. NaN, Infinity, -Infinity.
            Note that this will produce non-valid JSON.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.FloatFormatHandling.DefaultValue">
            <summary>
            Write special floating point values as the property's default value in JSON, e.g. 0.0 for a <see cref="T:System.Double"/> property, null for a <see cref="T:System.Nullable`1"/> property.
            </summary>
        </member>
        <member name="T:Newtonsoft.Json.FloatParseHandling">
            <summary>
            Specifies how floating point numbers, e.g. 1.0 and 9.9, are parsed when reading JSON text.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.FloatParseHandling.Double">
            <summary>
            Floating point numbers are parsed to <see cref="F:Newtonsoft.Json.FloatParseHandling.Double"/>.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.FloatParseHandling.Decimal">
            <summary>
            Floating point numbers are parsed to <see cref="F:Newtonsoft.Json.FloatParseHandling.Decimal"/>.
            </summary>
        </member>
        <member name="T:Newtonsoft.Json.Formatting">
            <summary>
            Specifies formatting options for the <see cref="T:Newtonsoft.Json.JsonTextWriter"/>.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.Formatting.None">
            <summary>
            No special formatting is applied. This is the default.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.Formatting.Indented">
            <summary>
            Causes child objects to be indented according to the <see cref="P:Newtonsoft.Json.JsonTextWriter.Indentation"/> and <see cref="P:Newtonsoft.Json.JsonTextWriter.IndentChar"/> settings.
            </summary>
        </member>
        <member name="T:Newtonsoft.Json.IJsonLineInfo">
            <summary>
            Provides an interface to enable a class to return line and position information.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.IJsonLineInfo.HasLineInfo">
            <summary>
            Gets a value indicating whether the class can return line information.
            </summary>
            <returns>
            	<c>true</c> if LineNumber and LinePosition can be provided; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="P:Newtonsoft.Json.IJsonLineInfo.LineNumber">
            <summary>
            Gets the current line number.
            </summary>
            <value>The current line number or 0 if no line information is available (for example, HasLineInfo returns false).</value>
        </member>
        <member name="P:Newtonsoft.Json.IJsonLineInfo.LinePosition">
            <summary>
            Gets the current line position.
            </summary>
            <value>The current line position or 0 if no line information is available (for example, HasLineInfo returns false).</value>
        </member>
        <member name="T:Newtonsoft.Json.JsonArrayAttribute">
            <summary>
            Instructs the <see cref="T:Newtonsoft.Json.JsonSerializer"/> how to serialize the collection.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.JsonArrayAttribute.AllowNullItems">
            <summary>
            Gets or sets a value indicating whether null items are allowed in the collection.
            </summary>
            <value><c>true</c> if null items are allowed in the collection; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:Newtonsoft.Json.JsonArrayAttribute.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonArrayAttribute"/> class.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.JsonArrayAttribute.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonObjectAttribute"/> class with a flag indicating whether the array can contain null items
            </summary>
            <param name="allowNullItems">A flag indicating whether the array can contain null items.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonArrayAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonArrayAttribute"/> class with the specified container Id.
            </summary>
            <param name="id">The container Id.</param>
        </member>
        <member name="T:Newtonsoft.Json.JsonConstructorAttribute">
            <summary>
            Instructs the <see cref="T:Newtonsoft.Json.JsonSerializer"/> to use the specified constructor when deserializing that object.
            </summary>
        </member>
        <member name="T:Newtonsoft.Json.JsonContainerAttribute">
            <summary>
            Instructs the <see cref="T:Newtonsoft.Json.JsonSerializer"/> how to serialize the object.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.JsonContainerAttribute.Id">
            <summary>
            Gets or sets the id.
            </summary>
            <value>The id.</value>
        </member>
        <member name="P:Newtonsoft.Json.JsonContainerAttribute.Title">
            <summary>
            Gets or sets the title.
            </summary>
            <value>The title.</value>
        </member>
        <member name="P:Newtonsoft.Json.JsonContainerAttribute.Description">
            <summary>
            Gets or sets the description.
            </summary>
            <value>The description.</value>
        </member>
        <member name="P:Newtonsoft.Json.JsonContainerAttribute.ItemConverterType">
            <summary>
            Gets the collection's items converter.
            </summary>
            <value>The collection's items converter.</value>
        </member>
        <member name="P:Newtonsoft.Json.JsonContainerAttribute.IsReference">
            <summary>
            Gets or sets a value that indicates whether to preserve object references.
            </summary>
            <value>
            	<c>true</c> to keep object reference; otherwise, <c>false</c>. The default is <c>false</c>.
            </value>
        </member>
        <member name="P:Newtonsoft.Json.JsonContainerAttribute.ItemIsReference">
            <summary>
            Gets or sets a value that indicates whether to preserve collection's items references.
            </summary>
            <value>
            	<c>true</c> to keep collection's items object references; otherwise, <c>false</c>. The default is <c>false</c>.
            </value>
        </member>
        <member name="P:Newtonsoft.Json.JsonContainerAttribute.ItemReferenceLoopHandling">
            <summary>
            Gets or sets the reference loop handling used when serializing the collection's items.
            </summary>
            <value>The reference loop handling.</value>
        </member>
        <member name="P:Newtonsoft.Json.JsonContainerAttribute.ItemTypeNameHandling">
            <summary>
            Gets or sets the type name handling used when serializing the collection's items.
            </summary>
            <value>The type name handling.</value>
        </member>
        <member name="M:Newtonsoft.Json.JsonContainerAttribute.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonContainerAttribute"/> class.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.JsonContainerAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonContainerAttribute"/> class with the specified container Id.
            </summary>
            <param name="id">The container Id.</param>
        </member>
        <member name="T:Newtonsoft.Json.JsonConvert">
            <summary>
            Provides methods for converting between common language runtime types and JSON types.
            </summary>
            <example>
              <code lang="cs" source="..\Src\Newtonsoft.Json.Tests\Documentation\SerializationTests.cs" region="SerializeObject" title="Serializing and Deserializing JSON with JsonConvert" />
            </example>
        </member>
        <member name="P:Newtonsoft.Json.JsonConvert.DefaultSettings">
            <summary>
            Gets or sets a function that creates default <see cref="T:Newtonsoft.Json.JsonSerializerSettings"/>.
            Default settings are automatically used by serialization methods on <see cref="T:Newtonsoft.Json.JsonConvert"/>,
            and <see cref="M:Newtonsoft.Json.Linq.JToken.ToObject``1"/> and <see cref="M:Newtonsoft.Json.Linq.JToken.FromObject(System.Object)"/> on <see cref="T:Newtonsoft.Json.Linq.JToken"/>.
            To serialize without using any default settings create a <see cref="T:Newtonsoft.Json.JsonSerializer"/> with
            <see cref="M:Newtonsoft.Json.JsonSerializer.Create"/>.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.JsonConvert.True">
            <summary>
            Represents JavaScript's boolean value true as a string. This field is read-only.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.JsonConvert.False">
            <summary>
            Represents JavaScript's boolean value false as a string. This field is read-only.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.JsonConvert.Null">
            <summary>
            Represents JavaScript's null as a string. This field is read-only.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.JsonConvert.Undefined">
            <summary>
            Represents JavaScript's undefined as a string. This field is read-only.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.JsonConvert.PositiveInfinity">
            <summary>
            Represents JavaScript's positive infinity as a string. This field is read-only.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.JsonConvert.NegativeInfinity">
            <summary>
            Represents JavaScript's negative infinity as a string. This field is read-only.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.JsonConvert.NaN">
            <summary>
            Represents JavaScript's NaN as a string. This field is read-only.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.DateTime)">
            <summary>
            Converts the <see cref="T:System.DateTime"/> to its JSON string representation.
            </summary>
            <param name="value">The value to convert.</param>
            <returns>A JSON string representation of the <see cref="T:System.DateTime"/>.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.DateTime,Newtonsoft.Json.DateFormatHandling,Newtonsoft.Json.DateTimeZoneHandling)">
            <summary>
            Converts the <see cref="T:System.DateTime"/> to its JSON string representation using the <see cref="T:Newtonsoft.Json.DateFormatHandling"/> specified.
            </summary>
            <param name="value">The value to convert.</param>
            <param name="format">The format the date will be converted to.</param>
            <param name="timeZoneHandling">The time zone handling when the date is converted to a string.</param>
            <returns>A JSON string representation of the <see cref="T:System.DateTime"/>.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.DateTimeOffset)">
            <summary>
            Converts the <see cref="T:System.DateTimeOffset"/> to its JSON string representation.
            </summary>
            <param name="value">The value to convert.</param>
            <returns>A JSON string representation of the <see cref="T:System.DateTimeOffset"/>.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.DateTimeOffset,Newtonsoft.Json.DateFormatHandling)">
            <summary>
            Converts the <see cref="T:System.DateTimeOffset"/> to its JSON string representation using the <see cref="T:Newtonsoft.Json.DateFormatHandling"/> specified.
            </summary>
            <param name="value">The value to convert.</param>
            <param name="format">The format the date will be converted to.</param>
            <returns>A JSON string representation of the <see cref="T:System.DateTimeOffset"/>.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.Boolean)">
            <summary>
            Converts the <see cref="T:System.Boolean"/> to its JSON string representation.
            </summary>
            <param name="value">The value to convert.</param>
            <returns>A JSON string representation of the <see cref="T:System.Boolean"/>.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.Char)">
            <summary>
            Converts the <see cref="T:System.Char"/> to its JSON string representation.
            </summary>
            <param name="value">The value to convert.</param>
            <returns>A JSON string representation of the <see cref="T:System.Char"/>.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.Enum)">
            <summary>
            Converts the <see cref="T:System.Enum"/> to its JSON string representation.
            </summary>
            <param name="value">The value to convert.</param>
            <returns>A JSON string representation of the <see cref="T:System.Enum"/>.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.Int32)">
            <summary>
            Converts the <see cref="T:System.Int32"/> to its JSON string representation.
            </summary>
            <param name="value">The value to convert.</param>
            <returns>A JSON string representation of the <see cref="T:System.Int32"/>.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.Int16)">
            <summary>
            Converts the <see cref="T:System.Int16"/> to its JSON string representation.
            </summary>
            <param name="value">The value to convert.</param>
            <returns>A JSON string representation of the <see cref="T:System.Int16"/>.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.UInt16)">
            <summary>
            Converts the <see cref="T:System.UInt16"/> to its JSON string representation.
            </summary>
            <param name="value">The value to convert.</param>
            <returns>A JSON string representation of the <see cref="T:System.UInt16"/>.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.UInt32)">
            <summary>
            Converts the <see cref="T:System.UInt32"/> to its JSON string representation.
            </summary>
            <param name="value">The value to convert.</param>
            <returns>A JSON string representation of the <see cref="T:System.UInt32"/>.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.Int64)">
            <summary>
            Converts the <see cref="T:System.Int64"/>  to its JSON string representation.
            </summary>
            <param name="value">The value to convert.</param>
            <returns>A JSON string representation of the <see cref="T:System.Int64"/>.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.UInt64)">
            <summary>
            Converts the <see cref="T:System.UInt64"/> to its JSON string representation.
            </summary>
            <param name="value">The value to convert.</param>
            <returns>A JSON string representation of the <see cref="T:System.UInt64"/>.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.Single)">
            <summary>
            Converts the <see cref="T:System.Single"/> to its JSON string representation.
            </summary>
            <param name="value">The value to convert.</param>
            <returns>A JSON string representation of the <see cref="T:System.Single"/>.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.Double)">
            <summary>
            Converts the <see cref="T:System.Double"/> to its JSON string representation.
            </summary>
            <param name="value">The value to convert.</param>
            <returns>A JSON string representation of the <see cref="T:System.Double"/>.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.Byte)">
            <summary>
            Converts the <see cref="T:System.Byte"/> to its JSON string representation.
            </summary>
            <param name="value">The value to convert.</param>
            <returns>A JSON string representation of the <see cref="T:System.Byte"/>.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.SByte)">
            <summary>
            Converts the <see cref="T:System.SByte"/> to its JSON string representation.
            </summary>
            <param name="value">The value to convert.</param>
            <returns>A JSON string representation of the <see cref="T:System.SByte"/>.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.Decimal)">
            <summary>
            Converts the <see cref="T:System.Decimal"/> to its JSON string representation.
            </summary>
            <param name="value">The value to convert.</param>
            <returns>A JSON string representation of the <see cref="T:System.SByte"/>.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.Guid)">
            <summary>
            Converts the <see cref="T:System.Guid"/> to its JSON string representation.
            </summary>
            <param name="value">The value to convert.</param>
            <returns>A JSON string representation of the <see cref="T:System.Guid"/>.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.TimeSpan)">
            <summary>
            Converts the <see cref="T:System.TimeSpan"/> to its JSON string representation.
            </summary>
            <param name="value">The value to convert.</param>
            <returns>A JSON string representation of the <see cref="T:System.TimeSpan"/>.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.Uri)">
            <summary>
            Converts the <see cref="T:System.Uri"/> to its JSON string representation.
            </summary>
            <param name="value">The value to convert.</param>
            <returns>A JSON string representation of the <see cref="T:System.Uri"/>.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.String)">
            <summary>
            Converts the <see cref="T:System.String"/> to its JSON string representation.
            </summary>
            <param name="value">The value to convert.</param>
            <returns>A JSON string representation of the <see cref="T:System.String"/>.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.String,System.Char)">
            <summary>
            Converts the <see cref="T:System.String"/> to its JSON string representation.
            </summary>
            <param name="value">The value to convert.</param>
            <param name="delimiter">The string delimiter character.</param>
            <returns>A JSON string representation of the <see cref="T:System.String"/>.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.Object)">
            <summary>
            Converts the <see cref="T:System.Object"/> to its JSON string representation.
            </summary>
            <param name="value">The value to convert.</param>
            <returns>A JSON string representation of the <see cref="T:System.Object"/>.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonConvert.SerializeObject(System.Object)">
            <summary>
            Serializes the specified object to a JSON string.
            </summary>
            <param name="value">The object to serialize.</param>
            <returns>A JSON string representation of the object.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonConvert.SerializeObject(System.Object,Newtonsoft.Json.Formatting)">
            <summary>
            Serializes the specified object to a JSON string using formatting.
            </summary>
            <param name="value">The object to serialize.</param>
            <param name="formatting">Indicates how the output is formatted.</param>
            <returns>
            A JSON string representation of the object.
            </returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonConvert.SerializeObject(System.Object,Newtonsoft.Json.JsonConverter[])">
            <summary>
            Serializes the specified object to a JSON string using a collection of <see cref="T:Newtonsoft.Json.JsonConverter"/>.
            </summary>
            <param name="value">The object to serialize.</param>
            <param name="converters">A collection converters used while serializing.</param>
            <returns>A JSON string representation of the object.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonConvert.SerializeObject(System.Object,Newtonsoft.Json.Formatting,Newtonsoft.Json.JsonConverter[])">
            <summary>
            Serializes the specified object to a JSON string using formatting and a collection of <see cref="T:Newtonsoft.Json.JsonConverter"/>.
            </summary>
            <param name="value">The object to serialize.</param>
            <param name="formatting">Indicates how the output is formatted.</param>
            <param name="converters">A collection converters used while serializing.</param>
            <returns>A JSON string representation of the object.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonConvert.SerializeObject(System.Object,Newtonsoft.Json.JsonSerializerSettings)">
            <summary>
            Serializes the specified object to a JSON string using <see cref="T:Newtonsoft.Json.JsonSerializerSettings"/>.
            </summary>
            <param name="value">The object to serialize.</param>
            <param name="settings">The <see cref="T:Newtonsoft.Json.JsonSerializerSettings"/> used to serialize the object.
            If this is null, default serialization settings will be is used.</param>
            <returns>
            A JSON string representation of the object.
            </returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonConvert.SerializeObject(System.Object,System.Type,Newtonsoft.Json.JsonSerializerSettings)">
            <summary>
            Serializes the specified object to a JSON string using a type, formatting and <see cref="T:Newtonsoft.Json.JsonSerializerSettings"/>.
            </summary>
            <param name="value">The object to serialize.</param>
            <param name="settings">The <see cref="T:Newtonsoft.Json.JsonSerializerSettings"/> used to serialize the object.
            If this is null, default serialization settings will be is used.</param>
            <param name="type">
            The type of the value being serialized.
            This parameter is used when <see cref="T:Newtonsoft.Json.TypeNameHandling"/> is Auto to write out the type name if the type of the value does not match.
            Specifing the type is optional.
            </param>
            <returns>
            A JSON string representation of the object.
            </returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonConvert.SerializeObject(System.Object,Newtonsoft.Json.Formatting,Newtonsoft.Json.JsonSerializerSettings)">
            <summary>
            Serializes the specified object to a JSON string using formatting and <see cref="T:Newtonsoft.Json.JsonSerializerSettings"/>.
            </summary>
            <param name="value">The object to serialize.</param>
            <param name="formatting">Indicates how the output is formatted.</param>
            <param name="settings">The <see cref="T:Newtonsoft.Json.JsonSerializerSettings"/> used to serialize the object.
            If this is null, default serialization settings will be is used.</param>
            <returns>
            A JSON string representation of the object.
            </returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonConvert.SerializeObject(System.Object,System.Type,Newtonsoft.Json.Formatting,Newtonsoft.Json.JsonSerializerSettings)">
            <summary>
            Serializes the specified object to a JSON string using a type, formatting and <see cref="T:Newtonsoft.Json.JsonSerializerSettings"/>.
            </summary>
            <param name="value">The object to serialize.</param>
            <param name="formatting">Indicates how the output is formatted.</param>
            <param name="settings">The <see cref="T:Newtonsoft.Json.JsonSerializerSettings"/> used to serialize the object.
            If this is null, default serialization settings will be is used.</param>
            <param name="type">
            The type of the value being serialized.
            This parameter is used when <see cref="T:Newtonsoft.Json.TypeNameHandling"/> is Auto to write out the type name if the type of the value does not match.
            Specifing the type is optional.
            </param>
            <returns>
            A JSON string representation of the object.
            </returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonConvert.DeserializeObject(System.String)">
            <summary>
            Deserializes the JSON to a .NET object.
            </summary>
            <param name="value">The JSON to deserialize.</param>
            <returns>The deserialized object from the Json string.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonConvert.DeserializeObject(System.String,Newtonsoft.Json.JsonSerializerSettings)">
            <summary>
            Deserializes the JSON to a .NET object using <see cref="T:Newtonsoft.Json.JsonSerializerSettings"/>.
            </summary>
            <param name="value">The JSON to deserialize.</param>
            <param name="settings">
            The <see cref="T:Newtonsoft.Json.JsonSerializerSettings"/> used to deserialize the object.
            If this is null, default serialization settings will be is used.
            </param>
            <returns>The deserialized object from the JSON string.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonConvert.DeserializeObject(System.String,System.Type)">
            <summary>
            Deserializes the JSON to the specified .NET type.
            </summary>
            <param name="value">The JSON to deserialize.</param>
            <param name="type">The <see cref="T:System.Type"/> of object being deserialized.</param>
            <returns>The deserialized object from the Json string.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonConvert.DeserializeObject``1(System.String)">
            <summary>
            Deserializes the JSON to the specified .NET type.
            </summary>
            <typeparam name="T">The type of the object to deserialize to.</typeparam>
            <param name="value">The JSON to deserialize.</param>
            <returns>The deserialized object from the Json string.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonConvert.DeserializeAnonymousType``1(System.String,``0)">
            <summary>
            Deserializes the JSON to the given anonymous type.
            </summary>
            <typeparam name="T">
            The anonymous type to deserialize to. This can't be specified
            traditionally and must be infered from the anonymous type passed
            as a parameter.
            </typeparam>
            <param name="value">The JSON to deserialize.</param>
            <param name="anonymousTypeObject">The anonymous type object.</param>
            <returns>The deserialized anonymous type from the JSON string.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonConvert.DeserializeAnonymousType``1(System.String,``0,Newtonsoft.Json.JsonSerializerSettings)">
            <summary>
            Deserializes the JSON to the given anonymous type using <see cref="T:Newtonsoft.Json.JsonSerializerSettings"/>.
            </summary>
            <typeparam name="T">
            The anonymous type to deserialize to. This can't be specified
            traditionally and must be infered from the anonymous type passed
            as a parameter.
            </typeparam>
            <param name="value">The JSON to deserialize.</param>
            <param name="anonymousTypeObject">The anonymous type object.</param>
            <param name="settings">
            The <see cref="T:Newtonsoft.Json.JsonSerializerSettings"/> used to deserialize the object.
            If this is null, default serialization settings will be is used.
            </param>
            <returns>The deserialized anonymous type from the JSON string.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonConvert.DeserializeObject``1(System.String,Newtonsoft.Json.JsonConverter[])">
            <summary>
            Deserializes the JSON to the specified .NET type using a collection of <see cref="T:Newtonsoft.Json.JsonConverter"/>.
            </summary>
            <typeparam name="T">The type of the object to deserialize to.</typeparam>
            <param name="value">The JSON to deserialize.</param>
            <param name="converters">Converters to use while deserializing.</param>
            <returns>The deserialized object from the JSON string.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonConvert.DeserializeObject``1(System.String,Newtonsoft.Json.JsonSerializerSettings)">
            <summary>
            Deserializes the JSON to the specified .NET type using <see cref="T:Newtonsoft.Json.JsonSerializerSettings"/>.
            </summary>
            <typeparam name="T">The type of the object to deserialize to.</typeparam>
            <param name="value">The object to deserialize.</param>
            <param name="settings">
            The <see cref="T:Newtonsoft.Json.JsonSerializerSettings"/> used to deserialize the object.
            If this is null, default serialization settings will be is used.
            </param>
            <returns>The deserialized object from the JSON string.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonConvert.DeserializeObject(System.String,System.Type,Newtonsoft.Json.JsonConverter[])">
            <summary>
            Deserializes the JSON to the specified .NET type using a collection of <see cref="T:Newtonsoft.Json.JsonConverter"/>.
            </summary>
            <param name="value">The JSON to deserialize.</param>
            <param name="type">The type of the object to deserialize.</param>
            <param name="converters">Converters to use while deserializing.</param>
            <returns>The deserialized object from the JSON string.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonConvert.DeserializeObject(System.String,System.Type,Newtonsoft.Json.JsonSerializerSettings)">
            <summary>
            Deserializes the JSON to the specified .NET type using <see cref="T:Newtonsoft.Json.JsonSerializerSettings"/>.
            </summary>
            <param name="value">The JSON to deserialize.</param>
            <param name="type">The type of the object to deserialize to.</param>
            <param name="settings">
            The <see cref="T:Newtonsoft.Json.JsonSerializerSettings"/> used to deserialize the object.
            If this is null, default serialization settings will be is used.
            </param>
            <returns>The deserialized object from the JSON string.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonConvert.PopulateObject(System.String,System.Object)">
            <summary>
            Populates the object with values from the JSON string.
            </summary>
            <param name="value">The JSON to populate values from.</param>
            <param name="target">The target object to populate values onto.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonConvert.PopulateObject(System.String,System.Object,Newtonsoft.Json.JsonSerializerSettings)">
            <summary>
            Populates the object with values from the JSON string using <see cref="T:Newtonsoft.Json.JsonSerializerSettings"/>.
            </summary>
            <param name="value">The JSON to populate values from.</param>
            <param name="target">The target object to populate values onto.</param>
            <param name="settings">
            The <see cref="T:Newtonsoft.Json.JsonSerializerSettings"/> used to deserialize the object.
            If this is null, default serialization settings will be is used.
            </param>
        </member>
        <member name="M:Newtonsoft.Json.JsonConvert.SerializeXmlNode(System.Xml.XmlNode)">
            <summary>
            Serializes the XML node to a JSON string.
            </summary>
            <param name="node">The node to serialize.</param>
            <returns>A JSON string of the XmlNode.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonConvert.SerializeXmlNode(System.Xml.XmlNode,Newtonsoft.Json.Formatting)">
            <summary>
            Serializes the XML node to a JSON string using formatting.
            </summary>
            <param name="node">The node to serialize.</param>
            <param name="formatting">Indicates how the output is formatted.</param>
            <returns>A JSON string of the XmlNode.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonConvert.SerializeXmlNode(System.Xml.XmlNode,Newtonsoft.Json.Formatting,System.Boolean)">
            <summary>
            Serializes the XML node to a JSON string using formatting and omits the root object if <paramref name="omitRootObject"/> is <c>true</c>.
            </summary>
            <param name="node">The node to serialize.</param>
            <param name="formatting">Indicates how the output is formatted.</param>
            <param name="omitRootObject">Omits writing the root object.</param>
            <returns>A JSON string of the XmlNode.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonConvert.DeserializeXmlNode(System.String)">
            <summary>
            Deserializes the XmlNode from a JSON string.
            </summary>
            <param name="value">The JSON string.</param>
            <returns>The deserialized XmlNode</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonConvert.DeserializeXmlNode(System.String,System.String)">
            <summary>
            Deserializes the XmlNode from a JSON string nested in a root elment specified by <paramref name="deserializeRootElementName"/>.
            </summary>
            <param name="value">The JSON string.</param>
            <param name="deserializeRootElementName">The name of the root element to append when deserializing.</param>
            <returns>The deserialized XmlNode</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonConvert.DeserializeXmlNode(System.String,System.String,System.Boolean)">
            <summary>
            Deserializes the XmlNode from a JSON string nested in a root elment specified by <paramref name="deserializeRootElementName"/>
            and writes a .NET array attribute for collections.
            </summary>
            <param name="value">The JSON string.</param>
            <param name="deserializeRootElementName">The name of the root element to append when deserializing.</param>
            <param name="writeArrayAttribute">
            A flag to indicate whether to write the Json.NET array attribute.
            This attribute helps preserve arrays when converting the written XML back to JSON.
            </param>
            <returns>The deserialized XmlNode</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonConvert.SerializeXNode(System.Xml.Linq.XObject)">
            <summary>
            Serializes the <see cref="T:System.Xml.Linq.XNode"/> to a JSON string.
            </summary>
            <param name="node">The node to convert to JSON.</param>
            <returns>A JSON string of the XNode.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonConvert.SerializeXNode(System.Xml.Linq.XObject,Newtonsoft.Json.Formatting)">
            <summary>
            Serializes the <see cref="T:System.Xml.Linq.XNode"/> to a JSON string using formatting.
            </summary>
            <param name="node">The node to convert to JSON.</param>
            <param name="formatting">Indicates how the output is formatted.</param>
            <returns>A JSON string of the XNode.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonConvert.SerializeXNode(System.Xml.Linq.XObject,Newtonsoft.Json.Formatting,System.Boolean)">
            <summary>
            Serializes the <see cref="T:System.Xml.Linq.XNode"/> to a JSON string using formatting and omits the root object if <paramref name="omitRootObject"/> is <c>true</c>.
            </summary>
            <param name="node">The node to serialize.</param>
            <param name="formatting">Indicates how the output is formatted.</param>
            <param name="omitRootObject">Omits writing the root object.</param>
            <returns>A JSON string of the XNode.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonConvert.DeserializeXNode(System.String)">
            <summary>
            Deserializes the <see cref="T:System.Xml.Linq.XNode"/> from a JSON string.
            </summary>
            <param name="value">The JSON string.</param>
            <returns>The deserialized XNode</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonConvert.DeserializeXNode(System.String,System.String)">
            <summary>
            Deserializes the <see cref="T:System.Xml.Linq.XNode"/> from a JSON string nested in a root elment specified by <paramref name="deserializeRootElementName"/>.
            </summary>
            <param name="value">The JSON string.</param>
            <param name="deserializeRootElementName">The name of the root element to append when deserializing.</param>
            <returns>The deserialized XNode</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonConvert.DeserializeXNode(System.String,System.String,System.Boolean)">
            <summary>
            Deserializes the <see cref="T:System.Xml.Linq.XNode"/> from a JSON string nested in a root elment specified by <paramref name="deserializeRootElementName"/>
            and writes a .NET array attribute for collections.
            </summary>
            <param name="value">The JSON string.</param>
            <param name="deserializeRootElementName">The name of the root element to append when deserializing.</param>
            <param name="writeArrayAttribute">
            A flag to indicate whether to write the Json.NET array attribute.
            This attribute helps preserve arrays when converting the written XML back to JSON.
            </param>
            <returns>The deserialized XNode</returns>
        </member>
        <member name="T:Newtonsoft.Json.JsonConverter">
            <summary>
            Converts an object to and from JSON.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.JsonConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Writes the JSON representation of the object.
            </summary>
            <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter"/> to write to.</param>
            <param name="value">The value.</param>
            <param name="serializer">The calling serializer.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Reads the JSON representation of the object.
            </summary>
            <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader"/> to read from.</param>
            <param name="objectType">Type of the object.</param>
            <param name="existingValue">The existing value of object being read.</param>
            <param name="serializer">The calling serializer.</param>
            <returns>The object value.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonConverter.CanConvert(System.Type)">
            <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
            <param name="objectType">Type of the object.</param>
            <returns>
            	<c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonConverter.GetSchema">
            <summary>
            Gets the <see cref="T:Newtonsoft.Json.Schema.JsonSchema"/> of the JSON produced by the JsonConverter.
            </summary>
            <returns>The <see cref="T:Newtonsoft.Json.Schema.JsonSchema"/> of the JSON produced by the JsonConverter.</returns>
        </member>
        <member name="P:Newtonsoft.Json.JsonConverter.CanRead">
            <summary>
            Gets a value indicating whether this <see cref="T:Newtonsoft.Json.JsonConverter"/> can read JSON.
            </summary>
            <value><c>true</c> if this <see cref="T:Newtonsoft.Json.JsonConverter"/> can read JSON; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Newtonsoft.Json.JsonConverter.CanWrite">
            <summary>
            Gets a value indicating whether this <see cref="T:Newtonsoft.Json.JsonConverter"/> can write JSON.
            </summary>
            <value><c>true</c> if this <see cref="T:Newtonsoft.Json.JsonConverter"/> can write JSON; otherwise, <c>false</c>.</value>
        </member>
        <member name="T:Newtonsoft.Json.JsonConverterAttribute">
            <summary>
            Instructs the <see cref="T:Newtonsoft.Json.JsonSerializer"/> to use the specified <see cref="T:Newtonsoft.Json.JsonConverter"/> when serializing the member or class.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.JsonConverterAttribute.ConverterType">
            <summary>
            Gets the type of the converter.
            </summary>
            <value>The type of the converter.</value>
        </member>
        <member name="M:Newtonsoft.Json.JsonConverterAttribute.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonConverterAttribute"/> class.
            </summary>
            <param name="converterType">Type of the converter.</param>
        </member>
        <member name="T:Newtonsoft.Json.JsonConverterCollection">
            <summary>
            Represents a collection of <see cref="T:Newtonsoft.Json.JsonConverter"/>.
            </summary>
        </member>
        <member name="T:Newtonsoft.Json.JsonDictionaryAttribute">
            <summary>
            Instructs the <see cref="T:Newtonsoft.Json.JsonSerializer"/> how to serialize the collection.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.JsonDictionaryAttribute.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonDictionaryAttribute"/> class.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.JsonDictionaryAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonDictionaryAttribute"/> class with the specified container Id.
            </summary>
            <param name="id">The container Id.</param>
        </member>
        <member name="T:Newtonsoft.Json.JsonException">
            <summary>
            The exception thrown when an error occurs during Json serialization or deserialization.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.JsonException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonException"/> class.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.JsonException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonException"/> class
            with a specified error message.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonException"/> class
            with a specified error message and a reference to the inner exception that is the cause of this exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception, or a null reference (Nothing in Visual Basic) if no inner exception is specified.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="info"/> parameter is null. </exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or <see cref="P:System.Exception.HResult"/> is zero (0). </exception>
        </member>
        <member name="T:Newtonsoft.Json.JsonExtensionDataAttribute">
            <summary>
            Instructs the <see cref="T:Newtonsoft.Json.JsonSerializer"/> to deserialize properties with no matching class member into the specified collection
            and write values during serialization.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.JsonExtensionDataAttribute.WriteData">
            <summary>
            Gets or sets a value that indicates whether to write extension data when serializing the object.
            </summary>
            <value>
            	<c>true</c> to write extension data when serializing the object; otherwise, <c>false</c>. The default is <c>true</c>.
            </value>
        </member>
        <member name="P:Newtonsoft.Json.JsonExtensionDataAttribute.ReadData">
            <summary>
            Gets or sets a value that indicates whether to read extension data when deserializing the object.
            </summary>
            <value>
            	<c>true</c> to read extension data when deserializing the object; otherwise, <c>false</c>. The default is <c>true</c>.
            </value>
        </member>
        <member name="M:Newtonsoft.Json.JsonExtensionDataAttribute.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonExtensionDataAttribute"/> class.
            </summary>
        </member>
        <member name="T:Newtonsoft.Json.JsonIgnoreAttribute">
            <summary>
            Instructs the <see cref="T:Newtonsoft.Json.JsonSerializer"/> not to serialize the public field or public read/write property value.
            </summary>
        </member>
        <member name="T:Newtonsoft.Json.JsonObjectAttribute">
            <summary>
            Instructs the <see cref="T:Newtonsoft.Json.JsonSerializer"/> how to serialize the object.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.JsonObjectAttribute.MemberSerialization">
            <summary>
            Gets or sets the member serialization.
            </summary>
            <value>The member serialization.</value>
        </member>
        <member name="P:Newtonsoft.Json.JsonObjectAttribute.ItemRequired">
            <summary>
            Gets or sets a value that indicates whether the object's properties are required.
            </summary>
            <value>
            	A value indicating whether the object's properties are required.
            </value>
        </member>
        <member name="M:Newtonsoft.Json.JsonObjectAttribute.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonObjectAttribute"/> class.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.JsonObjectAttribute.#ctor(Newtonsoft.Json.MemberSerialization)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonObjectAttribute"/> class with the specified member serialization.
            </summary>
            <param name="memberSerialization">The member serialization.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonObjectAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonObjectAttribute"/> class with the specified container Id.
            </summary>
            <param name="id">The container Id.</param>
        </member>
        <member name="T:Newtonsoft.Json.JsonPropertyAttribute">
            <summary>
            Instructs the <see cref="T:Newtonsoft.Json.JsonSerializer"/> to always serialize the member with the specified name.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.JsonPropertyAttribute.ItemConverterType">
            <summary>
            Gets or sets the converter used when serializing the property's collection items.
            </summary>
            <value>The collection's items converter.</value>
        </member>
        <member name="P:Newtonsoft.Json.JsonPropertyAttribute.NullValueHandling">
            <summary>
            Gets or sets the null value handling used when serializing this property.
            </summary>
            <value>The null value handling.</value>
        </member>
        <member name="P:Newtonsoft.Json.JsonPropertyAttribute.DefaultValueHandling">
            <summary>
            Gets or sets the default value handling used when serializing this property.
            </summary>
            <value>The default value handling.</value>
        </member>
        <member name="P:Newtonsoft.Json.JsonPropertyAttribute.ReferenceLoopHandling">
            <summary>
            Gets or sets the reference loop handling used when serializing this property.
            </summary>
            <value>The reference loop handling.</value>
        </member>
        <member name="P:Newtonsoft.Json.JsonPropertyAttribute.ObjectCreationHandling">
            <summary>
            Gets or sets the object creation handling used when deserializing this property.
            </summary>
            <value>The object creation handling.</value>
        </member>
        <member name="P:Newtonsoft.Json.JsonPropertyAttribute.TypeNameHandling">
            <summary>
            Gets or sets the type name handling used when serializing this property.
            </summary>
            <value>The type name handling.</value>
        </member>
        <member name="P:Newtonsoft.Json.JsonPropertyAttribute.IsReference">
            <summary>
            Gets or sets whether this property's value is serialized as a reference.
            </summary>
            <value>Whether this property's value is serialized as a reference.</value>
        </member>
        <member name="P:Newtonsoft.Json.JsonPropertyAttribute.Order">
            <summary>
            Gets or sets the order of serialization and deserialization of a member.
            </summary>
            <value>The numeric order of serialization or deserialization.</value>
        </member>
        <member name="P:Newtonsoft.Json.JsonPropertyAttribute.Required">
            <summary>
            Gets or sets a value indicating whether this property is required.
            </summary>
            <value>
            	A value indicating whether this property is required.
            </value>
        </member>
        <member name="P:Newtonsoft.Json.JsonPropertyAttribute.PropertyName">
            <summary>
            Gets or sets the name of the property.
            </summary>
            <value>The name of the property.</value>
        </member>
        <member name="P:Newtonsoft.Json.JsonPropertyAttribute.ItemReferenceLoopHandling">
            <summary>
            Gets or sets the the reference loop handling used when serializing the property's collection items.
            </summary>
            <value>The collection's items reference loop handling.</value>
        </member>
        <member name="P:Newtonsoft.Json.JsonPropertyAttribute.ItemTypeNameHandling">
            <summary>
            Gets or sets the the type name handling used when serializing the property's collection items.
            </summary>
            <value>The collection's items type name handling.</value>
        </member>
        <member name="P:Newtonsoft.Json.JsonPropertyAttribute.ItemIsReference">
            <summary>
            Gets or sets whether this property's collection items are serialized as a reference.
            </summary>
            <value>Whether this property's collection items are serialized as a reference.</value>
        </member>
        <member name="M:Newtonsoft.Json.JsonPropertyAttribute.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonPropertyAttribute"/> class.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.JsonPropertyAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonPropertyAttribute"/> class with the specified name.
            </summary>
            <param name="propertyName">Name of the property.</param>
        </member>
        <member name="T:Newtonsoft.Json.JsonReader">
            <summary>
            Represents a reader that provides fast, non-cached, forward-only access to serialized Json data.
            </summary>
        </member>
        <member name="T:Newtonsoft.Json.JsonReader.State">
            <summary>
            Specifies the state of the reader.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.JsonReader.State.Start">
            <summary>
            The Read method has not been called.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.JsonReader.State.Complete">
            <summary>
            The end of the file has been reached successfully.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.JsonReader.State.Property">
            <summary>
            Reader is at a property.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.JsonReader.State.ObjectStart">
            <summary>
            Reader is at the start of an object.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.JsonReader.State.Object">
            <summary>
            Reader is in an object.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.JsonReader.State.ArrayStart">
            <summary>
            Reader is at the start of an array.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.JsonReader.State.Array">
            <summary>
            Reader is in an array.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.JsonReader.State.Closed">
            <summary>
            The Close method has been called.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.JsonReader.State.PostValue">
            <summary>
            Reader has just read a value.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.JsonReader.State.ConstructorStart">
            <summary>
            Reader is at the start of a constructor.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.JsonReader.State.Constructor">
            <summary>
            Reader in a constructor.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.JsonReader.State.Error">
            <summary>
            An error occurred that prevents the read operation from continuing.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.JsonReader.State.Finished">
            <summary>
            The end of the file has been reached successfully.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.JsonReader.CurrentState">
            <summary>
            Gets the current reader state.
            </summary>
            <value>The current reader state.</value>
        </member>
        <member name="P:Newtonsoft.Json.JsonReader.CloseInput">
            <summary>
            Gets or sets a value indicating whether the underlying stream or
            <see cref="T:System.IO.TextReader"/> should be closed when the reader is closed.
            </summary>
            <value>
            true to close the underlying stream or <see cref="T:System.IO.TextReader"/> when
            the reader is closed; otherwise false. The default is true.
            </value>
        </member>
        <member name="P:Newtonsoft.Json.JsonReader.SupportMultipleContent">
            <summary>
            Gets or sets a value indicating whether multiple pieces of JSON content can
            be read from a continuous stream without erroring.
            </summary>
            <value>
            true to support reading multiple pieces of JSON content; otherwise false. The default is false.
            </value>
        </member>
        <member name="P:Newtonsoft.Json.JsonReader.QuoteChar">
            <summary>
            Gets the quotation mark character used to enclose the value of a string.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.JsonReader.DateTimeZoneHandling">
            <summary>
            Get or set how <see cref="T:System.DateTime"/> time zones are handling when reading JSON.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.JsonReader.DateParseHandling">
            <summary>
            Get or set how date formatted strings, e.g. "\/Date(1198908717056)\/" and "2012-03-21T05:40Z", are parsed when reading JSON.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.JsonReader.FloatParseHandling">
            <summary>
            Get or set how floating point numbers, e.g. 1.0 and 9.9, are parsed when reading JSON text.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.JsonReader.MaxDepth">
            <summary>
            Gets or sets the maximum depth allowed when reading JSON. Reading past this depth will throw a <see cref="T:Newtonsoft.Json.JsonReaderException"/>.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.JsonReader.TokenType">
            <summary>
            Gets the type of the current JSON token. 
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.JsonReader.Value">
            <summary>
            Gets the text value of the current JSON token.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.JsonReader.ValueType">
            <summary>
            Gets The Common Language Runtime (CLR) type for the current JSON token.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.JsonReader.Depth">
            <summary>
            Gets the depth of the current token in the JSON document.
            </summary>
            <value>The depth of the current token in the JSON document.</value>
        </member>
        <member name="P:Newtonsoft.Json.JsonReader.Path">
            <summary>
            Gets the path of the current JSON token. 
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.JsonReader.Culture">
            <summary>
            Gets or sets the culture used when reading JSON. Defaults to <see cref="P:System.Globalization.CultureInfo.InvariantCulture"/>.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.JsonReader.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonReader"/> class with the specified <see cref="T:System.IO.TextReader"/>.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.JsonReader.Read">
            <summary>
            Reads the next JSON token from the stream.
            </summary>
            <returns>true if the next token was read successfully; false if there are no more tokens to read.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonReader.ReadAsInt32">
            <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1"/>.
            </summary>
            <returns>A <see cref="T:System.Nullable`1"/>. This method will return <c>null</c> at the end of an array.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonReader.ReadAsString">
            <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.String"/>.
            </summary>
            <returns>A <see cref="T:System.String"/>. This method will return <c>null</c> at the end of an array.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonReader.ReadAsBytes">
            <summary>
            Reads the next JSON token from the stream as a <see cref="T:Byte[]"/>.
            </summary>
            <returns>A <see cref="T:Byte[]"/> or a null reference if the next JSON token is null. This method will return <c>null</c> at the end of an array.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonReader.ReadAsDecimal">
            <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1"/>.
            </summary>
            <returns>A <see cref="T:System.Nullable`1"/>. This method will return <c>null</c> at the end of an array.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonReader.ReadAsDateTime">
            <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1"/>.
            </summary>
            <returns>A <see cref="T:System.String"/>. This method will return <c>null</c> at the end of an array.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonReader.ReadAsDateTimeOffset">
            <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1"/>.
            </summary>
            <returns>A <see cref="T:System.Nullable`1"/>. This method will return <c>null</c> at the end of an array.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonReader.Skip">
            <summary>
            Skips the children of the current token.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.JsonReader.SetToken(Newtonsoft.Json.JsonToken)">
            <summary>
            Sets the current token.
            </summary>
            <param name="newToken">The new token.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonReader.SetToken(Newtonsoft.Json.JsonToken,System.Object)">
            <summary>
            Sets the current token and value.
            </summary>
            <param name="newToken">The new token.</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonReader.SetStateBasedOnCurrent">
            <summary>
            Sets the state based on current token type.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.JsonReader.System#IDisposable#Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.JsonReader.Dispose(System.Boolean)">
            <summary>
            Releases unmanaged and - optionally - managed resources
            </summary>
            <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonReader.Close">
            <summary>
            Changes the <see cref="T:Newtonsoft.Json.JsonReader.State"/> to Closed. 
            </summary>
        </member>
        <member name="T:Newtonsoft.Json.JsonReaderException">
            <summary>
            The exception thrown when an error occurs while reading Json text.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.JsonReaderException.LineNumber">
            <summary>
            Gets the line number indicating where the error occurred.
            </summary>
            <value>The line number indicating where the error occurred.</value>
        </member>
        <member name="P:Newtonsoft.Json.JsonReaderException.LinePosition">
            <summary>
            Gets the line position indicating where the error occurred.
            </summary>
            <value>The line position indicating where the error occurred.</value>
        </member>
        <member name="P:Newtonsoft.Json.JsonReaderException.Path">
            <summary>
            Gets the path to the JSON where the error occurred.
            </summary>
            <value>The path to the JSON where the error occurred.</value>
        </member>
        <member name="M:Newtonsoft.Json.JsonReaderException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonReaderException"/> class.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.JsonReaderException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonReaderException"/> class
            with a specified error message.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonReaderException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonReaderException"/> class
            with a specified error message and a reference to the inner exception that is the cause of this exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception, or a null reference (Nothing in Visual Basic) if no inner exception is specified.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonReaderException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonReaderException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="info"/> parameter is null. </exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or <see cref="P:System.Exception.HResult"/> is zero (0). </exception>
        </member>
        <member name="T:Newtonsoft.Json.JsonSerializationException">
            <summary>
            The exception thrown when an error occurs during Json serialization or deserialization.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.JsonSerializationException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonSerializationException"/> class.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.JsonSerializationException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonSerializationException"/> class
            with a specified error message.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonSerializationException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonSerializationException"/> class
            with a specified error message and a reference to the inner exception that is the cause of this exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception, or a null reference (Nothing in Visual Basic) if no inner exception is specified.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonSerializationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonSerializationException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="info"/> parameter is null. </exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or <see cref="P:System.Exception.HResult"/> is zero (0). </exception>
        </member>
        <member name="T:Newtonsoft.Json.JsonSerializer">
            <summary>
            Serializes and deserializes objects into and from the JSON format.
            The <see cref="T:Newtonsoft.Json.JsonSerializer"/> enables you to control how objects are encoded into JSON.
            </summary>
        </member>
        <member name="E:Newtonsoft.Json.JsonSerializer.Error">
            <summary>
            Occurs when the <see cref="T:Newtonsoft.Json.JsonSerializer"/> errors during serialization and deserialization.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.JsonSerializer.ReferenceResolver">
            <summary>
            Gets or sets the <see cref="T:Newtonsoft.Json.Serialization.IReferenceResolver"/> used by the serializer when resolving references.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.JsonSerializer.Binder">
            <summary>
            Gets or sets the <see cref="T:System.Runtime.Serialization.SerializationBinder"/> used by the serializer when resolving type names.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.JsonSerializer.TraceWriter">
            <summary>
            Gets or sets the <see cref="T:Newtonsoft.Json.Serialization.ITraceWriter"/> used by the serializer when writing trace messages.
            </summary>
            <value>The trace writer.</value>
        </member>
        <member name="P:Newtonsoft.Json.JsonSerializer.TypeNameHandling">
            <summary>
            Gets or sets how type name writing and reading is handled by the serializer.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.JsonSerializer.TypeNameAssemblyFormat">
            <summary>
            Gets or sets how a type name assembly is written and resolved by the serializer.
            </summary>
            <value>The type name assembly format.</value>
        </member>
        <member name="P:Newtonsoft.Json.JsonSerializer.PreserveReferencesHandling">
            <summary>
            Gets or sets how object references are preserved by the serializer.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.JsonSerializer.ReferenceLoopHandling">
            <summary>
            Get or set how reference loops (e.g. a class referencing itself) is handled.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.JsonSerializer.MissingMemberHandling">
            <summary>
            Get or set how missing members (e.g. JSON contains a property that isn't a member on the object) are handled during deserialization.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.JsonSerializer.NullValueHandling">
            <summary>
            Get or set how null values are handled during serialization and deserialization.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.JsonSerializer.DefaultValueHandling">
            <summary>
            Get or set how null default are handled during serialization and deserialization.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.JsonSerializer.ObjectCreationHandling">
            <summary>
            Gets or sets how objects are created during deserialization.
            </summary>
            <value>The object creation handling.</value>
        </member>
        <member name="P:Newtonsoft.Json.JsonSerializer.ConstructorHandling">
            <summary>
            Gets or sets how constructors are used during deserialization.
            </summary>
            <value>The constructor handling.</value>
        </member>
        <member name="P:Newtonsoft.Json.JsonSerializer.Converters">
            <summary>
            Gets a collection <see cref="T:Newtonsoft.Json.JsonConverter"/> that will be used during serialization.
            </summary>
            <value>Collection <see cref="T:Newtonsoft.Json.JsonConverter"/> that will be used during serialization.</value>
        </member>
        <member name="P:Newtonsoft.Json.JsonSerializer.ContractResolver">
            <summary>
            Gets or sets the contract resolver used by the serializer when
            serializing .NET objects to JSON and vice versa.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.JsonSerializer.Context">
            <summary>
            Gets or sets the <see cref="T:System.Runtime.Serialization.StreamingContext"/> used by the serializer when invoking serialization callback methods.
            </summary>
            <value>The context.</value>
        </member>
        <member name="P:Newtonsoft.Json.JsonSerializer.Formatting">
            <summary>
            Indicates how JSON text output is formatted.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.JsonSerializer.DateFormatHandling">
            <summary>
            Get or set how dates are written to JSON text.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.JsonSerializer.DateTimeZoneHandling">
            <summary>
            Get or set how <see cref="T:System.DateTime"/> time zones are handling during serialization and deserialization.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.JsonSerializer.DateParseHandling">
            <summary>
            Get or set how date formatted strings, e.g. "\/Date(1198908717056)\/" and "2012-03-21T05:40Z", are parsed when reading JSON.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.JsonSerializer.FloatParseHandling">
            <summary>
            Get or set how floating point numbers, e.g. 1.0 and 9.9, are parsed when reading JSON text.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.JsonSerializer.FloatFormatHandling">
            <summary>
            Get or set how special floating point numbers, e.g. <see cref="F:System.Double.NaN"/>,
            <see cref="F:System.Double.PositiveInfinity"/> and <see cref="F:System.Double.NegativeInfinity"/>,
            are written as JSON text.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.JsonSerializer.StringEscapeHandling">
            <summary>
            Get or set how strings are escaped when writing JSON text.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.JsonSerializer.DateFormatString">
            <summary>
            Get or set how <see cref="T:System.DateTime"/> and <see cref="T:System.DateTimeOffset"/> values are formatting when writing JSON text.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.JsonSerializer.Culture">
            <summary>
            Gets or sets the culture used when reading JSON. Defaults to <see cref="P:System.Globalization.CultureInfo.InvariantCulture"/>.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.JsonSerializer.MaxDepth">
            <summary>
            Gets or sets the maximum depth allowed when reading JSON. Reading past this depth will throw a <see cref="T:Newtonsoft.Json.JsonReaderException"/>.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.JsonSerializer.CheckAdditionalContent">
            <summary>
            Gets a value indicating whether there will be a check for additional JSON content after deserializing an object.
            </summary>
            <value>
            	<c>true</c> if there will be a check for additional JSON content after deserializing an object; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:Newtonsoft.Json.JsonSerializer.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonSerializer"/> class.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.JsonSerializer.Create">
            <summary>
            Creates a new <see cref="T:Newtonsoft.Json.JsonSerializer"/> instance.
            The <see cref="T:Newtonsoft.Json.JsonSerializer"/> will not use default settings.
            </summary>
            <returns>
            A new <see cref="T:Newtonsoft.Json.JsonSerializer"/> instance.
            The <see cref="T:Newtonsoft.Json.JsonSerializer"/> will not use default settings.
            </returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonSerializer.Create(Newtonsoft.Json.JsonSerializerSettings)">
            <summary>
            Creates a new <see cref="T:Newtonsoft.Json.JsonSerializer"/> instance using the specified <see cref="T:Newtonsoft.Json.JsonSerializerSettings"/>.
            The <see cref="T:Newtonsoft.Json.JsonSerializer"/> will not use default settings.
            </summary>
            <param name="settings">The settings to be applied to the <see cref="T:Newtonsoft.Json.JsonSerializer"/>.</param>
            <returns>
            A new <see cref="T:Newtonsoft.Json.JsonSerializer"/> instance using the specified <see cref="T:Newtonsoft.Json.JsonSerializerSettings"/>.
            The <see cref="T:Newtonsoft.Json.JsonSerializer"/> will not use default settings.
            </returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonSerializer.CreateDefault">
            <summary>
            Creates a new <see cref="T:Newtonsoft.Json.JsonSerializer"/> instance.
            The <see cref="T:Newtonsoft.Json.JsonSerializer"/> will use default settings.
            </summary>
            <returns>
            A new <see cref="T:Newtonsoft.Json.JsonSerializer"/> instance.
            The <see cref="T:Newtonsoft.Json.JsonSerializer"/> will use default settings.
            </returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonSerializer.CreateDefault(Newtonsoft.Json.JsonSerializerSettings)">
            <summary>
            Creates a new <see cref="T:Newtonsoft.Json.JsonSerializer"/> instance using the specified <see cref="T:Newtonsoft.Json.JsonSerializerSettings"/>.
            The <see cref="T:Newtonsoft.Json.JsonSerializer"/> will use default settings.
            </summary>
            <param name="settings">The settings to be applied to the <see cref="T:Newtonsoft.Json.JsonSerializer"/>.</param>
            <returns>
            A new <see cref="T:Newtonsoft.Json.JsonSerializer"/> instance using the specified <see cref="T:Newtonsoft.Json.JsonSerializerSettings"/>.
            The <see cref="T:Newtonsoft.Json.JsonSerializer"/> will use default settings.
            </returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonSerializer.Populate(System.IO.TextReader,System.Object)">
            <summary>
            Populates the JSON values onto the target object.
            </summary>
            <param name="reader">The <see cref="T:System.IO.TextReader"/> that contains the JSON structure to reader values from.</param>
            <param name="target">The target object to populate values onto.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonSerializer.Populate(Newtonsoft.Json.JsonReader,System.Object)">
            <summary>
            Populates the JSON values onto the target object.
            </summary>
            <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader"/> that contains the JSON structure to reader values from.</param>
            <param name="target">The target object to populate values onto.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonSerializer.Deserialize(Newtonsoft.Json.JsonReader)">
            <summary>
            Deserializes the Json structure contained by the specified <see cref="T:Newtonsoft.Json.JsonReader"/>.
            </summary>
            <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader"/> that contains the JSON structure to deserialize.</param>
            <returns>The <see cref="T:System.Object"/> being deserialized.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonSerializer.Deserialize(System.IO.TextReader,System.Type)">
            <summary>
            Deserializes the Json structure contained by the specified <see cref="T:System.IO.StringReader"/>
            into an instance of the specified type.
            </summary>
            <param name="reader">The <see cref="T:System.IO.TextReader"/> containing the object.</param>
            <param name="objectType">The <see cref="T:System.Type"/> of object being deserialized.</param>
            <returns>The instance of <paramref name="objectType"/> being deserialized.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonSerializer.Deserialize``1(Newtonsoft.Json.JsonReader)">
            <summary>
            Deserializes the Json structure contained by the specified <see cref="T:Newtonsoft.Json.JsonReader"/>
            into an instance of the specified type.
            </summary>
            <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader"/> containing the object.</param>
            <typeparam name="T">The type of the object to deserialize.</typeparam>
            <returns>The instance of <typeparamref name="T"/> being deserialized.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonSerializer.Deserialize(Newtonsoft.Json.JsonReader,System.Type)">
            <summary>
            Deserializes the Json structure contained by the specified <see cref="T:Newtonsoft.Json.JsonReader"/>
            into an instance of the specified type.
            </summary>
            <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader"/> containing the object.</param>
            <param name="objectType">The <see cref="T:System.Type"/> of object being deserialized.</param>
            <returns>The instance of <paramref name="objectType"/> being deserialized.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonSerializer.Serialize(System.IO.TextWriter,System.Object)">
            <summary>
            Serializes the specified <see cref="T:System.Object"/> and writes the Json structure
            to a <c>Stream</c> using the specified <see cref="T:System.IO.TextWriter"/>. 
            </summary>
            <param name="textWriter">The <see cref="T:System.IO.TextWriter"/> used to write the Json structure.</param>
            <param name="value">The <see cref="T:System.Object"/> to serialize.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonSerializer.Serialize(Newtonsoft.Json.JsonWriter,System.Object,System.Type)">
            <summary>
            Serializes the specified <see cref="T:System.Object"/> and writes the Json structure
            to a <c>Stream</c> using the specified <see cref="T:System.IO.TextWriter"/>. 
            </summary>
            <param name="jsonWriter">The <see cref="T:Newtonsoft.Json.JsonWriter"/> used to write the Json structure.</param>
            <param name="value">The <see cref="T:System.Object"/> to serialize.</param>
            <param name="objectType">
            The type of the value being serialized.
            This parameter is used when <see cref="P:Newtonsoft.Json.JsonSerializer.TypeNameHandling"/> is Auto to write out the type name if the type of the value does not match.
            Specifing the type is optional.
            </param>
        </member>
        <member name="M:Newtonsoft.Json.JsonSerializer.Serialize(System.IO.TextWriter,System.Object,System.Type)">
            <summary>
            Serializes the specified <see cref="T:System.Object"/> and writes the Json structure
            to a <c>Stream</c> using the specified <see cref="T:System.IO.TextWriter"/>. 
            </summary>
            <param name="textWriter">The <see cref="T:System.IO.TextWriter"/> used to write the Json structure.</param>
            <param name="value">The <see cref="T:System.Object"/> to serialize.</param>
            <param name="objectType">
            The type of the value being serialized.
            This parameter is used when <see cref="P:Newtonsoft.Json.JsonSerializer.TypeNameHandling"/> is Auto to write out the type name if the type of the value does not match.
            Specifing the type is optional.
            </param>
        </member>
        <member name="M:Newtonsoft.Json.JsonSerializer.Serialize(Newtonsoft.Json.JsonWriter,System.Object)">
            <summary>
            Serializes the specified <see cref="T:System.Object"/> and writes the Json structure
            to a <c>Stream</c> using the specified <see cref="T:Newtonsoft.Json.JsonWriter"/>. 
            </summary>
            <param name="jsonWriter">The <see cref="T:Newtonsoft.Json.JsonWriter"/> used to write the Json structure.</param>
            <param name="value">The <see cref="T:System.Object"/> to serialize.</param>
        </member>
        <member name="T:Newtonsoft.Json.JsonSerializerSettings">
            <summary>
            Specifies the settings on a <see cref="T:Newtonsoft.Json.JsonSerializer"/> object.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.JsonSerializerSettings.ReferenceLoopHandling">
            <summary>
            Gets or sets how reference loops (e.g. a class referencing itself) is handled.
            </summary>
            <value>Reference loop handling.</value>
        </member>
        <member name="P:Newtonsoft.Json.JsonSerializerSettings.MissingMemberHandling">
            <summary>
            Gets or sets how missing members (e.g. JSON contains a property that isn't a member on the object) are handled during deserialization.
            </summary>
            <value>Missing member handling.</value>
        </member>
        <member name="P:Newtonsoft.Json.JsonSerializerSettings.ObjectCreationHandling">
            <summary>
            Gets or sets how objects are created during deserialization.
            </summary>
            <value>The object creation handling.</value>
        </member>
        <member name="P:Newtonsoft.Json.JsonSerializerSettings.NullValueHandling">
            <summary>
            Gets or sets how null values are handled during serialization and deserialization.
            </summary>
            <value>Null value handling.</value>
        </member>
        <member name="P:Newtonsoft.Json.JsonSerializerSettings.DefaultValueHandling">
            <summary>
            Gets or sets how null default are handled during serialization and deserialization.
            </summary>
            <value>The default value handling.</value>
        </member>
        <member name="P:Newtonsoft.Json.JsonSerializerSettings.Converters">
            <summary>
            Gets or sets a collection <see cref="T:Newtonsoft.Json.JsonConverter"/> that will be used during serialization.
            </summary>
            <value>The converters.</value>
        </member>
        <member name="P:Newtonsoft.Json.JsonSerializerSettings.PreserveReferencesHandling">
            <summary>
            Gets or sets how object references are preserved by the serializer.
            </summary>
            <value>The preserve references handling.</value>
        </member>
        <member name="P:Newtonsoft.Json.JsonSerializerSettings.TypeNameHandling">
            <summary>
            Gets or sets how type name writing and reading is handled by the serializer.
            </summary>
            <value>The type name handling.</value>
        </member>
        <member name="P:Newtonsoft.Json.JsonSerializerSettings.TypeNameAssemblyFormat">
            <summary>
            Gets or sets how a type name assembly is written and resolved by the serializer.
            </summary>
            <value>The type name assembly format.</value>
        </member>
        <member name="P:Newtonsoft.Json.JsonSerializerSettings.ConstructorHandling">
            <summary>
            Gets or sets how constructors are used during deserialization.
            </summary>
            <value>The constructor handling.</value>
        </member>
        <member name="P:Newtonsoft.Json.JsonSerializerSettings.ContractResolver">
            <summary>
            Gets or sets the contract resolver used by the serializer when
            serializing .NET objects to JSON and vice versa.
            </summary>
            <value>The contract resolver.</value>
        </member>
        <member name="P:Newtonsoft.Json.JsonSerializerSettings.ReferenceResolver">
            <summary>
            Gets or sets the <see cref="T:Newtonsoft.Json.Serialization.IReferenceResolver"/> used by the serializer when resolving references.
            </summary>
            <value>The reference resolver.</value>
        </member>
        <member name="P:Newtonsoft.Json.JsonSerializerSettings.TraceWriter">
            <summary>
            Gets or sets the <see cref="T:Newtonsoft.Json.Serialization.ITraceWriter"/> used by the serializer when writing trace messages.
            </summary>
            <value>The trace writer.</value>
        </member>
        <member name="P:Newtonsoft.Json.JsonSerializerSettings.Binder">
            <summary>
            Gets or sets the <see cref="T:System.Runtime.Serialization.SerializationBinder"/> used by the serializer when resolving type names.
            </summary>
            <value>The binder.</value>
        </member>
        <member name="P:Newtonsoft.Json.JsonSerializerSettings.Error">
            <summary>
            Gets or sets the error handler called during serialization and deserialization.
            </summary>
            <value>The error handler called during serialization and deserialization.</value>
        </member>
        <member name="P:Newtonsoft.Json.JsonSerializerSettings.Context">
            <summary>
            Gets or sets the <see cref="T:System.Runtime.Serialization.StreamingContext"/> used by the serializer when invoking serialization callback methods.
            </summary>
            <value>The context.</value>
        </member>
        <member name="P:Newtonsoft.Json.JsonSerializerSettings.DateFormatString">
            <summary>
            Get or set how <see cref="T:System.DateTime"/> and <see cref="T:System.DateTimeOffset"/> values are formatting when writing JSON text.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.JsonSerializerSettings.MaxDepth">
            <summary>
            Gets or sets the maximum depth allowed when reading JSON. Reading past this depth will throw a <see cref="T:Newtonsoft.Json.JsonReaderException"/>.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.JsonSerializerSettings.Formatting">
            <summary>
            Indicates how JSON text output is formatted.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.JsonSerializerSettings.DateFormatHandling">
            <summary>
            Get or set how dates are written to JSON text.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.JsonSerializerSettings.DateTimeZoneHandling">
            <summary>
            Get or set how <see cref="T:System.DateTime"/> time zones are handling during serialization and deserialization.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.JsonSerializerSettings.DateParseHandling">
            <summary>
            Get or set how date formatted strings, e.g. "\/Date(1198908717056)\/" and "2012-03-21T05:40Z", are parsed when reading JSON.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.JsonSerializerSettings.FloatFormatHandling">
            <summary>
            Get or set how special floating point numbers, e.g. <see cref="F:System.Double.NaN"/>,
            <see cref="F:System.Double.PositiveInfinity"/> and <see cref="F:System.Double.NegativeInfinity"/>,
            are written as JSON.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.JsonSerializerSettings.FloatParseHandling">
            <summary>
            Get or set how floating point numbers, e.g. 1.0 and 9.9, are parsed when reading JSON text.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.JsonSerializerSettings.StringEscapeHandling">
            <summary>
            Get or set how strings are escaped when writing JSON text.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.JsonSerializerSettings.Culture">
            <summary>
            Gets or sets the culture used when reading JSON. Defaults to <see cref="P:System.Globalization.CultureInfo.InvariantCulture"/>.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.JsonSerializerSettings.CheckAdditionalContent">
            <summary>
            Gets a value indicating whether there will be a check for additional content after deserializing an object.
            </summary>
            <value>
            	<c>true</c> if there will be a check for additional content after deserializing an object; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:Newtonsoft.Json.JsonSerializerSettings.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonSerializerSettings"/> class.
            </summary>
        </member>
        <member name="T:Newtonsoft.Json.JsonTextReader">
            <summary>
            Represents a reader that provides fast, non-cached, forward-only access to JSON text data.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.JsonTextReader.#ctor(System.IO.TextReader)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonReader"/> class with the specified <see cref="T:System.IO.TextReader"/>.
            </summary>
            <param name="reader">The <c>TextReader</c> containing the XML data to read.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonTextReader.Read">
            <summary>
            Reads the next JSON token from the stream.
            </summary>
            <returns>
            true if the next token was read successfully; false if there are no more tokens to read.
            </returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonTextReader.ReadAsBytes">
            <summary>
            Reads the next JSON token from the stream as a <see cref="T:Byte[]"/>.
            </summary>
            <returns>
            A <see cref="T:Byte[]"/> or a null reference if the next JSON token is null. This method will return <c>null</c> at the end of an array.
            </returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonTextReader.ReadAsDecimal">
            <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1"/>.
            </summary>
            <returns>A <see cref="T:System.Nullable`1"/>. This method will return <c>null</c> at the end of an array.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonTextReader.ReadAsInt32">
            <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1"/>.
            </summary>
            <returns>A <see cref="T:System.Nullable`1"/>. This method will return <c>null</c> at the end of an array.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonTextReader.ReadAsString">
            <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.String"/>.
            </summary>
            <returns>A <see cref="T:System.String"/>. This method will return <c>null</c> at the end of an array.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonTextReader.ReadAsDateTime">
            <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1"/>.
            </summary>
            <returns>A <see cref="T:System.String"/>. This method will return <c>null</c> at the end of an array.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonTextReader.ReadAsDateTimeOffset">
            <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1"/>.
            </summary>
            <returns>A <see cref="T:System.DateTimeOffset"/>. This method will return <c>null</c> at the end of an array.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonTextReader.Close">
            <summary>
            Changes the state to closed. 
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.JsonTextReader.HasLineInfo">
            <summary>
            Gets a value indicating whether the class can return line information.
            </summary>
            <returns>
            	<c>true</c> if LineNumber and LinePosition can be provided; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="P:Newtonsoft.Json.JsonTextReader.LineNumber">
            <summary>
            Gets the current line number.
            </summary>
            <value>
            The current line number or 0 if no line information is available (for example, HasLineInfo returns false).
            </value>
        </member>
        <member name="P:Newtonsoft.Json.JsonTextReader.LinePosition">
            <summary>
            Gets the current line position.
            </summary>
            <value>
            The current line position or 0 if no line information is available (for example, HasLineInfo returns false).
            </value>
        </member>
        <member name="T:Newtonsoft.Json.JsonTextWriter">
            <summary>
            Represents a writer that provides a fast, non-cached, forward-only way of generating Json data.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.JsonTextWriter.Indentation">
            <summary>
            Gets or sets how many IndentChars to write for each level in the hierarchy when <see cref="T:Newtonsoft.Json.Formatting"/> is set to <c>Formatting.Indented</c>.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.JsonTextWriter.QuoteChar">
            <summary>
            Gets or sets which character to use to quote attribute values.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.JsonTextWriter.IndentChar">
            <summary>
            Gets or sets which character to use for indenting when <see cref="T:Newtonsoft.Json.Formatting"/> is set to <c>Formatting.Indented</c>.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.JsonTextWriter.QuoteName">
            <summary>
            Gets or sets a value indicating whether object names will be surrounded with quotes.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.JsonTextWriter.#ctor(System.IO.TextWriter)">
            <summary>
            Creates an instance of the <c>JsonWriter</c> class using the specified <see cref="T:System.IO.TextWriter"/>. 
            </summary>
            <param name="textWriter">The <c>TextWriter</c> to write to.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonTextWriter.Flush">
            <summary>
            Flushes whatever is in the buffer to the underlying streams and also flushes the underlying stream.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.JsonTextWriter.Close">
            <summary>
            Closes this stream and the underlying stream.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.JsonTextWriter.WriteStartObject">
            <summary>
            Writes the beginning of a Json object.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.JsonTextWriter.WriteStartArray">
            <summary>
            Writes the beginning of a Json array.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.JsonTextWriter.WriteStartConstructor(System.String)">
            <summary>
            Writes the start of a constructor with the given name.
            </summary>
            <param name="name">The name of the constructor.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonTextWriter.WriteEnd(Newtonsoft.Json.JsonToken)">
            <summary>
            Writes the specified end token.
            </summary>
            <param name="token">The end token to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonTextWriter.WritePropertyName(System.String)">
            <summary>
            Writes the property name of a name/value pair on a Json object.
            </summary>
            <param name="name">The name of the property.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonTextWriter.WritePropertyName(System.String,System.Boolean)">
            <summary>
            Writes the property name of a name/value pair on a JSON object.
            </summary>
            <param name="name">The name of the property.</param>
            <param name="escape">A flag to indicate whether the text should be escaped when it is written as a JSON property name.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonTextWriter.WriteIndent">
            <summary>
            Writes indent characters.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValueDelimiter">
            <summary>
            Writes the JSON value delimiter.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.JsonTextWriter.WriteIndentSpace">
            <summary>
            Writes an indent space.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.Object)">
            <summary>
            Writes a <see cref="T:System.Object"/> value.
            An error will raised if the value cannot be written as a single JSON token.
            </summary>
            <param name="value">The <see cref="T:System.Object"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonTextWriter.WriteNull">
            <summary>
            Writes a null value.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.JsonTextWriter.WriteUndefined">
            <summary>
            Writes an undefined value.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.JsonTextWriter.WriteRaw(System.String)">
            <summary>
            Writes raw JSON.
            </summary>
            <param name="json">The raw JSON to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.String)">
            <summary>
            Writes a <see cref="T:System.String"/> value.
            </summary>
            <param name="value">The <see cref="T:System.String"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.Int32)">
            <summary>
            Writes a <see cref="T:System.Int32"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Int32"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.UInt32)">
            <summary>
            Writes a <see cref="T:System.UInt32"/> value.
            </summary>
            <param name="value">The <see cref="T:System.UInt32"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.Int64)">
            <summary>
            Writes a <see cref="T:System.Int64"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Int64"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.UInt64)">
            <summary>
            Writes a <see cref="T:System.UInt64"/> value.
            </summary>
            <param name="value">The <see cref="T:System.UInt64"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.Single)">
            <summary>
            Writes a <see cref="T:System.Single"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Single"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.Nullable{System.Single})">
            <summary>
            Writes a <see cref="T:System.Nullable`1"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Nullable`1"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.Double)">
            <summary>
            Writes a <see cref="T:System.Double"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Double"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.Nullable{System.Double})">
            <summary>
            Writes a <see cref="T:System.Nullable`1"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Nullable`1"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.Boolean)">
            <summary>
            Writes a <see cref="T:System.Boolean"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Boolean"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.Int16)">
            <summary>
            Writes a <see cref="T:System.Int16"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Int16"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.UInt16)">
            <summary>
            Writes a <see cref="T:System.UInt16"/> value.
            </summary>
            <param name="value">The <see cref="T:System.UInt16"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.Char)">
            <summary>
            Writes a <see cref="T:System.Char"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Char"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.Byte)">
            <summary>
            Writes a <see cref="T:System.Byte"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Byte"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.SByte)">
            <summary>
            Writes a <see cref="T:System.SByte"/> value.
            </summary>
            <param name="value">The <see cref="T:System.SByte"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.Decimal)">
            <summary>
            Writes a <see cref="T:System.Decimal"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Decimal"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.DateTime)">
            <summary>
            Writes a <see cref="T:System.DateTime"/> value.
            </summary>
            <param name="value">The <see cref="T:System.DateTime"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.Byte[])">
            <summary>
            Writes a <see cref="T:Byte[]"/> value.
            </summary>
            <param name="value">The <see cref="T:Byte[]"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.DateTimeOffset)">
            <summary>
            Writes a <see cref="T:System.DateTimeOffset"/> value.
            </summary>
            <param name="value">The <see cref="T:System.DateTimeOffset"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.Guid)">
            <summary>
            Writes a <see cref="T:System.Guid"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Guid"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.TimeSpan)">
            <summary>
            Writes a <see cref="T:System.TimeSpan"/> value.
            </summary>
            <param name="value">The <see cref="T:System.TimeSpan"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.Uri)">
            <summary>
            Writes a <see cref="T:System.Uri"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Uri"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonTextWriter.WriteComment(System.String)">
            <summary>
            Writes out a comment <code>/*...*/</code> containing the specified text. 
            </summary>
            <param name="text">Text to place inside the comment.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonTextWriter.WriteWhitespace(System.String)">
            <summary>
            Writes out the given white space.
            </summary>
            <param name="ws">The string of white space characters.</param>
        </member>
        <member name="T:Newtonsoft.Json.JsonToken">
            <summary>
            Specifies the type of Json token.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.JsonToken.None">
            <summary>
            This is returned by the <see cref="T:Newtonsoft.Json.JsonReader"/> if a <see cref="M:Newtonsoft.Json.JsonReader.Read"/> method has not been called. 
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.JsonToken.StartObject">
            <summary>
            An object start token.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.JsonToken.StartArray">
            <summary>
            An array start token.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.JsonToken.StartConstructor">
            <summary>
            A constructor start token.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.JsonToken.PropertyName">
            <summary>
            An object property name.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.JsonToken.Comment">
            <summary>
            A comment.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.JsonToken.Raw">
            <summary>
            Raw JSON.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.JsonToken.Integer">
            <summary>
            An integer.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.JsonToken.Float">
            <summary>
            A float.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.JsonToken.String">
            <summary>
            A string.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.JsonToken.Boolean">
            <summary>
            A boolean.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.JsonToken.Null">
            <summary>
            A null token.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.JsonToken.Undefined">
            <summary>
            An undefined token.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.JsonToken.EndObject">
            <summary>
            An object end token.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.JsonToken.EndArray">
            <summary>
            An array end token.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.JsonToken.EndConstructor">
            <summary>
            A constructor end token.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.JsonToken.Date">
            <summary>
            A Date.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.JsonToken.Bytes">
            <summary>
            Byte data.
            </summary>
        </member>
        <member name="T:Newtonsoft.Json.JsonValidatingReader">
            <summary>
            Represents a reader that provides <see cref="T:Newtonsoft.Json.Schema.JsonSchema"/> validation.
            </summary>
        </member>
        <member name="E:Newtonsoft.Json.JsonValidatingReader.ValidationEventHandler">
            <summary>
            Sets an event handler for receiving schema validation errors.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.JsonValidatingReader.Value">
            <summary>
            Gets the text value of the current JSON token.
            </summary>
            <value></value>
        </member>
        <member name="P:Newtonsoft.Json.JsonValidatingReader.Depth">
            <summary>
            Gets the depth of the current token in the JSON document.
            </summary>
            <value>The depth of the current token in the JSON document.</value>
        </member>
        <member name="P:Newtonsoft.Json.JsonValidatingReader.Path">
            <summary>
            Gets the path of the current JSON token. 
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.JsonValidatingReader.QuoteChar">
            <summary>
            Gets the quotation mark character used to enclose the value of a string.
            </summary>
            <value></value>
        </member>
        <member name="P:Newtonsoft.Json.JsonValidatingReader.TokenType">
            <summary>
            Gets the type of the current JSON token.
            </summary>
            <value></value>
        </member>
        <member name="P:Newtonsoft.Json.JsonValidatingReader.ValueType">
            <summary>
            Gets the Common Language Runtime (CLR) type for the current JSON token.
            </summary>
            <value></value>
        </member>
        <member name="M:Newtonsoft.Json.JsonValidatingReader.#ctor(Newtonsoft.Json.JsonReader)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonValidatingReader"/> class that
            validates the content returned from the given <see cref="T:Newtonsoft.Json.JsonReader"/>.
            </summary>
            <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader"/> to read from while validating.</param>
        </member>
        <member name="P:Newtonsoft.Json.JsonValidatingReader.Schema">
            <summary>
            Gets or sets the schema.
            </summary>
            <value>The schema.</value>
        </member>
        <member name="P:Newtonsoft.Json.JsonValidatingReader.Reader">
            <summary>
            Gets the <see cref="T:Newtonsoft.Json.JsonReader"/> used to construct this <see cref="T:Newtonsoft.Json.JsonValidatingReader"/>.
            </summary>
            <value>The <see cref="T:Newtonsoft.Json.JsonReader"/> specified in the constructor.</value>
        </member>
        <member name="M:Newtonsoft.Json.JsonValidatingReader.ReadAsInt32">
            <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1"/>.
            </summary>
            <returns>A <see cref="T:System.Nullable`1"/>.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonValidatingReader.ReadAsBytes">
            <summary>
            Reads the next JSON token from the stream as a <see cref="T:Byte[]"/>.
            </summary>
            <returns>
            A <see cref="T:Byte[]"/> or a null reference if the next JSON token is null.
            </returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonValidatingReader.ReadAsDecimal">
            <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1"/>.
            </summary>
            <returns>A <see cref="T:System.Nullable`1"/>.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonValidatingReader.ReadAsString">
            <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.String"/>.
            </summary>
            <returns>A <see cref="T:System.String"/>. This method will return <c>null</c> at the end of an array.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonValidatingReader.ReadAsDateTime">
            <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1"/>.
            </summary>
            <returns>A <see cref="T:System.String"/>. This method will return <c>null</c> at the end of an array.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonValidatingReader.ReadAsDateTimeOffset">
            <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1"/>.
            </summary>
            <returns>A <see cref="T:System.Nullable`1"/>.</returns>
        </member>
        <member name="M:Newtonsoft.Json.JsonValidatingReader.Read">
            <summary>
            Reads the next JSON token from the stream.
            </summary>
            <returns>
            true if the next token was read successfully; false if there are no more tokens to read.
            </returns>
        </member>
        <member name="T:Newtonsoft.Json.JsonWriter">
            <summary>
            Represents a writer that provides a fast, non-cached, forward-only way of generating Json data.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.JsonWriter.CloseOutput">
            <summary>
            Gets or sets a value indicating whether the underlying stream or
            <see cref="T:System.IO.TextReader"/> should be closed when the writer is closed.
            </summary>
            <value>
            true to close the underlying stream or <see cref="T:System.IO.TextReader"/> when
            the writer is closed; otherwise false. The default is true.
            </value>
        </member>
        <member name="P:Newtonsoft.Json.JsonWriter.Top">
            <summary>
            Gets the top.
            </summary>
            <value>The top.</value>
        </member>
        <member name="P:Newtonsoft.Json.JsonWriter.WriteState">
            <summary>
            Gets the state of the writer.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.JsonWriter.Path">
            <summary>
            Gets the path of the writer. 
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.JsonWriter.Formatting">
            <summary>
            Indicates how JSON text output is formatted.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.JsonWriter.DateFormatHandling">
            <summary>
            Get or set how dates are written to JSON text.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.JsonWriter.DateTimeZoneHandling">
            <summary>
            Get or set how <see cref="T:System.DateTime"/> time zones are handling when writing JSON text.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.JsonWriter.StringEscapeHandling">
            <summary>
            Get or set how strings are escaped when writing JSON text.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.JsonWriter.FloatFormatHandling">
            <summary>
            Get or set how special floating point numbers, e.g. <see cref="F:System.Double.NaN"/>,
            <see cref="F:System.Double.PositiveInfinity"/> and <see cref="F:System.Double.NegativeInfinity"/>,
            are written to JSON text.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.JsonWriter.DateFormatString">
            <summary>
            Get or set how <see cref="T:System.DateTime"/> and <see cref="T:System.DateTimeOffset"/> values are formatting when writing JSON text.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.JsonWriter.Culture">
            <summary>
            Gets or sets the culture used when writing JSON. Defaults to <see cref="P:System.Globalization.CultureInfo.InvariantCulture"/>.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriter.#ctor">
            <summary>
            Creates an instance of the <c>JsonWriter</c> class. 
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriter.Flush">
            <summary>
            Flushes whatever is in the buffer to the underlying streams and also flushes the underlying stream.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriter.Close">
            <summary>
            Closes this stream and the underlying stream.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriter.WriteStartObject">
            <summary>
            Writes the beginning of a Json object.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriter.WriteEndObject">
            <summary>
            Writes the end of a Json object.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriter.WriteStartArray">
            <summary>
            Writes the beginning of a Json array.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriter.WriteEndArray">
            <summary>
            Writes the end of an array.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriter.WriteStartConstructor(System.String)">
            <summary>
            Writes the start of a constructor with the given name.
            </summary>
            <param name="name">The name of the constructor.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriter.WriteEndConstructor">
            <summary>
            Writes the end constructor.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriter.WritePropertyName(System.String)">
            <summary>
            Writes the property name of a name/value pair on a JSON object.
            </summary>
            <param name="name">The name of the property.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriter.WritePropertyName(System.String,System.Boolean)">
            <summary>
            Writes the property name of a name/value pair on a JSON object.
            </summary>
            <param name="name">The name of the property.</param>
            <param name="escape">A flag to indicate whether the text should be escaped when it is written as a JSON property name.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriter.WriteEnd">
            <summary>
            Writes the end of the current Json object or array.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriter.WriteToken(Newtonsoft.Json.JsonReader)">
            <summary>
            Writes the current <see cref="T:Newtonsoft.Json.JsonReader"/> token and its children.
            </summary>
            <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader"/> to read the token from.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriter.WriteToken(Newtonsoft.Json.JsonReader,System.Boolean)">
            <summary>
            Writes the current <see cref="T:Newtonsoft.Json.JsonReader"/> token.
            </summary>
            <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader"/> to read the token from.</param>
            <param name="writeChildren">A flag indicating whether the current token's children should be written.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriter.WriteEnd(Newtonsoft.Json.JsonToken)">
            <summary>
            Writes the specified end token.
            </summary>
            <param name="token">The end token to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriter.WriteIndent">
            <summary>
            Writes indent characters.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriter.WriteValueDelimiter">
            <summary>
            Writes the JSON value delimiter.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriter.WriteIndentSpace">
            <summary>
            Writes an indent space.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriter.WriteNull">
            <summary>
            Writes a null value.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriter.WriteUndefined">
            <summary>
            Writes an undefined value.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriter.WriteRaw(System.String)">
            <summary>
            Writes raw JSON without changing the writer's state.
            </summary>
            <param name="json">The raw JSON to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriter.WriteRawValue(System.String)">
            <summary>
            Writes raw JSON where a value is expected and updates the writer's state.
            </summary>
            <param name="json">The raw JSON to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.String)">
            <summary>
            Writes a <see cref="T:System.String"/> value.
            </summary>
            <param name="value">The <see cref="T:System.String"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Int32)">
            <summary>
            Writes a <see cref="T:System.Int32"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Int32"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.UInt32)">
            <summary>
            Writes a <see cref="T:System.UInt32"/> value.
            </summary>
            <param name="value">The <see cref="T:System.UInt32"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Int64)">
            <summary>
            Writes a <see cref="T:System.Int64"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Int64"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.UInt64)">
            <summary>
            Writes a <see cref="T:System.UInt64"/> value.
            </summary>
            <param name="value">The <see cref="T:System.UInt64"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Single)">
            <summary>
            Writes a <see cref="T:System.Single"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Single"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Double)">
            <summary>
            Writes a <see cref="T:System.Double"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Double"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Boolean)">
            <summary>
            Writes a <see cref="T:System.Boolean"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Boolean"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Int16)">
            <summary>
            Writes a <see cref="T:System.Int16"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Int16"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.UInt16)">
            <summary>
            Writes a <see cref="T:System.UInt16"/> value.
            </summary>
            <param name="value">The <see cref="T:System.UInt16"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Char)">
            <summary>
            Writes a <see cref="T:System.Char"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Char"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Byte)">
            <summary>
            Writes a <see cref="T:System.Byte"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Byte"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.SByte)">
            <summary>
            Writes a <see cref="T:System.SByte"/> value.
            </summary>
            <param name="value">The <see cref="T:System.SByte"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Decimal)">
            <summary>
            Writes a <see cref="T:System.Decimal"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Decimal"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.DateTime)">
            <summary>
            Writes a <see cref="T:System.DateTime"/> value.
            </summary>
            <param name="value">The <see cref="T:System.DateTime"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.DateTimeOffset)">
            <summary>
            Writes a <see cref="T:System.DateTimeOffset"/> value.
            </summary>
            <param name="value">The <see cref="T:System.DateTimeOffset"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Guid)">
            <summary>
            Writes a <see cref="T:System.Guid"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Guid"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.TimeSpan)">
            <summary>
            Writes a <see cref="T:System.TimeSpan"/> value.
            </summary>
            <param name="value">The <see cref="T:System.TimeSpan"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.Int32})">
            <summary>
            Writes a <see cref="T:System.Nullable`1"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Nullable`1"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.UInt32})">
            <summary>
            Writes a <see cref="T:System.Nullable`1"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Nullable`1"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.Int64})">
            <summary>
            Writes a <see cref="T:System.Nullable`1"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Nullable`1"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.UInt64})">
            <summary>
            Writes a <see cref="T:System.Nullable`1"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Nullable`1"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.Single})">
            <summary>
            Writes a <see cref="T:System.Nullable`1"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Nullable`1"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.Double})">
            <summary>
            Writes a <see cref="T:System.Nullable`1"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Nullable`1"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.Boolean})">
            <summary>
            Writes a <see cref="T:System.Nullable`1"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Nullable`1"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.Int16})">
            <summary>
            Writes a <see cref="T:System.Nullable`1"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Nullable`1"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.UInt16})">
            <summary>
            Writes a <see cref="T:System.Nullable`1"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Nullable`1"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.Char})">
            <summary>
            Writes a <see cref="T:System.Nullable`1"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Nullable`1"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.Byte})">
            <summary>
            Writes a <see cref="T:System.Nullable`1"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Nullable`1"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.SByte})">
            <summary>
            Writes a <see cref="T:System.Nullable`1"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Nullable`1"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.Decimal})">
            <summary>
            Writes a <see cref="T:System.Nullable`1"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Nullable`1"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.DateTime})">
            <summary>
            Writes a <see cref="T:System.Nullable`1"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Nullable`1"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.DateTimeOffset})">
            <summary>
            Writes a <see cref="T:System.Nullable`1"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Nullable`1"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.Guid})">
            <summary>
            Writes a <see cref="T:System.Nullable`1"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Nullable`1"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.TimeSpan})">
            <summary>
            Writes a <see cref="T:System.Nullable`1"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Nullable`1"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Byte[])">
            <summary>
            Writes a <see cref="T:Byte[]"/> value.
            </summary>
            <param name="value">The <see cref="T:Byte[]"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Uri)">
            <summary>
            Writes a <see cref="T:System.Uri"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Uri"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Object)">
            <summary>
            Writes a <see cref="T:System.Object"/> value.
            An error will raised if the value cannot be written as a single JSON token.
            </summary>
            <param name="value">The <see cref="T:System.Object"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriter.WriteComment(System.String)">
            <summary>
            Writes out a comment <code>/*...*/</code> containing the specified text. 
            </summary>
            <param name="text">Text to place inside the comment.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriter.WriteWhitespace(System.String)">
            <summary>
            Writes out the given white space.
            </summary>
            <param name="ws">The string of white space characters.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriter.SetWriteState(Newtonsoft.Json.JsonToken,System.Object)">
            <summary>
            Sets the state of the JsonWriter,
            </summary>
            <param name="token">The JsonToken being written.</param>
            <param name="value">The value being written.</param>
        </member>
        <member name="T:Newtonsoft.Json.JsonWriterException">
            <summary>
            The exception thrown when an error occurs while reading Json text.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.JsonWriterException.Path">
            <summary>
            Gets the path to the JSON where the error occurred.
            </summary>
            <value>The path to the JSON where the error occurred.</value>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriterException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonWriterException"/> class.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriterException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonWriterException"/> class
            with a specified error message.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriterException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonWriterException"/> class
            with a specified error message and a reference to the inner exception that is the cause of this exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception, or a null reference (Nothing in Visual Basic) if no inner exception is specified.</param>
        </member>
        <member name="M:Newtonsoft.Json.JsonWriterException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonWriterException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="info"/> parameter is null. </exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or <see cref="P:System.Exception.HResult"/> is zero (0). </exception>
        </member>
        <member name="T:Newtonsoft.Json.Linq.Extensions">
            <summary>
            Contains the LINQ to JSON extension methods.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.Linq.Extensions.Ancestors``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns a collection of tokens that contains the ancestors of every token in the source collection.
            </summary>
            <typeparam name="T">The type of the objects in source, constrained to <see cref="T:Newtonsoft.Json.Linq.JToken"/>.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="T:Newtonsoft.Json.Linq.JToken"/> that contains the source collection.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="T:Newtonsoft.Json.Linq.JToken"/> that contains the ancestors of every node in the source collection.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.Extensions.Descendants``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns a collection of tokens that contains the descendants of every token in the source collection.
            </summary>
            <typeparam name="T">The type of the objects in source, constrained to <see cref="T:Newtonsoft.Json.Linq.JContainer"/>.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="T:Newtonsoft.Json.Linq.JToken"/> that contains the source collection.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="T:Newtonsoft.Json.Linq.JToken"/> that contains the descendants of every node in the source collection.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.Extensions.Properties(System.Collections.Generic.IEnumerable{Newtonsoft.Json.Linq.JObject})">
            <summary>
            Returns a collection of child properties of every object in the source collection.
            </summary>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="T:Newtonsoft.Json.Linq.JObject"/> that contains the source collection.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="T:Newtonsoft.Json.Linq.JProperty"/> that contains the properties of every object in the source collection.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.Extensions.Values(System.Collections.Generic.IEnumerable{Newtonsoft.Json.Linq.JToken},System.Object)">
            <summary>
            Returns a collection of child values of every object in the source collection with the given key.
            </summary>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="T:Newtonsoft.Json.Linq.JToken"/> that contains the source collection.</param>
            <param name="key">The token key.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="T:Newtonsoft.Json.Linq.JToken"/> that contains the values of every node in the source collection with the given key.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.Extensions.Values(System.Collections.Generic.IEnumerable{Newtonsoft.Json.Linq.JToken})">
            <summary>
            Returns a collection of child values of every object in the source collection.
            </summary>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="T:Newtonsoft.Json.Linq.JToken"/> that contains the source collection.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="T:Newtonsoft.Json.Linq.JToken"/> that contains the values of every node in the source collection.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.Extensions.Values``1(System.Collections.Generic.IEnumerable{Newtonsoft.Json.Linq.JToken},System.Object)">
            <summary>
            Returns a collection of converted child values of every object in the source collection with the given key.
            </summary>
            <typeparam name="U">The type to convert the values to.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="T:Newtonsoft.Json.Linq.JToken"/> that contains the source collection.</param>
            <param name="key">The token key.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> that contains the converted values of every node in the source collection with the given key.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.Extensions.Values``1(System.Collections.Generic.IEnumerable{Newtonsoft.Json.Linq.JToken})">
            <summary>
            Returns a collection of converted child values of every object in the source collection.
            </summary>
            <typeparam name="U">The type to convert the values to.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="T:Newtonsoft.Json.Linq.JToken"/> that contains the source collection.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> that contains the converted values of every node in the source collection.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.Extensions.Value``1(System.Collections.Generic.IEnumerable{Newtonsoft.Json.Linq.JToken})">
            <summary>
            Converts the value.
            </summary>
            <typeparam name="U">The type to convert the value to.</typeparam>
            <param name="value">A <see cref="T:Newtonsoft.Json.Linq.JToken"/> cast as a <see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="T:Newtonsoft.Json.Linq.JToken"/>.</param>
            <returns>A converted value.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.Extensions.Value``2(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Converts the value.
            </summary>
            <typeparam name="T">The source collection type.</typeparam>
            <typeparam name="U">The type to convert the value to.</typeparam>
            <param name="value">A <see cref="T:Newtonsoft.Json.Linq.JToken"/> cast as a <see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="T:Newtonsoft.Json.Linq.JToken"/>.</param>
            <returns>A converted value.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.Extensions.Children``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns a collection of child tokens of every array in the source collection.
            </summary>
            <typeparam name="T">The source collection type.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="T:Newtonsoft.Json.Linq.JToken"/> that contains the source collection.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="T:Newtonsoft.Json.Linq.JToken"/> that contains the values of every node in the source collection.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.Extensions.Children``2(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns a collection of converted child tokens of every array in the source collection.
            </summary>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="T:Newtonsoft.Json.Linq.JToken"/> that contains the source collection.</param>
            <typeparam name="U">The type to convert the values to.</typeparam>
            <typeparam name="T">The source collection type.</typeparam>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> that contains the converted values of every node in the source collection.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.Extensions.AsJEnumerable(System.Collections.Generic.IEnumerable{Newtonsoft.Json.Linq.JToken})">
            <summary>
            Returns the input typed as <see cref="T:Newtonsoft.Json.Linq.IJEnumerable`1"/>.
            </summary>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="T:Newtonsoft.Json.Linq.JToken"/> that contains the source collection.</param>
            <returns>The input typed as <see cref="T:Newtonsoft.Json.Linq.IJEnumerable`1"/>.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.Extensions.AsJEnumerable``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns the input typed as <see cref="T:Newtonsoft.Json.Linq.IJEnumerable`1"/>.
            </summary>
            <typeparam name="T">The source collection type.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="T:Newtonsoft.Json.Linq.JToken"/> that contains the source collection.</param>
            <returns>The input typed as <see cref="T:Newtonsoft.Json.Linq.IJEnumerable`1"/>.</returns>
        </member>
        <member name="T:Newtonsoft.Json.Linq.IJEnumerable`1">
            <summary>
            Represents a collection of <see cref="T:Newtonsoft.Json.Linq.JToken"/> objects.
            </summary>
            <typeparam name="T">The type of token</typeparam>
        </member>
        <member name="P:Newtonsoft.Json.Linq.IJEnumerable`1.Item(System.Object)">
            <summary>
            Gets the <see cref="T:Newtonsoft.Json.Linq.IJEnumerable`1"/> with the specified key.
            </summary>
            <value></value>
        </member>
        <member name="T:Newtonsoft.Json.Linq.JArray">
            <summary>
            Represents a JSON array.
            </summary>
            <example>
              <code lang="cs" source="..\Src\Newtonsoft.Json.Tests\Documentation\LinqToJsonTests.cs" region="LinqToJsonCreateParseArray" title="Parsing a JSON Array from Text" />
            </example>
        </member>
        <member name="P:Newtonsoft.Json.Linq.JArray.ChildrenTokens">
            <summary>
            Gets the container's children tokens.
            </summary>
            <value>The container's children tokens.</value>
        </member>
        <member name="P:Newtonsoft.Json.Linq.JArray.Type">
            <summary>
            Gets the node type for this <see cref="T:Newtonsoft.Json.Linq.JToken"/>.
            </summary>
            <value>The type.</value>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JArray.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JArray"/> class.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JArray.#ctor(Newtonsoft.Json.Linq.JArray)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JArray"/> class from another <see cref="T:Newtonsoft.Json.Linq.JArray"/> object.
            </summary>
            <param name="other">A <see cref="T:Newtonsoft.Json.Linq.JArray"/> object to copy from.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JArray.#ctor(System.Object[])">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JArray"/> class with the specified content.
            </summary>
            <param name="content">The contents of the array.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JArray.#ctor(System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JArray"/> class with the specified content.
            </summary>
            <param name="content">The contents of the array.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JArray.Load(Newtonsoft.Json.JsonReader)">
            <summary>
            Loads an <see cref="T:Newtonsoft.Json.Linq.JArray"/> from a <see cref="T:Newtonsoft.Json.JsonReader"/>. 
            </summary>
            <param name="reader">A <see cref="T:Newtonsoft.Json.JsonReader"/> that will be read for the content of the <see cref="T:Newtonsoft.Json.Linq.JArray"/>.</param>
            <returns>A <see cref="T:Newtonsoft.Json.Linq.JArray"/> that contains the JSON that was read from the specified <see cref="T:Newtonsoft.Json.JsonReader"/>.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JArray.Parse(System.String)">
            <summary>
            Load a <see cref="T:Newtonsoft.Json.Linq.JArray"/> from a string that contains JSON.
            </summary>
            <param name="json">A <see cref="T:System.String"/> that contains JSON.</param>
            <returns>A <see cref="T:Newtonsoft.Json.Linq.JArray"/> populated from the string that contains JSON.</returns>
            <example>
              <code lang="cs" source="..\Src\Newtonsoft.Json.Tests\Documentation\LinqToJsonTests.cs" region="LinqToJsonCreateParseArray" title="Parsing a JSON Array from Text" />
            </example>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JArray.FromObject(System.Object)">
            <summary>
            Creates a <see cref="T:Newtonsoft.Json.Linq.JArray"/> from an object.
            </summary>
            <param name="o">The object that will be used to create <see cref="T:Newtonsoft.Json.Linq.JArray"/>.</param>
            <returns>A <see cref="T:Newtonsoft.Json.Linq.JArray"/> with the values of the specified object</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JArray.FromObject(System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Creates a <see cref="T:Newtonsoft.Json.Linq.JArray"/> from an object.
            </summary>
            <param name="o">The object that will be used to create <see cref="T:Newtonsoft.Json.Linq.JArray"/>.</param>
            <param name="jsonSerializer">The <see cref="T:Newtonsoft.Json.JsonSerializer"/> that will be used to read the object.</param>
            <returns>A <see cref="T:Newtonsoft.Json.Linq.JArray"/> with the values of the specified object</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JArray.WriteTo(Newtonsoft.Json.JsonWriter,Newtonsoft.Json.JsonConverter[])">
            <summary>
            Writes this token to a <see cref="T:Newtonsoft.Json.JsonWriter"/>.
            </summary>
            <param name="writer">A <see cref="T:Newtonsoft.Json.JsonWriter"/> into which this method will write.</param>
            <param name="converters">A collection of <see cref="T:Newtonsoft.Json.JsonConverter"/> which will be used when writing the token.</param>
        </member>
        <member name="P:Newtonsoft.Json.Linq.JArray.Item(System.Object)">
            <summary>
            Gets the <see cref="T:Newtonsoft.Json.Linq.JToken"/> with the specified key.
            </summary>
            <value>The <see cref="T:Newtonsoft.Json.Linq.JToken"/> with the specified key.</value>
        </member>
        <member name="P:Newtonsoft.Json.Linq.JArray.Item(System.Int32)">
            <summary>
            Gets or sets the <see cref="T:Newtonsoft.Json.Linq.JToken"/> at the specified index.
            </summary>
            <value></value>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JArray.IndexOf(Newtonsoft.Json.Linq.JToken)">
            <summary>
            Determines the index of a specific item in the <see cref="T:System.Collections.Generic.IList`1"/>.
            </summary>
            <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.IList`1"/>.</param>
            <returns>
            The index of <paramref name="item"/> if found in the list; otherwise, -1.
            </returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JArray.Insert(System.Int32,Newtonsoft.Json.Linq.JToken)">
            <summary>
            Inserts an item to the <see cref="T:System.Collections.Generic.IList`1"/> at the specified index.
            </summary>
            <param name="index">The zero-based index at which <paramref name="item"/> should be inserted.</param>
            <param name="item">The object to insert into the <see cref="T:System.Collections.Generic.IList`1"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="index"/> is not a valid index in the <see cref="T:System.Collections.Generic.IList`1"/>.</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.IList`1"/> is read-only.</exception>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JArray.RemoveAt(System.Int32)">
            <summary>
            Removes the <see cref="T:System.Collections.Generic.IList`1"/> item at the specified index.
            </summary>
            <param name="index">The zero-based index of the item to remove.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="index"/> is not a valid index in the <see cref="T:System.Collections.Generic.IList`1"/>.</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.IList`1"/> is read-only.</exception>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JArray.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JArray.Add(Newtonsoft.Json.Linq.JToken)">
            <summary>
            Adds an item to the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <param name="item">The object to add to the <see cref="T:System.Collections.Generic.ICollection`1"/>.</param>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only.</exception>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JArray.Clear">
            <summary>
            Removes all items from the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only. </exception>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JArray.Contains(Newtonsoft.Json.Linq.JToken)">
            <summary>
            Determines whether the <see cref="T:System.Collections.Generic.ICollection`1"/> contains a specific value.
            </summary>
            <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.ICollection`1"/>.</param>
            <returns>
            true if <paramref name="item"/> is found in the <see cref="T:System.Collections.Generic.ICollection`1"/>; otherwise, false.
            </returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JArray.CopyTo(Newtonsoft.Json.Linq.JToken[],System.Int32)">
            <summary>
            Copies to.
            </summary>
            <param name="array">The array.</param>
            <param name="arrayIndex">Index of the array.</param>
        </member>
        <member name="P:Newtonsoft.Json.Linq.JArray.IsReadOnly">
            <summary>
            Gets a value indicating whether the <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only.
            </summary>
            <returns>true if the <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only; otherwise, false.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JArray.Remove(Newtonsoft.Json.Linq.JToken)">
            <summary>
            Removes the first occurrence of a specific object from the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <param name="item">The object to remove from the <see cref="T:System.Collections.Generic.ICollection`1"/>.</param>
            <returns>
            true if <paramref name="item"/> was successfully removed from the <see cref="T:System.Collections.Generic.ICollection`1"/>; otherwise, false. This method also returns false if <paramref name="item"/> is not found in the original <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </returns>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only.</exception>
        </member>
        <member name="T:Newtonsoft.Json.Linq.JConstructor">
            <summary>
            Represents a JSON constructor.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.Linq.JConstructor.ChildrenTokens">
            <summary>
            Gets the container's children tokens.
            </summary>
            <value>The container's children tokens.</value>
        </member>
        <member name="P:Newtonsoft.Json.Linq.JConstructor.Name">
            <summary>
            Gets or sets the name of this constructor.
            </summary>
            <value>The constructor name.</value>
        </member>
        <member name="P:Newtonsoft.Json.Linq.JConstructor.Type">
            <summary>
            Gets the node type for this <see cref="T:Newtonsoft.Json.Linq.JToken"/>.
            </summary>
            <value>The type.</value>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JConstructor.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JConstructor"/> class.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JConstructor.#ctor(Newtonsoft.Json.Linq.JConstructor)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JConstructor"/> class from another <see cref="T:Newtonsoft.Json.Linq.JConstructor"/> object.
            </summary>
            <param name="other">A <see cref="T:Newtonsoft.Json.Linq.JConstructor"/> object to copy from.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JConstructor.#ctor(System.String,System.Object[])">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JConstructor"/> class with the specified name and content.
            </summary>
            <param name="name">The constructor name.</param>
            <param name="content">The contents of the constructor.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JConstructor.#ctor(System.String,System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JConstructor"/> class with the specified name and content.
            </summary>
            <param name="name">The constructor name.</param>
            <param name="content">The contents of the constructor.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JConstructor.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JConstructor"/> class with the specified name.
            </summary>
            <param name="name">The constructor name.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JConstructor.WriteTo(Newtonsoft.Json.JsonWriter,Newtonsoft.Json.JsonConverter[])">
            <summary>
            Writes this token to a <see cref="T:Newtonsoft.Json.JsonWriter"/>.
            </summary>
            <param name="writer">A <see cref="T:Newtonsoft.Json.JsonWriter"/> into which this method will write.</param>
            <param name="converters">A collection of <see cref="T:Newtonsoft.Json.JsonConverter"/> which will be used when writing the token.</param>
        </member>
        <member name="P:Newtonsoft.Json.Linq.JConstructor.Item(System.Object)">
            <summary>
            Gets the <see cref="T:Newtonsoft.Json.Linq.JToken"/> with the specified key.
            </summary>
            <value>The <see cref="T:Newtonsoft.Json.Linq.JToken"/> with the specified key.</value>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JConstructor.Load(Newtonsoft.Json.JsonReader)">
            <summary>
            Loads an <see cref="T:Newtonsoft.Json.Linq.JConstructor"/> from a <see cref="T:Newtonsoft.Json.JsonReader"/>. 
            </summary>
            <param name="reader">A <see cref="T:Newtonsoft.Json.JsonReader"/> that will be read for the content of the <see cref="T:Newtonsoft.Json.Linq.JConstructor"/>.</param>
            <returns>A <see cref="T:Newtonsoft.Json.Linq.JConstructor"/> that contains the JSON that was read from the specified <see cref="T:Newtonsoft.Json.JsonReader"/>.</returns>
        </member>
        <member name="T:Newtonsoft.Json.Linq.JContainer">
            <summary>
            Represents a token that can contain other tokens.
            </summary>
        </member>
        <member name="E:Newtonsoft.Json.Linq.JContainer.ListChanged">
            <summary>
            Occurs when the list changes or an item in the list changes.
            </summary>
        </member>
        <member name="E:Newtonsoft.Json.Linq.JContainer.AddingNew">
            <summary>
            Occurs before an item is added to the collection.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.Linq.JContainer.ChildrenTokens">
            <summary>
            Gets the container's children tokens.
            </summary>
            <value>The container's children tokens.</value>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JContainer.OnAddingNew(System.ComponentModel.AddingNewEventArgs)">
            <summary>
            Raises the <see cref="E:Newtonsoft.Json.Linq.JContainer.AddingNew"/> event.
            </summary>
            <param name="e">The <see cref="T:System.ComponentModel.AddingNewEventArgs"/> instance containing the event data.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JContainer.OnListChanged(System.ComponentModel.ListChangedEventArgs)">
            <summary>
            Raises the <see cref="E:Newtonsoft.Json.Linq.JContainer.ListChanged"/> event.
            </summary>
            <param name="e">The <see cref="T:System.ComponentModel.ListChangedEventArgs"/> instance containing the event data.</param>
        </member>
        <member name="P:Newtonsoft.Json.Linq.JContainer.HasValues">
            <summary>
            Gets a value indicating whether this token has child tokens.
            </summary>
            <value>
            	<c>true</c> if this token has child values; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Newtonsoft.Json.Linq.JContainer.First">
            <summary>
            Get the first child token of this token.
            </summary>
            <value>
            A <see cref="T:Newtonsoft.Json.Linq.JToken"/> containing the first child token of the <see cref="T:Newtonsoft.Json.Linq.JToken"/>.
            </value>
        </member>
        <member name="P:Newtonsoft.Json.Linq.JContainer.Last">
            <summary>
            Get the last child token of this token.
            </summary>
            <value>
            A <see cref="T:Newtonsoft.Json.Linq.JToken"/> containing the last child token of the <see cref="T:Newtonsoft.Json.Linq.JToken"/>.
            </value>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JContainer.Children">
            <summary>
            Returns a collection of the child tokens of this token, in document order.
            </summary>
            <returns>
            An <see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="T:Newtonsoft.Json.Linq.JToken"/> containing the child tokens of this <see cref="T:Newtonsoft.Json.Linq.JToken"/>, in document order.
            </returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JContainer.Values``1">
            <summary>
            Returns a collection of the child values of this token, in document order.
            </summary>
            <typeparam name="T">The type to convert the values to.</typeparam>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerable`1"/> containing the child values of this <see cref="T:Newtonsoft.Json.Linq.JToken"/>, in document order.
            </returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JContainer.Descendants">
            <summary>
            Returns a collection of the descendant tokens for this token in document order.
            </summary>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> containing the descendant tokens of the <see cref="T:Newtonsoft.Json.Linq.JToken"/>.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JContainer.Add(System.Object)">
            <summary>
            Adds the specified content as children of this <see cref="T:Newtonsoft.Json.Linq.JToken"/>.
            </summary>
            <param name="content">The content to be added.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JContainer.AddFirst(System.Object)">
            <summary>
            Adds the specified content as the first children of this <see cref="T:Newtonsoft.Json.Linq.JToken"/>.
            </summary>
            <param name="content">The content to be added.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JContainer.CreateWriter">
            <summary>
            Creates an <see cref="T:Newtonsoft.Json.JsonWriter"/> that can be used to add tokens to the <see cref="T:Newtonsoft.Json.Linq.JToken"/>.
            </summary>
            <returns>An <see cref="T:Newtonsoft.Json.JsonWriter"/> that is ready to have content written to it.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JContainer.ReplaceAll(System.Object)">
            <summary>
            Replaces the children nodes of this token with the specified content.
            </summary>
            <param name="content">The content.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JContainer.RemoveAll">
            <summary>
            Removes the child nodes from this token.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.Linq.JContainer.Count">
            <summary>
            Gets the count of child JSON tokens.
            </summary>
            <value>The count of child JSON tokens</value>
        </member>
        <member name="T:Newtonsoft.Json.Linq.JEnumerable`1">
            <summary>
            Represents a collection of <see cref="T:Newtonsoft.Json.Linq.JToken"/> objects.
            </summary>
            <typeparam name="T">The type of token</typeparam>
        </member>
        <member name="F:Newtonsoft.Json.Linq.JEnumerable`1.Empty">
            <summary>
            An empty collection of <see cref="T:Newtonsoft.Json.Linq.JToken"/> objects.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JEnumerable`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JEnumerable`1"/> struct.
            </summary>
            <param name="enumerable">The enumerable.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JEnumerable`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JEnumerable`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="P:Newtonsoft.Json.Linq.JEnumerable`1.Item(System.Object)">
            <summary>
            Gets the <see cref="T:Newtonsoft.Json.Linq.IJEnumerable`1"/> with the specified key.
            </summary>
            <value></value>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JEnumerable`1.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with this instance.</param>
            <returns>
            	<c>true</c> if the specified <see cref="T:System.Object"/> is equal to this instance; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JEnumerable`1.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
            </returns>
        </member>
        <member name="T:Newtonsoft.Json.Linq.JObject">
            <summary>
            Represents a JSON object.
            </summary>
            <example>
              <code lang="cs" source="..\Src\Newtonsoft.Json.Tests\Documentation\LinqToJsonTests.cs" region="LinqToJsonCreateParse" title="Parsing a JSON Object from Text" />
            </example>
        </member>
        <member name="P:Newtonsoft.Json.Linq.JObject.ChildrenTokens">
            <summary>
            Gets the container's children tokens.
            </summary>
            <value>The container's children tokens.</value>
        </member>
        <member name="E:Newtonsoft.Json.Linq.JObject.PropertyChanged">
            <summary>
            Occurs when a property value changes.
            </summary>
        </member>
        <member name="E:Newtonsoft.Json.Linq.JObject.PropertyChanging">
            <summary>
            Occurs when a property value is changing.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JObject.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JObject"/> class.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JObject.#ctor(Newtonsoft.Json.Linq.JObject)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JObject"/> class from another <see cref="T:Newtonsoft.Json.Linq.JObject"/> object.
            </summary>
            <param name="other">A <see cref="T:Newtonsoft.Json.Linq.JObject"/> object to copy from.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JObject.#ctor(System.Object[])">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JObject"/> class with the specified content.
            </summary>
            <param name="content">The contents of the object.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JObject.#ctor(System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JObject"/> class with the specified content.
            </summary>
            <param name="content">The contents of the object.</param>
        </member>
        <member name="P:Newtonsoft.Json.Linq.JObject.Type">
            <summary>
            Gets the node type for this <see cref="T:Newtonsoft.Json.Linq.JToken"/>.
            </summary>
            <value>The type.</value>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JObject.Properties">
            <summary>
            Gets an <see cref="T:System.Collections.Generic.IEnumerable`1"/> of this object's properties.
            </summary>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> of this object's properties.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JObject.Property(System.String)">
            <summary>
            Gets a <see cref="T:Newtonsoft.Json.Linq.JProperty"/> the specified name.
            </summary>
            <param name="name">The property name.</param>
            <returns>A <see cref="T:Newtonsoft.Json.Linq.JProperty"/> with the specified name or null.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JObject.PropertyValues">
            <summary>
            Gets an <see cref="T:Newtonsoft.Json.Linq.JEnumerable`1"/> of this object's property values.
            </summary>
            <returns>An <see cref="T:Newtonsoft.Json.Linq.JEnumerable`1"/> of this object's property values.</returns>
        </member>
        <member name="P:Newtonsoft.Json.Linq.JObject.Item(System.Object)">
            <summary>
            Gets the <see cref="T:Newtonsoft.Json.Linq.JToken"/> with the specified key.
            </summary>
            <value>The <see cref="T:Newtonsoft.Json.Linq.JToken"/> with the specified key.</value>
        </member>
        <member name="P:Newtonsoft.Json.Linq.JObject.Item(System.String)">
            <summary>
            Gets or sets the <see cref="T:Newtonsoft.Json.Linq.JToken"/> with the specified property name.
            </summary>
            <value></value>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JObject.Load(Newtonsoft.Json.JsonReader)">
            <summary>
            Loads an <see cref="T:Newtonsoft.Json.Linq.JObject"/> from a <see cref="T:Newtonsoft.Json.JsonReader"/>. 
            </summary>
            <param name="reader">A <see cref="T:Newtonsoft.Json.JsonReader"/> that will be read for the content of the <see cref="T:Newtonsoft.Json.Linq.JObject"/>.</param>
            <returns>A <see cref="T:Newtonsoft.Json.Linq.JObject"/> that contains the JSON that was read from the specified <see cref="T:Newtonsoft.Json.JsonReader"/>.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JObject.Parse(System.String)">
            <summary>
            Load a <see cref="T:Newtonsoft.Json.Linq.JObject"/> from a string that contains JSON.
            </summary>
            <param name="json">A <see cref="T:System.String"/> that contains JSON.</param>
            <returns>A <see cref="T:Newtonsoft.Json.Linq.JObject"/> populated from the string that contains JSON.</returns>
            <example>
              <code lang="cs" source="..\Src\Newtonsoft.Json.Tests\Documentation\LinqToJsonTests.cs" region="LinqToJsonCreateParse" title="Parsing a JSON Object from Text" />
            </example>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JObject.FromObject(System.Object)">
            <summary>
            Creates a <see cref="T:Newtonsoft.Json.Linq.JObject"/> from an object.
            </summary>
            <param name="o">The object that will be used to create <see cref="T:Newtonsoft.Json.Linq.JObject"/>.</param>
            <returns>A <see cref="T:Newtonsoft.Json.Linq.JObject"/> with the values of the specified object</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JObject.FromObject(System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Creates a <see cref="T:Newtonsoft.Json.Linq.JArray"/> from an object.
            </summary>
            <param name="o">The object that will be used to create <see cref="T:Newtonsoft.Json.Linq.JArray"/>.</param>
            <param name="jsonSerializer">The <see cref="T:Newtonsoft.Json.JsonSerializer"/> that will be used to read the object.</param>
            <returns>A <see cref="T:Newtonsoft.Json.Linq.JArray"/> with the values of the specified object</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JObject.WriteTo(Newtonsoft.Json.JsonWriter,Newtonsoft.Json.JsonConverter[])">
            <summary>
            Writes this token to a <see cref="T:Newtonsoft.Json.JsonWriter"/>.
            </summary>
            <param name="writer">A <see cref="T:Newtonsoft.Json.JsonWriter"/> into which this method will write.</param>
            <param name="converters">A collection of <see cref="T:Newtonsoft.Json.JsonConverter"/> which will be used when writing the token.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JObject.GetValue(System.String)">
            <summary>
            Gets the <see cref="T:Newtonsoft.Json.Linq.JToken"/> with the specified property name.
            </summary>
            <param name="propertyName">Name of the property.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JToken"/> with the specified property name.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JObject.GetValue(System.String,System.StringComparison)">
            <summary>
            Gets the <see cref="T:Newtonsoft.Json.Linq.JToken"/> with the specified property name.
            The exact property name will be searched for first and if no matching property is found then
            the <see cref="T:System.StringComparison"/> will be used to match a property.
            </summary>
            <param name="propertyName">Name of the property.</param>
            <param name="comparison">One of the enumeration values that specifies how the strings will be compared.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JToken"/> with the specified property name.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JObject.TryGetValue(System.String,System.StringComparison,Newtonsoft.Json.Linq.JToken@)">
            <summary>
            Tries to get the <see cref="T:Newtonsoft.Json.Linq.JToken"/> with the specified property name.
            The exact property name will be searched for first and if no matching property is found then
            the <see cref="T:System.StringComparison"/> will be used to match a property.
            </summary>
            <param name="propertyName">Name of the property.</param>
            <param name="value">The value.</param>
            <param name="comparison">One of the enumeration values that specifies how the strings will be compared.</param>
            <returns>true if a value was successfully retrieved; otherwise, false.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JObject.Add(System.String,Newtonsoft.Json.Linq.JToken)">
            <summary>
            Adds the specified property name.
            </summary>
            <param name="propertyName">Name of the property.</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JObject.Remove(System.String)">
            <summary>
            Removes the property with the specified name.
            </summary>
            <param name="propertyName">Name of the property.</param>
            <returns>true if item was successfully removed; otherwise, false.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JObject.TryGetValue(System.String,Newtonsoft.Json.Linq.JToken@)">
            <summary>
            Tries the get value.
            </summary>
            <param name="propertyName">Name of the property.</param>
            <param name="value">The value.</param>
            <returns>true if a value was successfully retrieved; otherwise, false.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JObject.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JObject.OnPropertyChanged(System.String)">
            <summary>
            Raises the <see cref="E:Newtonsoft.Json.Linq.JObject.PropertyChanged"/> event with the provided arguments.
            </summary>
            <param name="propertyName">Name of the property.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JObject.OnPropertyChanging(System.String)">
            <summary>
            Raises the <see cref="E:Newtonsoft.Json.Linq.JObject.PropertyChanging"/> event with the provided arguments.
            </summary>
            <param name="propertyName">Name of the property.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JObject.System#ComponentModel#ICustomTypeDescriptor#GetProperties">
            <summary>
            Returns the properties for this instance of a component.
            </summary>
            <returns>
            A <see cref="T:System.ComponentModel.PropertyDescriptorCollection"/> that represents the properties for this component instance.
            </returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JObject.System#ComponentModel#ICustomTypeDescriptor#GetProperties(System.Attribute[])">
            <summary>
            Returns the properties for this instance of a component using the attribute array as a filter.
            </summary>
            <param name="attributes">An array of type <see cref="T:System.Attribute"/> that is used as a filter.</param>
            <returns>
            A <see cref="T:System.ComponentModel.PropertyDescriptorCollection"/> that represents the filtered properties for this component instance.
            </returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JObject.System#ComponentModel#ICustomTypeDescriptor#GetAttributes">
            <summary>
            Returns a collection of custom attributes for this instance of a component.
            </summary>
            <returns>
            An <see cref="T:System.ComponentModel.AttributeCollection"/> containing the attributes for this object.
            </returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JObject.System#ComponentModel#ICustomTypeDescriptor#GetClassName">
            <summary>
            Returns the class name of this instance of a component.
            </summary>
            <returns>
            The class name of the object, or null if the class does not have a name.
            </returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JObject.System#ComponentModel#ICustomTypeDescriptor#GetComponentName">
            <summary>
            Returns the name of this instance of a component.
            </summary>
            <returns>
            The name of the object, or null if the object does not have a name.
            </returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JObject.System#ComponentModel#ICustomTypeDescriptor#GetConverter">
            <summary>
            Returns a type converter for this instance of a component.
            </summary>
            <returns>
            A <see cref="T:System.ComponentModel.TypeConverter"/> that is the converter for this object, or null if there is no <see cref="T:System.ComponentModel.TypeConverter"/> for this object.
            </returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JObject.System#ComponentModel#ICustomTypeDescriptor#GetDefaultEvent">
            <summary>
            Returns the default event for this instance of a component.
            </summary>
            <returns>
            An <see cref="T:System.ComponentModel.EventDescriptor"/> that represents the default event for this object, or null if this object does not have events.
            </returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JObject.System#ComponentModel#ICustomTypeDescriptor#GetDefaultProperty">
            <summary>
            Returns the default property for this instance of a component.
            </summary>
            <returns>
            A <see cref="T:System.ComponentModel.PropertyDescriptor"/> that represents the default property for this object, or null if this object does not have properties.
            </returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JObject.System#ComponentModel#ICustomTypeDescriptor#GetEditor(System.Type)">
            <summary>
            Returns an editor of the specified type for this instance of a component.
            </summary>
            <param name="editorBaseType">A <see cref="T:System.Type"/> that represents the editor for this object.</param>
            <returns>
            An <see cref="T:System.Object"/> of the specified type that is the editor for this object, or null if the editor cannot be found.
            </returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JObject.System#ComponentModel#ICustomTypeDescriptor#GetEvents(System.Attribute[])">
            <summary>
            Returns the events for this instance of a component using the specified attribute array as a filter.
            </summary>
            <param name="attributes">An array of type <see cref="T:System.Attribute"/> that is used as a filter.</param>
            <returns>
            An <see cref="T:System.ComponentModel.EventDescriptorCollection"/> that represents the filtered events for this component instance.
            </returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JObject.System#ComponentModel#ICustomTypeDescriptor#GetEvents">
            <summary>
            Returns the events for this instance of a component.
            </summary>
            <returns>
            An <see cref="T:System.ComponentModel.EventDescriptorCollection"/> that represents the events for this component instance.
            </returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JObject.System#ComponentModel#ICustomTypeDescriptor#GetPropertyOwner(System.ComponentModel.PropertyDescriptor)">
            <summary>
            Returns an object that contains the property described by the specified property descriptor.
            </summary>
            <param name="pd">A <see cref="T:System.ComponentModel.PropertyDescriptor"/> that represents the property whose owner is to be found.</param>
            <returns>
            An <see cref="T:System.Object"/> that represents the owner of the specified property.
            </returns>
        </member>
        <member name="T:Newtonsoft.Json.Linq.JProperty">
            <summary>
            Represents a JSON property.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.Linq.JProperty.ChildrenTokens">
            <summary>
            Gets the container's children tokens.
            </summary>
            <value>The container's children tokens.</value>
        </member>
        <member name="P:Newtonsoft.Json.Linq.JProperty.Name">
            <summary>
            Gets the property name.
            </summary>
            <value>The property name.</value>
        </member>
        <member name="P:Newtonsoft.Json.Linq.JProperty.Value">
            <summary>
            Gets or sets the property value.
            </summary>
            <value>The property value.</value>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JProperty.#ctor(Newtonsoft.Json.Linq.JProperty)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JProperty"/> class from another <see cref="T:Newtonsoft.Json.Linq.JProperty"/> object.
            </summary>
            <param name="other">A <see cref="T:Newtonsoft.Json.Linq.JProperty"/> object to copy from.</param>
        </member>
        <member name="P:Newtonsoft.Json.Linq.JProperty.Type">
            <summary>
            Gets the node type for this <see cref="T:Newtonsoft.Json.Linq.JToken"/>.
            </summary>
            <value>The type.</value>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JProperty.#ctor(System.String,System.Object[])">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JProperty"/> class.
            </summary>
            <param name="name">The property name.</param>
            <param name="content">The property content.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JProperty.#ctor(System.String,System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JProperty"/> class.
            </summary>
            <param name="name">The property name.</param>
            <param name="content">The property content.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JProperty.WriteTo(Newtonsoft.Json.JsonWriter,Newtonsoft.Json.JsonConverter[])">
            <summary>
            Writes this token to a <see cref="T:Newtonsoft.Json.JsonWriter"/>.
            </summary>
            <param name="writer">A <see cref="T:Newtonsoft.Json.JsonWriter"/> into which this method will write.</param>
            <param name="converters">A collection of <see cref="T:Newtonsoft.Json.JsonConverter"/> which will be used when writing the token.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JProperty.Load(Newtonsoft.Json.JsonReader)">
            <summary>
            Loads an <see cref="T:Newtonsoft.Json.Linq.JProperty"/> from a <see cref="T:Newtonsoft.Json.JsonReader"/>. 
            </summary>
            <param name="reader">A <see cref="T:Newtonsoft.Json.JsonReader"/> that will be read for the content of the <see cref="T:Newtonsoft.Json.Linq.JProperty"/>.</param>
            <returns>A <see cref="T:Newtonsoft.Json.Linq.JProperty"/> that contains the JSON that was read from the specified <see cref="T:Newtonsoft.Json.JsonReader"/>.</returns>
        </member>
        <member name="T:Newtonsoft.Json.Linq.JPropertyDescriptor">
            <summary>
            Represents a view of a <see cref="T:Newtonsoft.Json.Linq.JProperty"/>.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JPropertyDescriptor.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JPropertyDescriptor"/> class.
            </summary>
            <param name="name">The name.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JPropertyDescriptor.CanResetValue(System.Object)">
            <summary>
            When overridden in a derived class, returns whether resetting an object changes its value.
            </summary>
            <returns>
            true if resetting the component changes its value; otherwise, false.
            </returns>
            <param name="component">The component to test for reset capability. 
                            </param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JPropertyDescriptor.GetValue(System.Object)">
            <summary>
            When overridden in a derived class, gets the current value of the property on a component.
            </summary>
            <returns>
            The value of a property for a given component.
            </returns>
            <param name="component">The component with the property for which to retrieve the value. 
                            </param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JPropertyDescriptor.ResetValue(System.Object)">
            <summary>
            When overridden in a derived class, resets the value for this property of the component to the default value.
            </summary>
            <param name="component">The component with the property value that is to be reset to the default value. 
                            </param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JPropertyDescriptor.SetValue(System.Object,System.Object)">
            <summary>
            When overridden in a derived class, sets the value of the component to a different value.
            </summary>
            <param name="component">The component with the property value that is to be set. 
                            </param><param name="value">The new value. 
                            </param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JPropertyDescriptor.ShouldSerializeValue(System.Object)">
            <summary>
            When overridden in a derived class, determines a value indicating whether the value of this property needs to be persisted.
            </summary>
            <returns>
            true if the property should be persisted; otherwise, false.
            </returns>
            <param name="component">The component with the property to be examined for persistence. 
                            </param>
        </member>
        <member name="P:Newtonsoft.Json.Linq.JPropertyDescriptor.ComponentType">
            <summary>
            When overridden in a derived class, gets the type of the component this property is bound to.
            </summary>
            <returns>
            A <see cref="T:System.Type"/> that represents the type of component this property is bound to. When the <see cref="M:System.ComponentModel.PropertyDescriptor.GetValue(System.Object)"/> or <see cref="M:System.ComponentModel.PropertyDescriptor.SetValue(System.Object,System.Object)"/> methods are invoked, the object specified might be an instance of this type.
            </returns>
        </member>
        <member name="P:Newtonsoft.Json.Linq.JPropertyDescriptor.IsReadOnly">
            <summary>
            When overridden in a derived class, gets a value indicating whether this property is read-only.
            </summary>
            <returns>
            true if the property is read-only; otherwise, false.
            </returns>
        </member>
        <member name="P:Newtonsoft.Json.Linq.JPropertyDescriptor.PropertyType">
            <summary>
            When overridden in a derived class, gets the type of the property.
            </summary>
            <returns>
            A <see cref="T:System.Type"/> that represents the type of the property.
            </returns>
        </member>
        <member name="P:Newtonsoft.Json.Linq.JPropertyDescriptor.NameHashCode">
            <summary>
            Gets the hash code for the name of the member.
            </summary>
            <value></value>
            <returns>
            The hash code for the name of the member.
            </returns>
        </member>
        <member name="T:Newtonsoft.Json.Linq.JRaw">
            <summary>
            Represents a raw JSON string.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JRaw.#ctor(Newtonsoft.Json.Linq.JRaw)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JRaw"/> class from another <see cref="T:Newtonsoft.Json.Linq.JRaw"/> object.
            </summary>
            <param name="other">A <see cref="T:Newtonsoft.Json.Linq.JRaw"/> object to copy from.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JRaw.#ctor(System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JRaw"/> class.
            </summary>
            <param name="rawJson">The raw json.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JRaw.Create(Newtonsoft.Json.JsonReader)">
            <summary>
            Creates an instance of <see cref="T:Newtonsoft.Json.Linq.JRaw"/> with the content of the reader's current token.
            </summary>
            <param name="reader">The reader.</param>
            <returns>An instance of <see cref="T:Newtonsoft.Json.Linq.JRaw"/> with the content of the reader's current token.</returns>
        </member>
        <member name="T:Newtonsoft.Json.Linq.JToken">
            <summary>
            Represents an abstract JSON token.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.Linq.JToken.EqualityComparer">
            <summary>
            Gets a comparer that can compare two tokens for value equality.
            </summary>
            <value>A <see cref="T:Newtonsoft.Json.Linq.JTokenEqualityComparer"/> that can compare two nodes for value equality.</value>
        </member>
        <member name="P:Newtonsoft.Json.Linq.JToken.Parent">
            <summary>
            Gets or sets the parent.
            </summary>
            <value>The parent.</value>
        </member>
        <member name="P:Newtonsoft.Json.Linq.JToken.Root">
            <summary>
            Gets the root <see cref="T:Newtonsoft.Json.Linq.JToken"/> of this <see cref="T:Newtonsoft.Json.Linq.JToken"/>.
            </summary>
            <value>The root <see cref="T:Newtonsoft.Json.Linq.JToken"/> of this <see cref="T:Newtonsoft.Json.Linq.JToken"/>.</value>
        </member>
        <member name="P:Newtonsoft.Json.Linq.JToken.Type">
            <summary>
            Gets the node type for this <see cref="T:Newtonsoft.Json.Linq.JToken"/>.
            </summary>
            <value>The type.</value>
        </member>
        <member name="P:Newtonsoft.Json.Linq.JToken.HasValues">
            <summary>
            Gets a value indicating whether this token has child tokens.
            </summary>
            <value>
            	<c>true</c> if this token has child values; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.DeepEquals(Newtonsoft.Json.Linq.JToken,Newtonsoft.Json.Linq.JToken)">
            <summary>
            Compares the values of two tokens, including the values of all descendant tokens.
            </summary>
            <param name="t1">The first <see cref="T:Newtonsoft.Json.Linq.JToken"/> to compare.</param>
            <param name="t2">The second <see cref="T:Newtonsoft.Json.Linq.JToken"/> to compare.</param>
            <returns>true if the tokens are equal; otherwise false.</returns>
        </member>
        <member name="P:Newtonsoft.Json.Linq.JToken.Next">
            <summary>
            Gets the next sibling token of this node.
            </summary>
            <value>The <see cref="T:Newtonsoft.Json.Linq.JToken"/> that contains the next sibling token.</value>
        </member>
        <member name="P:Newtonsoft.Json.Linq.JToken.Previous">
            <summary>
            Gets the previous sibling token of this node.
            </summary>
            <value>The <see cref="T:Newtonsoft.Json.Linq.JToken"/> that contains the previous sibling token.</value>
        </member>
        <member name="P:Newtonsoft.Json.Linq.JToken.Path">
            <summary>
            Gets the path of the JSON token. 
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.AddAfterSelf(System.Object)">
            <summary>
            Adds the specified content immediately after this token.
            </summary>
            <param name="content">A content object that contains simple content or a collection of content objects to be added after this token.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.AddBeforeSelf(System.Object)">
            <summary>
            Adds the specified content immediately before this token.
            </summary>
            <param name="content">A content object that contains simple content or a collection of content objects to be added before this token.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.Ancestors">
            <summary>
            Returns a collection of the ancestor tokens of this token.
            </summary>
            <returns>A collection of the ancestor tokens of this token.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.AfterSelf">
            <summary>
            Returns a collection of the sibling tokens after this token, in document order.
            </summary>
            <returns>A collection of the sibling tokens after this tokens, in document order.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.BeforeSelf">
            <summary>
            Returns a collection of the sibling tokens before this token, in document order.
            </summary>
            <returns>A collection of the sibling tokens before this token, in document order.</returns>
        </member>
        <member name="P:Newtonsoft.Json.Linq.JToken.Item(System.Object)">
            <summary>
            Gets the <see cref="T:Newtonsoft.Json.Linq.JToken"/> with the specified key.
            </summary>
            <value>The <see cref="T:Newtonsoft.Json.Linq.JToken"/> with the specified key.</value>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.Value``1(System.Object)">
            <summary>
            Gets the <see cref="T:Newtonsoft.Json.Linq.JToken"/> with the specified key converted to the specified type.
            </summary>
            <typeparam name="T">The type to convert the token to.</typeparam>
            <param name="key">The token key.</param>
            <returns>The converted token value.</returns>
        </member>
        <member name="P:Newtonsoft.Json.Linq.JToken.First">
            <summary>
            Get the first child token of this token.
            </summary>
            <value>A <see cref="T:Newtonsoft.Json.Linq.JToken"/> containing the first child token of the <see cref="T:Newtonsoft.Json.Linq.JToken"/>.</value>
        </member>
        <member name="P:Newtonsoft.Json.Linq.JToken.Last">
            <summary>
            Get the last child token of this token.
            </summary>
            <value>A <see cref="T:Newtonsoft.Json.Linq.JToken"/> containing the last child token of the <see cref="T:Newtonsoft.Json.Linq.JToken"/>.</value>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.Children">
            <summary>
            Returns a collection of the child tokens of this token, in document order.
            </summary>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="T:Newtonsoft.Json.Linq.JToken"/> containing the child tokens of this <see cref="T:Newtonsoft.Json.Linq.JToken"/>, in document order.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.Children``1">
            <summary>
            Returns a collection of the child tokens of this token, in document order, filtered by the specified type.
            </summary>
            <typeparam name="T">The type to filter the child tokens on.</typeparam>
            <returns>A <see cref="T:Newtonsoft.Json.Linq.JEnumerable`1"/> containing the child tokens of this <see cref="T:Newtonsoft.Json.Linq.JToken"/>, in document order.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.Values``1">
            <summary>
            Returns a collection of the child values of this token, in document order.
            </summary>
            <typeparam name="T">The type to convert the values to.</typeparam>
            <returns>A <see cref="T:System.Collections.Generic.IEnumerable`1"/> containing the child values of this <see cref="T:Newtonsoft.Json.Linq.JToken"/>, in document order.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.Remove">
            <summary>
            Removes this token from its parent.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.Replace(Newtonsoft.Json.Linq.JToken)">
            <summary>
            Replaces this token with the specified token.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.WriteTo(Newtonsoft.Json.JsonWriter,Newtonsoft.Json.JsonConverter[])">
            <summary>
            Writes this token to a <see cref="T:Newtonsoft.Json.JsonWriter"/>.
            </summary>
            <param name="writer">A <see cref="T:Newtonsoft.Json.JsonWriter"/> into which this method will write.</param>
            <param name="converters">A collection of <see cref="T:Newtonsoft.Json.JsonConverter"/> which will be used when writing the token.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.ToString">
            <summary>
            Returns the indented JSON for this token.
            </summary>
            <returns>
            The indented JSON for this token.
            </returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.ToString(Newtonsoft.Json.Formatting,Newtonsoft.Json.JsonConverter[])">
            <summary>
            Returns the JSON for this token using the given formatting and converters.
            </summary>
            <param name="formatting">Indicates how the output is formatted.</param>
            <param name="converters">A collection of <see cref="T:Newtonsoft.Json.JsonConverter"/> which will be used when writing the token.</param>
            <returns>The JSON for this token using the given formatting and converters.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Boolean">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken"/> to <see cref="T:System.Boolean"/>.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.DateTimeOffset">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken"/> to <see cref="T:System.DateTimeOffset"/>.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Nullable{System.Boolean}">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken"/> to <see cref="T:System.Nullable`1"/>.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Int64">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken"/> to <see cref="T:System.Int64"/>.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Nullable{System.DateTime}">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken"/> to <see cref="T:System.Nullable`1"/>.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Nullable{System.DateTimeOffset}">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken"/> to <see cref="T:System.Nullable`1"/>.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Nullable{System.Decimal}">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken"/> to <see cref="T:System.Nullable`1"/>.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Nullable{System.Double}">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken"/> to <see cref="T:System.Nullable`1"/>.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Nullable{System.Char}">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken"/> to <see cref="T:System.Nullable`1"/>.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Int32">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken"/> to <see cref="T:System.Int32"/>.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Int16">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken"/> to <see cref="T:System.Int16"/>.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.UInt16">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken"/> to <see cref="T:System.UInt16"/>.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Char">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken"/> to <see cref="T:System.Char"/>.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Byte">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken"/> to <see cref="T:System.Byte"/>.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.SByte">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken"/> to <see cref="T:System.SByte"/>.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Nullable{System.Int32}">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken"/> to <see cref="T:System.Nullable`1"/>.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Nullable{System.Int16}">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken"/> to <see cref="T:System.Nullable`1"/>.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Nullable{System.UInt16}">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken"/> to <see cref="T:System.Nullable`1"/>.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Nullable{System.Byte}">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken"/> to <see cref="T:System.Nullable`1"/>.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Nullable{System.SByte}">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken"/> to <see cref="T:System.Nullable`1"/>.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.DateTime">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken"/> to <see cref="T:System.DateTime"/>.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Nullable{System.Int64}">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken"/> to <see cref="T:System.Nullable`1"/>.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Nullable{System.Single}">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken"/> to <see cref="T:System.Nullable`1"/>.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Decimal">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken"/> to <see cref="T:System.Decimal"/>.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Nullable{System.UInt32}">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken"/> to <see cref="T:System.Nullable`1"/>.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Nullable{System.UInt64}">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken"/> to <see cref="T:System.Nullable`1"/>.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Double">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken"/> to <see cref="T:System.Double"/>.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Single">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken"/> to <see cref="T:System.Single"/>.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.String">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken"/> to <see cref="T:System.String"/>.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.UInt32">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken"/> to <see cref="T:System.UInt32"/>.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.UInt64">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken"/> to <see cref="T:System.UInt64"/>.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Byte[]">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken"/> to <see cref="T:System.Byte[]"/>.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Guid">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken"/> to <see cref="T:System.Guid"/>.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Nullable{System.Guid}">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken"/> to <see cref="T:System.Guid"/>.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.TimeSpan">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken"/> to <see cref="T:System.TimeSpan"/>.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Nullable{System.TimeSpan}">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken"/> to <see cref="T:System.TimeSpan"/>.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Uri">
            <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken"/> to <see cref="T:System.Uri"/>.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Boolean)~Newtonsoft.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.Boolean"/> to <see cref="T:Newtonsoft.Json.Linq.JToken"/>.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue"/> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue"/> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.DateTimeOffset)~Newtonsoft.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.DateTimeOffset"/> to <see cref="T:Newtonsoft.Json.Linq.JToken"/>.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue"/> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue"/> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Byte)~Newtonsoft.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.Byte"/> to <see cref="T:Newtonsoft.Json.Linq.JToken"/>.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue"/> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue"/> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Nullable{System.Byte})~Newtonsoft.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1"/> to <see cref="T:Newtonsoft.Json.Linq.JToken"/>.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue"/> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue"/> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.SByte)~Newtonsoft.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.SByte"/> to <see cref="T:Newtonsoft.Json.Linq.JToken"/>.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue"/> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue"/> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Nullable{System.SByte})~Newtonsoft.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1"/> to <see cref="T:Newtonsoft.Json.Linq.JToken"/>.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue"/> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue"/> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Nullable{System.Boolean})~Newtonsoft.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1"/> to <see cref="T:Newtonsoft.Json.Linq.JToken"/>.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue"/> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue"/> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Int64)~Newtonsoft.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1"/> to <see cref="T:Newtonsoft.Json.Linq.JToken"/>.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue"/> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue"/> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Nullable{System.DateTime})~Newtonsoft.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1"/> to <see cref="T:Newtonsoft.Json.Linq.JToken"/>.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue"/> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue"/> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Nullable{System.DateTimeOffset})~Newtonsoft.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1"/> to <see cref="T:Newtonsoft.Json.Linq.JToken"/>.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue"/> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue"/> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Nullable{System.Decimal})~Newtonsoft.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1"/> to <see cref="T:Newtonsoft.Json.Linq.JToken"/>.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue"/> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue"/> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Nullable{System.Double})~Newtonsoft.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1"/> to <see cref="T:Newtonsoft.Json.Linq.JToken"/>.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue"/> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue"/> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Int16)~Newtonsoft.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.Int16"/> to <see cref="T:Newtonsoft.Json.Linq.JToken"/>.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue"/> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue"/> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.UInt16)~Newtonsoft.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.UInt16"/> to <see cref="T:Newtonsoft.Json.Linq.JToken"/>.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue"/> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue"/> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Int32)~Newtonsoft.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.Int32"/> to <see cref="T:Newtonsoft.Json.Linq.JToken"/>.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue"/> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue"/> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Nullable{System.Int32})~Newtonsoft.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1"/> to <see cref="T:Newtonsoft.Json.Linq.JToken"/>.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue"/> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue"/> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.DateTime)~Newtonsoft.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.DateTime"/> to <see cref="T:Newtonsoft.Json.Linq.JToken"/>.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue"/> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue"/> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Nullable{System.Int64})~Newtonsoft.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1"/> to <see cref="T:Newtonsoft.Json.Linq.JToken"/>.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue"/> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue"/> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Nullable{System.Single})~Newtonsoft.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1"/> to <see cref="T:Newtonsoft.Json.Linq.JToken"/>.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue"/> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue"/> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Decimal)~Newtonsoft.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.Decimal"/> to <see cref="T:Newtonsoft.Json.Linq.JToken"/>.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue"/> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue"/> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Nullable{System.Int16})~Newtonsoft.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1"/> to <see cref="T:Newtonsoft.Json.Linq.JToken"/>.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue"/> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue"/> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Nullable{System.UInt16})~Newtonsoft.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1"/> to <see cref="T:Newtonsoft.Json.Linq.JToken"/>.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue"/> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue"/> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Nullable{System.UInt32})~Newtonsoft.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1"/> to <see cref="T:Newtonsoft.Json.Linq.JToken"/>.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue"/> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue"/> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Nullable{System.UInt64})~Newtonsoft.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1"/> to <see cref="T:Newtonsoft.Json.Linq.JToken"/>.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue"/> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue"/> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Double)~Newtonsoft.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.Double"/> to <see cref="T:Newtonsoft.Json.Linq.JToken"/>.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue"/> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue"/> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Single)~Newtonsoft.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.Single"/> to <see cref="T:Newtonsoft.Json.Linq.JToken"/>.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue"/> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue"/> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.String)~Newtonsoft.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.String"/> to <see cref="T:Newtonsoft.Json.Linq.JToken"/>.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue"/> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue"/> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.UInt32)~Newtonsoft.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.UInt32"/> to <see cref="T:Newtonsoft.Json.Linq.JToken"/>.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue"/> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue"/> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.UInt64)~Newtonsoft.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.UInt64"/> to <see cref="T:Newtonsoft.Json.Linq.JToken"/>.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue"/> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue"/> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Byte[])~Newtonsoft.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.Byte[]"/> to <see cref="T:Newtonsoft.Json.Linq.JToken"/>.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue"/> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue"/> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Uri)~Newtonsoft.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.Uri"/> to <see cref="T:Newtonsoft.Json.Linq.JToken"/>.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue"/> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue"/> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.TimeSpan)~Newtonsoft.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.TimeSpan"/> to <see cref="T:Newtonsoft.Json.Linq.JToken"/>.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue"/> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue"/> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Nullable{System.TimeSpan})~Newtonsoft.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1"/> to <see cref="T:Newtonsoft.Json.Linq.JToken"/>.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue"/> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue"/> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Guid)~Newtonsoft.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.Guid"/> to <see cref="T:Newtonsoft.Json.Linq.JToken"/>.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue"/> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue"/> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Nullable{System.Guid})~Newtonsoft.Json.Linq.JToken">
            <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1"/> to <see cref="T:Newtonsoft.Json.Linq.JToken"/>.
            </summary>
            <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue"/> from.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue"/> initialized with the specified value.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.CreateReader">
            <summary>
            Creates an <see cref="T:Newtonsoft.Json.JsonReader"/> for this token.
            </summary>
            <returns>An <see cref="T:Newtonsoft.Json.JsonReader"/> that can be used to read this token and its descendants.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.FromObject(System.Object)">
            <summary>
            Creates a <see cref="T:Newtonsoft.Json.Linq.JToken"/> from an object.
            </summary>
            <param name="o">The object that will be used to create <see cref="T:Newtonsoft.Json.Linq.JToken"/>.</param>
            <returns>A <see cref="T:Newtonsoft.Json.Linq.JToken"/> with the value of the specified object</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.FromObject(System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Creates a <see cref="T:Newtonsoft.Json.Linq.JToken"/> from an object using the specified <see cref="T:Newtonsoft.Json.JsonSerializer"/>.
            </summary>
            <param name="o">The object that will be used to create <see cref="T:Newtonsoft.Json.Linq.JToken"/>.</param>
            <param name="jsonSerializer">The <see cref="T:Newtonsoft.Json.JsonSerializer"/> that will be used when reading the object.</param>
            <returns>A <see cref="T:Newtonsoft.Json.Linq.JToken"/> with the value of the specified object</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.ToObject``1">
            <summary>
            Creates the specified .NET type from the <see cref="T:Newtonsoft.Json.Linq.JToken"/>.
            </summary>
            <typeparam name="T">The object type that the token will be deserialized to.</typeparam>
            <returns>The new object created from the JSON value.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.ToObject(System.Type)">
            <summary>
            Creates the specified .NET type from the <see cref="T:Newtonsoft.Json.Linq.JToken"/>.
            </summary>
            <param name="objectType">The object type that the token will be deserialized to.</param>
            <returns>The new object created from the JSON value.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.ToObject``1(Newtonsoft.Json.JsonSerializer)">
            <summary>
            Creates the specified .NET type from the <see cref="T:Newtonsoft.Json.Linq.JToken"/> using the specified <see cref="T:Newtonsoft.Json.JsonSerializer"/>.
            </summary>
            <typeparam name="T">The object type that the token will be deserialized to.</typeparam>
            <param name="jsonSerializer">The <see cref="T:Newtonsoft.Json.JsonSerializer"/> that will be used when creating the object.</param>
            <returns>The new object created from the JSON value.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.ToObject(System.Type,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Creates the specified .NET type from the <see cref="T:Newtonsoft.Json.Linq.JToken"/> using the specified <see cref="T:Newtonsoft.Json.JsonSerializer"/>.
            </summary>
            <param name="objectType">The object type that the token will be deserialized to.</param>
            <param name="jsonSerializer">The <see cref="T:Newtonsoft.Json.JsonSerializer"/> that will be used when creating the object.</param>
            <returns>The new object created from the JSON value.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.ReadFrom(Newtonsoft.Json.JsonReader)">
            <summary>
            Creates a <see cref="T:Newtonsoft.Json.Linq.JToken"/> from a <see cref="T:Newtonsoft.Json.JsonReader"/>.
            </summary>
            <param name="reader">An <see cref="T:Newtonsoft.Json.JsonReader"/> positioned at the token to read into this <see cref="T:Newtonsoft.Json.Linq.JToken"/>.</param>
            <returns>
            An <see cref="T:Newtonsoft.Json.Linq.JToken"/> that contains the token and its descendant tokens
            that were read from the reader. The runtime type of the token is determined
            by the token type of the first token encountered in the reader.
            </returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.Parse(System.String)">
            <summary>
            Load a <see cref="T:Newtonsoft.Json.Linq.JToken"/> from a string that contains JSON.
            </summary>
            <param name="json">A <see cref="T:System.String"/> that contains JSON.</param>
            <returns>A <see cref="T:Newtonsoft.Json.Linq.JToken"/> populated from the string that contains JSON.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.Load(Newtonsoft.Json.JsonReader)">
            <summary>
            Creates a <see cref="T:Newtonsoft.Json.Linq.JToken"/> from a <see cref="T:Newtonsoft.Json.JsonReader"/>.
            </summary>
            <param name="reader">An <see cref="T:Newtonsoft.Json.JsonReader"/> positioned at the token to read into this <see cref="T:Newtonsoft.Json.Linq.JToken"/>.</param>
            <returns>
            An <see cref="T:Newtonsoft.Json.Linq.JToken"/> that contains the token and its descendant tokens
            that were read from the reader. The runtime type of the token is determined
            by the token type of the first token encountered in the reader.
            </returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.SelectToken(System.String)">
            <summary>
            Selects a <see cref="T:Newtonsoft.Json.Linq.JToken"/> using a JPath expression. Selects the token that matches the object path.
            </summary>
            <param name="path">
            A <see cref="T:System.String"/> that contains a JPath expression.
            </param>
            <returns>A <see cref="T:Newtonsoft.Json.Linq.JToken"/>, or null.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.SelectToken(System.String,System.Boolean)">
            <summary>
            Selects a <see cref="T:Newtonsoft.Json.Linq.JToken"/> using a JPath expression. Selects the token that matches the object path.
            </summary>
            <param name="path">
            A <see cref="T:System.String"/> that contains a JPath expression.
            </param>
            <param name="errorWhenNoMatch">A flag to indicate whether an error should be thrown if no tokens are found when evaluating part of the expression.</param>
            <returns>A <see cref="T:Newtonsoft.Json.Linq.JToken"/>.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.SelectTokens(System.String)">
            <summary>
            Selects a collection of elements using a JPath expression.
            </summary>
            <param name="path">
            A <see cref="T:System.String"/> that contains a JPath expression.
            </param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> that contains the selected elements.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.SelectTokens(System.String,System.Boolean)">
            <summary>
            Selects a collection of elements using a JPath expression.
            </summary>
            <param name="path">
            A <see cref="T:System.String"/> that contains a JPath expression.
            </param>
            <param name="errorWhenNoMatch">A flag to indicate whether an error should be thrown if no tokens are found when evaluating part of the expression.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> that contains the selected elements.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JToken.DeepClone">
            <summary>
            Creates a new instance of the <see cref="T:Newtonsoft.Json.Linq.JToken"/>. All child tokens are recursively cloned.
            </summary>
            <returns>A new instance of the <see cref="T:Newtonsoft.Json.Linq.JToken"/>.</returns>
        </member>
        <member name="T:Newtonsoft.Json.Linq.JTokenEqualityComparer">
            <summary>
            Compares tokens to determine whether they are equal.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JTokenEqualityComparer.Equals(Newtonsoft.Json.Linq.JToken,Newtonsoft.Json.Linq.JToken)">
            <summary>
            Determines whether the specified objects are equal.
            </summary>
            <param name="x">The first object of type <see cref="T:Newtonsoft.Json.Linq.JToken"/> to compare.</param>
            <param name="y">The second object of type <see cref="T:Newtonsoft.Json.Linq.JToken"/> to compare.</param>
            <returns>
            true if the specified objects are equal; otherwise, false.
            </returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JTokenEqualityComparer.GetHashCode(Newtonsoft.Json.Linq.JToken)">
            <summary>
            Returns a hash code for the specified object.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> for which a hash code is to be returned.</param>
            <returns>A hash code for the specified object.</returns>
            <exception cref="T:System.ArgumentNullException">The type of <paramref name="obj"/> is a reference type and <paramref name="obj"/> is null.</exception>
        </member>
        <member name="T:Newtonsoft.Json.Linq.JTokenReader">
            <summary>
            Represents a reader that provides fast, non-cached, forward-only access to serialized Json data.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JTokenReader.#ctor(Newtonsoft.Json.Linq.JToken)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JTokenReader"/> class.
            </summary>
            <param name="token">The token to read from.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JTokenReader.ReadAsBytes">
            <summary>
            Reads the next JSON token from the stream as a <see cref="T:Byte[]"/>.
            </summary>
            <returns>
            A <see cref="T:Byte[]"/> or a null reference if the next JSON token is null. This method will return <c>null</c> at the end of an array.
            </returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JTokenReader.ReadAsDecimal">
            <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1"/>.
            </summary>
            <returns>A <see cref="T:System.Nullable`1"/>. This method will return <c>null</c> at the end of an array.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JTokenReader.ReadAsInt32">
            <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1"/>.
            </summary>
            <returns>A <see cref="T:System.Nullable`1"/>. This method will return <c>null</c> at the end of an array.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JTokenReader.ReadAsString">
            <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.String"/>.
            </summary>
            <returns>A <see cref="T:System.String"/>. This method will return <c>null</c> at the end of an array.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JTokenReader.ReadAsDateTime">
            <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1"/>.
            </summary>
            <returns>A <see cref="T:System.String"/>. This method will return <c>null</c> at the end of an array.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JTokenReader.ReadAsDateTimeOffset">
            <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1"/>.
            </summary>
            <returns>A <see cref="T:System.Nullable`1"/>. This method will return <c>null</c> at the end of an array.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JTokenReader.Read">
            <summary>
            Reads the next JSON token from the stream.
            </summary>
            <returns>
            true if the next token was read successfully; false if there are no more tokens to read.
            </returns>
        </member>
        <member name="T:Newtonsoft.Json.Linq.JTokenType">
            <summary>
            Specifies the type of token.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.Linq.JTokenType.None">
            <summary>
            No token type has been set.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.Linq.JTokenType.Object">
            <summary>
            A JSON object.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.Linq.JTokenType.Array">
            <summary>
            A JSON array.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.Linq.JTokenType.Constructor">
            <summary>
            A JSON constructor.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.Linq.JTokenType.Property">
            <summary>
            A JSON object property.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.Linq.JTokenType.Comment">
            <summary>
            A comment.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.Linq.JTokenType.Integer">
            <summary>
            An integer value.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.Linq.JTokenType.Float">
            <summary>
            A float value.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.Linq.JTokenType.String">
            <summary>
            A string value.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.Linq.JTokenType.Boolean">
            <summary>
            A boolean value.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.Linq.JTokenType.Null">
            <summary>
            A null value.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.Linq.JTokenType.Undefined">
            <summary>
            An undefined value.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.Linq.JTokenType.Date">
            <summary>
            A date value.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.Linq.JTokenType.Raw">
            <summary>
            A raw JSON value.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.Linq.JTokenType.Bytes">
            <summary>
            A collection of bytes value.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.Linq.JTokenType.Guid">
            <summary>
            A Guid value.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.Linq.JTokenType.Uri">
            <summary>
            A Uri value.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.Linq.JTokenType.TimeSpan">
            <summary>
            A TimeSpan value.
            </summary>
        </member>
        <member name="T:Newtonsoft.Json.Linq.JTokenWriter">
            <summary>
            Represents a writer that provides a fast, non-cached, forward-only way of generating Json data.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.Linq.JTokenWriter.Token">
            <summary>
            Gets the token being writen.
            </summary>
            <value>The token being writen.</value>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JTokenWriter.#ctor(Newtonsoft.Json.Linq.JContainer)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JTokenWriter"/> class writing to the given <see cref="T:Newtonsoft.Json.Linq.JContainer"/>.
            </summary>
            <param name="container">The container being written to.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JTokenWriter.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JTokenWriter"/> class.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JTokenWriter.Flush">
            <summary>
            Flushes whatever is in the buffer to the underlying streams and also flushes the underlying stream.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JTokenWriter.Close">
            <summary>
            Closes this stream and the underlying stream.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteStartObject">
            <summary>
            Writes the beginning of a Json object.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteStartArray">
            <summary>
            Writes the beginning of a Json array.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteStartConstructor(System.String)">
            <summary>
            Writes the start of a constructor with the given name.
            </summary>
            <param name="name">The name of the constructor.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteEnd(Newtonsoft.Json.JsonToken)">
            <summary>
            Writes the end.
            </summary>
            <param name="token">The token.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WritePropertyName(System.String)">
            <summary>
            Writes the property name of a name/value pair on a Json object.
            </summary>
            <param name="name">The name of the property.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.Object)">
            <summary>
            Writes a <see cref="T:System.Object"/> value.
            An error will raised if the value cannot be written as a single JSON token.
            </summary>
            <param name="value">The <see cref="T:System.Object"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteNull">
            <summary>
            Writes a null value.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteUndefined">
            <summary>
            Writes an undefined value.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteRaw(System.String)">
            <summary>
            Writes raw JSON.
            </summary>
            <param name="json">The raw JSON to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteComment(System.String)">
            <summary>
            Writes out a comment <code>/*...*/</code> containing the specified text.
            </summary>
            <param name="text">Text to place inside the comment.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.String)">
            <summary>
            Writes a <see cref="T:System.String"/> value.
            </summary>
            <param name="value">The <see cref="T:System.String"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.Int32)">
            <summary>
            Writes a <see cref="T:System.Int32"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Int32"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.UInt32)">
            <summary>
            Writes a <see cref="T:System.UInt32"/> value.
            </summary>
            <param name="value">The <see cref="T:System.UInt32"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.Int64)">
            <summary>
            Writes a <see cref="T:System.Int64"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Int64"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.UInt64)">
            <summary>
            Writes a <see cref="T:System.UInt64"/> value.
            </summary>
            <param name="value">The <see cref="T:System.UInt64"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.Single)">
            <summary>
            Writes a <see cref="T:System.Single"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Single"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.Double)">
            <summary>
            Writes a <see cref="T:System.Double"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Double"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.Boolean)">
            <summary>
            Writes a <see cref="T:System.Boolean"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Boolean"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.Int16)">
            <summary>
            Writes a <see cref="T:System.Int16"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Int16"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.UInt16)">
            <summary>
            Writes a <see cref="T:System.UInt16"/> value.
            </summary>
            <param name="value">The <see cref="T:System.UInt16"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.Char)">
            <summary>
            Writes a <see cref="T:System.Char"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Char"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.Byte)">
            <summary>
            Writes a <see cref="T:System.Byte"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Byte"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.SByte)">
            <summary>
            Writes a <see cref="T:System.SByte"/> value.
            </summary>
            <param name="value">The <see cref="T:System.SByte"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.Decimal)">
            <summary>
            Writes a <see cref="T:System.Decimal"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Decimal"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.DateTime)">
            <summary>
            Writes a <see cref="T:System.DateTime"/> value.
            </summary>
            <param name="value">The <see cref="T:System.DateTime"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.DateTimeOffset)">
            <summary>
            Writes a <see cref="T:System.DateTimeOffset"/> value.
            </summary>
            <param name="value">The <see cref="T:System.DateTimeOffset"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.Byte[])">
            <summary>
            Writes a <see cref="T:Byte[]"/> value.
            </summary>
            <param name="value">The <see cref="T:Byte[]"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.TimeSpan)">
            <summary>
            Writes a <see cref="T:System.TimeSpan"/> value.
            </summary>
            <param name="value">The <see cref="T:System.TimeSpan"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.Guid)">
            <summary>
            Writes a <see cref="T:System.Guid"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Guid"/> value to write.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.Uri)">
            <summary>
            Writes a <see cref="T:System.Uri"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Uri"/> value to write.</param>
        </member>
        <member name="T:Newtonsoft.Json.Linq.JValue">
            <summary>
            Represents a value in JSON (string, integer, date, etc).
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JValue.#ctor(Newtonsoft.Json.Linq.JValue)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue"/> class from another <see cref="T:Newtonsoft.Json.Linq.JValue"/> object.
            </summary>
            <param name="other">A <see cref="T:Newtonsoft.Json.Linq.JValue"/> object to copy from.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JValue.#ctor(System.Int64)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue"/> class with the given value.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JValue.#ctor(System.Decimal)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue"/> class with the given value.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JValue.#ctor(System.Char)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue"/> class with the given value.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JValue.#ctor(System.UInt64)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue"/> class with the given value.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JValue.#ctor(System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue"/> class with the given value.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JValue.#ctor(System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue"/> class with the given value.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JValue.#ctor(System.DateTime)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue"/> class with the given value.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JValue.#ctor(System.DateTimeOffset)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue"/> class with the given value.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JValue.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue"/> class with the given value.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JValue.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue"/> class with the given value.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JValue.#ctor(System.Guid)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue"/> class with the given value.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JValue.#ctor(System.Uri)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue"/> class with the given value.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JValue.#ctor(System.TimeSpan)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue"/> class with the given value.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JValue.#ctor(System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue"/> class with the given value.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="P:Newtonsoft.Json.Linq.JValue.HasValues">
            <summary>
            Gets a value indicating whether this token has child tokens.
            </summary>
            <value>
            	<c>true</c> if this token has child values; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JValue.CreateComment(System.String)">
            <summary>
            Creates a <see cref="T:Newtonsoft.Json.Linq.JValue"/> comment with the given value.
            </summary>
            <param name="value">The value.</param>
            <returns>A <see cref="T:Newtonsoft.Json.Linq.JValue"/> comment with the given value.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JValue.CreateString(System.String)">
            <summary>
            Creates a <see cref="T:Newtonsoft.Json.Linq.JValue"/> string with the given value.
            </summary>
            <param name="value">The value.</param>
            <returns>A <see cref="T:Newtonsoft.Json.Linq.JValue"/> string with the given value.</returns>
        </member>
        <member name="P:Newtonsoft.Json.Linq.JValue.Type">
            <summary>
            Gets the node type for this <see cref="T:Newtonsoft.Json.Linq.JToken"/>.
            </summary>
            <value>The type.</value>
        </member>
        <member name="P:Newtonsoft.Json.Linq.JValue.Value">
            <summary>
            Gets or sets the underlying token value.
            </summary>
            <value>The underlying token value.</value>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JValue.WriteTo(Newtonsoft.Json.JsonWriter,Newtonsoft.Json.JsonConverter[])">
            <summary>
            Writes this token to a <see cref="T:Newtonsoft.Json.JsonWriter"/>.
            </summary>
            <param name="writer">A <see cref="T:Newtonsoft.Json.JsonWriter"/> into which this method will write.</param>
            <param name="converters">A collection of <see cref="T:Newtonsoft.Json.JsonConverter"/> which will be used when writing the token.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JValue.Equals(Newtonsoft.Json.Linq.JValue)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JValue.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with the current <see cref="T:System.Object"/>.</param>
            <returns>
            true if the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>; otherwise, false.
            </returns>
            <exception cref="T:System.NullReferenceException">
            The <paramref name="obj"/> parameter is null.
            </exception>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JValue.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JValue.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JValue.ToString(System.String)">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <param name="format">The format.</param>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JValue.ToString(System.IFormatProvider)">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <param name="formatProvider">The format provider.</param>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JValue.ToString(System.String,System.IFormatProvider)">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <param name="format">The format.</param>
            <param name="formatProvider">The format provider.</param>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JValue.CompareTo(Newtonsoft.Json.Linq.JValue)">
            <summary>
            Compares the current instance with another object of the same type and returns an integer that indicates whether the current instance precedes, follows, or occurs in the same position in the sort order as the other object.
            </summary>
            <param name="obj">An object to compare with this instance.</param>
            <returns>
            A 32-bit signed integer that indicates the relative order of the objects being compared. The return value has these meanings:
            Value
            Meaning
            Less than zero
            This instance is less than <paramref name="obj"/>.
            Zero
            This instance is equal to <paramref name="obj"/>.
            Greater than zero
            This instance is greater than <paramref name="obj"/>.
            </returns>
            <exception cref="T:System.ArgumentException">
            	<paramref name="obj"/> is not the same type as this instance.
            </exception>
        </member>
        <member name="T:Newtonsoft.Json.MemberSerialization">
            <summary>
            Specifies the member serialization options for the <see cref="T:Newtonsoft.Json.JsonSerializer"/>.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.MemberSerialization.OptOut">
            <summary>
            All public members are serialized by default. Members can be excluded using <see cref="T:Newtonsoft.Json.JsonIgnoreAttribute"/> or <see cref="T:System.NonSerializedAttribute"/>.
            This is the default member serialization mode.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.MemberSerialization.OptIn">
            <summary>
            Only members must be marked with <see cref="T:Newtonsoft.Json.JsonPropertyAttribute"/> or <see cref="T:System.Runtime.Serialization.DataMemberAttribute"/> are serialized.
            This member serialization mode can also be set by marking the class with <see cref="T:System.Runtime.Serialization.DataContractAttribute"/>.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.MemberSerialization.Fields">
            <summary>
            All public and private fields are serialized. Members can be excluded using <see cref="T:Newtonsoft.Json.JsonIgnoreAttribute"/> or <see cref="T:System.NonSerializedAttribute"/>.
            This member serialization mode can also be set by marking the class with <see cref="T:System.SerializableAttribute"/>
            and setting IgnoreSerializableAttribute on <see cref="T:Newtonsoft.Json.Serialization.DefaultContractResolver"/> to false.
            </summary>
        </member>
        <member name="T:Newtonsoft.Json.MissingMemberHandling">
            <summary>
            Specifies missing member handling options for the <see cref="T:Newtonsoft.Json.JsonSerializer"/>.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.MissingMemberHandling.Ignore">
            <summary>
            Ignore a missing member and do not attempt to deserialize it.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.MissingMemberHandling.Error">
            <summary>
            Throw a <see cref="T:Newtonsoft.Json.JsonSerializationException"/> when a missing member is encountered during deserialization.
            </summary>
        </member>
        <member name="T:Newtonsoft.Json.NullValueHandling">
            <summary>
            Specifies null value handling options for the <see cref="T:Newtonsoft.Json.JsonSerializer"/>.
            </summary>
            <example>
              <code lang="cs" source="..\Src\Newtonsoft.Json.Tests\Documentation\SerializationTests.cs" region="ReducingSerializedJsonSizeNullValueHandlingObject" title="NullValueHandling Class" />
              <code lang="cs" source="..\Src\Newtonsoft.Json.Tests\Documentation\SerializationTests.cs" region="ReducingSerializedJsonSizeNullValueHandlingExample" title="NullValueHandling Ignore Example" />
            </example>
        </member>
        <member name="F:Newtonsoft.Json.NullValueHandling.Include">
            <summary>
            Include null values when serializing and deserializing objects.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.NullValueHandling.Ignore">
            <summary>
            Ignore null values when serializing and deserializing objects.
            </summary>
        </member>
        <member name="T:Newtonsoft.Json.ObjectCreationHandling">
            <summary>
            Specifies how object creation is handled by the <see cref="T:Newtonsoft.Json.JsonSerializer"/>.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.ObjectCreationHandling.Auto">
            <summary>
            Reuse existing objects, create new objects when needed.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.ObjectCreationHandling.Reuse">
            <summary>
            Only reuse existing objects.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.ObjectCreationHandling.Replace">
            <summary>
            Always create new objects.
            </summary>
        </member>
        <member name="T:Newtonsoft.Json.PreserveReferencesHandling">
            <summary>
            Specifies reference handling options for the <see cref="T:Newtonsoft.Json.JsonSerializer"/>.
            Note that references cannot be preserved when a value is set via a non-default constructor such as types that implement ISerializable.
            </summary>
            <example>
              <code lang="cs" source="..\Src\Newtonsoft.Json.Tests\Documentation\SerializationTests.cs" region="PreservingObjectReferencesOn" title="Preserve Object References" />       
            </example>
        </member>
        <member name="F:Newtonsoft.Json.PreserveReferencesHandling.None">
            <summary>
            Do not preserve references when serializing types.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.PreserveReferencesHandling.Objects">
            <summary>
            Preserve references when serializing into a JSON object structure.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.PreserveReferencesHandling.Arrays">
            <summary>
            Preserve references when serializing into a JSON array structure.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.PreserveReferencesHandling.All">
            <summary>
            Preserve references when serializing.
            </summary>
        </member>
        <member name="T:Newtonsoft.Json.ReferenceLoopHandling">
            <summary>
            Specifies reference loop handling options for the <see cref="T:Newtonsoft.Json.JsonSerializer"/>.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.ReferenceLoopHandling.Error">
            <summary>
            Throw a <see cref="T:Newtonsoft.Json.JsonSerializationException"/> when a loop is encountered.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.ReferenceLoopHandling.Ignore">
            <summary>
            Ignore loop references and do not serialize.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.ReferenceLoopHandling.Serialize">
            <summary>
            Serialize loop references.
            </summary>
        </member>
        <member name="T:Newtonsoft.Json.Required">
            <summary>
            Indicating whether a property is required.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.Required.Default">
            <summary>
            The property is not required. The default state.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.Required.AllowNull">
            <summary>
            The property must be defined in JSON but can be a null value.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.Required.Always">
            <summary>
            The property must be defined in JSON and cannot be a null value.
            </summary>
        </member>
        <member name="T:Newtonsoft.Json.Schema.Extensions">
            <summary>
            Contains the JSON schema extension methods.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.Schema.Extensions.IsValid(Newtonsoft.Json.Linq.JToken,Newtonsoft.Json.Schema.JsonSchema)">
            <summary>
            Determines whether the <see cref="T:Newtonsoft.Json.Linq.JToken"/> is valid.
            </summary>
            <param name="source">The source <see cref="T:Newtonsoft.Json.Linq.JToken"/> to test.</param>
            <param name="schema">The schema to test with.</param>
            <returns>
            	<c>true</c> if the specified <see cref="T:Newtonsoft.Json.Linq.JToken"/> is valid; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Newtonsoft.Json.Schema.Extensions.IsValid(Newtonsoft.Json.Linq.JToken,Newtonsoft.Json.Schema.JsonSchema,System.Collections.Generic.IList{System.String}@)">
            <summary>
            Determines whether the <see cref="T:Newtonsoft.Json.Linq.JToken"/> is valid.
            </summary>
            <param name="source">The source <see cref="T:Newtonsoft.Json.Linq.JToken"/> to test.</param>
            <param name="schema">The schema to test with.</param>
            <param name="errorMessages">When this method returns, contains any error messages generated while validating. </param>
            <returns>
            	<c>true</c> if the specified <see cref="T:Newtonsoft.Json.Linq.JToken"/> is valid; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Newtonsoft.Json.Schema.Extensions.Validate(Newtonsoft.Json.Linq.JToken,Newtonsoft.Json.Schema.JsonSchema)">
            <summary>
            Validates the specified <see cref="T:Newtonsoft.Json.Linq.JToken"/>.
            </summary>
            <param name="source">The source <see cref="T:Newtonsoft.Json.Linq.JToken"/> to test.</param>
            <param name="schema">The schema to test with.</param>
        </member>
        <member name="M:Newtonsoft.Json.Schema.Extensions.Validate(Newtonsoft.Json.Linq.JToken,Newtonsoft.Json.Schema.JsonSchema,Newtonsoft.Json.Schema.ValidationEventHandler)">
            <summary>
            Validates the specified <see cref="T:Newtonsoft.Json.Linq.JToken"/>.
            </summary>
            <param name="source">The source <see cref="T:Newtonsoft.Json.Linq.JToken"/> to test.</param>
            <param name="schema">The schema to test with.</param>
            <param name="validationEventHandler">The validation event handler.</param>
        </member>
        <member name="T:Newtonsoft.Json.Schema.JsonSchema">
            <summary>
            An in-memory representation of a JSON Schema.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.Schema.JsonSchema.Id">
            <summary>
            Gets or sets the id.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.Schema.JsonSchema.Title">
            <summary>
            Gets or sets the title.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.Schema.JsonSchema.Required">
            <summary>
            Gets or sets whether the object is required.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.Schema.JsonSchema.ReadOnly">
            <summary>
            Gets or sets whether the object is read only.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.Schema.JsonSchema.Hidden">
            <summary>
            Gets or sets whether the object is visible to users.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.Schema.JsonSchema.Transient">
            <summary>
            Gets or sets whether the object is transient.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.Schema.JsonSchema.Description">
            <summary>
            Gets or sets the description of the object.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.Schema.JsonSchema.Type">
            <summary>
            Gets or sets the types of values allowed by the object.
            </summary>
            <value>The type.</value>
        </member>
        <member name="P:Newtonsoft.Json.Schema.JsonSchema.Pattern">
            <summary>
            Gets or sets the pattern.
            </summary>
            <value>The pattern.</value>
        </member>
        <member name="P:Newtonsoft.Json.Schema.JsonSchema.MinimumLength">
            <summary>
            Gets or sets the minimum length.
            </summary>
            <value>The minimum length.</value>
        </member>
        <member name="P:Newtonsoft.Json.Schema.JsonSchema.MaximumLength">
            <summary>
            Gets or sets the maximum length.
            </summary>
            <value>The maximum length.</value>
        </member>
        <member name="P:Newtonsoft.Json.Schema.JsonSchema.DivisibleBy">
            <summary>
            Gets or sets a number that the value should be divisble by.
            </summary>
            <value>A number that the value should be divisble by.</value>
        </member>
        <member name="P:Newtonsoft.Json.Schema.JsonSchema.Minimum">
            <summary>
            Gets or sets the minimum.
            </summary>
            <value>The minimum.</value>
        </member>
        <member name="P:Newtonsoft.Json.Schema.JsonSchema.Maximum">
            <summary>
            Gets or sets the maximum.
            </summary>
            <value>The maximum.</value>
        </member>
        <member name="P:Newtonsoft.Json.Schema.JsonSchema.ExclusiveMinimum">
            <summary>
            Gets or sets a flag indicating whether the value can not equal the number defined by the "minimum" attribute.
            </summary>
            <value>A flag indicating whether the value can not equal the number defined by the "minimum" attribute.</value>
        </member>
        <member name="P:Newtonsoft.Json.Schema.JsonSchema.ExclusiveMaximum">
            <summary>
            Gets or sets a flag indicating whether the value can not equal the number defined by the "maximum" attribute.
            </summary>
            <value>A flag indicating whether the value can not equal the number defined by the "maximum" attribute.</value>
        </member>
        <member name="P:Newtonsoft.Json.Schema.JsonSchema.MinimumItems">
            <summary>
            Gets or sets the minimum number of items.
            </summary>
            <value>The minimum number of items.</value>
        </member>
        <member name="P:Newtonsoft.Json.Schema.JsonSchema.MaximumItems">
            <summary>
            Gets or sets the maximum number of items.
            </summary>
            <value>The maximum number of items.</value>
        </member>
        <member name="P:Newtonsoft.Json.Schema.JsonSchema.Items">
            <summary>
            Gets or sets the <see cref="T:Newtonsoft.Json.Schema.JsonSchema"/> of items.
            </summary>
            <value>The <see cref="T:Newtonsoft.Json.Schema.JsonSchema"/> of items.</value>
        </member>
        <member name="P:Newtonsoft.Json.Schema.JsonSchema.PositionalItemsValidation">
            <summary>
            Gets or sets a value indicating whether items in an array are validated using the <see cref="T:Newtonsoft.Json.Schema.JsonSchema"/> instance at their array position from <see cref="P:Newtonsoft.Json.Schema.JsonSchema.Items"/>.
            </summary>
            <value>
            	<c>true</c> if items are validated using their array position; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Newtonsoft.Json.Schema.JsonSchema.AdditionalItems">
            <summary>
            Gets or sets the <see cref="T:Newtonsoft.Json.Schema.JsonSchema"/> of additional items.
            </summary>
            <value>The <see cref="T:Newtonsoft.Json.Schema.JsonSchema"/> of additional items.</value>
        </member>
        <member name="P:Newtonsoft.Json.Schema.JsonSchema.AllowAdditionalItems">
            <summary>
            Gets or sets a value indicating whether additional items are allowed.
            </summary>
            <value>
            	<c>true</c> if additional items are allowed; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Newtonsoft.Json.Schema.JsonSchema.UniqueItems">
            <summary>
            Gets or sets whether the array items must be unique.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.Schema.JsonSchema.Properties">
            <summary>
            Gets or sets the <see cref="T:Newtonsoft.Json.Schema.JsonSchema"/> of properties.
            </summary>
            <value>The <see cref="T:Newtonsoft.Json.Schema.JsonSchema"/> of properties.</value>
        </member>
        <member name="P:Newtonsoft.Json.Schema.JsonSchema.AdditionalProperties">
            <summary>
            Gets or sets the <see cref="T:Newtonsoft.Json.Schema.JsonSchema"/> of additional properties.
            </summary>
            <value>The <see cref="T:Newtonsoft.Json.Schema.JsonSchema"/> of additional properties.</value>
        </member>
        <member name="P:Newtonsoft.Json.Schema.JsonSchema.PatternProperties">
            <summary>
            Gets or sets the pattern properties.
            </summary>
            <value>The pattern properties.</value>
        </member>
        <member name="P:Newtonsoft.Json.Schema.JsonSchema.AllowAdditionalProperties">
            <summary>
            Gets or sets a value indicating whether additional properties are allowed.
            </summary>
            <value>
            	<c>true</c> if additional properties are allowed; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Newtonsoft.Json.Schema.JsonSchema.Requires">
            <summary>
            Gets or sets the required property if this property is present.
            </summary>
            <value>The required property if this property is present.</value>
        </member>
        <member name="P:Newtonsoft.Json.Schema.JsonSchema.Enum">
            <summary>
            Gets or sets the a collection of valid enum values allowed.
            </summary>
            <value>A collection of valid enum values allowed.</value>
        </member>
        <member name="P:Newtonsoft.Json.Schema.JsonSchema.Disallow">
            <summary>
            Gets or sets disallowed types.
            </summary>
            <value>The disallow types.</value>
        </member>
        <member name="P:Newtonsoft.Json.Schema.JsonSchema.Default">
            <summary>
            Gets or sets the default value.
            </summary>
            <value>The default value.</value>
        </member>
        <member name="P:Newtonsoft.Json.Schema.JsonSchema.Extends">
            <summary>
            Gets or sets the collection of <see cref="T:Newtonsoft.Json.Schema.JsonSchema"/> that this schema extends.
            </summary>
            <value>The collection of <see cref="T:Newtonsoft.Json.Schema.JsonSchema"/> that this schema extends.</value>
        </member>
        <member name="P:Newtonsoft.Json.Schema.JsonSchema.Format">
            <summary>
            Gets or sets the format.
            </summary>
            <value>The format.</value>
        </member>
        <member name="M:Newtonsoft.Json.Schema.JsonSchema.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Schema.JsonSchema"/> class.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.Schema.JsonSchema.Read(Newtonsoft.Json.JsonReader)">
            <summary>
            Reads a <see cref="T:Newtonsoft.Json.Schema.JsonSchema"/> from the specified <see cref="T:Newtonsoft.Json.JsonReader"/>.
            </summary>
            <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader"/> containing the JSON Schema to read.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Schema.JsonSchema"/> object representing the JSON Schema.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Schema.JsonSchema.Read(Newtonsoft.Json.JsonReader,Newtonsoft.Json.Schema.JsonSchemaResolver)">
            <summary>
            Reads a <see cref="T:Newtonsoft.Json.Schema.JsonSchema"/> from the specified <see cref="T:Newtonsoft.Json.JsonReader"/>.
            </summary>
            <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader"/> containing the JSON Schema to read.</param>
            <param name="resolver">The <see cref="T:Newtonsoft.Json.Schema.JsonSchemaResolver"/> to use when resolving schema references.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Schema.JsonSchema"/> object representing the JSON Schema.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Schema.JsonSchema.Parse(System.String)">
            <summary>
            Load a <see cref="T:Newtonsoft.Json.Schema.JsonSchema"/> from a string that contains schema JSON.
            </summary>
            <param name="json">A <see cref="T:System.String"/> that contains JSON.</param>
            <returns>A <see cref="T:Newtonsoft.Json.Schema.JsonSchema"/> populated from the string that contains JSON.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Schema.JsonSchema.Parse(System.String,Newtonsoft.Json.Schema.JsonSchemaResolver)">
            <summary>
            Parses the specified json.
            </summary>
            <param name="json">The json.</param>
            <param name="resolver">The resolver.</param>
            <returns>A <see cref="T:Newtonsoft.Json.Schema.JsonSchema"/> populated from the string that contains JSON.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Schema.JsonSchema.WriteTo(Newtonsoft.Json.JsonWriter)">
            <summary>
            Writes this schema to a <see cref="T:Newtonsoft.Json.JsonWriter"/>.
            </summary>
            <param name="writer">A <see cref="T:Newtonsoft.Json.JsonWriter"/> into which this method will write.</param>
        </member>
        <member name="M:Newtonsoft.Json.Schema.JsonSchema.WriteTo(Newtonsoft.Json.JsonWriter,Newtonsoft.Json.Schema.JsonSchemaResolver)">
            <summary>
            Writes this schema to a <see cref="T:Newtonsoft.Json.JsonWriter"/> using the specified <see cref="T:Newtonsoft.Json.Schema.JsonSchemaResolver"/>.
            </summary>
            <param name="writer">A <see cref="T:Newtonsoft.Json.JsonWriter"/> into which this method will write.</param>
            <param name="resolver">The resolver used.</param>
        </member>
        <member name="M:Newtonsoft.Json.Schema.JsonSchema.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="T:Newtonsoft.Json.Schema.JsonSchemaException">
            <summary>
            Returns detailed information about the schema exception.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.Schema.JsonSchemaException.LineNumber">
            <summary>
            Gets the line number indicating where the error occurred.
            </summary>
            <value>The line number indicating where the error occurred.</value>
        </member>
        <member name="P:Newtonsoft.Json.Schema.JsonSchemaException.LinePosition">
            <summary>
            Gets the line position indicating where the error occurred.
            </summary>
            <value>The line position indicating where the error occurred.</value>
        </member>
        <member name="P:Newtonsoft.Json.Schema.JsonSchemaException.Path">
            <summary>
            Gets the path to the JSON where the error occurred.
            </summary>
            <value>The path to the JSON where the error occurred.</value>
        </member>
        <member name="M:Newtonsoft.Json.Schema.JsonSchemaException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Schema.JsonSchemaException"/> class.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.Schema.JsonSchemaException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Schema.JsonSchemaException"/> class
            with a specified error message.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:Newtonsoft.Json.Schema.JsonSchemaException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Schema.JsonSchemaException"/> class
            with a specified error message and a reference to the inner exception that is the cause of this exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception, or a null reference (Nothing in Visual Basic) if no inner exception is specified.</param>
        </member>
        <member name="M:Newtonsoft.Json.Schema.JsonSchemaException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Schema.JsonSchemaException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="info"/> parameter is null. </exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or <see cref="P:System.Exception.HResult"/> is zero (0). </exception>
        </member>
        <member name="T:Newtonsoft.Json.Schema.JsonSchemaGenerator">
            <summary>
            Generates a <see cref="T:Newtonsoft.Json.Schema.JsonSchema"/> from a specified <see cref="T:System.Type"/>.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.Schema.JsonSchemaGenerator.UndefinedSchemaIdHandling">
            <summary>
            Gets or sets how undefined schemas are handled by the serializer.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.Schema.JsonSchemaGenerator.ContractResolver">
            <summary>
            Gets or sets the contract resolver.
            </summary>
            <value>The contract resolver.</value>
        </member>
        <member name="M:Newtonsoft.Json.Schema.JsonSchemaGenerator.Generate(System.Type)">
            <summary>
            Generate a <see cref="T:Newtonsoft.Json.Schema.JsonSchema"/> from the specified type.
            </summary>
            <param name="type">The type to generate a <see cref="T:Newtonsoft.Json.Schema.JsonSchema"/> from.</param>
            <returns>A <see cref="T:Newtonsoft.Json.Schema.JsonSchema"/> generated from the specified type.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Schema.JsonSchemaGenerator.Generate(System.Type,Newtonsoft.Json.Schema.JsonSchemaResolver)">
            <summary>
            Generate a <see cref="T:Newtonsoft.Json.Schema.JsonSchema"/> from the specified type.
            </summary>
            <param name="type">The type to generate a <see cref="T:Newtonsoft.Json.Schema.JsonSchema"/> from.</param>
            <param name="resolver">The <see cref="T:Newtonsoft.Json.Schema.JsonSchemaResolver"/> used to resolve schema references.</param>
            <returns>A <see cref="T:Newtonsoft.Json.Schema.JsonSchema"/> generated from the specified type.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Schema.JsonSchemaGenerator.Generate(System.Type,System.Boolean)">
            <summary>
            Generate a <see cref="T:Newtonsoft.Json.Schema.JsonSchema"/> from the specified type.
            </summary>
            <param name="type">The type to generate a <see cref="T:Newtonsoft.Json.Schema.JsonSchema"/> from.</param>
            <param name="rootSchemaNullable">Specify whether the generated root <see cref="T:Newtonsoft.Json.Schema.JsonSchema"/> will be nullable.</param>
            <returns>A <see cref="T:Newtonsoft.Json.Schema.JsonSchema"/> generated from the specified type.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Schema.JsonSchemaGenerator.Generate(System.Type,Newtonsoft.Json.Schema.JsonSchemaResolver,System.Boolean)">
            <summary>
            Generate a <see cref="T:Newtonsoft.Json.Schema.JsonSchema"/> from the specified type.
            </summary>
            <param name="type">The type to generate a <see cref="T:Newtonsoft.Json.Schema.JsonSchema"/> from.</param>
            <param name="resolver">The <see cref="T:Newtonsoft.Json.Schema.JsonSchemaResolver"/> used to resolve schema references.</param>
            <param name="rootSchemaNullable">Specify whether the generated root <see cref="T:Newtonsoft.Json.Schema.JsonSchema"/> will be nullable.</param>
            <returns>A <see cref="T:Newtonsoft.Json.Schema.JsonSchema"/> generated from the specified type.</returns>
        </member>
        <member name="T:Newtonsoft.Json.Schema.JsonSchemaResolver">
            <summary>
            Resolves <see cref="T:Newtonsoft.Json.Schema.JsonSchema"/> from an id.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.Schema.JsonSchemaResolver.LoadedSchemas">
            <summary>
            Gets or sets the loaded schemas.
            </summary>
            <value>The loaded schemas.</value>
        </member>
        <member name="M:Newtonsoft.Json.Schema.JsonSchemaResolver.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Schema.JsonSchemaResolver"/> class.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.Schema.JsonSchemaResolver.GetSchema(System.String)">
            <summary>
            Gets a <see cref="T:Newtonsoft.Json.Schema.JsonSchema"/> for the specified reference.
            </summary>
            <param name="reference">The id.</param>
            <returns>A <see cref="T:Newtonsoft.Json.Schema.JsonSchema"/> for the specified reference.</returns>
        </member>
        <member name="T:Newtonsoft.Json.Schema.JsonSchemaType">
            <summary>
            The value types allowed by the <see cref="T:Newtonsoft.Json.Schema.JsonSchema"/>.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.Schema.JsonSchemaType.None">
            <summary>
            No type specified.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.Schema.JsonSchemaType.String">
            <summary>
            String type.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.Schema.JsonSchemaType.Float">
            <summary>
            Float type.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.Schema.JsonSchemaType.Integer">
            <summary>
            Integer type.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.Schema.JsonSchemaType.Boolean">
            <summary>
            Boolean type.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.Schema.JsonSchemaType.Object">
            <summary>
            Object type.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.Schema.JsonSchemaType.Array">
            <summary>
            Array type.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.Schema.JsonSchemaType.Null">
            <summary>
            Null type.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.Schema.JsonSchemaType.Any">
            <summary>
            Any type.
            </summary>
        </member>
        <member name="T:Newtonsoft.Json.Schema.UndefinedSchemaIdHandling">
            <summary>
            Specifies undefined schema Id handling options for the <see cref="T:Newtonsoft.Json.Schema.JsonSchemaGenerator"/>.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.Schema.UndefinedSchemaIdHandling.None">
            <summary>
            Do not infer a schema Id.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.Schema.UndefinedSchemaIdHandling.UseTypeName">
            <summary>
            Use the .NET type name as the schema Id.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.Schema.UndefinedSchemaIdHandling.UseAssemblyQualifiedName">
            <summary>
            Use the assembly qualified .NET type name as the schema Id.
            </summary>
        </member>
        <member name="T:Newtonsoft.Json.Schema.ValidationEventArgs">
            <summary>
            Returns detailed information related to the <see cref="T:Newtonsoft.Json.Schema.ValidationEventHandler"/>.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.Schema.ValidationEventArgs.Exception">
            <summary>
            Gets the <see cref="T:Newtonsoft.Json.Schema.JsonSchemaException"/> associated with the validation error.
            </summary>
            <value>The JsonSchemaException associated with the validation error.</value>
        </member>
        <member name="P:Newtonsoft.Json.Schema.ValidationEventArgs.Path">
            <summary>
            Gets the path of the JSON location where the validation error occurred.
            </summary>
            <value>The path of the JSON location where the validation error occurred.</value>
        </member>
        <member name="P:Newtonsoft.Json.Schema.ValidationEventArgs.Message">
            <summary>
            Gets the text description corresponding to the validation error.
            </summary>
            <value>The text description.</value>
        </member>
        <member name="T:Newtonsoft.Json.Schema.ValidationEventHandler">
            <summary>
            Represents the callback method that will handle JSON schema validation events and the <see cref="T:Newtonsoft.Json.Schema.ValidationEventArgs"/>.
            </summary>
        </member>
        <member name="T:Newtonsoft.Json.Serialization.CamelCasePropertyNamesContractResolver">
            <summary>
            Resolves member mappings for a type, camel casing property names.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.Serialization.CamelCasePropertyNamesContractResolver.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.CamelCasePropertyNamesContractResolver"/> class.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.Serialization.CamelCasePropertyNamesContractResolver.ResolvePropertyName(System.String)">
            <summary>
            Resolves the name of the property.
            </summary>
            <param name="propertyName">Name of the property.</param>
            <returns>The property name camel cased.</returns>
        </member>
        <member name="T:Newtonsoft.Json.Serialization.DefaultContractResolver">
            <summary>
            Used by <see cref="T:Newtonsoft.Json.JsonSerializer"/> to resolves a <see cref="T:Newtonsoft.Json.Serialization.JsonContract"/> for a given <see cref="T:System.Type"/>.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.DefaultContractResolver.DynamicCodeGeneration">
            <summary>
            Gets a value indicating whether members are being get and set using dynamic code generation.
            This value is determined by the runtime permissions available.
            </summary>
            <value>
            	<c>true</c> if using dynamic code generation; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.DefaultContractResolver.DefaultMembersSearchFlags">
            <summary>
            Gets or sets the default members search flags.
            </summary>
            <value>The default members search flags.</value>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.DefaultContractResolver.SerializeCompilerGeneratedMembers">
            <summary>
            Gets or sets a value indicating whether compiler generated members should be serialized.
            </summary>
            <value>
            	<c>true</c> if serialized compiler generated members; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.DefaultContractResolver.IgnoreSerializableInterface">
            <summary>
            Gets or sets a value indicating whether to ignore the <see cref="T:System.Runtime.Serialization.ISerializable"/> interface when serializing and deserializing types.
            </summary>
            <value>
            	<c>true</c> if the <see cref="T:System.Runtime.Serialization.ISerializable"/> interface will be ignored when serializing and deserializing types; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.DefaultContractResolver.IgnoreSerializableAttribute">
            <summary>
            Gets or sets a value indicating whether to ignore the <see cref="T:System.SerializableAttribute"/> attribute when serializing and deserializing types.
            </summary>
            <value>
            	<c>true</c> if the <see cref="T:System.SerializableAttribute"/> attribute will be ignored when serializing and deserializing types; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.DefaultContractResolver"/> class.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.DefaultContractResolver"/> class.
            </summary>
            <param name="shareCache">
            If set to <c>true</c> the <see cref="T:Newtonsoft.Json.Serialization.DefaultContractResolver"/> will use a cached shared with other resolvers of the same type.
            Sharing the cache will significantly performance because expensive reflection will only happen once but could cause unexpected
            behavior if different instances of the resolver are suppose to produce different results. When set to false it is highly
            recommended to reuse <see cref="T:Newtonsoft.Json.Serialization.DefaultContractResolver"/> instances with the <see cref="T:Newtonsoft.Json.JsonSerializer"/>.
            </param>
        </member>
        <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.ResolveContract(System.Type)">
            <summary>
            Resolves the contract for a given type.
            </summary>
            <param name="type">The type to resolve a contract for.</param>
            <returns>The contract for a given type.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.GetSerializableMembers(System.Type)">
            <summary>
            Gets the serializable members for the type.
            </summary>
            <param name="objectType">The type to get serializable members for.</param>
            <returns>The serializable members for the type.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.CreateObjectContract(System.Type)">
            <summary>
            Creates a <see cref="T:Newtonsoft.Json.Serialization.JsonObjectContract"/> for the given type.
            </summary>
            <param name="objectType">Type of the object.</param>
            <returns>A <see cref="T:Newtonsoft.Json.Serialization.JsonObjectContract"/> for the given type.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.CreateConstructorParameters(System.Reflection.ConstructorInfo,Newtonsoft.Json.Serialization.JsonPropertyCollection)">
            <summary>
            Creates the constructor parameters.
            </summary>
            <param name="constructor">The constructor to create properties for.</param>
            <param name="memberProperties">The type's member properties.</param>
            <returns>Properties for the given <see cref="T:System.Reflection.ConstructorInfo"/>.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.CreatePropertyFromConstructorParameter(Newtonsoft.Json.Serialization.JsonProperty,System.Reflection.ParameterInfo)">
            <summary>
            Creates a <see cref="T:Newtonsoft.Json.Serialization.JsonProperty"/> for the given <see cref="T:System.Reflection.ParameterInfo"/>.
            </summary>
            <param name="matchingMemberProperty">The matching member property.</param>
            <param name="parameterInfo">The constructor parameter.</param>
            <returns>A created <see cref="T:Newtonsoft.Json.Serialization.JsonProperty"/> for the given <see cref="T:System.Reflection.ParameterInfo"/>.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.ResolveContractConverter(System.Type)">
            <summary>
            Resolves the default <see cref="T:Newtonsoft.Json.JsonConverter" /> for the contract.
            </summary>
            <param name="objectType">Type of the object.</param>
            <returns>The contract's default <see cref="T:Newtonsoft.Json.JsonConverter" />.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.CreateDictionaryContract(System.Type)">
            <summary>
            Creates a <see cref="T:Newtonsoft.Json.Serialization.JsonDictionaryContract"/> for the given type.
            </summary>
            <param name="objectType">Type of the object.</param>
            <returns>A <see cref="T:Newtonsoft.Json.Serialization.JsonDictionaryContract"/> for the given type.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.CreateArrayContract(System.Type)">
            <summary>
            Creates a <see cref="T:Newtonsoft.Json.Serialization.JsonArrayContract"/> for the given type.
            </summary>
            <param name="objectType">Type of the object.</param>
            <returns>A <see cref="T:Newtonsoft.Json.Serialization.JsonArrayContract"/> for the given type.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.CreatePrimitiveContract(System.Type)">
            <summary>
            Creates a <see cref="T:Newtonsoft.Json.Serialization.JsonPrimitiveContract"/> for the given type.
            </summary>
            <param name="objectType">Type of the object.</param>
            <returns>A <see cref="T:Newtonsoft.Json.Serialization.JsonPrimitiveContract"/> for the given type.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.CreateLinqContract(System.Type)">
            <summary>
            Creates a <see cref="T:Newtonsoft.Json.Serialization.JsonLinqContract"/> for the given type.
            </summary>
            <param name="objectType">Type of the object.</param>
            <returns>A <see cref="T:Newtonsoft.Json.Serialization.JsonLinqContract"/> for the given type.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.CreateISerializableContract(System.Type)">
            <summary>
            Creates a <see cref="T:Newtonsoft.Json.Serialization.JsonISerializableContract"/> for the given type.
            </summary>
            <param name="objectType">Type of the object.</param>
            <returns>A <see cref="T:Newtonsoft.Json.Serialization.JsonISerializableContract"/> for the given type.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.CreateStringContract(System.Type)">
            <summary>
            Creates a <see cref="T:Newtonsoft.Json.Serialization.JsonStringContract"/> for the given type.
            </summary>
            <param name="objectType">Type of the object.</param>
            <returns>A <see cref="T:Newtonsoft.Json.Serialization.JsonStringContract"/> for the given type.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.CreateContract(System.Type)">
            <summary>
            Determines which contract type is created for the given type.
            </summary>
            <param name="objectType">Type of the object.</param>
            <returns>A <see cref="T:Newtonsoft.Json.Serialization.JsonContract"/> for the given type.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.CreateProperties(System.Type,Newtonsoft.Json.MemberSerialization)">
            <summary>
            Creates properties for the given <see cref="T:Newtonsoft.Json.Serialization.JsonContract"/>.
            </summary>
            <param name="type">The type to create properties for.</param>
            /// <param name="memberSerialization">The member serialization mode for the type.</param>
            <returns>Properties for the given <see cref="T:Newtonsoft.Json.Serialization.JsonContract"/>.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.CreateMemberValueProvider(System.Reflection.MemberInfo)">
            <summary>
            Creates the <see cref="T:Newtonsoft.Json.Serialization.IValueProvider"/> used by the serializer to get and set values from a member.
            </summary>
            <param name="member">The member.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Serialization.IValueProvider"/> used by the serializer to get and set values from a member.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.CreateProperty(System.Reflection.MemberInfo,Newtonsoft.Json.MemberSerialization)">
            <summary>
            Creates a <see cref="T:Newtonsoft.Json.Serialization.JsonProperty"/> for the given <see cref="T:System.Reflection.MemberInfo"/>.
            </summary>
            <param name="memberSerialization">The member's parent <see cref="T:Newtonsoft.Json.MemberSerialization"/>.</param>
            <param name="member">The member to create a <see cref="T:Newtonsoft.Json.Serialization.JsonProperty"/> for.</param>
            <returns>A created <see cref="T:Newtonsoft.Json.Serialization.JsonProperty"/> for the given <see cref="T:System.Reflection.MemberInfo"/>.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.ResolvePropertyName(System.String)">
            <summary>
            Resolves the name of the property.
            </summary>
            <param name="propertyName">Name of the property.</param>
            <returns>Name of the property.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.GetResolvedPropertyName(System.String)">
            <summary>
            Gets the resolved name of the property.
            </summary>
            <param name="propertyName">Name of the property.</param>
            <returns>Name of the property.</returns>
        </member>
        <member name="T:Newtonsoft.Json.Serialization.DefaultSerializationBinder">
            <summary>
            The default serialization binder used when resolving and loading classes from type names.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.Serialization.DefaultSerializationBinder.BindToType(System.String,System.String)">
            <summary>
            When overridden in a derived class, controls the binding of a serialized object to a type.
            </summary>
            <param name="assemblyName">Specifies the <see cref="T:System.Reflection.Assembly"/> name of the serialized object.</param>
            <param name="typeName">Specifies the <see cref="T:System.Type"/> name of the serialized object.</param>
            <returns>
            The type of the object the formatter creates a new instance of.
            </returns>
        </member>
        <member name="T:Newtonsoft.Json.Serialization.DiagnosticsTraceWriter">
            <summary>
            Represents a trace writer that writes to the application's <see cref="T:System.Diagnostics.TraceListener"/> instances.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.DiagnosticsTraceWriter.LevelFilter">
            <summary>
            Gets the <see cref="T:System.Diagnostics.TraceLevel"/> that will be used to filter the trace messages passed to the writer.
            For example a filter level of <code>Info</code> will exclude <code>Verbose</code> messages and include <code>Info</code>,
            <code>Warning</code> and <code>Error</code> messages.
            </summary>
            <value>
            The <see cref="T:System.Diagnostics.TraceLevel"/> that will be used to filter the trace messages passed to the writer.
            </value>
        </member>
        <member name="M:Newtonsoft.Json.Serialization.DiagnosticsTraceWriter.Trace(System.Diagnostics.TraceLevel,System.String,System.Exception)">
            <summary>
            Writes the specified trace level, message and optional exception.
            </summary>
            <param name="level">The <see cref="T:System.Diagnostics.TraceLevel"/> at which to write this trace.</param>
            <param name="message">The trace message.</param>
            <param name="ex">The trace exception. This parameter is optional.</param>
        </member>
        <member name="T:Newtonsoft.Json.Serialization.DynamicValueProvider">
            <summary>
            Get and set values for a <see cref="T:System.Reflection.MemberInfo"/> using dynamic methods.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.Serialization.DynamicValueProvider.#ctor(System.Reflection.MemberInfo)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.DynamicValueProvider"/> class.
            </summary>
            <param name="memberInfo">The member info.</param>
        </member>
        <member name="M:Newtonsoft.Json.Serialization.DynamicValueProvider.SetValue(System.Object,System.Object)">
            <summary>
            Sets the value.
            </summary>
            <param name="target">The target to set the value on.</param>
            <param name="value">The value to set on the target.</param>
        </member>
        <member name="M:Newtonsoft.Json.Serialization.DynamicValueProvider.GetValue(System.Object)">
            <summary>
            Gets the value.
            </summary>
            <param name="target">The target to get the value from.</param>
            <returns>The value.</returns>
        </member>
        <member name="T:Newtonsoft.Json.Serialization.ErrorContext">
            <summary>
            Provides information surrounding an error.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.ErrorContext.Error">
            <summary>
            Gets the error.
            </summary>
            <value>The error.</value>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.ErrorContext.OriginalObject">
            <summary>
            Gets the original object that caused the error.
            </summary>
            <value>The original object that caused the error.</value>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.ErrorContext.Member">
            <summary>
            Gets the member that caused the error.
            </summary>
            <value>The member that caused the error.</value>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.ErrorContext.Path">
            <summary>
            Gets the path of the JSON location where the error occurred.
            </summary>
            <value>The path of the JSON location where the error occurred.</value>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.ErrorContext.Handled">
            <summary>
            Gets or sets a value indicating whether this <see cref="T:Newtonsoft.Json.Serialization.ErrorContext"/> is handled.
            </summary>
            <value><c>true</c> if handled; otherwise, <c>false</c>.</value>
        </member>
        <member name="T:Newtonsoft.Json.Serialization.ErrorEventArgs">
            <summary>
            Provides data for the Error event.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.ErrorEventArgs.CurrentObject">
            <summary>
            Gets the current object the error event is being raised against.
            </summary>
            <value>The current object the error event is being raised against.</value>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.ErrorEventArgs.ErrorContext">
            <summary>
            Gets the error context.
            </summary>
            <value>The error context.</value>
        </member>
        <member name="M:Newtonsoft.Json.Serialization.ErrorEventArgs.#ctor(System.Object,Newtonsoft.Json.Serialization.ErrorContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.ErrorEventArgs"/> class.
            </summary>
            <param name="currentObject">The current object.</param>
            <param name="errorContext">The error context.</param>
        </member>
        <member name="T:Newtonsoft.Json.Serialization.IContractResolver">
            <summary>
            Used by <see cref="T:Newtonsoft.Json.JsonSerializer"/> to resolves a <see cref="T:Newtonsoft.Json.Serialization.JsonContract"/> for a given <see cref="T:System.Type"/>.
            </summary>
            <example>
              <code lang="cs" source="..\Src\Newtonsoft.Json.Tests\Documentation\SerializationTests.cs" region="ReducingSerializedJsonSizeContractResolverObject" title="IContractResolver Class" />
              <code lang="cs" source="..\Src\Newtonsoft.Json.Tests\Documentation\SerializationTests.cs" region="ReducingSerializedJsonSizeContractResolverExample" title="IContractResolver Example" />
            </example>
        </member>
        <member name="M:Newtonsoft.Json.Serialization.IContractResolver.ResolveContract(System.Type)">
            <summary>
            Resolves the contract for a given type.
            </summary>
            <param name="type">The type to resolve a contract for.</param>
            <returns>The contract for a given type.</returns>
        </member>
        <member name="T:Newtonsoft.Json.Serialization.IReferenceResolver">
            <summary>
            Used to resolve references when serializing and deserializing JSON by the <see cref="T:Newtonsoft.Json.JsonSerializer"/>.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.Serialization.IReferenceResolver.ResolveReference(System.Object,System.String)">
            <summary>
            Resolves a reference to its object.
            </summary>
            <param name="context">The serialization context.</param>
            <param name="reference">The reference to resolve.</param>
            <returns>The object that</returns>
        </member>
        <member name="M:Newtonsoft.Json.Serialization.IReferenceResolver.GetReference(System.Object,System.Object)">
            <summary>
            Gets the reference for the sepecified object.
            </summary>
            <param name="context">The serialization context.</param>
            <param name="value">The object to get a reference for.</param>
            <returns>The reference to the object.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Serialization.IReferenceResolver.IsReferenced(System.Object,System.Object)">
            <summary>
            Determines whether the specified object is referenced.
            </summary>
            <param name="context">The serialization context.</param>
            <param name="value">The object to test for a reference.</param>
            <returns>
            	<c>true</c> if the specified object is referenced; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Newtonsoft.Json.Serialization.IReferenceResolver.AddReference(System.Object,System.String,System.Object)">
            <summary>
            Adds a reference to the specified object.
            </summary>
            <param name="context">The serialization context.</param>
            <param name="reference">The reference.</param>
            <param name="value">The object to reference.</param>
        </member>
        <member name="T:Newtonsoft.Json.Serialization.ITraceWriter">
            <summary>
            Represents a trace writer.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.ITraceWriter.LevelFilter">
            <summary>
            Gets the <see cref="T:System.Diagnostics.TraceLevel"/> that will be used to filter the trace messages passed to the writer.
            For example a filter level of <code>Info</code> will exclude <code>Verbose</code> messages and include <code>Info</code>,
            <code>Warning</code> and <code>Error</code> messages.
            </summary>
            <value>The <see cref="T:System.Diagnostics.TraceLevel"/> that will be used to filter the trace messages passed to the writer.</value>
        </member>
        <member name="M:Newtonsoft.Json.Serialization.ITraceWriter.Trace(System.Diagnostics.TraceLevel,System.String,System.Exception)">
            <summary>
            Writes the specified trace level, message and optional exception.
            </summary>
            <param name="level">The <see cref="T:System.Diagnostics.TraceLevel"/> at which to write this trace.</param>
            <param name="message">The trace message.</param>
            <param name="ex">The trace exception. This parameter is optional.</param>
        </member>
        <member name="T:Newtonsoft.Json.Serialization.IValueProvider">
            <summary>
            Provides methods to get and set values.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.Serialization.IValueProvider.SetValue(System.Object,System.Object)">
            <summary>
            Sets the value.
            </summary>
            <param name="target">The target to set the value on.</param>
            <param name="value">The value to set on the target.</param>
        </member>
        <member name="M:Newtonsoft.Json.Serialization.IValueProvider.GetValue(System.Object)">
            <summary>
            Gets the value.
            </summary>
            <param name="target">The target to get the value from.</param>
            <returns>The value.</returns>
        </member>
        <member name="T:Newtonsoft.Json.Serialization.JsonArrayContract">
            <summary>
            Contract details for a <see cref="T:System.Type"/> used by the <see cref="T:Newtonsoft.Json.JsonSerializer"/>.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.JsonArrayContract.CollectionItemType">
            <summary>
            Gets the <see cref="T:System.Type"/> of the collection items.
            </summary>
            <value>The <see cref="T:System.Type"/> of the collection items.</value>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.JsonArrayContract.IsMultidimensionalArray">
            <summary>
            Gets a value indicating whether the collection type is a multidimensional array.
            </summary>
            <value><c>true</c> if the collection type is a multidimensional array; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:Newtonsoft.Json.Serialization.JsonArrayContract.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.JsonArrayContract"/> class.
            </summary>
            <param name="underlyingType">The underlying type for the contract.</param>
        </member>
        <member name="T:Newtonsoft.Json.Serialization.JsonContainerContract">
            <summary>
            Contract details for a <see cref="T:System.Type"/> used by the <see cref="T:Newtonsoft.Json.JsonSerializer"/>.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.JsonContainerContract.ItemConverter">
            <summary>
            Gets or sets the default collection items <see cref="T:Newtonsoft.Json.JsonConverter" />.
            </summary>
            <value>The converter.</value>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.JsonContainerContract.ItemIsReference">
            <summary>
            Gets or sets a value indicating whether the collection items preserve object references.
            </summary>
            <value><c>true</c> if collection items preserve object references; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.JsonContainerContract.ItemReferenceLoopHandling">
            <summary>
            Gets or sets the collection item reference loop handling.
            </summary>
            <value>The reference loop handling.</value>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.JsonContainerContract.ItemTypeNameHandling">
            <summary>
            Gets or sets the collection item type name handling.
            </summary>
            <value>The type name handling.</value>
        </member>
        <member name="M:Newtonsoft.Json.Serialization.JsonContainerContract.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.JsonContainerContract"/> class.
            </summary>
            <param name="underlyingType">The underlying type for the contract.</param>
        </member>
        <member name="T:Newtonsoft.Json.Serialization.SerializationCallback">
            <summary>
            Handles <see cref="T:Newtonsoft.Json.JsonSerializer"/> serialization callback events.
            </summary>
            <param name="o">The object that raised the callback event.</param>
            <param name="context">The streaming context.</param>
        </member>
        <member name="T:Newtonsoft.Json.Serialization.SerializationErrorCallback">
            <summary>
            Handles <see cref="T:Newtonsoft.Json.JsonSerializer"/> serialization error callback events.
            </summary>
            <param name="o">The object that raised the callback event.</param>
            <param name="context">The streaming context.</param>
            <param name="errorContext">The error context.</param>
        </member>
        <member name="T:Newtonsoft.Json.Serialization.ExtensionDataSetter">
            <summary>
            Sets extension data for an object during deserialization.
            </summary>
            <param name="o">The object to set extension data on.</param>
            <param name="key">The extension data key.</param>
            <param name="value">The extension data value.</param>
        </member>
        <member name="T:Newtonsoft.Json.Serialization.ExtensionDataGetter">
            <summary>
            Gets extension data for an object during serialization.
            </summary>
            <param name="o">The object to set extension data on.</param>
        </member>
        <member name="T:Newtonsoft.Json.Serialization.JsonContract">
            <summary>
            Contract details for a <see cref="T:System.Type"/> used by the <see cref="T:Newtonsoft.Json.JsonSerializer"/>.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.JsonContract.UnderlyingType">
            <summary>
            Gets the underlying type for the contract.
            </summary>
            <value>The underlying type for the contract.</value>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.JsonContract.CreatedType">
            <summary>
            Gets or sets the type created during deserialization.
            </summary>
            <value>The type created during deserialization.</value>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.JsonContract.IsReference">
            <summary>
            Gets or sets whether this type contract is serialized as a reference.
            </summary>
            <value>Whether this type contract is serialized as a reference.</value>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.JsonContract.Converter">
            <summary>
            Gets or sets the default <see cref="T:Newtonsoft.Json.JsonConverter" /> for this contract.
            </summary>
            <value>The converter.</value>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.JsonContract.OnDeserializedCallbacks">
            <summary>
            Gets or sets all methods called immediately after deserialization of the object.
            </summary>
            <value>The methods called immediately after deserialization of the object.</value>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.JsonContract.OnDeserializingCallbacks">
            <summary>
            Gets or sets all methods called during deserialization of the object.
            </summary>
            <value>The methods called during deserialization of the object.</value>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.JsonContract.OnSerializedCallbacks">
            <summary>
            Gets or sets all methods called after serialization of the object graph.
            </summary>
            <value>The methods called after serialization of the object graph.</value>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.JsonContract.OnSerializingCallbacks">
            <summary>
            Gets or sets all methods called before serialization of the object.
            </summary>
            <value>The methods called before serialization of the object.</value>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.JsonContract.OnErrorCallbacks">
            <summary>
            Gets or sets all method called when an error is thrown during the serialization of the object.
            </summary>
            <value>The methods called when an error is thrown during the serialization of the object.</value>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.JsonContract.OnDeserialized">
            <summary>
            Gets or sets the method called immediately after deserialization of the object.
            </summary>
            <value>The method called immediately after deserialization of the object.</value>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.JsonContract.OnDeserializing">
            <summary>
            Gets or sets the method called during deserialization of the object.
            </summary>
            <value>The method called during deserialization of the object.</value>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.JsonContract.OnSerialized">
            <summary>
            Gets or sets the method called after serialization of the object graph.
            </summary>
            <value>The method called after serialization of the object graph.</value>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.JsonContract.OnSerializing">
            <summary>
            Gets or sets the method called before serialization of the object.
            </summary>
            <value>The method called before serialization of the object.</value>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.JsonContract.OnError">
            <summary>
            Gets or sets the method called when an error is thrown during the serialization of the object.
            </summary>
            <value>The method called when an error is thrown during the serialization of the object.</value>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.JsonContract.DefaultCreator">
            <summary>
            Gets or sets the default creator method used to create the object.
            </summary>
            <value>The default creator method used to create the object.</value>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.JsonContract.DefaultCreatorNonPublic">
            <summary>
            Gets or sets a value indicating whether the default creator is non public.
            </summary>
            <value><c>true</c> if the default object creator is non-public; otherwise, <c>false</c>.</value>
        </member>
        <member name="T:Newtonsoft.Json.Serialization.JsonDictionaryContract">
            <summary>
            Contract details for a <see cref="T:System.Type"/> used by the <see cref="T:Newtonsoft.Json.JsonSerializer"/>.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.JsonDictionaryContract.PropertyNameResolver">
            <summary>
            Gets or sets the property name resolver.
            </summary>
            <value>The property name resolver.</value>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.JsonDictionaryContract.DictionaryKeyType">
            <summary>
            Gets the <see cref="T:System.Type"/> of the dictionary keys.
            </summary>
            <value>The <see cref="T:System.Type"/> of the dictionary keys.</value>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.JsonDictionaryContract.DictionaryValueType">
            <summary>
            Gets the <see cref="T:System.Type"/> of the dictionary values.
            </summary>
            <value>The <see cref="T:System.Type"/> of the dictionary values.</value>
        </member>
        <member name="M:Newtonsoft.Json.Serialization.JsonDictionaryContract.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.JsonDictionaryContract"/> class.
            </summary>
            <param name="underlyingType">The underlying type for the contract.</param>
        </member>
        <member name="T:Newtonsoft.Json.Serialization.JsonISerializableContract">
            <summary>
            Contract details for a <see cref="T:System.Type"/> used by the <see cref="T:Newtonsoft.Json.JsonSerializer"/>.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.JsonISerializableContract.ISerializableCreator">
            <summary>
            Gets or sets the ISerializable object constructor.
            </summary>
            <value>The ISerializable object constructor.</value>
        </member>
        <member name="M:Newtonsoft.Json.Serialization.JsonISerializableContract.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.JsonISerializableContract"/> class.
            </summary>
            <param name="underlyingType">The underlying type for the contract.</param>
        </member>
        <member name="T:Newtonsoft.Json.Serialization.JsonLinqContract">
            <summary>
            Contract details for a <see cref="T:System.Type"/> used by the <see cref="T:Newtonsoft.Json.JsonSerializer"/>.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.Serialization.JsonLinqContract.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.JsonLinqContract"/> class.
            </summary>
            <param name="underlyingType">The underlying type for the contract.</param>
        </member>
        <member name="T:Newtonsoft.Json.Serialization.JsonObjectContract">
            <summary>
            Contract details for a <see cref="T:System.Type"/> used by the <see cref="T:Newtonsoft.Json.JsonSerializer"/>.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.JsonObjectContract.MemberSerialization">
            <summary>
            Gets or sets the object member serialization.
            </summary>
            <value>The member object serialization.</value>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.JsonObjectContract.ItemRequired">
            <summary>
            Gets or sets a value that indicates whether the object's properties are required.
            </summary>
            <value>
            	A value indicating whether the object's properties are required.
            </value>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.JsonObjectContract.Properties">
            <summary>
            Gets the object's properties.
            </summary>
            <value>The object's properties.</value>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.JsonObjectContract.ConstructorParameters">
            <summary>
            Gets the constructor parameters required for any non-default constructor
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.JsonObjectContract.OverrideConstructor">
            <summary>
            Gets or sets the override constructor used to create the object.
            This is set when a constructor is marked up using the
            JsonConstructor attribute.
            </summary>
            <value>The override constructor.</value>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.JsonObjectContract.ParametrizedConstructor">
            <summary>
            Gets or sets the parametrized constructor used to create the object.
            </summary>
            <value>The parametrized constructor.</value>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.JsonObjectContract.ExtensionDataSetter">
            <summary>
            Gets or sets the extension data setter.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.JsonObjectContract.ExtensionDataGetter">
            <summary>
            Gets or sets the extension data getter.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.Serialization.JsonObjectContract.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.JsonObjectContract"/> class.
            </summary>
            <param name="underlyingType">The underlying type for the contract.</param>
        </member>
        <member name="T:Newtonsoft.Json.Serialization.JsonPrimitiveContract">
            <summary>
            Contract details for a <see cref="T:System.Type"/> used by the <see cref="T:Newtonsoft.Json.JsonSerializer"/>.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.Serialization.JsonPrimitiveContract.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.JsonPrimitiveContract"/> class.
            </summary>
            <param name="underlyingType">The underlying type for the contract.</param>
        </member>
        <member name="T:Newtonsoft.Json.Serialization.JsonProperty">
            <summary>
            Maps a JSON property to a .NET member or constructor parameter.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.JsonProperty.PropertyName">
            <summary>
            Gets or sets the name of the property.
            </summary>
            <value>The name of the property.</value>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.JsonProperty.DeclaringType">
            <summary>
            Gets or sets the type that declared this property.
            </summary>
            <value>The type that declared this property.</value>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.JsonProperty.Order">
            <summary>
            Gets or sets the order of serialization and deserialization of a member.
            </summary>
            <value>The numeric order of serialization or deserialization.</value>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.JsonProperty.UnderlyingName">
            <summary>
            Gets or sets the name of the underlying member or parameter.
            </summary>
            <value>The name of the underlying member or parameter.</value>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.JsonProperty.ValueProvider">
            <summary>
            Gets the <see cref="T:Newtonsoft.Json.Serialization.IValueProvider"/> that will get and set the <see cref="T:Newtonsoft.Json.Serialization.JsonProperty"/> during serialization.
            </summary>
            <value>The <see cref="T:Newtonsoft.Json.Serialization.IValueProvider"/> that will get and set the <see cref="T:Newtonsoft.Json.Serialization.JsonProperty"/> during serialization.</value>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.JsonProperty.PropertyType">
            <summary>
            Gets or sets the type of the property.
            </summary>
            <value>The type of the property.</value>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.JsonProperty.Converter">
            <summary>
            Gets or sets the <see cref="T:Newtonsoft.Json.JsonConverter" /> for the property.
            If set this converter takes presidence over the contract converter for the property type.
            </summary>
            <value>The converter.</value>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.JsonProperty.MemberConverter">
            <summary>
            Gets or sets the member converter.
            </summary>
            <value>The member converter.</value>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.JsonProperty.Ignored">
            <summary>
            Gets or sets a value indicating whether this <see cref="T:Newtonsoft.Json.Serialization.JsonProperty"/> is ignored.
            </summary>
            <value><c>true</c> if ignored; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.JsonProperty.Readable">
            <summary>
            Gets or sets a value indicating whether this <see cref="T:Newtonsoft.Json.Serialization.JsonProperty"/> is readable.
            </summary>
            <value><c>true</c> if readable; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.JsonProperty.Writable">
            <summary>
            Gets or sets a value indicating whether this <see cref="T:Newtonsoft.Json.Serialization.JsonProperty"/> is writable.
            </summary>
            <value><c>true</c> if writable; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.JsonProperty.HasMemberAttribute">
            <summary>
            Gets or sets a value indicating whether this <see cref="T:Newtonsoft.Json.Serialization.JsonProperty"/> has a member attribute.
            </summary>
            <value><c>true</c> if has a member attribute; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.JsonProperty.DefaultValue">
            <summary>
            Gets the default value.
            </summary>
            <value>The default value.</value>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.JsonProperty.Required">
            <summary>
            Gets or sets a value indicating whether this <see cref="T:Newtonsoft.Json.Serialization.JsonProperty"/> is required.
            </summary>
            <value>A value indicating whether this <see cref="T:Newtonsoft.Json.Serialization.JsonProperty"/> is required.</value>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.JsonProperty.IsReference">
            <summary>
            Gets or sets a value indicating whether this property preserves object references.
            </summary>
            <value>
            	<c>true</c> if this instance is reference; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.JsonProperty.NullValueHandling">
            <summary>
            Gets or sets the property null value handling.
            </summary>
            <value>The null value handling.</value>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.JsonProperty.DefaultValueHandling">
            <summary>
            Gets or sets the property default value handling.
            </summary>
            <value>The default value handling.</value>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.JsonProperty.ReferenceLoopHandling">
            <summary>
            Gets or sets the property reference loop handling.
            </summary>
            <value>The reference loop handling.</value>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.JsonProperty.ObjectCreationHandling">
            <summary>
            Gets or sets the property object creation handling.
            </summary>
            <value>The object creation handling.</value>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.JsonProperty.TypeNameHandling">
            <summary>
            Gets or sets or sets the type name handling.
            </summary>
            <value>The type name handling.</value>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.JsonProperty.ShouldSerialize">
            <summary>
            Gets or sets a predicate used to determine whether the property should be serialize.
            </summary>
            <value>A predicate used to determine whether the property should be serialize.</value>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.JsonProperty.GetIsSpecified">
            <summary>
            Gets or sets a predicate used to determine whether the property should be serialized.
            </summary>
            <value>A predicate used to determine whether the property should be serialized.</value>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.JsonProperty.SetIsSpecified">
            <summary>
            Gets or sets an action used to set whether the property has been deserialized.
            </summary>
            <value>An action used to set whether the property has been deserialized.</value>
        </member>
        <member name="M:Newtonsoft.Json.Serialization.JsonProperty.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.JsonProperty.ItemConverter">
            <summary>
            Gets or sets the converter used when serializing the property's collection items.
            </summary>
            <value>The collection's items converter.</value>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.JsonProperty.ItemIsReference">
            <summary>
            Gets or sets whether this property's collection items are serialized as a reference.
            </summary>
            <value>Whether this property's collection items are serialized as a reference.</value>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.JsonProperty.ItemTypeNameHandling">
            <summary>
            Gets or sets the the type name handling used when serializing the property's collection items.
            </summary>
            <value>The collection's items type name handling.</value>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.JsonProperty.ItemReferenceLoopHandling">
            <summary>
            Gets or sets the the reference loop handling used when serializing the property's collection items.
            </summary>
            <value>The collection's items reference loop handling.</value>
        </member>
        <member name="T:Newtonsoft.Json.Serialization.JsonPropertyCollection">
            <summary>
            A collection of <see cref="T:Newtonsoft.Json.Serialization.JsonProperty"/> objects.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.Serialization.JsonPropertyCollection.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.JsonPropertyCollection"/> class.
            </summary>
            <param name="type">The type.</param>
        </member>
        <member name="M:Newtonsoft.Json.Serialization.JsonPropertyCollection.GetKeyForItem(Newtonsoft.Json.Serialization.JsonProperty)">
            <summary>
            When implemented in a derived class, extracts the key from the specified element.
            </summary>
            <param name="item">The element from which to extract the key.</param>
            <returns>The key for the specified element.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Serialization.JsonPropertyCollection.AddProperty(Newtonsoft.Json.Serialization.JsonProperty)">
            <summary>
            Adds a <see cref="T:Newtonsoft.Json.Serialization.JsonProperty"/> object.
            </summary>
            <param name="property">The property to add to the collection.</param>
        </member>
        <member name="M:Newtonsoft.Json.Serialization.JsonPropertyCollection.GetClosestMatchProperty(System.String)">
            <summary>
            Gets the closest matching <see cref="T:Newtonsoft.Json.Serialization.JsonProperty"/> object.
            First attempts to get an exact case match of propertyName and then
            a case insensitive match.
            </summary>
            <param name="propertyName">Name of the property.</param>
            <returns>A matching property if found.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Serialization.JsonPropertyCollection.GetProperty(System.String,System.StringComparison)">
            <summary>
            Gets a property by property name.
            </summary>
            <param name="propertyName">The name of the property to get.</param>
            <param name="comparisonType">Type property name string comparison.</param>
            <returns>A matching property if found.</returns>
        </member>
        <member name="T:Newtonsoft.Json.Serialization.JsonStringContract">
            <summary>
            Contract details for a <see cref="T:System.Type"/> used by the <see cref="T:Newtonsoft.Json.JsonSerializer"/>.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.Serialization.JsonStringContract.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.JsonStringContract"/> class.
            </summary>
            <param name="underlyingType">The underlying type for the contract.</param>
        </member>
        <member name="T:Newtonsoft.Json.Serialization.MemoryTraceWriter">
            <summary>
            Represents a trace writer that writes to memory. When the trace message limit is
            reached then old trace messages will be removed as new messages are added.
            </summary>
        </member>
        <member name="P:Newtonsoft.Json.Serialization.MemoryTraceWriter.LevelFilter">
            <summary>
            Gets the <see cref="T:System.Diagnostics.TraceLevel"/> that will be used to filter the trace messages passed to the writer.
            For example a filter level of <code>Info</code> will exclude <code>Verbose</code> messages and include <code>Info</code>,
            <code>Warning</code> and <code>Error</code> messages.
            </summary>
            <value>
            The <see cref="T:System.Diagnostics.TraceLevel"/> that will be used to filter the trace messages passed to the writer.
            </value>
        </member>
        <member name="M:Newtonsoft.Json.Serialization.MemoryTraceWriter.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.MemoryTraceWriter"/> class.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.Serialization.MemoryTraceWriter.Trace(System.Diagnostics.TraceLevel,System.String,System.Exception)">
            <summary>
            Writes the specified trace level, message and optional exception.
            </summary>
            <param name="level">The <see cref="T:System.Diagnostics.TraceLevel"/> at which to write this trace.</param>
            <param name="message">The trace message.</param>
            <param name="ex">The trace exception. This parameter is optional.</param>
        </member>
        <member name="M:Newtonsoft.Json.Serialization.MemoryTraceWriter.GetTraceMessages">
            <summary>
            Returns an enumeration of the most recent trace messages.
            </summary>
            <returns>An enumeration of the most recent trace messages.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Serialization.MemoryTraceWriter.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> of the most recent trace messages.
            </summary>
            <returns>
            A <see cref="T:System.String"/> of the most recent trace messages.
            </returns>
        </member>
        <member name="T:Newtonsoft.Json.Serialization.ObjectConstructor`1">
            <summary>
            Represents a method that constructs an object.
            </summary>
            <typeparam name="T">The object type to create.</typeparam>
        </member>
        <member name="T:Newtonsoft.Json.Serialization.OnErrorAttribute">
            <summary>
            When applied to a method, specifies that the method is called when an error occurs serializing an object.
            </summary>
        </member>
        <member name="T:Newtonsoft.Json.Serialization.ReflectionValueProvider">
            <summary>
            Get and set values for a <see cref="T:System.Reflection.MemberInfo"/> using reflection.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.Serialization.ReflectionValueProvider.#ctor(System.Reflection.MemberInfo)">
            <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.ReflectionValueProvider"/> class.
            </summary>
            <param name="memberInfo">The member info.</param>
        </member>
        <member name="M:Newtonsoft.Json.Serialization.ReflectionValueProvider.SetValue(System.Object,System.Object)">
            <summary>
            Sets the value.
            </summary>
            <param name="target">The target to set the value on.</param>
            <param name="value">The value to set on the target.</param>
        </member>
        <member name="M:Newtonsoft.Json.Serialization.ReflectionValueProvider.GetValue(System.Object)">
            <summary>
            Gets the value.
            </summary>
            <param name="target">The target to get the value from.</param>
            <returns>The value.</returns>
        </member>
        <member name="T:Newtonsoft.Json.StringEscapeHandling">
            <summary>
            Specifies how strings are escaped when writing JSON text.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.StringEscapeHandling.Default">
            <summary>
            Only control characters (e.g. newline) are escaped.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.StringEscapeHandling.EscapeNonAscii">
            <summary>
            All non-ASCII and control characters (e.g. newline) are escaped.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.StringEscapeHandling.EscapeHtml">
            <summary>
            HTML (&lt;, &gt;, &amp;, &apos;, &quot;) and control characters (e.g. newline) are escaped.
            </summary>
        </member>
        <member name="T:Newtonsoft.Json.TypeNameHandling">
            <summary>
            Specifies type name handling options for the <see cref="T:Newtonsoft.Json.JsonSerializer"/>.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.TypeNameHandling.None">
            <summary>
            Do not include the .NET type name when serializing types.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.TypeNameHandling.Objects">
            <summary>
            Include the .NET type name when serializing into a JSON object structure.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.TypeNameHandling.Arrays">
            <summary>
            Include the .NET type name when serializing into a JSON array structure.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.TypeNameHandling.All">
            <summary>
            Always include the .NET type name when serializing.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.TypeNameHandling.Auto">
            <summary>
            Include the .NET type name when the type of the object being serialized is not the same as its declared type.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.Utilities.CollectionUtils.IsNullOrEmpty``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            Determines whether the collection is null or empty.
            </summary>
            <param name="collection">The collection.</param>
            <returns>
            	<c>true</c> if the collection is null or empty; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Newtonsoft.Json.Utilities.CollectionUtils.AddRange``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Adds the elements of the specified collection to the specified generic IList.
            </summary>
            <param name="initial">The list to add to.</param>
            <param name="collection">The collection of elements to add.</param>
        </member>
        <member name="M:Newtonsoft.Json.Utilities.CollectionUtils.IndexOf``1(System.Collections.Generic.IEnumerable{``0},``0,System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Returns the index of the first occurrence in a sequence by using a specified IEqualityComparer.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="list">A sequence in which to locate a value.</param>
            <param name="value">The object to locate in the sequence</param>
            <param name="comparer">An equality comparer to compare values.</param>
            <returns>The zero-based index of the first occurrence of value within the entire sequence, if found; otherwise, ?.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Utilities.ConvertUtils.Convert(System.Object,System.Globalization.CultureInfo,System.Type)">
            <summary>
            Converts the value to the specified type.
            </summary>
            <param name="initialValue">The value to convert.</param>
            <param name="culture">The culture to use when converting.</param>
            <param name="targetType">The type to convert the value to.</param>
            <returns>The converted type.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Utilities.ConvertUtils.TryConvert(System.Object,System.Globalization.CultureInfo,System.Type,System.Object@)">
            <summary>
            Converts the value to the specified type.
            </summary>
            <param name="initialValue">The value to convert.</param>
            <param name="culture">The culture to use when converting.</param>
            <param name="targetType">The type to convert the value to.</param>
            <param name="convertedValue">The converted value if the conversion was successful or the default value of <c>T</c> if it failed.</param>
            <returns>
            	<c>true</c> if <c>initialValue</c> was converted successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Newtonsoft.Json.Utilities.ConvertUtils.ConvertOrCast(System.Object,System.Globalization.CultureInfo,System.Type)">
            <summary>
            Converts the value to the specified type. If the value is unable to be converted, the
            value is checked whether it assignable to the specified type.
            </summary>
            <param name="initialValue">The value to convert.</param>
            <param name="culture">The culture to use when converting.</param>
            <param name="targetType">The type to convert or cast the value to.</param>
            <returns>
            The converted type. If conversion was unsuccessful, the initial value
            is returned if assignable to the target type.
            </returns>
        </member>
        <member name="M:Newtonsoft.Json.Utilities.EnumUtils.GetNamesAndValues``1">
            <summary>
            Gets a dictionary of the names and values of an Enum type.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Newtonsoft.Json.Utilities.EnumUtils.GetNamesAndValues``1(System.Type)">
            <summary>
            Gets a dictionary of the names and values of an Enum type.
            </summary>
            <param name="enumType">The enum type to get names and values for.</param>
            <returns></returns>
        </member>
        <member name="M:Newtonsoft.Json.Utilities.ReflectionUtils.GetCollectionItemType(System.Type)">
            <summary>
            Gets the type of the typed collection's items.
            </summary>
            <param name="type">The type.</param>
            <returns>The type of the typed collection's items.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Utilities.ReflectionUtils.GetMemberUnderlyingType(System.Reflection.MemberInfo)">
            <summary>
            Gets the member's underlying type.
            </summary>
            <param name="member">The member.</param>
            <returns>The underlying type of the member.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Utilities.ReflectionUtils.IsIndexedProperty(System.Reflection.MemberInfo)">
            <summary>
            Determines whether the member is an indexed property.
            </summary>
            <param name="member">The member.</param>
            <returns>
            	<c>true</c> if the member is an indexed property; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Newtonsoft.Json.Utilities.ReflectionUtils.IsIndexedProperty(System.Reflection.PropertyInfo)">
            <summary>
            Determines whether the property is an indexed property.
            </summary>
            <param name="property">The property.</param>
            <returns>
            	<c>true</c> if the property is an indexed property; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Newtonsoft.Json.Utilities.ReflectionUtils.GetMemberValue(System.Reflection.MemberInfo,System.Object)">
            <summary>
            Gets the member's value on the object.
            </summary>
            <param name="member">The member.</param>
            <param name="target">The target object.</param>
            <returns>The member's value on the object.</returns>
        </member>
        <member name="M:Newtonsoft.Json.Utilities.ReflectionUtils.SetMemberValue(System.Reflection.MemberInfo,System.Object,System.Object)">
            <summary>
            Sets the member's value on the target object.
            </summary>
            <param name="member">The member.</param>
            <param name="target">The target.</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:Newtonsoft.Json.Utilities.ReflectionUtils.CanReadMemberValue(System.Reflection.MemberInfo,System.Boolean)">
            <summary>
            Determines whether the specified MemberInfo can be read.
            </summary>
            <param name="member">The MemberInfo to determine whether can be read.</param>
            /// <param name="nonPublic">if set to <c>true</c> then allow the member to be gotten non-publicly.</param>
            <returns>
            	<c>true</c> if the specified MemberInfo can be read; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Newtonsoft.Json.Utilities.ReflectionUtils.CanSetMemberValue(System.Reflection.MemberInfo,System.Boolean,System.Boolean)">
            <summary>
            Determines whether the specified MemberInfo can be set.
            </summary>
            <param name="member">The MemberInfo to determine whether can be set.</param>
            <param name="nonPublic">if set to <c>true</c> then allow the member to be set non-publicly.</param>
            <param name="canSetReadOnly">if set to <c>true</c> then allow the member to be set if read-only.</param>
            <returns>
            	<c>true</c> if the specified MemberInfo can be set; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:Newtonsoft.Json.Utilities.StringBuffer">
            <summary>
            Builds a string. Unlike StringBuilder this class lets you reuse it's internal buffer.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.Utilities.StringUtils.IsWhiteSpace(System.String)">
            <summary>
            Determines whether the string is all white space. Empty string will return false.
            </summary>
            <param name="s">The string to test whether it is all white space.</param>
            <returns>
            	<c>true</c> if the string is all white space; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Newtonsoft.Json.Utilities.StringUtils.NullEmptyString(System.String)">
            <summary>
            Nulls an empty string.
            </summary>
            <param name="s">The string.</param>
            <returns>Null if the string was null, otherwise the string unchanged.</returns>
        </member>
        <member name="T:Newtonsoft.Json.WriteState">
            <summary>
            Specifies the state of the <see cref="T:Newtonsoft.Json.JsonWriter"/>.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.WriteState.Error">
            <summary>
            An exception has been thrown, which has left the <see cref="T:Newtonsoft.Json.JsonWriter"/> in an invalid state.
            You may call the <see cref="M:Newtonsoft.Json.JsonWriter.Close"/> method to put the <see cref="T:Newtonsoft.Json.JsonWriter"/> in the <c>Closed</c> state.
            Any other <see cref="T:Newtonsoft.Json.JsonWriter"/> method calls results in an <see cref="T:System.InvalidOperationException"/> being thrown. 
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.WriteState.Closed">
            <summary>
            The <see cref="M:Newtonsoft.Json.JsonWriter.Close"/> method has been called. 
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.WriteState.Object">
            <summary>
            An object is being written. 
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.WriteState.Array">
            <summary>
            A array is being written.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.WriteState.Constructor">
            <summary>
            A constructor is being written.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.WriteState.Property">
            <summary>
            A property is being written.
            </summary>
        </member>
        <member name="F:Newtonsoft.Json.WriteState.Start">
            <summary>
            A write method has not been called.
            </summary>
        </member>
        <member name="T:NPOI.DDF.DefaultEscherRecordFactory">
            <summary>
            Generates escher records when provided the byte array containing those records.
            @author Glen Stampoultzis
            @author Nick Burch   (nick at torchbox . com)
            </summary>
            <see cref="T:NPOI.DDF.EscherRecordFactory"/>
        </member>
        <member name="M:NPOI.DDF.DefaultEscherRecordFactory.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.DDF.DefaultEscherRecordFactory"/> class.
            </summary>
        </member>
        <member name="M:NPOI.DDF.DefaultEscherRecordFactory.CreateRecord(System.Byte[],System.Int32)">
            <summary>
            Generates an escher record including the any children contained under that record.
            An exception is thrown if the record could not be generated.
            </summary>
            <param name="data">The byte array containing the records</param>
            <param name="offset">The starting offset into the byte array</param>
            <returns>The generated escher record</returns>
        </member>
        <member name="M:NPOI.DDF.DefaultEscherRecordFactory.RecordsToMap(System.Type[])">
            <summary>
            Converts from a list of classes into a map that Contains the record id as the key and
            the Constructor in the value part of the map.  It does this by using reflection to look up
            the RECORD_ID field then using reflection again to find a reference to the constructor.
            </summary>
            <param name="records">The records to convert</param>
            <returns>The map containing the id/constructor pairs.</returns>
        </member>
        <member name="T:NPOI.DDF.EscherArrayProperty">
            <summary>
            Escher array properties are the most wierd construction ever invented
            with all sorts of special cases.  I'm hopeful I've got them all.
            @author Glen Stampoultzis (glens at superlinksoftware.com)
            </summary>
        </member>
        <member name="F:NPOI.DDF.EscherArrayProperty.FIXED_SIZE">
            The size of the header that goes at the
             start of the array, before the data
        </member>
        <member name="F:NPOI.DDF.EscherArrayProperty.sizeIncludesHeaderSize">
            Normally, the size recorded in the simple data (for the complex
             data) includes the size of the header.
            There are a few cases when it doesn't though...
        </member>
        <member name="F:NPOI.DDF.EscherArrayProperty.emptyComplexPart">
            When Reading a property from data stream remeber if the complex part is empty and Set this flag.
        </member>
        <member name="M:NPOI.DDF.EscherArrayProperty.GetElement(System.Int32)">
            <summary>
            Gets the element.
            </summary>
            <param name="index">The index.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.DDF.EscherArrayProperty.SetElement(System.Int32,System.Byte[])">
            <summary>
            Sets the element.
            </summary>
            <param name="index">The index.</param>
            <param name="element">The element.</param>
        </member>
        <member name="M:NPOI.DDF.EscherArrayProperty.ToString">
            <summary>
            Retrieves the string representation for this property.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NPOI.DDF.EscherArrayProperty.SetArrayData(System.Byte[],System.Int32)">
            <summary>
            We have this method because the way in which arrays in escher works
            is screwed for seemly arbitary reasons.  While most properties are
            fairly consistent and have a predictable array size, escher arrays
            have special cases.
            </summary>
            <param name="data">The data array containing the escher array information</param>
            <param name="offset">The offset into the array to start Reading from.</param>
            <returns>the number of bytes used by this complex property.</returns>
        </member>
        <member name="M:NPOI.DDF.EscherArrayProperty.SerializeSimplePart(System.Byte[],System.Int32)">
            <summary>
            Serializes the simple part of this property.  ie the first 6 bytes.
            Needs special code to handle the case when the size doesn't
            include the size of the header block
            </summary>
            <param name="data"></param>
            <param name="pos"></param>
            <returns></returns>
        </member>
        <member name="M:NPOI.DDF.EscherArrayProperty.GetActualSizeOfElements(System.Int16)">
            <summary>
            Sometimes the element size is stored as a negative number.  We
            negate it and shift it to Get the real value.
            </summary>
            <param name="sizeOfElements">The size of elements.</param>
            <returns></returns>
        </member>
        <member name="T:NPOI.DDF.EscherBitmapBlip">
            <summary>
            @author Glen Stampoultzis
            @version $Id: EscherBitmapBlip.java 569827 2007-08-26 15:26:29Z yegor $
            </summary>
        </member>
        <member name="M:NPOI.DDF.EscherBitmapBlip.FillFields(System.Byte[],System.Int32,NPOI.DDF.EscherRecordFactory)">
            <summary>
            This method deSerializes the record from a byte array.    
            </summary>
            <param name="data"> The byte array containing the escher record information</param>
            <param name="offset">The starting offset into </param>
            <param name="recordFactory">May be null since this is not a container record.</param>
            <returns>The number of bytes Read from the byte array.</returns>
        </member>
        <member name="M:NPOI.DDF.EscherBitmapBlip.Serialize(System.Int32,System.Byte[],NPOI.DDF.EscherSerializationListener)">
            <summary>
            Serializes the record to an existing byte array.
            </summary>
            <param name="offset">the offset within the byte array</param>
            <param name="data">the data array to Serialize to</param>
            <returns>the number of bytes written.</returns>
        </member>
        <member name="P:NPOI.DDF.EscherBitmapBlip.RecordSize">
            <summary>
            Returns the number of bytes that are required to Serialize this record.
            </summary>
            <value> Number of bytes</value>
        </member>
        <member name="P:NPOI.DDF.EscherBitmapBlip.UID">
            <summary>
            Gets or sets the UID.
            </summary>
            <value>The UID.</value>
        </member>
        <member name="P:NPOI.DDF.EscherBitmapBlip.Marker">
            <summary>
            Gets or sets the marker.
            </summary>
            <value>The marker.</value>
        </member>
        <member name="M:NPOI.DDF.EscherBitmapBlip.ToString">
            <summary>
            Toes the string.
            </summary>
            <returns></returns>
        </member>
        <member name="T:NPOI.DDF.EscherBlipRecord">
            <summary>
            @author Glen Stampoultzis
            @version $Id: EscherBlipRecord.java 569827 2007-08-26 15:26:29Z yegor $
            </summary>
        </member>
        <member name="M:NPOI.DDF.EscherBlipRecord.FillFields(System.Byte[],System.Int32,NPOI.DDF.EscherRecordFactory)">
            <summary>
            This method deSerializes the record from a byte array.
            </summary>
            <param name="data">The byte array containing the escher record information</param>
            <param name="offset">The starting offset into </param>
            <param name="recordFactory">May be null since this is not a container record.</param>
            <returns>The number of bytes Read from the byte array.</returns>
        </member>
        <member name="M:NPOI.DDF.EscherBlipRecord.Serialize(System.Int32,System.Byte[],NPOI.DDF.EscherSerializationListener)">
            <summary>
            Serializes the record to an existing byte array.
            </summary>
            <param name="offset"> the offset within the byte array</param>
            <param name="data">the data array to Serialize to</param>
            <returns>the number of bytes written.</returns>
        </member>
        <member name="P:NPOI.DDF.EscherBlipRecord.RecordSize">
            <summary>
            Returns the number of bytes that are required to Serialize this record.
            </summary>
            <value>Number of bytes</value>
        </member>
        <member name="P:NPOI.DDF.EscherBlipRecord.RecordName">
            <summary>
            The short name for this record
            </summary>
            <value></value>
        </member>
        <member name="P:NPOI.DDF.EscherBlipRecord.PictureData">
            <summary>
            Gets or sets the picture data.
            </summary>
            <value>The picture data.</value>
        </member>
        <member name="M:NPOI.DDF.EscherBlipRecord.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="T:NPOI.DDF.EscherBlipWMFRecord">
            <summary>
            The blip record is used to hold details about large binary objects that occur in escher such
            as JPEG, GIF, PICT and WMF files.  The contents of the stream is usually compressed.  Inflate
            can be used to decompress the data.
            @author Glen Stampoultzis
            </summary>
        </member>
        <member name="M:NPOI.DDF.EscherBlipWMFRecord.FillFields(System.Byte[],System.Int32,NPOI.DDF.EscherRecordFactory)">
            <summary>
            This method deserializes the record from a byte array.
            </summary>
            <param name="data">The byte array containing the escher record information</param>
            <param name="offset">The starting offset into</param>
            <param name="recordFactory">May be null since this is not a container record.</param>
            <returns>
            The number of bytes Read from the byte array.
            </returns>
        </member>
        <member name="M:NPOI.DDF.EscherBlipWMFRecord.Serialize(System.Int32,System.Byte[],NPOI.DDF.EscherSerializationListener)">
            <summary>
            This method Serializes this escher record into a byte array.
            @param offset   
            </summary>
            <param name="offset">The offset into data to start writing the record data to.</param>
            <param name="data">the data array to Serialize to</param>
            <returns>the number of bytes written.</returns>
        </member>
        <member name="P:NPOI.DDF.EscherBlipWMFRecord.RecordSize">
            <summary>
            Returns the number of bytes that are required to Serialize this record.
            </summary>
            <value>Number of bytes</value>
        </member>
        <member name="P:NPOI.DDF.EscherBlipWMFRecord.RecordName">
            <summary>
            The short name for this record
            </summary>
            <value></value>
        </member>
        <member name="P:NPOI.DDF.EscherBlipWMFRecord.SecondaryUID">
            <summary>
            Gets or sets the secondary UID.
            </summary>
            <value>The secondary UID.</value>
        </member>
        <member name="P:NPOI.DDF.EscherBlipWMFRecord.CacheOfSize">
            <summary>
            Gets or sets the size of the cache of.
            </summary>
            <value>The size of the cache of.</value>
        </member>
        <member name="P:NPOI.DDF.EscherBlipWMFRecord.BoundaryTop">
            <summary>
            Gets or sets the top boundary of the metafile drawing commands
            </summary>
            <value>The boundary top.</value>
        </member>
        <member name="P:NPOI.DDF.EscherBlipWMFRecord.BoundaryLeft">
            <summary>
            Gets or sets the left boundary of the metafile drawing commands
            </summary>
            <value>The boundary left.</value>
        </member>
        <member name="P:NPOI.DDF.EscherBlipWMFRecord.BoundaryWidth">
            <summary>
            Gets or sets the boundary width of the metafile drawing commands
            </summary>
            <value>The width of the boundary.</value>
        </member>
        <member name="P:NPOI.DDF.EscherBlipWMFRecord.BoundaryHeight">
            <summary>
            Gets or sets the boundary height of the metafile drawing commands
            </summary>
            <value>The height of the boundary.</value>
        </member>
        <member name="P:NPOI.DDF.EscherBlipWMFRecord.Width">
            <summary>
            Gets or sets the width of the metafile in EMU's (English Metric Units).
            </summary>
            <value>The width.</value>
        </member>
        <member name="P:NPOI.DDF.EscherBlipWMFRecord.Height">
            <summary>
            Gets or sets the height of the metafile in EMU's (English Metric Units).
            </summary>
            <value>The height.</value>
        </member>
        <member name="P:NPOI.DDF.EscherBlipWMFRecord.CacheOfSavedSize">
            <summary>
            Gets or sets the cache of the saved size
            </summary>
            <value>the cache of the saved size.</value>
        </member>
        <member name="P:NPOI.DDF.EscherBlipWMFRecord.CompressionFlag">
            <summary>
            Is the contents of the blip compressed?
            </summary>
            <value>The compression flag.</value>
        </member>
        <member name="P:NPOI.DDF.EscherBlipWMFRecord.Filter">
            <summary>
            Gets or sets the filter.
            </summary>
            <value>The filter.</value>
        </member>
        <member name="P:NPOI.DDF.EscherBlipWMFRecord.Data">
            <summary>
            Gets or sets The BLIP data
            </summary>
            <value>The data.</value>
        </member>
        <member name="M:NPOI.DDF.EscherBlipWMFRecord.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="M:NPOI.DDF.EscherBlipWMFRecord.Compress(System.Byte[])">
            <summary>
            Compress the contents of the provided array
            </summary>
            <param name="data">An uncompressed byte array</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.DDF.EscherBlipWMFRecord.Decompress(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Decompresses the specified data.
            </summary>
            <param name="data">The compressed byte array.</param>
            <param name="pos">The starting position into the byte array.</param>
            <param name="Length">The number of compressed bytes to decompress.</param>
            <returns>An uncompressed byte array</returns>
        </member>
        <member name="T:NPOI.DDF.EscherBoolProperty">
            <summary>
            Represents a bool property.  The actual utility of this property is in doubt because many
            of the properties marked as bool seem to actually contain special values.  In other words
            they're not true bools.
            @author Glen Stampoultzis
            </summary>
        </member>
        <member name="M:NPOI.DDF.EscherBoolProperty.#ctor(System.Int16,System.Int32)">
            <summary>
            Create an instance of an escher bool property.
            </summary>
            <param name="propertyNumber">The property number (or id)</param>
            <param name="value">The 32 bit value of this bool property</param>
        </member>
        <member name="P:NPOI.DDF.EscherBoolProperty.IsTrue">
            <summary>
            Whether this bool property is true
            </summary>
            <value><c>true</c> if this instance is true; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:NPOI.DDF.EscherBoolProperty.IsFalse">
            <summary>
            Whether this bool property is false
            </summary>
            <value><c>true</c> if this instance is false; otherwise, <c>false</c>.</value>
        </member>
        <member name="T:NPOI.DDF.EscherBSERecord">
            <summary>
            The BSE record is related closely to the EscherBlipRecord and stores
            extra information about the blip.  A blip record is actually stored inside
            the BSE record even though the BSE record isn't actually a container record.
            @author Glen Stampoultzis
            @see EscherBlipRecord
            </summary>
        </member>
        <member name="M:NPOI.DDF.EscherBSERecord.FillFields(System.Byte[],System.Int32,NPOI.DDF.EscherRecordFactory)">
            <summary>
            This method deSerializes the record from a byte array.
            </summary>
            <param name="data">The byte array containing the escher record information</param>
            <param name="offset">The starting offset into data</param>
            <param name="recordFactory">May be null since this is not a container record.</param>
            <returns>The number of bytes Read from the byte array.</returns>
        </member>
        <member name="M:NPOI.DDF.EscherBSERecord.Serialize(System.Int32,System.Byte[],NPOI.DDF.EscherSerializationListener)">
            <summary>
            This method Serializes this escher record into a byte array.  
            </summary>
            <param name="offset">The offset into 
            data to start writing the record data to</param>
            <param name="data">The byte array to Serialize to.</param>
            <returns>The number of bytes written.</returns>
        </member>
        <member name="P:NPOI.DDF.EscherBSERecord.RecordSize">
            <summary>
            Returns the number of bytes that are required to Serialize this record.
            </summary>
            <value>Number of bytes</value>
        </member>
        <member name="P:NPOI.DDF.EscherBSERecord.RecordName">
            <summary>
            The short name for this record
            </summary>
            <value></value>
        </member>
        <member name="P:NPOI.DDF.EscherBSERecord.BlipTypeWin32">
            <summary>
            Gets or sets the expected blip type under windows (failure to match this blip type will result in
            Excel converting to this format).
            </summary>
            <value>The blip type win32.</value>
        </member>
        <member name="P:NPOI.DDF.EscherBSERecord.BlipTypeMacOS">
            <summary>
            Gets or sets the expected blip type under MacOS (failure to match this blip type will result in
            Excel converting to this format).
            </summary>
            <value>The blip type mac OS.</value>
        </member>
        <member name="P:NPOI.DDF.EscherBSERecord.UID">
            <summary>
            Gets or sets 16 byte MD4 checksum.
            </summary>
            <value>The UID.</value>
        </member>
        <member name="P:NPOI.DDF.EscherBSERecord.Tag">
            <summary>
            Gets or sets the tag. (Unused)
            </summary>
            <value>The tag.</value>
        </member>
        <member name="P:NPOI.DDF.EscherBSERecord.Size">
            <summary>
            Gets or sets Blip size in stream..
            </summary>
            <value>The size.</value>
        </member>
        <member name="P:NPOI.DDF.EscherBSERecord.Ref">
            <summary>
            Gets or sets the reference count of this blip.
            </summary>
            <value>The ref.</value>
        </member>
        <member name="P:NPOI.DDF.EscherBSERecord.Offset">
            <summary>
            Gets or sets the offset in the delay stream..
            </summary>
            <value>The offset.</value>
        </member>
        <member name="P:NPOI.DDF.EscherBSERecord.Usage">
            <summary>
            Defines the way this blip is used.
            </summary>
            <value>The usage.</value>
        </member>
        <member name="P:NPOI.DDF.EscherBSERecord.Name">
            <summary>
            Gets or sets the blip name.
            </summary>
            <value>The name.</value>
        </member>
        <member name="P:NPOI.DDF.EscherBSERecord.Unused2">
            <summary>
            Gets or sets the unused2.
            </summary>
            <value>The unused2.</value>
        </member>
        <member name="P:NPOI.DDF.EscherBSERecord.Unused3">
            <summary>
            Gets or sets the unused3.
            </summary>
            <value>The unused3.</value>
        </member>
        <member name="P:NPOI.DDF.EscherBSERecord.BlipRecord">
            <summary>
            Gets or sets the blip record.
            </summary>
            <value>The blip record.</value>
        </member>
        <member name="P:NPOI.DDF.EscherBSERecord.RemainingData">
            <summary>
            Gets or sets any remaining data in this record.
            </summary>
            <value>The remaining data.</value>
        </member>
        <member name="M:NPOI.DDF.EscherBSERecord.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="M:NPOI.DDF.EscherBSERecord.GetBlipType(System.Byte)">
            <summary>
            Retrieve the string representation given a blip id.
            </summary>
            <param name="b">The b.</param>
            <returns></returns>
        </member>
        <member name="T:NPOI.DDF.EscherChildAnchorRecord">
            <summary>
            The escher child achor record is used to specify the position of a shape under an
            existing group.  The first level of shape records use a EscherClientAnchor record instead.
            @author Glen Stampoultzis
            </summary>
        </member>
        <member name="M:NPOI.DDF.EscherChildAnchorRecord.FillFields(System.Byte[],System.Int32,NPOI.DDF.EscherRecordFactory)">
            <summary>
            This method deSerializes the record from a byte array.
            </summary>
            <param name="data">The byte array containing the escher record information</param>
            <param name="offset">The starting offset into data</param>
            <param name="recordFactory">May be null since this is not a container record.</param>
            <returns>The number of bytes Read from the byte array.</returns>
        </member>
        <member name="M:NPOI.DDF.EscherChildAnchorRecord.Serialize(System.Int32,System.Byte[],NPOI.DDF.EscherSerializationListener)">
            <summary>
            This method Serializes this escher record into a byte array.
            </summary>
            <param name="offset">The offset into data to start writing the record data to.</param>
            <param name="data">The byte array to Serialize to.</param>
            <returns>The number of bytes written.</returns>
        </member>
        <member name="P:NPOI.DDF.EscherChildAnchorRecord.RecordSize">
            <summary>
            Returns the number of bytes that are required to Serialize this record.
            </summary>
            <value>Number of bytes</value>
        </member>
        <member name="P:NPOI.DDF.EscherChildAnchorRecord.RecordId">
            <summary>
            The record id for the EscherChildAnchorRecord.
            </summary>
            <value></value>
        </member>
        <member name="P:NPOI.DDF.EscherChildAnchorRecord.RecordName">
            <summary>
            The short name for this record
            </summary>
            <value></value>
        </member>
        <member name="M:NPOI.DDF.EscherChildAnchorRecord.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="P:NPOI.DDF.EscherChildAnchorRecord.Dx1">
            <summary>
            Gets or sets offset within the parent coordinate space for the top left point.
            </summary>
            <value>The DX1.</value>
        </member>
        <member name="P:NPOI.DDF.EscherChildAnchorRecord.Dy1">
            <summary>
            Gets or sets the offset within the parent coordinate space for the top left point.
            </summary>
            <value>The dy1.</value>
        </member>
        <member name="P:NPOI.DDF.EscherChildAnchorRecord.Dx2">
            <summary>
            Gets or sets the offset within the parent coordinate space for the bottom right point.
            </summary>
            <value>The DX2.</value>
        </member>
        <member name="P:NPOI.DDF.EscherChildAnchorRecord.Dy2">
            <summary>
            Gets or sets the offset within the parent coordinate space for the bottom right point.
            </summary>
            <value>The dy2.</value>
        </member>
        <member name="T:NPOI.DDF.EscherClientAnchorRecord">
            <summary>
            The escher client anchor specifies which rows and cells the shape is bound to as well as
            the offsets within those cells.  Each cell is 1024 units wide by 256 units long regardless
            of the actual size of the cell.  The EscherClientAnchorRecord only applies to the top-most
            shapes.  Shapes contained in groups are bound using the EscherChildAnchorRecords.
            @author Glen Stampoultzis
            </summary>
        </member>
        <member name="M:NPOI.DDF.EscherClientAnchorRecord.FillFields(System.Byte[],System.Int32,NPOI.DDF.EscherRecordFactory)">
            <summary>
            This method deSerializes the record from a byte array.
            </summary>
            <param name="data">The byte array containing the escher record information</param>
            <param name="offset">The starting offset into data</param>
            <param name="recordFactory">May be null since this is not a container record.</param>
            <returns>The number of bytes Read from the byte array.</returns>
        </member>
        <member name="M:NPOI.DDF.EscherClientAnchorRecord.Serialize(System.Int32,System.Byte[],NPOI.DDF.EscherSerializationListener)">
            <summary>
            This method Serializes this escher record into a byte array.
            </summary>
            <param name="offset">The offset into data to start writing the record data to.</param>
            <param name="data">The byte array to Serialize to.</param>
            <returns>The number of bytes written.</returns>
        </member>
        <member name="P:NPOI.DDF.EscherClientAnchorRecord.RecordSize">
            <summary>
            Returns the number of bytes that are required to Serialize this record.
            </summary>
            <value>Number of bytes</value>
        </member>
        <member name="P:NPOI.DDF.EscherClientAnchorRecord.RecordId">
            <summary>
            The record id for this record.
            </summary>
            <value></value>
        </member>
        <member name="P:NPOI.DDF.EscherClientAnchorRecord.RecordName">
            <summary>
            The short name for this record
            </summary>
            <value></value>
        </member>
        <member name="M:NPOI.DDF.EscherClientAnchorRecord.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="P:NPOI.DDF.EscherClientAnchorRecord.Flag">
            <summary>
            Gets or sets the flag.
            </summary>
            <value>0 = Move and size with Cells, 2 = Move but don't size with cells, 3 = Don't move or size with cells.</value>
        </member>
        <member name="P:NPOI.DDF.EscherClientAnchorRecord.Col1">
            <summary>
            Gets or sets The column number for the top-left position.  0 based.
            </summary>
            <value>The col1.</value>
        </member>
        <member name="P:NPOI.DDF.EscherClientAnchorRecord.Dx1">
            <summary>
            Gets or sets The x offset within the top-left cell.  Range is from 0 to 1023.
            </summary>
            <value>The DX1.</value>
        </member>
        <member name="P:NPOI.DDF.EscherClientAnchorRecord.Row1">
            <summary>
            Gets or sets The row number for the top-left corner of the shape.
            </summary>
            <value>The row1.</value>
        </member>
        <member name="P:NPOI.DDF.EscherClientAnchorRecord.Dy1">
            <summary>
            Gets or sets The y offset within the top-left corner of the current shape.
            </summary>
            <value>The dy1.</value>
        </member>
        <member name="P:NPOI.DDF.EscherClientAnchorRecord.Col2">
            <summary>
            Gets or sets The column of the bottom right corner of this shape.
            </summary>
            <value>The col2.</value>
        </member>
        <member name="P:NPOI.DDF.EscherClientAnchorRecord.Dx2">
            <summary>
            Gets or sets The x offset withing the cell for the bottom-right corner of this shape.
            </summary>
            <value>The DX2.</value>
        </member>
        <member name="P:NPOI.DDF.EscherClientAnchorRecord.Row2">
            <summary>
            Gets or sets The row number for the bottom-right corner of the current shape.
            </summary>
            <value>The row2.</value>
        </member>
        <member name="P:NPOI.DDF.EscherClientAnchorRecord.Dy2">
            <summary>
            Gets or sets The y offset withing the cell for the bottom-right corner of this shape.
            </summary>
            <value>The dy2.</value>
        </member>
        <member name="P:NPOI.DDF.EscherClientAnchorRecord.RemainingData">
            <summary>
            Gets or sets the remaining data.
            </summary>
            <value>The remaining data.</value>
        </member>
        <member name="T:NPOI.DDF.EscherClientDataRecord">
            <summary>
            The EscherClientDataRecord is used to store client specific data about the position of a
            shape within a container.
            @author Glen Stampoultzis
            </summary>
        </member>
        <member name="M:NPOI.DDF.EscherClientDataRecord.FillFields(System.Byte[],System.Int32,NPOI.DDF.EscherRecordFactory)">
            <summary>
            This method deSerializes the record from a byte array.
            </summary>
            <param name="data">The byte array containing the escher record information</param>
            <param name="offset">The starting offset into data</param>
            <param name="recordFactory">May be null since this is not a container record.</param>
            <returns>The number of bytes Read from the byte array.</returns>
        </member>
        <member name="M:NPOI.DDF.EscherClientDataRecord.Serialize(System.Int32,System.Byte[],NPOI.DDF.EscherSerializationListener)">
             This method Serializes this escher record into a byte array.
            
             @param offset   The offset into <c>data</c> to start writing the record data to.
             @param data     The byte array to Serialize to.
             @param listener A listener to retrieve start and end callbacks.  Use a <c>NullEscherSerailizationListener</c> to ignore these events.
             @return The number of bytes written.
             @see NullEscherSerializationListener
        </member>
        <member name="P:NPOI.DDF.EscherClientDataRecord.RecordSize">
             Returns the number of bytes that are required to Serialize this record.
            
             @return Number of bytes
        </member>
        <member name="P:NPOI.DDF.EscherClientDataRecord.RecordId">
            Returns the identifier of this record.
        </member>
        <member name="P:NPOI.DDF.EscherClientDataRecord.RecordName">
            The short name for this record
        </member>
        <member name="M:NPOI.DDF.EscherClientDataRecord.ToString">
            Returns the string representation of this record.
        </member>
        <member name="P:NPOI.DDF.EscherClientDataRecord.RemainingData">
            Any data recording this record.
        </member>
        <member name="T:NPOI.DDF.EscherComplexProperty">
            <summary>
            A complex property differs from a simple property in that the data can not fit inside a 32 bit
            integer.  See the specification for more detailed information regarding exactly what is
            stored here.
            @author Glen Stampoultzis
            </summary>
        </member>
        <member name="M:NPOI.DDF.EscherComplexProperty.#ctor(System.Int16,System.Byte[])">
            <summary>
            Create a complex property using the property id and a byte array containing the complex
            data value.
            </summary>
            <param name="id"> The id consists of the property number, a flag indicating whether this is a blip id and a flag
            indicating that this is a complex property.</param>
            <param name="complexData">The value of this property.</param>
        </member>
        <member name="M:NPOI.DDF.EscherComplexProperty.#ctor(System.Int16,System.Boolean,System.Byte[])">
            <summary>
            Create a complex property using the property number, a flag to indicate whether this is a
            blip reference and the complex property data.
            </summary>
            <param name="propertyNumber">The property number.</param>
            <param name="isBlipId">Whether this is a blip id.  Should be false.</param>
            <param name="complexData">The value of this complex property.</param> 
        </member>
        <member name="M:NPOI.DDF.EscherComplexProperty.SerializeSimplePart(System.Byte[],System.Int32)">
            <summary>
            Serializes the simple part of this property.  ie the first 6 bytes.
            </summary>
            <param name="data"></param>
            <param name="pos"></param>
            <returns></returns>
        </member>
        <member name="M:NPOI.DDF.EscherComplexProperty.SerializeComplexPart(System.Byte[],System.Int32)">
            <summary>
            Serializes the complex part of this property
            </summary>
            <param name="data">The data array to Serialize to</param>
            <param name="pos">The offset within data to start serializing to.</param>
            <returns>The number of bytes Serialized.</returns>
        </member>
        <member name="P:NPOI.DDF.EscherComplexProperty.ComplexData">
            <summary>
            Gets the complex data.
            </summary>
            <value>The complex data.</value>
        </member>
        <member name="M:NPOI.DDF.EscherComplexProperty.Equals(System.Object)">
            <summary>
            Determine whether this property is equal to another property.
            </summary>
            <param name="o">The object to compare to.</param>
            <returns>True if the objects are equal.</returns>
        </member>
        <member name="P:NPOI.DDF.EscherComplexProperty.PropertySize">
            <summary>
            Caclulates the number of bytes required to Serialize this property.
            </summary>
            <value>Number of bytes</value>
        </member>
        <member name="M:NPOI.DDF.EscherComplexProperty.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="M:NPOI.DDF.EscherComplexProperty.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="T:NPOI.DDF.EscherContainerRecord">
            <summary>
            Escher container records store other escher records as children.
            The container records themselves never store any information beyond
            the standard header used by all escher records.  This one record is
            used to represent many different types of records.
            @author Glen Stampoultzis
            </summary>
        </member>
        <member name="M:NPOI.DDF.EscherContainerRecord.FillFields(System.Byte[],System.Int32,NPOI.DDF.EscherRecordFactory)">
            <summary>
            The contract of this method is to deSerialize an escher record including
            it's children.
            </summary>
            <param name="data">The byte array containing the Serialized escher
            records.</param>
            <param name="offset">The offset into the byte array.</param>
            <param name="recordFactory">A factory for creating new escher records</param>
            <returns>The number of bytes written.</returns>        
        </member>
        <member name="M:NPOI.DDF.EscherContainerRecord.Serialize(System.Int32,System.Byte[],NPOI.DDF.EscherSerializationListener)">
            <summary>
            Serializes to an existing byte array without serialization listener.
            This is done by delegating to Serialize(int, byte[], EscherSerializationListener).
            </summary>
            <param name="offset">the offset within the data byte array.</param>
            <param name="data"> the data array to Serialize to.</param>
            <returns>The number of bytes written.</returns>
        </member>
        <member name="P:NPOI.DDF.EscherContainerRecord.RecordSize">
            <summary>
            Subclasses should effeciently return the number of bytes required to
            Serialize the record.
            </summary>
            <value>number of bytes</value>
        </member>
        <member name="M:NPOI.DDF.EscherContainerRecord.HasChildOfType(System.Int16)">
            <summary>
            Do any of our (top level) children have the
            given recordId?
            </summary>
            <param name="recordId">The record id.</param>
            <returns>
            	<c>true</c> if [has child of type] [the specified record id]; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="P:NPOI.DDF.EscherContainerRecord.ChildRecords">
            <summary>
            Returns a list of all the child (escher) records
            of the container.
            </summary>
            <value></value>
        </member>
        <member name="P:NPOI.DDF.EscherContainerRecord.ChildContainers">
            <summary>
            Returns all of our children which are also
            EscherContainers (may be 0, 1, or vary rarely
            2 or 3)
            </summary>
            <value>The child containers.</value>
        </member>
        <member name="P:NPOI.DDF.EscherContainerRecord.RecordName">
            <summary>
            Subclasses should return the short name for this escher record.
            </summary>
            <value></value>
        </member>
        <member name="M:NPOI.DDF.EscherContainerRecord.Display(System.Int32)">
            <summary>
            The display methods allows escher variables to print the record names
            according to their hierarchy.
            </summary>
            <param name="indent">The current indent level.</param> 
        </member>
        <member name="M:NPOI.DDF.EscherContainerRecord.AddChildRecord(NPOI.DDF.EscherRecord)">
            <summary>
            Adds the child record.
            </summary>
            <param name="record">The record.</param>
        </member>
        <member name="M:NPOI.DDF.EscherContainerRecord.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="M:NPOI.DDF.EscherContainerRecord.ToString(System.String)">
            <summary>
            Toes the string.
            </summary>
            <param name="indent">The indent.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.DDF.EscherContainerRecord.GetChildById(System.Int16)">
            <summary>
            Gets the child by id.
            </summary>
            <param name="recordId">The record id.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.DDF.EscherContainerRecord.GetRecordsById(System.Int16,System.Collections.ArrayList@)">
            <summary>
            Recursively find records with the specified record ID
            </summary>
            <param name="recordId"></param>
            <param name="out1">list to store found records</param>
        </member>
        <member name="T:NPOI.DDF.EscherDggRecord">
            <summary>
            This record defines the drawing groups used for a particular sheet.
            </summary>
        </member>
        <member name="M:NPOI.DDF.EscherDggRecord.FillFields(System.Byte[],System.Int32,NPOI.DDF.EscherRecordFactory)">
            <summary>
            This method deSerializes the record from a byte array.
            </summary>
            <param name="data">The byte array containing the escher record information</param>
            <param name="offset">The starting offset into data</param>
            <param name="recordFactory">May be null since this is not a container record.</param>
            <returns>The number of bytes Read from the byte array.</returns>
        </member>
        <member name="M:NPOI.DDF.EscherDggRecord.Serialize(System.Int32,System.Byte[],NPOI.DDF.EscherSerializationListener)">
            <summary>
            This method Serializes this escher record into a byte array.
            </summary>
            <param name="offset">The offset into data to start writing the record data to.</param>
            <param name="data">The byte array to Serialize to.</param>
            <returns>The number of bytes written.</returns>
        </member>
        <member name="P:NPOI.DDF.EscherDggRecord.RecordSize">
            <summary>
            Returns the number of bytes that are required to Serialize this record.
            </summary>
            <value>Number of bytes</value>
        </member>
        <member name="P:NPOI.DDF.EscherDggRecord.RecordId">
            <summary>
            Return the current record id.
            </summary>
            <value>The 16 bit record id.</value>
        </member>
        <member name="P:NPOI.DDF.EscherDggRecord.RecordName">
            <summary>
            The short name for this record
            </summary>
            <value></value>
        </member>
        <member name="M:NPOI.DDF.EscherDggRecord.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="P:NPOI.DDF.EscherDggRecord.ShapeIdMax">
            <summary>
            Gets or sets the shape id max.
            </summary>
            <value>The shape id max.</value>
        </member>
        <member name="P:NPOI.DDF.EscherDggRecord.NumIdClusters">
            <summary>
            Gets the Number of id clusters + 1
            </summary>
            <value>The num id clusters.</value>
        </member>
        <member name="P:NPOI.DDF.EscherDggRecord.NumShapesSaved">
            <summary>
            Gets or sets the num shapes saved.
            </summary>
            <value>The num shapes saved.</value>
        </member>
        <member name="P:NPOI.DDF.EscherDggRecord.DrawingsSaved">
            <summary>
            Gets or sets the drawings saved.
            </summary>
            <value>The drawings saved.</value>
        </member>
        <member name="P:NPOI.DDF.EscherDggRecord.MaxDrawingGroupId">
            <summary>
            Gets or sets the max drawing group id.
            </summary>
            <value>The max drawing group id.</value>
        </member>
        <member name="P:NPOI.DDF.EscherDggRecord.FileIdClusters">
            <summary>
            Gets or sets the file id clusters.
            </summary>
            <value>The file id clusters.</value>
        </member>
        <member name="M:NPOI.DDF.EscherDggRecord.AddCluster(System.Int32,System.Int32)">
            <summary>
            Adds the cluster.
            </summary>
            <param name="dgId">The dg id.</param>
            <param name="numShapedUsed">The num shaped used.</param>
        </member>
        <member name="M:NPOI.DDF.EscherDggRecord.AddCluster(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Adds the cluster.
            </summary>
            <param name="dgId">id of the drawing group (stored in the record options)</param>
            <param name="numShapedUsed">initial value of the numShapedUsed field</param>
            <param name="sort">if set to <c>true</c> if true then sort clusters by drawing group id.(
            In Excel the clusters are sorted but in PPT they are not).</param>
        </member>
        <member name="T:NPOI.DDF.EscherDgRecord">
            <summary>
            This record simply holds the number of shapes in the drawing group and the
            last shape id used for this drawing group.
            @author Glen Stampoultzis
            </summary>
        </member>
        <member name="M:NPOI.DDF.EscherDgRecord.FillFields(System.Byte[],System.Int32,NPOI.DDF.EscherRecordFactory)">
            <summary>
            This method deSerializes the record from a byte array.
            </summary>
            <param name="data">The byte array containing the escher record information</param>
            <param name="offset">The starting offset into data</param>
            <param name="recordFactory">May be null since this is not a container record.</param>
            <returns>The number of bytes Read from the byte array.</returns>
        </member>
        <member name="M:NPOI.DDF.EscherDgRecord.Serialize(System.Int32,System.Byte[],NPOI.DDF.EscherSerializationListener)">
            <summary>
            This method Serializes this escher record into a byte array.
            </summary>
            <param name="offset"> The offset into data to start writing the record data to.</param>
            <param name="data"> The byte array to Serialize to.</param>
            <returns>The number of bytes written.</returns>
        </member>
        <member name="P:NPOI.DDF.EscherDgRecord.RecordSize">
            <summary>
            Returns the number of bytes that are required to Serialize this record.
            </summary>
            <value>Number of bytes</value>
        </member>
        <member name="P:NPOI.DDF.EscherDgRecord.RecordId">
            <summary>
            Return the current record id.
            </summary>
            <value>The 16 bit record id.</value>
        </member>
        <member name="P:NPOI.DDF.EscherDgRecord.RecordName">
            <summary>
             The short name for this record
            </summary>
            <value></value>
        </member>
        <member name="M:NPOI.DDF.EscherDgRecord.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="P:NPOI.DDF.EscherDgRecord.NumShapes">
            <summary>
            Gets or sets The number of shapes in this drawing group.
            </summary>
            <value>The num shapes.</value>
        </member>
        <member name="P:NPOI.DDF.EscherDgRecord.LastMSOSPID">
            <summary>
            Gets or sets The last shape id used in this drawing group.
            </summary>
            <value>The last MSOSPID.</value>
        </member>
        <member name="P:NPOI.DDF.EscherDgRecord.DrawingGroupId">
            <summary>
            Gets the drawing group id for this record.  This is encoded in the
            instance part of the option record.
            </summary>
            <value>The drawing group id.</value>
        </member>
        <member name="M:NPOI.DDF.EscherDgRecord.IncrementShapeCount">
            <summary>
            Increments the shape count.
            </summary>
        </member>
        <member name="T:NPOI.DDF.EscherDump">
            <summary>
            Used to dump the contents of escher records to a PrintStream.
            @author Glen Stampoultzis (glens at apache.org)
            </summary>
        </member>
        <member name="M:NPOI.DDF.EscherDump.Dump(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Decodes the escher stream from a byte array and dumps the results to
            a print stream.
            </summary>
            <param name="data">The data array containing the escher records.</param>
            <param name="offset">The starting offset within the data array.</param>
            <param name="size">The number of bytes to Read.</param>
        </member>
        <member name="M:NPOI.DDF.EscherDump.DumpOld(System.Int64,System.IO.Stream)">
            <summary>
            This version of dump is a translation from the open office escher dump routine.
            </summary>
            <param name="maxLength">The number of bytes to Read</param>
            <param name="in1">An input stream to Read from.</param>
        </member>
        <member name="M:NPOI.DDF.EscherDump.PropertyName(System.Int16)">
            <summary>
            Returns a property name given a property id.  This is used only by the
            old escher dump routine.
            </summary>
            <param name="propertyId">The property number for the name</param>
            <returns>A descriptive name.</returns>
        </member>
        <member name="M:NPOI.DDF.EscherDump.GetBlipType(System.Byte)">
            <summary>
            Returns the blip description given a blip id.
            </summary>
            <param name="b">blip id</param>
            <returns> A description.</returns>
        </member>
        <member name="M:NPOI.DDF.EscherDump.Dec1616(System.Int32)">
            <summary>
            Straight conversion from OO.  Converts a type of float.
            </summary>
            <param name="n32">The N32.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.DDF.EscherDump.OutHex(System.Int32,System.IO.Stream)">
            <summary>
            Dumps out a hex value by Reading from a input stream.
            </summary>
            <param name="bytes">How many bytes this hex value consists of.</param>
            <param name="in1">The stream to Read the hex value from.</param>
        </member>
        <member name="M:NPOI.DDF.EscherDump.Dump(System.Int32,System.Byte[])">
            <summary>
            Dumps the specified record size.
            </summary>
            <param name="recordSize">Size of the record.</param>
            <param name="data">The data.</param>
        </member>
        <member name="T:NPOI.DDF.EscherMetafileBlip">
            <summary>
            @author Daniel Noll
            </summary>
        </member>
        <member name="F:NPOI.DDF.EscherMetafileBlip.SIGNATURE_EMF">
            BLIP signatures as defined in the escher spec
        </member>
        <member name="F:NPOI.DDF.EscherMetafileBlip.field_2_UID">
            The primary UID is only saved to disk if (blip_instance ^ blip_signature == 1)
        </member>
        <member name="M:NPOI.DDF.EscherMetafileBlip.FillFields(System.Byte[],System.Int32,NPOI.DDF.EscherRecordFactory)">
            <summary>
            This method deSerializes the record from a byte array.
            </summary>
            <param name="data">The byte array containing the escher record information</param>
            <param name="offset">The starting offset into</param>
            <param name="recordFactory">May be null since this is not a container record.</param>
            <returns>
            The number of bytes Read from the byte array.
            </returns>
        </member>
        <member name="M:NPOI.DDF.EscherMetafileBlip.Serialize(System.Int32,System.Byte[],NPOI.DDF.EscherSerializationListener)">
            <summary>
            Serializes the record to an existing byte array.
            </summary>
            <param name="offset">the offset within the byte array</param>
            <param name="data">the data array to Serialize to</param>
            <returns>the number of bytes written.</returns>
        </member>
        <member name="M:NPOI.DDF.EscherMetafileBlip.InflatePictureData(System.Byte[])">
            <summary>
            Decompresses the provided data, returning the inflated result.
            </summary>
            <param name="data">the deflated picture data.</param>
            <returns>the inflated picture data.</returns>
        </member>
        <member name="P:NPOI.DDF.EscherMetafileBlip.RecordSize">
            <summary>
            Returns the number of bytes that are required to Serialize this record.
            </summary>
            <value>Number of bytes</value>
        </member>
        <member name="P:NPOI.DDF.EscherMetafileBlip.UID">
            <summary>
            Gets or sets the UID.
            </summary>
            <value>The UID.</value>
        </member>
        <member name="P:NPOI.DDF.EscherMetafileBlip.PrimaryUID">
            <summary>
            Gets or sets the primary UID.
            </summary>
            <value>The primary UID.</value>
        </member>
        <member name="P:NPOI.DDF.EscherMetafileBlip.UncompressedSize">
            <summary>
            Gets or sets the size of the uncompressed.
            </summary>
            <value>The size of the uncompressed.</value>
        </member>
        <member name="P:NPOI.DDF.EscherMetafileBlip.Bounds">
            <summary>
            Gets or sets the bounds.
            </summary>
            <value>The bounds.</value>
        </member>
        <member name="P:NPOI.DDF.EscherMetafileBlip.SizeEMU">
            <summary>
            Gets or sets the size EMU.
            </summary>
            <value>The size EMU.</value>
        </member>
        <member name="P:NPOI.DDF.EscherMetafileBlip.CompressedSize">
            <summary>
            Gets or sets the size of the compressed.
            </summary>
            <value>The size of the compressed.</value>
        </member>
        <member name="P:NPOI.DDF.EscherMetafileBlip.IsCompressed">
            <summary>
            Gets or sets a value indicating whether this instance is compressed.
            </summary>
            <value>
            	<c>true</c> if this instance is compressed; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:NPOI.DDF.EscherMetafileBlip.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="P:NPOI.DDF.EscherMetafileBlip.Signature">
            <summary>
            Return the blip signature
            </summary>
            <value>the blip signature</value>
        </member>
        <member name="T:NPOI.DDF.EscherOptRecord">
            <summary>
            The opt record is used to store property values for a shape.  It is the key to determining
            the attributes of a shape.  Properties can be of two types: simple or complex.  Simple types
            are fixed Length.  Complex properties are variable Length.
            @author Glen Stampoultzis
            </summary>
        </member>
        <member name="M:NPOI.DDF.EscherOptRecord.FillFields(System.Byte[],System.Int32,NPOI.DDF.EscherRecordFactory)">
            <summary>
            This method deSerializes the record from a byte array.
            </summary>
            <param name="data">The byte array containing the escher record information</param>
            <param name="offset">The starting offset into data</param>
            <param name="recordFactory">May be null since this is not a container record.</param>
            <returns>The number of bytes Read from the byte array.</returns>
        </member>
        <member name="M:NPOI.DDF.EscherOptRecord.Serialize(System.Int32,System.Byte[],NPOI.DDF.EscherSerializationListener)">
            <summary>
            This method Serializes this escher record into a byte array
            </summary>
            <param name="offset">The offset into data
             to start writing the record data to.</param>
            <param name="data">The byte array to Serialize to.</param>
            <returns>The number of bytes written.</returns>
        </member>
        <member name="P:NPOI.DDF.EscherOptRecord.RecordSize">
            <summary>
            Returns the number of bytes that are required to Serialize this record.
            </summary>
            <value>Number of bytes</value>
        </member>
        <member name="P:NPOI.DDF.EscherOptRecord.Options">
            <summary>
            Automatically recalculate the correct option
            </summary>
            <value></value>
        </member>
        <member name="P:NPOI.DDF.EscherOptRecord.RecordName">
            <summary>
            The short name for this record
            </summary>
            <value></value>
        </member>
        <member name="P:NPOI.DDF.EscherOptRecord.PropertiesSize">
            <summary>
            Gets the size of the properties.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NPOI.DDF.EscherOptRecord.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="P:NPOI.DDF.EscherOptRecord.EscherProperties">
            <summary>
            The list of properties stored by this record.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NPOI.DDF.EscherOptRecord.GetEscherProperty(System.Int32)">
            <summary>
            The list of properties stored by this record.
            </summary>
            <param name="index">The index.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.DDF.EscherOptRecord.AddEscherProperty(NPOI.DDF.EscherProperty)">
            <summary>
            Add a property to this record.
            </summary>
            <param name="prop">The prop.</param>
        </member>
        <member name="M:NPOI.DDF.EscherOptRecord.SortProperties">
            <summary>
            Records should be sorted by property number before being stored.
            </summary>
        </member>
        <member name="T:NPOI.DDF.EscherPictBlip">
            <summary>
            @author Daniel Noll
            </summary>
        </member>
        <member name="M:NPOI.DDF.EscherPictBlip.FillFields(System.Byte[],System.Int32,NPOI.DDF.EscherRecordFactory)">
            <summary>
            This method deSerializes the record from a byte array.
            </summary>
            <param name="data">The byte array containing the escher record information</param>
            <param name="offset">The starting offset into</param>
            <param name="recordFactory">May be null since this is not a container record.</param>
            <returns>
            The number of bytes Read from the byte array.
            </returns>
        </member>
        <member name="M:NPOI.DDF.EscherPictBlip.Serialize(System.Int32,System.Byte[],NPOI.DDF.EscherSerializationListener)">
            <summary>
            Serializes the record to an existing byte array.
            </summary>
            <param name="offset">the offset within the byte array</param>
            <param name="data">the data array to Serialize to</param>
            <returns>the number of bytes written.</returns>
        </member>
        <member name="M:NPOI.DDF.EscherPictBlip.InflatePictureData(System.Byte[])">
            <summary>
            Decompresses the provided data, returning the inflated result.
            </summary>
            <param name="data">the deflated picture data.</param>
            <returns>the inflated picture data.</returns>
        </member>
        <member name="P:NPOI.DDF.EscherPictBlip.RecordSize">
            <summary>
            Returns the number of bytes that are required to Serialize this record.
            </summary>
            <value>Number of bytes</value>
        </member>
        <member name="P:NPOI.DDF.EscherPictBlip.UID">
            <summary>
            Gets or sets the UID.
            </summary>
            <value>The UID.</value>
        </member>
        <member name="P:NPOI.DDF.EscherPictBlip.UncompressedSize">
            <summary>
            Gets or sets the size of the uncompressed.
            </summary>
            <value>The size of the uncompressed.</value>
        </member>
        <member name="P:NPOI.DDF.EscherPictBlip.Bounds">
            <summary>
            Gets or sets the bounds.
            </summary>
            <value>The bounds.</value>
        </member>
        <member name="P:NPOI.DDF.EscherPictBlip.SizeEMU">
            <summary>
            Gets or sets the size EMU.
            </summary>
            <value>The size EMU.</value>
        </member>
        <member name="P:NPOI.DDF.EscherPictBlip.CompressedSize">
            <summary>
            Gets or sets the size of the compressed.
            </summary>
            <value>The size of the compressed.</value>
        </member>
        <member name="P:NPOI.DDF.EscherPictBlip.IsCompressed">
            <summary>
            Gets a value indicating whether this instance is compressed.
            </summary>
            <value>
            	<c>true</c> if this instance is compressed; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:NPOI.DDF.EscherPictBlip.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="T:NPOI.DDF.EscherProperties">
            <summary>
            Provides a list of all known escher properties including the description and
            type.
            @author Glen Stampoultzis (glens at apache.org)
            </summary>
        </member>
        <member name="M:NPOI.DDF.EscherProperties.InitProps">
            <summary>
            Inits the props.
            </summary>
        </member>
        <member name="M:NPOI.DDF.EscherProperties.AddProp(System.Int32,NPOI.DDF.EscherPropertyMetaData)">
            <summary>
            Adds the prop.
            </summary>
            <param name="s">The s.</param>
            <param name="data">The data.</param>
        </member>
        <member name="M:NPOI.DDF.EscherProperties.GetData(System.String,System.Byte)">
            <summary>
            Gets the data.
            </summary>
            <param name="propName">Name of the prop.</param>
            <param name="type">The type.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.DDF.EscherProperties.GetData(System.String)">
            <summary>
            Gets the data.
            </summary>
            <param name="propName">Name of the prop.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.DDF.EscherProperties.GetPropertyName(System.Int16)">
            <summary>
            Gets the name of the property.
            </summary>
            <param name="propertyId">The property id.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.DDF.EscherProperties.GetPropertyType(System.Int16)">
            <summary>
            Gets the type of the property.
            </summary>
            <param name="propertyId">The property id.</param>
            <returns></returns>
        </member>
        <member name="T:NPOI.DDF.EscherProperty">
            <summary>
            This is the abstract base class for all escher properties.
            @see EscherOptRecord
            @author Glen Stampoultzis (glens at apache.org)
            </summary>
        </member>
        <member name="M:NPOI.DDF.EscherProperty.#ctor(System.Int16)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.DDF.EscherProperty"/> class.
            </summary>
            <param name="id">The id is distinct from the actual property number.  The id includes the property number the blip id
            flag and an indicator whether the property is complex or not.</param>
        </member>
        <member name="M:NPOI.DDF.EscherProperty.#ctor(System.Int16,System.Boolean,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.DDF.EscherProperty"/> class.The three parameters are combined to form a property
            id.
            </summary>
            <param name="propertyNumber">The property number.</param>
            <param name="isComplex">if set to <c>true</c> [is complex].</param>
            <param name="isBlipId">if set to <c>true</c> [is blip id].</param> 
        </member>
        <member name="P:NPOI.DDF.EscherProperty.Id">
            <summary>
            Gets the id.
            </summary>
            <value>The id.</value>
        </member>
        <member name="P:NPOI.DDF.EscherProperty.PropertyNumber">
            <summary>
            Gets the property number.
            </summary>
            <value>The property number.</value>
        </member>
        <member name="P:NPOI.DDF.EscherProperty.IsComplex">
            <summary>
            Gets a value indicating whether this instance is complex.
            </summary>
            <value>
            	<c>true</c> if this instance is complex; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:NPOI.DDF.EscherProperty.IsBlipId">
            <summary>
            Gets a value indicating whether this instance is blip id.
            </summary>
            <value>
            	<c>true</c> if this instance is blip id; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:NPOI.DDF.EscherProperty.Name">
            <summary>
            Gets the name.
            </summary>
            <value>The name.</value>
        </member>
        <member name="P:NPOI.DDF.EscherProperty.PropertySize">
            <summary>
            Most properties are just 6 bytes in Length.  Override this if we're
            dealing with complex properties.
            </summary>
            <value>The size of the property.</value>
        </member>
        <member name="M:NPOI.DDF.EscherProperty.SerializeSimplePart(System.Byte[],System.Int32)">
            <summary>
            Escher properties consist of a simple fixed Length part and a complex variable Length part.
            The fixed Length part is Serialized first.
            </summary>
            <param name="data">The data.</param>
            <param name="pos">The pos.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.DDF.EscherProperty.SerializeComplexPart(System.Byte[],System.Int32)">
            <summary>
            Escher properties consist of a simple fixed Length part and a complex variable Length part.
            The fixed Length part is Serialized first.
            </summary>
            <param name="data">The data.</param>
            <param name="pos">The pos.</param>
            <returns></returns>
        </member>
        <member name="T:NPOI.DDF.EscherPropertyFactory">
            <summary>
            Generates a property given a reference into the byte array storing that property.
            @author Glen Stampoultzis
            </summary>
        </member>
        <member name="M:NPOI.DDF.EscherPropertyFactory.CreateProperties(System.Byte[],System.Int32,System.Int16)">
            <summary>
            Create new properties from a byte array.
            </summary>
            <param name="data">The byte array containing the property</param>
            <param name="offset">The starting offset into the byte array</param>
            <param name="numProperties">The new properties</param>
            <returns></returns>        
        </member>
        <member name="T:NPOI.DDF.EscherPropertyMetaData">
            <summary>
            This class stores the type and description of an escher property.
            @author Glen Stampoultzis (glens at apache.org)
            </summary>
        </member>
        <member name="M:NPOI.DDF.EscherPropertyMetaData.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.DDF.EscherPropertyMetaData"/> class.
            </summary>
            <param name="description">The description of the escher property.</param>
        </member>
        <member name="M:NPOI.DDF.EscherPropertyMetaData.#ctor(System.String,System.Byte)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.DDF.EscherPropertyMetaData"/> class.
            </summary>
            <param name="description">The description of the escher property.</param>
            <param name="type">The type of the property.</param> 
        </member>
        <member name="P:NPOI.DDF.EscherPropertyMetaData.Description">
            <summary>
            Gets the description.
            </summary>
            <value>The description.</value>
        </member>
        <member name="P:NPOI.DDF.EscherPropertyMetaData.Type">
            <summary>
            Gets the type.
            </summary>
            <value>The type.</value>
        </member>
        <member name="T:NPOI.DDF.EscherRecord">
            <summary>
            The base abstract record from which all escher records are defined.  Subclasses will need
            to define methods for serialization/deserialization and for determining the record size.
            @author Glen Stampoultzis
            </summary>
        </member>
        <member name="M:NPOI.DDF.EscherRecord.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.DDF.EscherRecord"/> class.
            </summary>
        </member>
        <member name="M:NPOI.DDF.EscherRecord.FillFields(System.Byte[],NPOI.DDF.EscherRecordFactory)">
            <summary>
            Delegates to FillFields(byte[], int, EscherRecordFactory)
            </summary>
            <param name="data">The data.</param>
            <param name="f">The f.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.DDF.EscherRecord.FillFields(System.Byte[],System.Int32,NPOI.DDF.EscherRecordFactory)">
            <summary>
            The contract of this method is to deSerialize an escher record including
            it's children.
            </summary>
            <param name="data">The byte array containing the Serialized escher
            records.</param>
            <param name="offset">The offset into the byte array.</param>
            <param name="recordFactory">A factory for creating new escher records.</param>
            <returns>The number of bytes written.</returns>       
        </member>
        <member name="M:NPOI.DDF.EscherRecord.ReadHeader(System.Byte[],System.Int32)">
            <summary>
            Reads the 8 byte header information and populates the 
            <c>options</c>
            and 
            <c>recordId</c>
             records.
            </summary>
            <param name="data">the byte array to Read from</param>
            <param name="offset">the offset to start Reading from</param>
            <returns>the number of bytes remaining in this record.  This</returns>
        </member>
        <member name="P:NPOI.DDF.EscherRecord.IsContainerRecord">
            <summary>
            Determine whether this is a container record by inspecting the option
            field.
            </summary>
            <value>
            	<c>true</c> if this instance is container record; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:NPOI.DDF.EscherRecord.Options">
            <summary>
            Gets or sets the options field for this record.  All records have one
            </summary>
            <value>The options.</value>
        </member>
        <member name="M:NPOI.DDF.EscherRecord.Serialize">
            <summary>
            Serializes to a new byte array.  This is done by delegating to
            Serialize(int, byte[]);
            </summary>
            <returns>the Serialized record.</returns>
        </member>
        <member name="M:NPOI.DDF.EscherRecord.Serialize(System.Int32,System.Byte[])">
            <summary>
            Serializes to an existing byte array without serialization listener.
            This is done by delegating to Serialize(int, byte[], EscherSerializationListener).
            </summary>
            <param name="offset">the offset within the data byte array.</param>
            <param name="data">the data array to Serialize to.</param>
            <returns>The number of bytes written.</returns>
        </member>
        <member name="M:NPOI.DDF.EscherRecord.Serialize(System.Int32,System.Byte[],NPOI.DDF.EscherSerializationListener)">
            <summary>
            Serializes the record to an existing byte array.
            </summary>
            <param name="offset">the offset within the byte array.</param>
            <param name="data">the offset within the byte array</param>
            <param name="listener">a listener for begin and end serialization events.  This.
            is useful because the serialization is
            hierarchical/recursive and sometimes you need to be able
            break into that.
            </param>
            <returns></returns>
        </member>
        <member name="P:NPOI.DDF.EscherRecord.RecordSize">
            <summary>
            Subclasses should effeciently return the number of bytes required to
            Serialize the record.
            </summary>
            <value>number of bytes</value>
        </member>
        <member name="P:NPOI.DDF.EscherRecord.RecordId">
            <summary>
            Return the current record id.
            </summary>
            <value>The 16 bit record id.</value>
        </member>
        <member name="P:NPOI.DDF.EscherRecord.ChildRecords">
            <summary>
            Gets or sets the child records.
            </summary>
            <value>Returns the children of this record.  By default this will
            be an empty list.  EscherCotainerRecord is the only record that may contain children.</value>
        </member>
        <member name="M:NPOI.DDF.EscherRecord.Clone">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
            A new object that is a copy of this instance.
            </returns>
        </member>
        <member name="M:NPOI.DDF.EscherRecord.GetChild(System.Int32)">
            <summary>
            Returns the indexed child record.
            </summary>
            <param name="index">The index.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.DDF.EscherRecord.Display(System.Int32)">
            <summary>
            The display methods allows escher variables to print the record names
            according to their hierarchy.
            </summary>
            <param name="indent">The current indent level.</param>  
        </member>
        <member name="P:NPOI.DDF.EscherRecord.RecordName">
            <summary>
            Gets the name of the record.
            </summary>
            <value>The name of the record.</value>
        </member>
        <member name="M:NPOI.DDF.EscherRecord.GetInstance">
            <summary>
            Returns the instance part of the option record.
            </summary>
            <returns>The instance part of the record</returns>
        </member>
        <member name="T:NPOI.DDF.EscherRecord.EscherRecordHeader">
            <summary>
            This class Reads the standard escher header.
            </summary>
        </member>
        <member name="M:NPOI.DDF.EscherRecord.EscherRecordHeader.ReadHeader(System.Byte[],System.Int32)">
            <summary>
            Reads the header.
            </summary>
            <param name="data">The data.</param>
            <param name="offset">The off set.</param>
            <returns></returns>
        </member>
        <member name="P:NPOI.DDF.EscherRecord.EscherRecordHeader.Options">
            <summary>
            Gets the options.
            </summary>
            <value>The options.</value>
        </member>
        <member name="P:NPOI.DDF.EscherRecord.EscherRecordHeader.RecordId">
            <summary>
            Gets the record id.
            </summary>
            <value>The record id.</value>
        </member>
        <member name="P:NPOI.DDF.EscherRecord.EscherRecordHeader.RemainingBytes">
            <summary>
            Gets the remaining bytes.
            </summary>
            <value>The remaining bytes.</value>
        </member>
        <member name="M:NPOI.DDF.EscherRecord.EscherRecordHeader.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="T:NPOI.DDF.EscherRecordFactory">
            <summary>
            The escher record factory interface allows for the creation of escher
            records from a pointer into a data array.
            @author Glen Stampoultzis (glens at apache.org)
            </summary>
        </member>
        <member name="M:NPOI.DDF.EscherRecordFactory.CreateRecord(System.Byte[],System.Int32)">
            <summary>
            Create a new escher record from the data provided.  Does not attempt
            to Fill the contents of the record however.
            </summary>
            <param name="data">The data.</param>
            <param name="offset">The off set.</param>
            <returns></returns>
        </member>
        <member name="T:NPOI.DDF.EscherRGBProperty">
            <summary>
            A color property.
            @author Glen Stampoultzis (glens at apache.org)
            </summary>
        </member>
        <member name="M:NPOI.DDF.EscherRGBProperty.#ctor(System.Int16,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.DDF.EscherRGBProperty"/> class.
            </summary>
            <param name="propertyNumber">The property number.</param>
            <param name="rgbColor">Color of the RGB.</param>
        </member>
        <member name="P:NPOI.DDF.EscherRGBProperty.RgbColor">
            <summary>
            Gets the color of the RGB.
            </summary>
            <value>The color of the RGB.</value>
        </member>
        <member name="P:NPOI.DDF.EscherRGBProperty.Red">
            <summary>
            Gets the red.
            </summary>
            <value>The red.</value>
        </member>
        <member name="P:NPOI.DDF.EscherRGBProperty.Green">
            <summary>
            Gets the green.
            </summary>
            <value>The green.</value>
        </member>
        <member name="P:NPOI.DDF.EscherRGBProperty.Blue">
            <summary>
            Gets the blue.
            </summary>
            <value>The blue.</value>
        </member>
        <member name="T:NPOI.DDF.EscherSerializationListener">
             Interface for listening to escher serialization events.
            
             @author Glen Stampoultzis (glens at apache.org)
        </member>
        <member name="M:NPOI.DDF.EscherSerializationListener.BeforeRecordSerialize(System.Int32,System.Int16,NPOI.DDF.EscherRecord)">
             Fired before a given escher record is Serialized.
            
             @param offset    The position in the data array at which the record will be Serialized.
             @param recordId  The id of the record about to be Serialized.
        </member>
        <member name="M:NPOI.DDF.EscherSerializationListener.AfterRecordSerialize(System.Int32,System.Int16,System.Int32,NPOI.DDF.EscherRecord)">
             Fired after a record has been Serialized.
            
             @param offset    The position of the end of the Serialized record + 1
             @param recordId  The id of the record about to be Serialized
             @param size      The number of bytes written for this record.  If it is a container
                              record then this will include the size of any included records.
        </member>
        <member name="T:NPOI.DDF.EscherShapePathProperty">
            <summary>
            Defines the constants for the various possible shape paths.
            @author Glen Stampoultzis (glens at apache.org)
            </summary>
        </member>
        <member name="M:NPOI.DDF.EscherShapePathProperty.#ctor(System.Int16,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.DDF.EscherShapePathProperty"/> class.
            </summary>
            <param name="propertyNumber">The property number.</param>
            <param name="shapePath">The shape path.</param>
        </member>
        <member name="T:NPOI.DDF.EscherSimpleProperty">
            <summary>
            A simple property is of fixed Length and as a property number in Addition
            to a 32-bit value.  Properties that can't be stored in only 32-bits are
            stored as EscherComplexProperty objects.
            @author Glen Stampoultzis (glens at apache.org)
            </summary>
        </member>
        <member name="M:NPOI.DDF.EscherSimpleProperty.#ctor(System.Int16,System.Int32)">
            <summary>
            The id is distinct from the actual property number.  The id includes the property number the blip id
            flag and an indicator whether the property is complex or not.
            </summary>
            <param name="id">The id.</param>
            <param name="propertyValue">The property value.</param>
        </member>
        <member name="M:NPOI.DDF.EscherSimpleProperty.#ctor(System.Int16,System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Constructs a new escher property.  The three parameters are combined to form a property
            id.
            </summary>
            <param name="propertyNumber">The property number.</param>
            <param name="isComplex">if set to <c>true</c> [is complex].</param>
            <param name="isBlipId">if set to <c>true</c> [is blip id].</param>
            <param name="propertyValue">The property value.</param>
        </member>
        <member name="M:NPOI.DDF.EscherSimpleProperty.SerializeSimplePart(System.Byte[],System.Int32)">
            <summary>
            Serialize the simple part of the escher record.
            </summary>
            <param name="data">The data.</param>
            <param name="offset">The off set.</param>
            <returns>the number of bytes Serialized.</returns>
        </member>
        <member name="M:NPOI.DDF.EscherSimpleProperty.SerializeComplexPart(System.Byte[],System.Int32)">
            <summary>
            Escher properties consist of a simple fixed Length part and a complex variable Length part.
            The fixed Length part is Serialized first.
            </summary>
            <param name="data"></param>
            <param name="pos"></param>
            <returns></returns>
        </member>
        <member name="P:NPOI.DDF.EscherSimpleProperty.PropertyValue">
            <summary>
            Return the 32 bit value of this property.
            </summary>
            <value>The property value.</value>
        </member>
        <member name="M:NPOI.DDF.EscherSimpleProperty.Equals(System.Object)">
            <summary>
            Returns true if one escher property is equal to another.
            </summary>
            <param name="o">The o.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.DDF.EscherSimpleProperty.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="M:NPOI.DDF.EscherSimpleProperty.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="T:NPOI.DDF.EscherSpgrRecord">
            <summary>
            The spgr record defines information about a shape group.  Groups in escher
            are simply another form of shape that you can't physically see.
            @author Glen Stampoultzis (glens at apache.org)
            </summary>
        </member>
        <member name="M:NPOI.DDF.EscherSpgrRecord.FillFields(System.Byte[],System.Int32,NPOI.DDF.EscherRecordFactory)">
            <summary>
            This method deSerializes the record from a byte array.
            </summary>
            <param name="data">The byte array containing the escher record information</param>
            <param name="offset">The starting offset into data</param>
            <param name="recordFactory">May be null since this is not a container record.</param>
            <returns>The number of bytes Read from the byte array.</returns>
        </member>
        <member name="M:NPOI.DDF.EscherSpgrRecord.Serialize(System.Int32,System.Byte[],NPOI.DDF.EscherSerializationListener)">
            <summary>
            This method Serializes this escher record into a byte array
            </summary>
            <param name="offset">The offset into data
             to start writing the record data to.</param>
            <param name="data">The byte array to Serialize to.</param>
            <returns>The number of bytes written.</returns>
        </member>
        <member name="P:NPOI.DDF.EscherSpgrRecord.RecordSize">
            <summary>
            Returns the number of bytes that are required to Serialize this record.
            </summary>
            <value>Number of bytes</value>
        </member>
        <member name="P:NPOI.DDF.EscherSpgrRecord.RecordId">
            <summary>
            Return the current record id.
            </summary>
            <value>The 16 bit identifier of this shape group record.</value>
        </member>
        <member name="P:NPOI.DDF.EscherSpgrRecord.RecordName">
            <summary>
            The short name for this record
            </summary>
            <value></value>
        </member>
        <member name="M:NPOI.DDF.EscherSpgrRecord.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="P:NPOI.DDF.EscherSpgrRecord.RectX1">
            <summary>
            Gets or sets the starting top-left coordinate of child records.
            </summary>
            <value>The rect x1.</value>
        </member>
        <member name="P:NPOI.DDF.EscherSpgrRecord.RectX2">
            <summary>
            Gets or sets the starting bottom-right coordinate of child records.
            </summary>
            <value>The rect x2.</value>
        </member>
        <member name="P:NPOI.DDF.EscherSpgrRecord.RectY1">
            <summary>
            Gets or sets the starting top-left coordinate of child records.
            </summary>
            <value>The rect y1.</value>
        </member>
        <member name="P:NPOI.DDF.EscherSpgrRecord.RectY2">
            <summary>
            Gets or sets the starting bottom-right coordinate of child records.
            </summary>
            <value>The rect y2.</value>
        </member>
        <member name="T:NPOI.DDF.EscherSplitMenuColorsRecord">
            <summary>
            A list of the most recently used colours for the drawings contained in
            this document.
            @author Glen Stampoultzis (glens at apache.org)
            </summary>
        </member>
        <member name="M:NPOI.DDF.EscherSplitMenuColorsRecord.FillFields(System.Byte[],System.Int32,NPOI.DDF.EscherRecordFactory)">
            <summary>
            This method deSerializes the record from a byte array.
            </summary>
            <param name="data">The byte array containing the escher record information</param>
            <param name="offset">The starting offset into data</param>
            <param name="recordFactory">May be null since this is not a container record.</param>
            <returns>The number of bytes Read from the byte array.</returns>
        </member>
        <member name="M:NPOI.DDF.EscherSplitMenuColorsRecord.Serialize(System.Int32,System.Byte[],NPOI.DDF.EscherSerializationListener)">
            <summary>
            This method Serializes this escher record into a byte array
            </summary>
            <param name="offset">The offset into data
             to start writing the record data to.</param>
            <param name="data">The byte array to Serialize to.</param>
            <returns>The number of bytes written.</returns>
        </member>
        <member name="P:NPOI.DDF.EscherSplitMenuColorsRecord.RecordSize">
            <summary>
            Returns the number of bytes that are required to Serialize this record.
            </summary>
            <value>number of bytes</value>
        </member>
        <member name="P:NPOI.DDF.EscherSplitMenuColorsRecord.RecordId">
            <summary>
            Return the current record id.
            </summary>
            <value>the 16 bit identifer for this record.</value>
        </member>
        <member name="P:NPOI.DDF.EscherSplitMenuColorsRecord.RecordName">
            <summary>
            Gets the short name for this record
            </summary>
            <value>The name of the record.</value>
        </member>
        <member name="M:NPOI.DDF.EscherSplitMenuColorsRecord.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
            @return  a string representation of this record.
        </member>
        <member name="P:NPOI.DDF.EscherSplitMenuColorsRecord.Color1">
            <summary>
            Gets or sets the color1.
            </summary>
            <value>The color1.</value>
        </member>
        <member name="P:NPOI.DDF.EscherSplitMenuColorsRecord.Color2">
            <summary>
            Gets or sets the color2.
            </summary>
            <value>The color2.</value>
        </member>
        <member name="P:NPOI.DDF.EscherSplitMenuColorsRecord.Color3">
            <summary>
            Gets or sets the color3.
            </summary>
            <value>The color3.</value>
        </member>
        <member name="P:NPOI.DDF.EscherSplitMenuColorsRecord.Color4">
            <summary>
            Gets or sets the color4.
            </summary>
            <value>The color4.</value>
        </member>
        <member name="T:NPOI.DDF.EscherSpRecord">
            <summary>
            ToGether the the EscherOptRecord this record defines some of the basic
            properties of a shape.
            @author Glen Stampoultzis (glens at apache.org)
            </summary>
        </member>
        <member name="M:NPOI.DDF.EscherSpRecord.FillFields(System.Byte[],System.Int32,NPOI.DDF.EscherRecordFactory)">
            <summary>
            The contract of this method is to deSerialize an escher record including
            it's children.
            </summary>
            <param name="data">The byte array containing the Serialized escher
            records.</param>
            <param name="offset">The offset into the byte array.</param>
            <param name="recordFactory">A factory for creating new escher records</param>
            <returns>The number of bytes written.</returns>  
        </member>
        <member name="M:NPOI.DDF.EscherSpRecord.Serialize(System.Int32,System.Byte[],NPOI.DDF.EscherSerializationListener)">
            <summary>
            Serializes to an existing byte array without serialization listener.
            This is done by delegating to Serialize(int, byte[], EscherSerializationListener).
            </summary>
            <param name="offset">the offset within the data byte array.</param>
            <param name="data"> the data array to Serialize to.</param>
            <returns>The number of bytes written.</returns>
        </member>
        <member name="P:NPOI.DDF.EscherSpRecord.RecordSize">
            <summary>
            Returns the number of bytes that are required to Serialize this record.
            </summary>
            <value>Number of bytes</value>
        </member>
        <member name="P:NPOI.DDF.EscherSpRecord.RecordId">
            <summary>
            @return  the 16 bit identifier for this record.
            </summary>
            <value></value>
        </member>
        <member name="P:NPOI.DDF.EscherSpRecord.RecordName">
            <summary>
            The short name for this record
            </summary>
            <value></value>
        </member>
        <member name="M:NPOI.DDF.EscherSpRecord.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="M:NPOI.DDF.EscherSpRecord.DecodeFlags(System.Int32)">
            <summary>
            Converts the shape flags into a more descriptive name.
            </summary>
            <param name="flags">The flags.</param>
            <returns></returns>
        </member>
        <member name="P:NPOI.DDF.EscherSpRecord.ShapeId">
            <summary>
            Gets or sets A number that identifies this shape
            </summary>
            <value>The shape id.</value>
        </member>
        <member name="P:NPOI.DDF.EscherSpRecord.Flags">
            <summary>
            The flags that apply to this shape.
            </summary>
            <value>The flags.</value>
        </member>
        <member name="T:NPOI.DDF.EscherTextboxRecord">
            <summary>
            Holds data from the parent application. Most commonly used to store
            text in the format of the parent application, rather than in
            Escher format. We don't attempt to understand the contents, since
            they will be in the parent's format, not Escher format.
            @author Glen Stampoultzis (glens at apache.org)
            @author Nick Burch  (nick at torchbox dot com)
            </summary>
        </member>
        <member name="F:NPOI.DDF.EscherTextboxRecord.thedata">
            The data for this record not including the the 8 byte header 
        </member>
        <member name="M:NPOI.DDF.EscherTextboxRecord.FillFields(System.Byte[],System.Int32,NPOI.DDF.EscherRecordFactory)">
             This method deserializes the record from a byte array.
            
             @param data          The byte array containing the escher record information
             @param offset        The starting offset into <c>data</c>.
             @param recordFactory May be null since this is not a container record.
             @return The number of bytes Read from the byte array.
        </member>
        <member name="M:NPOI.DDF.EscherTextboxRecord.Serialize(System.Int32,System.Byte[],NPOI.DDF.EscherSerializationListener)">
            <summary>
            Writes this record and any contained records to the supplied byte
            </summary>
            <param name="offset"></param>
            <param name="data"></param>
            <returns>the number of bytes written.</returns>
        </member>
        <member name="P:NPOI.DDF.EscherTextboxRecord.Data">
            <summary>
            Returns any extra data associated with this record.  In practice excel
            does not seem to put anything here, but with PowerPoint this will
            contain the bytes that make up a TextHeaderAtom followed by a
            TextBytesAtom/TextCharsAtom
            </summary>
            <value>The data.</value>
        </member>
        <member name="M:NPOI.DDF.EscherTextboxRecord.SetData(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Sets the extra data (in the parent application's format) to be
            contained by the record. Used when the parent application changes
            the contents.
            </summary>
            <param name="b">The b.</param>
            <param name="start">The start.</param>
            <param name="Length">The length.</param>
        </member>
        <member name="M:NPOI.DDF.EscherTextboxRecord.SetData(System.Byte[])">
            <summary>
            Sets the data.
            </summary>
            <param name="b">The b.</param>
        </member>
        <member name="P:NPOI.DDF.EscherTextboxRecord.RecordSize">
            <summary>
            Returns the number of bytes that are required to serialize this record.
            </summary>
            <value>Number of bytes</value>
        </member>
        <member name="P:NPOI.DDF.EscherTextboxRecord.RecordName">
            <summary>
            The short name for this record
            </summary>
            <value></value>
        </member>
        <member name="M:NPOI.DDF.EscherTextboxRecord.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="T:NPOI.DDF.UnknownEscherRecord">
            <summary>
            This record is used whenever a escher record is encountered that
            we do not explicitly support.
            @author Glen Stampoultzis (glens at apache.org)
            </summary>
        </member>
        <member name="F:NPOI.DDF.UnknownEscherRecord.thedata">
            The data for this record not including the the 8 byte header 
        </member>
        <member name="M:NPOI.DDF.UnknownEscherRecord.FillFields(System.Byte[],System.Int32,NPOI.DDF.EscherRecordFactory)">
            <summary>
            This method deSerializes the record from a byte array.
            </summary>
            <param name="data"> The byte array containing the escher record information</param>
            <param name="offset">The starting offset into data </param>
            <param name="recordFactory">May be null since this is not a container record.</param>
            <returns>The number of bytes Read from the byte array.</returns>
        </member>
        <member name="M:NPOI.DDF.UnknownEscherRecord.Serialize(System.Int32,System.Byte[],NPOI.DDF.EscherSerializationListener)">
            <summary>
            Writes this record and any contained records to the supplied byte
            array.
            </summary>
            <param name="offset"></param>
            <param name="data"></param>
            <returns>the number of bytes written.</returns>
        </member>
        <member name="P:NPOI.DDF.UnknownEscherRecord.Data">
            <summary>
            Gets the data.
            </summary>
            <value>The data.</value>
        </member>
        <member name="P:NPOI.DDF.UnknownEscherRecord.RecordSize">
            <summary>
            Returns the number of bytes that are required to Serialize this record.
            </summary>
            <value>Number of bytes</value>
        </member>
        <member name="P:NPOI.DDF.UnknownEscherRecord.ChildRecords">
            <summary>
            Returns the children of this record.  By default this will
            be an empty list.  EscherCotainerRecord is the only record
            that may contain children.
            </summary>
            <value></value>
        </member>
        <member name="P:NPOI.DDF.UnknownEscherRecord.RecordName">
            <summary>
            The short name for this record
            </summary>
            <value></value>
        </member>
        <member name="M:NPOI.DDF.UnknownEscherRecord.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="M:NPOI.DDF.UnknownEscherRecord.AddChildRecord(NPOI.DDF.EscherRecord)">
            <summary>
            Adds the child record.
            </summary>
            <param name="childRecord">The child record.</param>
        </member>
        <member name="T:NPOI.HPSF.Constants">
            <summary>
            Defines constants of general use.
            @author Rainer Klute klute@rainer-klute.de
            @since 2004-06-20
            </summary>
        </member>
        <member name="F:NPOI.HPSF.Constants.CP_037">
            Codepage 037, a special case 
        </member>
        <member name="F:NPOI.HPSF.Constants.CP_SJIS">
            Codepage for SJIS 
        </member>
        <member name="F:NPOI.HPSF.Constants.CP_GBK">
            Codepage for GBK, aka MS936 
        </member>
        <member name="F:NPOI.HPSF.Constants.CP_MS949">
            Codepage for MS949 
        </member>
        <member name="F:NPOI.HPSF.Constants.CP_UTF16">
            Codepage for UTF-16 
        </member>
        <member name="F:NPOI.HPSF.Constants.CP_UTF16_BE">
            Codepage for UTF-16 big-endian 
        </member>
        <member name="F:NPOI.HPSF.Constants.CP_WINDOWS_1250">
            Codepage for Windows 1250 
        </member>
        <member name="F:NPOI.HPSF.Constants.CP_WINDOWS_1251">
            Codepage for Windows 1251 
        </member>
        <member name="F:NPOI.HPSF.Constants.CP_WINDOWS_1252">
            Codepage for Windows 1252 
        </member>
        <member name="F:NPOI.HPSF.Constants.CP_WINDOWS_1253">
            Codepage for Windows 1253 
        </member>
        <member name="F:NPOI.HPSF.Constants.CP_WINDOWS_1254">
            Codepage for Windows 1254 
        </member>
        <member name="F:NPOI.HPSF.Constants.CP_WINDOWS_1255">
            Codepage for Windows 1255 
        </member>
        <member name="F:NPOI.HPSF.Constants.CP_WINDOWS_1256">
            Codepage for Windows 1256 
        </member>
        <member name="F:NPOI.HPSF.Constants.CP_WINDOWS_1257">
            Codepage for Windows 1257 
        </member>
        <member name="F:NPOI.HPSF.Constants.CP_WINDOWS_1258">
            Codepage for Windows 1258 
        </member>
        <member name="F:NPOI.HPSF.Constants.CP_JOHAB">
            Codepage for Johab 
        </member>
        <member name="F:NPOI.HPSF.Constants.CP_MAC_ROMAN">
            Codepage for Macintosh Roman (Java: MacRoman) 
        </member>
        <member name="F:NPOI.HPSF.Constants.CP_MAC_JAPAN">
            Codepage for Macintosh Japan (Java: unknown - use SJIS, cp942 or
            cp943) 
        </member>
        <member name="F:NPOI.HPSF.Constants.CP_MAC_CHINESE_TRADITIONAL">
            Codepage for Macintosh Chinese Traditional (Java: unknown - use Big5,
            MS950, or cp937) 
        </member>
        <member name="F:NPOI.HPSF.Constants.CP_MAC_KOREAN">
            Codepage for Macintosh Korean (Java: unknown - use EUC_KR or
            cp949) 
        </member>
        <member name="F:NPOI.HPSF.Constants.CP_MAC_ARABIC">
            Codepage for Macintosh Arabic (Java: MacArabic) 
        </member>
        <member name="F:NPOI.HPSF.Constants.CP_MAC_HEBREW">
            Codepage for Macintosh Hebrew (Java: MacHebrew) 
        </member>
        <member name="F:NPOI.HPSF.Constants.CP_MAC_GREEK">
            Codepage for Macintosh Greek (Java: MacGreek) 
        </member>
        <member name="F:NPOI.HPSF.Constants.CP_MAC_CYRILLIC">
            Codepage for Macintosh Cyrillic (Java: MacCyrillic) 
        </member>
        <member name="F:NPOI.HPSF.Constants.CP_MAC_CHINESE_SIMPLE">
            Codepage for Macintosh Chinese Simplified (Java: unknown - use
            EUC_CN, ISO2022_CN_GB, MS936 or cp935) 
        </member>
        <member name="F:NPOI.HPSF.Constants.CP_MAC_ROMANIA">
            Codepage for Macintosh Romanian (Java: MacRomania) 
        </member>
        <member name="F:NPOI.HPSF.Constants.CP_MAC_UKRAINE">
            Codepage for Macintosh Ukrainian (Java: MacUkraine) 
        </member>
        <member name="F:NPOI.HPSF.Constants.CP_MAC_THAI">
            Codepage for Macintosh Thai (Java: MacThai) 
        </member>
        <member name="F:NPOI.HPSF.Constants.CP_MAC_CENTRAL_EUROPE">
            Codepage for Macintosh Central Europe (Latin-2)
            (Java: MacCentralEurope) 
        </member>
        <member name="F:NPOI.HPSF.Constants.CP_MAC_ICELAND">
            Codepage for Macintosh Iceland (Java: MacIceland) 
        </member>
        <member name="F:NPOI.HPSF.Constants.CP_MAC_TURKISH">
            Codepage for Macintosh Turkish (Java: MacTurkish) 
        </member>
        <member name="F:NPOI.HPSF.Constants.CP_MAC_CROATIAN">
            Codepage for Macintosh Croatian (Java: MacCroatian) 
        </member>
        <member name="F:NPOI.HPSF.Constants.CP_US_ACSII">
            Codepage for US-ASCII 
        </member>
        <member name="F:NPOI.HPSF.Constants.CP_KOI8_R">
            Codepage for KOI8-R 
        </member>
        <member name="F:NPOI.HPSF.Constants.CP_ISO_8859_1">
            Codepage for ISO-8859-1 
        </member>
        <member name="F:NPOI.HPSF.Constants.CP_ISO_8859_2">
            Codepage for ISO-8859-2 
        </member>
        <member name="F:NPOI.HPSF.Constants.CP_ISO_8859_3">
            Codepage for ISO-8859-3 
        </member>
        <member name="F:NPOI.HPSF.Constants.CP_ISO_8859_4">
            Codepage for ISO-8859-4 
        </member>
        <member name="F:NPOI.HPSF.Constants.CP_ISO_8859_5">
            Codepage for ISO-8859-5 
        </member>
        <member name="F:NPOI.HPSF.Constants.CP_ISO_8859_6">
            Codepage for ISO-8859-6 
        </member>
        <member name="F:NPOI.HPSF.Constants.CP_ISO_8859_7">
            Codepage for ISO-8859-7 
        </member>
        <member name="F:NPOI.HPSF.Constants.CP_ISO_8859_8">
            Codepage for ISO-8859-8 
        </member>
        <member name="F:NPOI.HPSF.Constants.CP_ISO_8859_9">
            Codepage for ISO-8859-9 
        </member>
        <member name="F:NPOI.HPSF.Constants.CP_ISO_2022_JP1">
            Codepage for ISO-2022-JP 
        </member>
        <member name="F:NPOI.HPSF.Constants.CP_ISO_2022_JP2">
            Another codepage for ISO-2022-JP 
        </member>
        <member name="F:NPOI.HPSF.Constants.CP_ISO_2022_JP3">
            Yet another codepage for ISO-2022-JP 
        </member>
        <member name="F:NPOI.HPSF.Constants.CP_ISO_2022_KR">
            Codepage for ISO-2022-KR 
        </member>
        <member name="F:NPOI.HPSF.Constants.CP_EUC_JP">
            Codepage for EUC-JP 
        </member>
        <member name="F:NPOI.HPSF.Constants.CP_EUC_KR">
            Codepage for EUC-KR 
        </member>
        <member name="F:NPOI.HPSF.Constants.CP_GB2312">
            Codepage for GB2312 
        </member>
        <member name="F:NPOI.HPSF.Constants.CP_GB18030">
            Codepage for GB18030 
        </member>
        <member name="F:NPOI.HPSF.Constants.CP_US_ASCII2">
            Another codepage for US-ASCII 
        </member>
        <member name="F:NPOI.HPSF.Constants.CP_UTF8">
            Codepage for UTF-8 
        </member>
        <member name="F:NPOI.HPSF.Constants.CP_UNICODE">
            Codepage for Unicode 
        </member>
        <member name="T:NPOI.HPSF.CustomProperties">
            <summary>
            Maintains the instances of {@link CustomProperty} that belong To a
            {@link DocumentSummaryInformation}. The class maintains the names of the
            custom properties in a dictionary. It implements the {@link Map} interface
            and by this provides a simplified view on custom properties: A property's
            name is the key that maps To a typed value. This implementation hides
            property IDs from the developer and regards the property names as keys To
            typed values.
            While this class provides a simple API To custom properties, it ignores
            the fact that not names, but IDs are the real keys To properties. Under the
            hood this class maintains a 1:1 relationship between IDs and names. Therefore
            you should not use this class To process property Sets with several IDs
            mapping To the same name or with properties without a name: the result will
            contain only a subSet of the original properties. If you really need To deal
            such property Sets, use HPSF's low-level access methods.
            An application can call the {@link #isPure} method To check whether a
            property Set parsed by {@link CustomProperties} is still pure (i.e.
            unmodified) or whether one or more properties have been dropped.
            This class is not thRead-safe; concurrent access To instances of this
            class must be syncronized.
            @author Rainer Klute 
            <a href="mailto:klute@rainer-klute.de">&lt;klute@rainer-klute.de&gt;</a>
            @since 2006-02-09
            </summary>
        </member>
        <member name="F:NPOI.HPSF.CustomProperties.dictionaryIDToName">
            Maps property IDs To property names.
        </member>
        <member name="F:NPOI.HPSF.CustomProperties.dictionaryNameToID">
            Maps property names To property IDs.
        </member>
        <member name="F:NPOI.HPSF.CustomProperties.isPure">
            Tells whether this object is pure or not.
        </member>
        <member name="M:NPOI.HPSF.CustomProperties.Put(System.Object,System.Object)">
            <summary>
            Puts a {@link CustomProperty} into this map. It is assumed that the
            {@link CustomProperty} alReady has a valid ID. Otherwise use
            {@link #Put(CustomProperty)}.
            </summary>
            <param name="name">The name.</param>
            <param name="customProperty">The custom property.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.HPSF.CustomProperties.Put(NPOI.HPSF.CustomProperty)">
            <summary>
            Puts a {@link CustomProperty} that has not yet a valid ID into this
            map. The method will allocate a suitable ID for the custom property:
            <ul>
            	<li>If there is alReady a property with the same name, take the ID
            of that property.</li>
            	<li>Otherwise Find the highest ID and use its value plus one.</li>
            </ul>
            </summary>
            <param name="customProperty">The custom property.</param>
            <returns>If the was alReady a property with the same name, the</returns>
        </member>
        <member name="M:NPOI.HPSF.CustomProperties.Remove(System.String)">
            <summary>
            Removes a custom property.
            </summary>
            <param name="name">The name of the custom property To Remove</param>
            <returns>The Removed property or 
            <c>null</c>
             if the specified property was not found.</returns>
        </member>
        <member name="M:NPOI.HPSF.CustomProperties.Put(System.String,System.String)">
            <summary>
            Adds a named string property.
            </summary>
            <param name="name">The property's name.</param>
            <param name="value">The property's value.</param>
            <returns>the property that was stored under the specified name before, or
            <c>null</c>
             if there was no such property before.</returns>
        </member>
        <member name="M:NPOI.HPSF.CustomProperties.Put(System.String,System.Int64)">
            <summary>
            Adds a named long property
            </summary>
            <param name="name">The property's name.</param>
            <param name="value">The property's value.</param>
            <returns>the property that was stored under the specified name before, or
            <c>null</c>
             if there was no such property before.</returns>
        </member>
        <member name="M:NPOI.HPSF.CustomProperties.Put(System.String,System.Double)">
            <summary>
            Adds a named double property.
            </summary>
            <param name="name">The property's name.</param>
            <param name="value">The property's value.</param>
            <returns>the property that was stored under the specified name before, or
            <c>null</c>
             if there was no such property before.</returns>
        </member>
        <member name="M:NPOI.HPSF.CustomProperties.Put(System.String,System.Int32)">
            <summary>
            Adds a named integer property.
            </summary>
            <param name="name">The property's name.</param>
            <param name="value">The property's value.</param>
            <returns>the property that was stored under the specified name before, or
            <c>null</c>
             if there was no such property before.</returns>
        </member>
        <member name="M:NPOI.HPSF.CustomProperties.Put(System.String,System.Boolean)">
            <summary>
            Adds a named bool property.
            </summary>
            <param name="name">The property's name.</param>
            <param name="value">The property's value.</param>
            <returns>the property that was stored under the specified name before, or
            <c>null</c>
             if there was no such property before.</returns>
        </member>
        <member name="M:NPOI.HPSF.CustomProperties.Put(System.String,System.DateTime)">
            <summary>
            Adds a named date property.
            </summary>
            <param name="name">The property's name.</param>
            <param name="value">The property's value.</param>
            <returns>the property that was stored under the specified name before, or
            <c>null</c>
             if there was no such property before.</returns>
        </member>
        <member name="P:NPOI.HPSF.CustomProperties.Item(System.String)">
            <summary>
            Gets the <see cref="T:System.Object"/> with the specified name.
            </summary>
            <value>the value or 
            <c>null</c>
             if a value with the specified
            name is not found in the custom properties.</value>
        </member>
        <member name="P:NPOI.HPSF.CustomProperties.Dictionary">
            <summary>
            Gets the dictionary which Contains IDs and names of the named custom
            properties.
            </summary>
            <value>The dictionary.</value>
        </member>
        <member name="P:NPOI.HPSF.CustomProperties.Codepage">
            <summary>
            Gets or sets the codepage.
            </summary>
            <value>The codepage.</value>
        </member>
        <member name="P:NPOI.HPSF.CustomProperties.IsPure">
            <summary>
            Tells whether this {@link CustomProperties} instance is pure or one or
            more properties of the underlying low-level property Set has been
            dropped.
            </summary>
            <value><c>true</c> if this instance is pure; otherwise, <c>false</c>.</value>
        </member>
        <member name="T:NPOI.HPSF.CustomProperty">
            <summary>
            This class represents custum properties in the document summary
            information stream. The difference To normal properties is that custom
            properties have an optional name. If the name is not <c>null</c> it
            will be maintained in the section's dictionary.
            @author Rainer Klute 
            <a href="mailto:klute@rainer-klute.de">&lt;klute@rainer-klute.de&gt;</a>
            @since 2006-02-09
            </summary>
        </member>
        <member name="M:NPOI.HPSF.CustomProperty.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HPSF.CustomProperty"/> class.
            </summary>
        </member>
        <member name="M:NPOI.HPSF.CustomProperty.#ctor(NPOI.HPSF.Property)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HPSF.CustomProperty"/> class.
            </summary>
            <param name="property">the property To copy</param>
        </member>
        <member name="M:NPOI.HPSF.CustomProperty.#ctor(NPOI.HPSF.Property,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HPSF.CustomProperty"/> class.
            </summary>
            <param name="property">This property's attributes are copied To the new custom
            property.</param>
            <param name="name">The new custom property's name.</param>
        </member>
        <member name="P:NPOI.HPSF.CustomProperty.Name">
            <summary>
            Gets or sets the property's name.
            </summary>
            <value>the property's name.</value>
        </member>
        <member name="M:NPOI.HPSF.CustomProperty.EqualsContents(System.Object)">
            <summary>
            Compares two custom properties for equality. The method returns
            <c>true</c> if all attributes of the two custom properties are
            equal.
            </summary>
            <param name="o">The custom property To Compare with.</param>
            <returns><c>true</c>
             if both custom properties are equal, else
            <c>false</c></returns>
        </member>
        <member name="M:NPOI.HPSF.CustomProperty.GetHashCode">
            <summary>
            </summary>
            <returns></returns>
            @see Object#GetHashCode()
        </member>
        <member name="T:NPOI.HPSF.DocumentSummaryInformation">
            <summary>
            Convenience class representing a DocumentSummary Information stream in a
            Microsoft Office document.
            @author Rainer Klute 
            klute@rainer-klute.de
            @author Drew Varner (Drew.Varner cloSeto sc.edu)
            @author robert_flaherty@hyperion.com
            @since 2002-02-09
            </summary>
        </member>
        <member name="F:NPOI.HPSF.DocumentSummaryInformation.DEFAULT_STREAM_NAME">
            The document name a document summary information stream
            usually has in a POIFS filesystem.
        </member>
        <member name="M:NPOI.HPSF.DocumentSummaryInformation.#ctor(NPOI.HPSF.PropertySet)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HPSF.DocumentSummaryInformation"/> class.
            </summary>
            <param name="ps">A property Set which should be Created from a
            document summary information stream.</param>
        </member>
        <member name="P:NPOI.HPSF.DocumentSummaryInformation.Category">
            <summary>
            Gets or sets the category.
            </summary>
            <value>The category value</value>
        </member>
        <member name="M:NPOI.HPSF.DocumentSummaryInformation.RemoveCategory">
            <summary>
            Removes the category.
            </summary>
        </member>
        <member name="P:NPOI.HPSF.DocumentSummaryInformation.PresentationFormat">
            <summary>
            Gets or sets the presentation format (or null).
            </summary>
            <value>The presentation format value</value>
        </member>
        <member name="M:NPOI.HPSF.DocumentSummaryInformation.RemovePresentationFormat">
            <summary>
            Removes the presentation format.
            </summary>
        </member>
        <member name="P:NPOI.HPSF.DocumentSummaryInformation.ByteCount">
            <summary>
            Gets or sets the byte count or 0 if the {@link
            DocumentSummaryInformation} does not contain a byte count.
            </summary>
            <value>The byteCount value</value>
        </member>
        <member name="M:NPOI.HPSF.DocumentSummaryInformation.RemoveByteCount">
            <summary>
            Removes the byte count.
            </summary>
        </member>
        <member name="P:NPOI.HPSF.DocumentSummaryInformation.LineCount">
            <summary>
            Gets or sets the line count or 0 if the {@link
            DocumentSummaryInformation} does not contain a line count.
            </summary>
            <value>The line count value.</value>
        </member>
        <member name="M:NPOI.HPSF.DocumentSummaryInformation.RemoveLineCount">
            <summary>
            Removes the line count.
            </summary>
        </member>
        <member name="P:NPOI.HPSF.DocumentSummaryInformation.ParCount">
            <summary>
            Gets or sets the par count or 0 if the {@link
            DocumentSummaryInformation} does not contain a par count.
            </summary>
            <value>The par count value</value>
        </member>
        <member name="M:NPOI.HPSF.DocumentSummaryInformation.RemoveParCount">
            <summary>
            Removes the par count.
            </summary>
        </member>
        <member name="P:NPOI.HPSF.DocumentSummaryInformation.SlideCount">
            <summary>
            Gets or sets the slide count or 0 if the {@link
            DocumentSummaryInformation} does not contain a slide count.
            </summary>
            <value>The slide count value</value>
        </member>
        <member name="M:NPOI.HPSF.DocumentSummaryInformation.RemoveSlideCount">
            <summary>
            Removes the slide count.
            </summary>
        </member>
        <member name="P:NPOI.HPSF.DocumentSummaryInformation.NoteCount">
            <summary>
            Gets or sets the note count or 0 if the {@link
            DocumentSummaryInformation} does not contain a note count
            </summary>
            <value>The note count value</value>
        </member>
        <member name="M:NPOI.HPSF.DocumentSummaryInformation.RemoveNoteCount">
            <summary>
            Removes the note count.
            </summary>
        </member>
        <member name="P:NPOI.HPSF.DocumentSummaryInformation.HiddenCount">
            <summary>
            Gets or sets the hidden count or 0 if the {@link
            DocumentSummaryInformation} does not contain a hidden
            count.
            </summary>
            <value>The hidden count value.</value>
        </member>
        <member name="M:NPOI.HPSF.DocumentSummaryInformation.RemoveHiddenCount">
            <summary>
            Removes the hidden count.
            </summary>
        </member>
        <member name="P:NPOI.HPSF.DocumentSummaryInformation.MMClipCount">
            <summary>
            Returns the mmclip count or 0 if the {@link
            DocumentSummaryInformation} does not contain a mmclip
            count.
            </summary>
            <value>The mmclip count value.</value>
        </member>
        <member name="M:NPOI.HPSF.DocumentSummaryInformation.RemoveMMClipCount">
            <summary>
            Removes the MMClip count.
            </summary>
        </member>
        <member name="P:NPOI.HPSF.DocumentSummaryInformation.Scale">
            <summary>
            Gets or sets a value indicating whether this <see cref="T:NPOI.HPSF.DocumentSummaryInformation"/> is scale.
            </summary>
            <value><c>true</c> if cropping is desired; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:NPOI.HPSF.DocumentSummaryInformation.RemoveScale">
            <summary>
            Removes the scale.
            </summary>
        </member>
        <member name="P:NPOI.HPSF.DocumentSummaryInformation.HeadingPair">
            <summary>
            Gets or sets the heading pair (or null)
            </summary>
            <value>The heading pair value.</value>
        </member>
        <member name="M:NPOI.HPSF.DocumentSummaryInformation.RemoveHeadingPair">
            <summary>
            Removes the heading pair.
            </summary>
        </member>
        <member name="P:NPOI.HPSF.DocumentSummaryInformation.Docparts">
            <summary>
            Gets or sets the doc parts.
            </summary>
            <value>The doc parts value</value>
        </member>
        <member name="M:NPOI.HPSF.DocumentSummaryInformation.RemoveDocparts">
            <summary>
            Removes the doc parts.
            </summary>
        </member>
        <member name="P:NPOI.HPSF.DocumentSummaryInformation.Manager">
            <summary>
            Gets or sets the manager (or <c>null</c>).
            </summary>
            <value>The manager value</value>
        </member>
        <member name="M:NPOI.HPSF.DocumentSummaryInformation.RemoveManager">
            <summary>
            Removes the manager.
            </summary>
        </member>
        <member name="P:NPOI.HPSF.DocumentSummaryInformation.Company">
            <summary>
            Gets or sets the company (or <c>null</c>).
            </summary>
            <value>The company value</value>
        </member>
        <member name="M:NPOI.HPSF.DocumentSummaryInformation.RemoveCompany">
            <summary>
            Removes the company.
            </summary>
        </member>
        <member name="P:NPOI.HPSF.DocumentSummaryInformation.LinksDirty">
            <summary>
            Gets or sets a value indicating whether [links dirty].
            </summary>
            <value><c>true</c> if the custom links are dirty.; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:NPOI.HPSF.DocumentSummaryInformation.RemoveLinksDirty">
            <summary>
            Removes the links dirty.
            </summary>
        </member>
        <member name="P:NPOI.HPSF.DocumentSummaryInformation.CustomProperties">
            <summary>
            Gets or sets the custom properties.
            </summary>
            <value>The custom properties.</value>
        </member>
        <member name="M:NPOI.HPSF.DocumentSummaryInformation.EnsureSection2">
            <summary>
            Creates section 2 if it is not alReady present.
            </summary>
        </member>
        <member name="M:NPOI.HPSF.DocumentSummaryInformation.RemoveCustomProperties">
            <summary>
            Removes the custom properties.
            </summary>
        </member>
        <member name="T:NPOI.HPSF.HPSFException">
            <summary>
            This exception is the superclass of all other checked exceptions thrown
            in this package. It supports a nested "reason" throwable, i.e. an exception
            that caused this one To be thrown.
            @author Rainer Klute 
            <a href="mailto:klute@rainer-klute.de">&lt;klute@rainer-klute.de&gt;</a>
            @since 2002-02-09
            </summary>
        </member>
        <member name="M:NPOI.HPSF.HPSFException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HPSF.HPSFException"/> class.
            </summary>
        </member>
        <member name="M:NPOI.HPSF.HPSFException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HPSF.HPSFException"/> class.
            </summary>
            <param name="msg">The message string.</param>
        </member>
        <member name="M:NPOI.HPSF.HPSFException.#ctor(System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HPSF.HPSFException"/> class.
            </summary>
            <param name="reason">The reason, i.e. a throwable that indirectly
            caused this exception.</param>
        </member>
        <member name="M:NPOI.HPSF.HPSFException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HPSF.HPSFException"/> class.
            </summary>
            <param name="msg">The message string.</param>
            <param name="reason">The reason, i.e. a throwable that indirectly
            caused this exception.</param>
        </member>
        <member name="P:NPOI.HPSF.HPSFException.Reason">
            <summary>
            Returns the {@link Exception} that caused this exception To
            be thrown or null if there was no such {@link
            Exception}.
            </summary>
            <value>The reason.</value>
        </member>
        <member name="T:NPOI.HPSF.HPSFRuntimeException">
            <summary>
            This exception is the superclass of all other unchecked
            exceptions thrown in this package. It supports a nested "reason"
            throwable, i.e. an exception that caused this one To be thrown.
            @author Rainer Klute 
            <a href="mailto:klute@rainer-klute.de">&lt;klute@rainer-klute.de&gt;</a>
            @since 2002-02-09
            </summary>
        </member>
        <member name="M:NPOI.HPSF.HPSFRuntimeException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HPSF.HPSFRuntimeException"/> class.
            </summary>
        </member>
        <member name="M:NPOI.HPSF.HPSFRuntimeException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HPSF.HPSFRuntimeException"/> class.
            </summary>
            <param name="msg">The message string.</param>
        </member>
        <member name="M:NPOI.HPSF.HPSFRuntimeException.#ctor(System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HPSF.HPSFRuntimeException"/> class.
            </summary>
            <param name="reason">The reason, i.e. a throwable that indirectly
            caused this exception.</param>
        </member>
        <member name="M:NPOI.HPSF.HPSFRuntimeException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HPSF.HPSFRuntimeException"/> class.
            </summary>
            <param name="msg">The message string.</param>
            <param name="reason">The reason, i.e. a throwable that indirectly
            caused this exception.</param>
        </member>
        <member name="T:NPOI.HPSF.IllegalPropertySetDataException">
            <summary>
            This exception is thrown when there is an illegal value Set in a
            {@link PropertySet}. For example, a {@link Variant#VT_BOOL} must
            have a value of <c>-1 (true)</c> or <c>0 (false)</c>.
            Any other value would trigger this exception. It supports a nested
            "reason" throwable, i.e. an exception that caused this one To be
            thrown.
            @author Drew Varner(Drew.Varner atDomain sc.edu)
            @since 2002-05-26
            </summary>
        </member>
        <member name="M:NPOI.HPSF.IllegalPropertySetDataException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HPSF.IllegalPropertySetDataException"/> class.
            </summary>
        </member>
        <member name="M:NPOI.HPSF.IllegalPropertySetDataException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HPSF.IllegalPropertySetDataException"/> class.
            </summary>
            <param name="msg">The exception's message string</param>
        </member>
        <member name="M:NPOI.HPSF.IllegalPropertySetDataException.#ctor(System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HPSF.IllegalPropertySetDataException"/> class.
            </summary>
            <param name="reason">This exception's underlying reason</param>
        </member>
        <member name="M:NPOI.HPSF.IllegalPropertySetDataException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HPSF.IllegalPropertySetDataException"/> class.
            </summary>
            <param name="msg"> The exception's message string</param>
            <param name="reason">This exception's underlying reason</param>
        </member>
        <member name="T:NPOI.HPSF.IllegalVariantTypeException">
            <summary>
            This exception is thrown if HPSF encounters a variant type that is illegal
            in the current context.
            @author Rainer Klute 
            <a href="mailto:klute@rainer-klute.de">&lt;klute@rainer-klute.de&gt;</a>
            @since 2004-06-21
            </summary>
        </member>
        <member name="M:NPOI.HPSF.IllegalVariantTypeException.#ctor(System.Int64,System.Object,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HPSF.IllegalVariantTypeException"/> class.
            </summary>
            <param name="variantType">The unsupported variant type</param>
            <param name="value">The value</param>
            <param name="msg">A message string</param>
        </member>
        <member name="M:NPOI.HPSF.IllegalVariantTypeException.#ctor(System.Int64,System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HPSF.IllegalVariantTypeException"/> class.
            </summary>
            <param name="variantType">The unsupported variant type</param>
            <param name="value">The value.</param>
        </member>
        <member name="T:NPOI.HPSF.MarkUnsupportedException">
            <summary>
            This exception is thrown if an {@link java.io.InputStream} does
            not support the {@link java.io.InputStream#mark} operation.
            @author Rainer Klute 
            <a href="mailto:klute@rainer-klute.de">&lt;klute@rainer-klute.de&gt;</a>
            @since 2002-02-09
            </summary>
        </member>
        <member name="M:NPOI.HPSF.MarkUnsupportedException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HPSF.MarkUnsupportedException"/> class.
            </summary>
        </member>
        <member name="M:NPOI.HPSF.MarkUnsupportedException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HPSF.MarkUnsupportedException"/> class.
            </summary>
            <param name="msg">The exception's message string.</param>
        </member>
        <member name="M:NPOI.HPSF.MarkUnsupportedException.#ctor(System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HPSF.MarkUnsupportedException"/> class.
            </summary>
            <param name="reason">This exception's underlying reason.</param>
        </member>
        <member name="M:NPOI.HPSF.MarkUnsupportedException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HPSF.MarkUnsupportedException"/> class.
            </summary>
            <param name="msg">The exception's message string</param>
            <param name="reason">This exception's underlying reason</param>
        </member>
        <member name="T:NPOI.HPSF.MissingSectionException">
            <summary>
            This exception is thrown if one of the {@link PropertySet}'s
            convenience methods does not Find a required {@link Section}.
            The constructors of this class are analogous To those of its
            superclass and documented there.
            @author Rainer Klute 
            <a href="mailto:klute@rainer-klute.de">&lt;klute@rainer-klute.de&gt;</a>
            @since 2006-02-08
            </summary>
        </member>
        <member name="M:NPOI.HPSF.MissingSectionException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HPSF.MissingSectionException"/> class.
            </summary>
        </member>
        <member name="M:NPOI.HPSF.MissingSectionException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HPSF.MissingSectionException"/> class.
            </summary>
            <param name="msg">The exception's message string</param>
        </member>
        <member name="M:NPOI.HPSF.MissingSectionException.#ctor(System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HPSF.MissingSectionException"/> class.
            </summary>
            <param name="reason">This exception's underlying reason.</param>
        </member>
        <member name="M:NPOI.HPSF.MissingSectionException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HPSF.MissingSectionException"/> class.
            </summary>
            <param name="msg">The exception's message string</param>
            <param name="reason">This exception's underlying reason</param>
        </member>
        <member name="T:NPOI.HPSF.MutableProperty">
            <summary>
            Adds writing capability To the {@link Property} class.
            Please be aware that this class' functionality will be merged into the
            {@link Property} class at a later time, so the API will Change.
            @author Rainer Klute 
            <a href="mailto:klute@rainer-klute.de">&lt;klute@rainer-klute.de&gt;</a>
            @since 2003-08-03
            </summary>
        </member>
        <member name="M:NPOI.HPSF.MutableProperty.#ctor">
            <summary>
            Creates an empty property. It must be Filled using the Set method To
            be usable.
            </summary>
        </member>
        <member name="M:NPOI.HPSF.MutableProperty.#ctor(NPOI.HPSF.Property)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HPSF.MutableProperty"/> class.
            </summary>
            <param name="p">The property To copy.</param>
        </member>
        <member name="M:NPOI.HPSF.MutableProperty.Write(System.IO.Stream,System.Int32)">
            <summary>
            Writes the property To an output stream.
            </summary>
            <param name="out1">The output stream To Write To.</param>
            <param name="codepage">The codepage To use for writing non-wide strings</param>
            <returns>the number of bytes written To the stream</returns>
        </member>
        <member name="T:NPOI.HPSF.MutablePropertySet">
            <summary>
            Adds writing support To the {@link PropertySet} class.
            Please be aware that this class' functionality will be merged into the
            {@link PropertySet} class at a later time, so the API will Change.
            @author Rainer Klute 
            <a href="mailto:klute@rainer-klute.de">&lt;klute@rainer-klute.de&gt;</a>
            @since 2003-02-19
            </summary>
        </member>
        <member name="M:NPOI.HPSF.MutablePropertySet.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HPSF.MutablePropertySet"/> class.
            Its primary task is To initialize the immutable field with their proper
            values. It also Sets fields that might Change To reasonable defaults.
            </summary>
        </member>
        <member name="M:NPOI.HPSF.MutablePropertySet.#ctor(NPOI.HPSF.PropertySet)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HPSF.MutablePropertySet"/> class.
            All nested elements, i.e.<c>Section</c>s and <c>Property</c> instances, will be their
            mutable counterparts in the new <c>MutablePropertySet</c>.
            </summary>
            <param name="ps">The property Set To copy</param>
        </member>
        <member name="F:NPOI.HPSF.MutablePropertySet.OFFSet_HEADER">
            The Length of the property Set stream header.
        </member>
        <member name="P:NPOI.HPSF.MutablePropertySet.ByteOrder">
            <summary>
            Gets or sets the "byteOrder" property.
            </summary>
            <value>the byteOrder value To Set</value>
        </member>
        <member name="P:NPOI.HPSF.MutablePropertySet.Format">
            <summary>
            Gets or sets the "format" property.
            </summary>
            <value>the format value To Set</value>
        </member>
        <member name="P:NPOI.HPSF.MutablePropertySet.OSVersion">
            <summary>
            Gets or sets the "osVersion" property
            </summary>
            <value>the osVersion value To Set.</value>
        </member>
        <member name="P:NPOI.HPSF.MutablePropertySet.ClassID">
            <summary>
            Gets or sets the property Set stream's low-level "class ID"
            </summary>
            <value>The property Set stream's low-level "class ID" field.</value>
        </member>
        <member name="M:NPOI.HPSF.MutablePropertySet.ClearSections">
            <summary>
            Removes all sections from this property Set.
            </summary>
        </member>
        <member name="M:NPOI.HPSF.MutablePropertySet.AddSection(NPOI.HPSF.Section)">
            <summary>
            Adds a section To this property Set.
            </summary>
            <param name="section">section The {@link Section} To Add. It will be Appended
            after any sections that are alReady present in the property Set
            and thus become the last section.</param>
        </member>
        <member name="M:NPOI.HPSF.MutablePropertySet.Write(System.IO.Stream)">
            <summary>
            Writes the property Set To an output stream.
            </summary>
            <param name="out1">the output stream To Write the section To</param>
        </member>
        <member name="M:NPOI.HPSF.MutablePropertySet.GetStream">
            <summary>
            Returns the contents of this property Set stream as an input stream.
            The latter can be used for example To Write the property Set into a POIFS
            document. The input stream represents a snapshot of the property Set.
            If the latter is modified while the input stream is still being
            Read, the modifications will not be reflected in the input stream but in
            the {@link MutablePropertySet} only.
            </summary>
            <returns>the contents of this property Set stream</returns>
        </member>
        <member name="M:NPOI.HPSF.MutablePropertySet.ToStream">
            <summary>
            Returns the contents of this property set stream as an input stream.
            The latter can be used for example to write the property set into a POIFS
            document. The input stream represents a snapshot of the property set.
            If the latter is modified while the input stream is still being
            read, the modifications will not be reflected in the input stream but in
            the {@link MutablePropertySet} only.
            </summary>
            <returns>the contents of this property set stream</returns>
        </member>
        <member name="M:NPOI.HPSF.MutablePropertySet.Write(NPOI.POIFS.FileSystem.DirectoryEntry,System.String)">
            <summary>
            Writes a property Set To a document in a POI filesystem directory
            </summary>
            <param name="dir">The directory in the POI filesystem To Write the document To.</param>
            <param name="name">The document's name. If there is alReady a document with the
            same name in the directory the latter will be overwritten.</param>
        </member>
        <member name="T:NPOI.HPSF.MutableSection">
            <summary>
            Adds writing capability To the {@link Section} class.
            Please be aware that this class' functionality will be merged into the
            {@link Section} class at a later time, so the API will Change.
            @since 2002-02-20
            </summary>
        </member>
        <member name="F:NPOI.HPSF.MutableSection.dirty">
            If the "dirty" flag is true, the section's size must be
            (re-)calculated before the section is written.
        </member>
        <member name="F:NPOI.HPSF.MutableSection.preprops">
            List To assemble the properties. Unfortunately a wrong
            decision has been taken when specifying the "properties" field
            as an Property[]. It should have been a {@link java.util.List}.
        </member>
        <member name="F:NPOI.HPSF.MutableSection.sectionBytes">
            Contains the bytes making out the section. This byte array is
            established when the section's size is calculated and can be reused
            later. It is valid only if the "dirty" flag is false.
        </member>
        <member name="M:NPOI.HPSF.MutableSection.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HPSF.MutableSection"/> class.
            </summary>
        </member>
        <member name="M:NPOI.HPSF.MutableSection.#ctor(NPOI.HPSF.Section)">
            <summary>
            Constructs a <c>MutableSection</c> by doing a deep copy of an
            existing <c>Section</c>. All nested <c>Property</c>
            instances, will be their mutable counterparts in the new
            <c>MutableSection</c>.
            </summary>
            <param name="s">The section Set To copy</param>
        </member>
        <member name="M:NPOI.HPSF.MutableSection.SetFormatID(NPOI.Util.ClassID)">
            <summary>
            Sets the section's format ID.
            </summary>
            <param name="formatID">The section's format ID</param>
        </member>
        <member name="M:NPOI.HPSF.MutableSection.SetFormatID(System.Byte[])">
            <summary>
            Sets the section's format ID.
            </summary>
            <param name="formatID">The section's format ID as a byte array. It components
            are in big-endian format.</param>
        </member>
        <member name="M:NPOI.HPSF.MutableSection.SetProperties(NPOI.HPSF.Property[])">
            <summary>
            Sets this section's properties. Any former values are overwritten.
            </summary>
            <param name="properties">This section's new properties.</param>
        </member>
        <member name="M:NPOI.HPSF.MutableSection.SetProperty(System.Int32,System.String)">
            <summary>
            Sets the string value of the property with the specified ID.
            </summary>
            <param name="id">The property's ID</param>
            <param name="value">The property's value. It will be written as a Unicode
            string.</param>
        </member>
        <member name="M:NPOI.HPSF.MutableSection.SetProperty(System.Int32,System.Int32)">
            <summary>
            Sets the int value of the property with the specified ID.
            </summary>
            <param name="id">The property's ID</param>
            <param name="value">The property's value.</param>
        </member>
        <member name="M:NPOI.HPSF.MutableSection.SetProperty(System.Int32,System.Int64)">
            <summary>
            Sets the long value of the property with the specified ID.
            </summary>
            <param name="id">The property's ID</param>
            <param name="value">The property's value.</param>
        </member>
        <member name="M:NPOI.HPSF.MutableSection.SetProperty(System.Int32,System.Boolean)">
            <summary>
            Sets the bool value of the property with the specified ID.
            </summary>
            <param name="id">The property's ID</param>
            <param name="value">The property's value.</param>
        </member>
        <member name="M:NPOI.HPSF.MutableSection.SetProperty(System.Int32,System.Int64,System.Object)">
            <summary>
            Sets the value and the variant type of the property with the
            specified ID. If a property with this ID is not yet present in
            the section, it will be Added. An alReady present property with
            the specified ID will be overwritten. A default mapping will be
            used To choose the property's type.
            </summary>
            <param name="id">The property's ID.</param>
            <param name="variantType">The property's variant type.</param>
            <param name="value">The property's value.</param>
        </member>
        <member name="M:NPOI.HPSF.MutableSection.SetProperty(NPOI.HPSF.Property)">
            <summary>
            Sets the property.
            </summary>
            <param name="p">The property To be Set.</param>
        </member>
        <member name="M:NPOI.HPSF.MutableSection.RemoveProperty(System.Int64)">
            <summary>
            Removes the property.
            </summary>
            <param name="id">The ID of the property To be Removed</param>
        </member>
        <member name="M:NPOI.HPSF.MutableSection.SetPropertyBooleanValue(System.Int32,System.Boolean)">
            <summary>
            Sets the value of the bool property with the specified
            ID.
            </summary>
            <param name="id">The property's ID</param>
            <param name="value">The property's value</param>
        </member>
        <member name="P:NPOI.HPSF.MutableSection.Size">
            <summary>
            Returns the section's size in bytes.
            </summary>
            <value>The section's size in bytes.</value>
        </member>
        <member name="M:NPOI.HPSF.MutableSection.CalcSize">
            <summary>
            Calculates the section's size. It is the sum of the Lengths of the
            section's header (8), the properties list (16 times the number of
            properties) and the properties themselves.
            </summary>
            <returns>the section's Length in bytes.</returns>
        </member>
        <member name="M:NPOI.HPSF.MutableSection.Write(System.IO.Stream)">
            <summary>
            Writes this section into an output stream.
            Internally this is done by writing into three byte array output
            streams: one for the properties, one for the property list and one for
            the section as such. The two former are Appended To the latter when they
            have received all their data.
            </summary>
            <param name="out1">The stream To Write into.</param>
            <returns>The number of bytes written, i.e. the section's size.</returns>
        </member>
        <member name="M:NPOI.HPSF.MutableSection.WriteDictionary(System.IO.Stream,System.Collections.IDictionary,System.Int32)">
            <summary>
            Writes the section's dictionary
            </summary>
            <param name="out1">The output stream To Write To.</param>
            <param name="dictionary">The dictionary.</param>
            <param name="codepage">The codepage To be used To Write the dictionary items.</param>
            <returns>The number of bytes written</returns>
            <remarks>
            see MSDN KB: http://msdn.microsoft.com/en-us/library/aa380065(VS.85).aspx
            </remarks>
        </member>
        <member name="P:NPOI.HPSF.MutableSection.PropertyCount">
            <summary>
            OverWrites the base class' method To cope with a redundancy:
            the property count is maintained in a separate member variable, but
            shouldn't.
            </summary>
            <value>The number of properties in this section.</value>
        </member>
        <member name="P:NPOI.HPSF.MutableSection.Properties">
            <summary>
            Returns this section's properties.
            </summary>
            <value>This section's properties.</value>
        </member>
        <member name="M:NPOI.HPSF.MutableSection.EnsureProperties">
            <summary>
            Ensures the properties.
            </summary>
        </member>
        <member name="M:NPOI.HPSF.MutableSection.GetProperty(System.Int64)">
            <summary>
            Gets a property.
            </summary>
            <param name="id">The ID of the property To Get</param>
            <returns>The property or null  if there is no such property</returns>
        </member>
        <member name="P:NPOI.HPSF.MutableSection.Dictionary">
            <summary>
            Sets the section's dictionary. All keys in the dictionary must be
            {@link java.lang.long} instances, all values must be
            {@link java.lang.String}s. This method overWrites the properties with IDs
            0 and 1 since they are reserved for the dictionary and the dictionary's
            codepage. Setting these properties explicitly might have surprising
            effects. An application should never do this but always use this
            method.
            </summary>
            <value>
            the dictionary
            </value>
        </member>
        <member name="M:NPOI.HPSF.MutableSection.SetProperty(System.Int32,System.Object)">
            <summary>
            Sets the property.
            </summary>
            <param name="id">The property ID.</param>
            <param name="value">The property's value. The value's class must be one of those
            supported by HPSF.</param>
        </member>
        <member name="M:NPOI.HPSF.MutableSection.Clear">
            <summary>
            Removes all properties from the section including 0 (dictionary) and
            1 (codepage).
            </summary>
        </member>
        <member name="P:NPOI.HPSF.MutableSection.Codepage">
            <summary>
            Gets the section's codepage, if any.
            </summary>
            <value>The section's codepage if one is defined, else -1.</value>
        </member>
        <member name="T:NPOI.HPSF.NoFormatIDException">
            <summary>
            This exception is thrown if a {@link MutablePropertySet} is To be written
            but does not have a formatID Set (see {@link
            MutableSection#SetFormatID(ClassID)} or
            {@link org.apache.poi.hpsf.MutableSection#SetFormatID(byte[])}.
            @author Rainer Klute 
            <a href="mailto:klute@rainer-klute.de">&lt;klute@rainer-klute.de&gt;</a>
            @since 2002-09-03 
            </summary>
        </member>
        <member name="M:NPOI.HPSF.NoFormatIDException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HPSF.NoFormatIDException"/> class.
            </summary>
        </member>
        <member name="M:NPOI.HPSF.NoFormatIDException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HPSF.NoFormatIDException"/> class.
            </summary>
            <param name="msg">The exception's message string</param>
        </member>
        <member name="M:NPOI.HPSF.NoFormatIDException.#ctor(System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HPSF.NoFormatIDException"/> class.
            </summary>
            <param name="reason">This exception's underlying reason</param>
        </member>
        <member name="M:NPOI.HPSF.NoFormatIDException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HPSF.NoFormatIDException"/> class.
            </summary>
            <param name="msg">The exception's message string</param>
            <param name="reason">This exception's underlying reason</param>
        </member>
        <member name="T:NPOI.HPSF.NoPropertySetStreamException">
            <summary>
            This exception is thrown if a format error in a property Set stream Is
            detected or when the input data do not constitute a property Set stream.
            The constructors of this class are analogous To those of its superclass
            and are documented there.
            @author Rainer Klute 
            <a href="mailto:klute@rainer-klute.de">&lt;klute@rainer-klute.de&gt;</a>
            @since 2002-02-09
            </summary>
        </member>
        <member name="M:NPOI.HPSF.NoPropertySetStreamException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HPSF.NoPropertySetStreamException"/> class.
            </summary>
        </member>
        <member name="M:NPOI.HPSF.NoPropertySetStreamException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HPSF.NoPropertySetStreamException"/> class.
            </summary>
            <param name="msg">The exception's message string</param>
        </member>
        <member name="M:NPOI.HPSF.NoPropertySetStreamException.#ctor(System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HPSF.NoPropertySetStreamException"/> class.
            </summary>
            <param name="reason">This exception's underlying reason</param>
        </member>
        <member name="M:NPOI.HPSF.NoPropertySetStreamException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HPSF.NoPropertySetStreamException"/> class.
            </summary>
            <param name="msg">The exception's message string</param>
            <param name="reason">This exception's underlying reason</param>
        </member>
        <member name="T:NPOI.HPSF.NoSingleSectionException">
            <summary>
            This exception is thrown if one of the {@link PropertySet}'s
            convenience methods that require a single {@link Section} is called
            and the {@link PropertySet} does not contain exactly one {@link
            Section}.
            The constructors of this class are analogous To those of its
            superclass and documented there.
            @author Rainer Klute 
            <a href="mailto:klute@rainer-klute.de">&lt;klute@rainer-klute.de&gt;</a>
            @since 2002-02-09
            </summary>
        </member>
        <member name="M:NPOI.HPSF.NoSingleSectionException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HPSF.NoSingleSectionException"/> class.
            </summary>
        </member>
        <member name="M:NPOI.HPSF.NoSingleSectionException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HPSF.NoSingleSectionException"/> class.
            </summary>
            <param name="msg">The exception's message string</param>
        </member>
        <member name="M:NPOI.HPSF.NoSingleSectionException.#ctor(System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HPSF.NoSingleSectionException"/> class.
            </summary>
            <param name="reason">This exception's underlying reason</param>
        </member>
        <member name="M:NPOI.HPSF.NoSingleSectionException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HPSF.NoSingleSectionException"/> class.
            </summary>
            <param name="msg">The exception's message string</param>
            <param name="reason">This exception's underlying reason</param>
        </member>
        <member name="T:NPOI.HPSF.Property">
            <summary>
            A property in a {@link Section} of a {@link PropertySet}.
            The property's ID gives the property a meaning
            in the context of its {@link Section}. Each {@link Section} spans
            its own name space of property IDs.
            The property's type determines how its
            value  is interpreted. For example, if the type Is
            {@link Variant#VT_LPSTR} (byte string), the value consists of a
            DWord telling how many bytes the string Contains. The bytes follow
            immediately, including any null bytes that terminate the
            string. The type {@link Variant#VT_I4} denotes a four-byte integer
            value, {@link Variant#VT_FILETIME} some DateTime and time (of a
            file).
            Please note that not all {@link Variant} types yet. This might Change
            over time but largely depends on your feedback so that the POI team knows
            which variant types are really needed. So please feel free To submit error
            reports or patches for the types you need.
            Microsoft documentation: 
            <a href="http://msdn.microsoft.com/library/en-us/stg/stg/property_Set_display_name_dictionary.asp?frame=true">
            Property Set Display Name Dictionary</a>
            .
            @author Rainer Klute 
            <a href="mailto:klute@rainer-klute.de">&lt;klute@rainer-klute.de&gt;</a>
            @author Drew Varner (Drew.Varner InAndAround sc.edu)
            @see Section
            @see Variant
            @since 2002-02-09
            </summary>
        </member>
        <member name="F:NPOI.HPSF.Property.id">
            The property's ID. 
        </member>
        <member name="P:NPOI.HPSF.Property.ID">
             Returns the property's ID.
            
             @return The ID value
        </member>
        <member name="F:NPOI.HPSF.Property.type">
            The property's type. 
        </member>
        <member name="P:NPOI.HPSF.Property.Type">
             Returns the property's type.
            
             @return The type value
        </member>
        <member name="F:NPOI.HPSF.Property.value">
            The property's value. 
        </member>
        <member name="P:NPOI.HPSF.Property.Value">
            <summary>
            Gets the property's value.
            </summary>
            <value>The property's value</value>
        </member>
        <member name="M:NPOI.HPSF.Property.#ctor(System.Int64,System.Int64,System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HPSF.Property"/> class.
            </summary>
            <param name="id">the property's ID.</param>
            <param name="type">the property's type, see {@link Variant}.</param>
            <param name="value">the property's value. Only certain types are allowed, see
            {@link Variant}.</param>
        </member>
        <member name="M:NPOI.HPSF.Property.#ctor(System.Int64,System.Byte[],System.Int64,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HPSF.Property"/> class.
            </summary>
            <param name="id">The property's ID.</param>
            <param name="src">The bytes the property Set stream consists of.</param>
            <param name="offset">The property's type/value pair's offset in the
            section.</param>
            <param name="Length">The property's type/value pair's Length in bytes.</param>
            <param name="codepage">The section's and thus the property's
            codepage. It is needed only when Reading string values</param>
        </member>
        <member name="M:NPOI.HPSF.Property.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HPSF.Property"/> class.
            </summary>
        </member>
        <member name="M:NPOI.HPSF.Property.ReadDictionary(System.Byte[],System.Int64,System.Int32,System.Int32)">
            <summary>
            Reads the dictionary.
            </summary>
            <param name="src">The byte array containing the bytes making out the dictionary.</param>
            <param name="offset">At this offset within src the dictionary starts.</param>
            <param name="Length">The dictionary Contains at most this many bytes.</param>
            <param name="codepage">The codepage of the string values.</param>
            <returns>The dictonary</returns>
        </member>
        <member name="P:NPOI.HPSF.Property.Count">
            <summary>
            Gets the property's size in bytes. This is always a multiple of
            4.
            </summary>
            <value>the property's size in bytes</value>
        </member>
        <member name="M:NPOI.HPSF.Property.Equals(System.Object)">
            <summary>
            Compares two properties.
            Please beware that a property with
            ID == 0 is a special case: It does not have a type, and its value is the
            section's dictionary. Another special case are strings: Two properties
            may have the different types Variant.VT_LPSTR and Variant.VT_LPWSTR;
            </summary>
            <param name="o">The o.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.HPSF.Property.TypesAreEqual(System.Int64,System.Int64)">
            <summary>
            Typeses the are equal.
            </summary>
            <param name="t1">The t1.</param>
            <param name="t2">The t2.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.HPSF.Property.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="M:NPOI.HPSF.Property.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="T:NPOI.HPSF.PropertySet">
            <summary>
            Represents a property Set in the Horrible Property Set Format
            (HPSF). These are usually metadata of a Microsoft Office
            document.
            An application that wants To access these metadata should Create
            an instance of this class or one of its subclasses by calling the
            factory method {@link PropertySetFactory#Create} and then retrieve
            the information its needs by calling appropriate methods.
            {@link PropertySetFactory#Create} does its work by calling one
            of the constructors {@link PropertySet#PropertySet(InputStream)} or
            {@link PropertySet#PropertySet(byte[])}. If the constructor's
            argument is not in the Horrible Property Set Format, i.e. not a
            property Set stream, or if any other error occurs, an appropriate
            exception is thrown.
            A {@link PropertySet} has a list of {@link Section}s, and each
            {@link Section} has a {@link Property} array. Use {@link
            #GetSections} To retrieve the {@link Section}s, then call {@link
            Section#GetProperties} for each {@link Section} To Get hold of the
            {@link Property} arrays. Since the vast majority of {@link
            PropertySet}s Contains only a single {@link Section}, the
            convenience method {@link #GetProperties} returns the properties of
            a {@link PropertySet}'s {@link Section} (throwing a {@link
            NoSingleSectionException} if the {@link PropertySet} Contains more
            (or less) than exactly one {@link Section}).
            @author Rainer Klute 
            <a href="mailto:klute@rainer-klute.de">&lt;klute@rainer-klute.de&gt;</a>
            @author Drew Varner (Drew.Varner hanginIn sc.edu)
            @since 2002-02-09
            </summary>
        </member>
        <member name="F:NPOI.HPSF.PropertySet.BYTE_ORDER_ASSERTION">
            The "byteOrder" field must equal this value.
        </member>
        <member name="F:NPOI.HPSF.PropertySet.byteOrder">
            Specifies this {@link PropertySet}'s byte order. See the
            HPFS documentation for details!
        </member>
        <member name="P:NPOI.HPSF.PropertySet.ByteOrder">
            <summary>
            Gets or sets the property Set stream's low-level "byte order"
            field. It is always <tt>0xFFFE</tt>
            </summary>
            <value>The property Set stream's low-level "byte order" field..</value>
        </member>
        <member name="F:NPOI.HPSF.PropertySet.FORMAT_ASSERTION">
            The "format" field must equal this value.
        </member>
        <member name="F:NPOI.HPSF.PropertySet.format">
            Specifies this {@link PropertySet}'s format. See the HPFS
            documentation for details!
        </member>
        <member name="P:NPOI.HPSF.PropertySet.Format">
            <summary>
            Gets or sets the property Set stream's low-level "format"
            field. It is always <tt>0x0000</tt>
            </summary>
            <value>The property Set stream's low-level "format" field.</value>
        </member>
        <member name="F:NPOI.HPSF.PropertySet.osVersion">
            Specifies the version of the operating system that Created
            this {@link PropertySet}. See the HPFS documentation for
            details!
        </member>
        <member name="F:NPOI.HPSF.PropertySet.OS_WIN16">
            If the OS version field holds this value the property Set stream Was
            Created on a 16-bit Windows system.
        </member>
        <member name="F:NPOI.HPSF.PropertySet.OS_MACINTOSH">
            If the OS version field holds this value the property Set stream Was
            Created on a Macintosh system.
        </member>
        <member name="F:NPOI.HPSF.PropertySet.OS_WIN32">
            If the OS version field holds this value the property Set stream Was
            Created on a 32-bit Windows system.
        </member>
        <member name="P:NPOI.HPSF.PropertySet.OSVersion">
            <summary>
            Returns the property Set stream's low-level "OS version"
            field.
            </summary>
            <value>The property Set stream's low-level "OS version" field.</value>
        </member>
        <member name="F:NPOI.HPSF.PropertySet.classID">
            Specifies this {@link PropertySet}'s "classID" field. See
            the HPFS documentation for details!
        </member>
        <member name="P:NPOI.HPSF.PropertySet.ClassID">
            <summary>
            Gets or sets the property Set stream's low-level "class ID"
            </summary>
            <value>The property Set stream's low-level "class ID" field.</value>
        </member>
        <member name="P:NPOI.HPSF.PropertySet.SectionCount">
            <summary>
            Returns the number of {@link Section}s in the property
            Set.
            </summary>
            <value>The number of {@link Section}s in the property Set.</value>
        </member>
        <member name="F:NPOI.HPSF.PropertySet.sections">
            The sections in this {@link PropertySet}.
        </member>
        <member name="P:NPOI.HPSF.PropertySet.Sections">
            <summary>
            Returns the {@link Section}s in the property Set.
            </summary>
            <value>{@link Section}s in the property Set.</value>
        </member>
        <member name="M:NPOI.HPSF.PropertySet.#ctor">
            <summary>
            Creates an empty (uninitialized) {@link PropertySet}
            Please note: For the time being this
            constructor is protected since it is used for internal purposes
            only, but expect it To become public once the property Set's
            writing functionality is implemented.
            </summary>
        </member>
        <member name="M:NPOI.HPSF.PropertySet.#ctor(System.IO.Stream)">
            <summary>
            Creates a {@link PropertySet} instance from an {@link
            InputStream} in the Horrible Property Set Format.
            The constructor Reads the first few bytes from the stream
            and determines whether it is really a property Set stream. If
            it Is, it parses the rest of the stream. If it is not, it
            Resets the stream To its beginning in order To let other
            components mess around with the data and throws an
            exception.
            </summary>
            <param name="stream">Holds the data making out the property Set
            stream.</param>
        </member>
        <member name="M:NPOI.HPSF.PropertySet.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Creates a {@link PropertySet} instance from a byte array
            that represents a stream in the Horrible Property Set
            Format.
            </summary>
            <param name="stream">The byte array holding the stream data.</param>
            <param name="offset">The offset in stream where the stream data begin. 
            If the stream data begin with the first byte in the
            array, the offset is 0.</param>
            <param name="Length"> The Length of the stream data.</param>
        </member>
        <member name="M:NPOI.HPSF.PropertySet.#ctor(System.Byte[])">
            <summary>
            Creates a {@link PropertySet} instance from a byte array
            that represents a stream in the Horrible Property Set
            Format.
            </summary>
            <param name="stream">The byte array holding the stream data. The
            complete byte array contents is the stream data.</param>
        </member>
        <member name="M:NPOI.HPSF.PropertySet.IsPropertySetStream(System.IO.Stream)">
            <summary>
            Checks whether an {@link InputStream} is in the Horrible
            Property Set Format.
            </summary>
            <param name="stream">The {@link InputStream} To check. In order To
            perform the check, the method Reads the first bytes from the
            stream. After Reading, the stream is Reset To the position it
            had before Reading. The {@link InputStream} must support the
            {@link InputStream#mark} method.</param>
            <returns>
            	<c>true</c> if the stream is a property Set
            stream; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NPOI.HPSF.PropertySet.IsPropertySetStream(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Checks whether a byte array is in the Horrible Property Set
            Format.
            </summary>
            <param name="src">The byte array To check.</param>
            <param name="offset">The offset in the byte array.</param>
            <param name="Length">The significant number of bytes in the byte
            array. Only this number of bytes will be checked.</param>
            <returns>
            	<c>true</c> if the byte array is a property Set
            stream; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NPOI.HPSF.PropertySet.init(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Initializes this {@link PropertySet} instance from a byte
            array. The method assumes that it has been checked alReady that
            the byte array indeed represents a property Set stream. It does
            no more checks on its own.
            </summary>
            <param name="src">Byte array containing the property Set stream</param>
            <param name="offset">The property Set stream starts at this offset</param>
            <param name="Length">Length of the property Set stream.</param>
        </member>
        <member name="P:NPOI.HPSF.PropertySet.IsSummaryInformation">
            <summary>
            Checks whether this {@link PropertySet} represents a Summary
            Information.
            </summary>
            <value>
            	<c>true</c> Checks whether this {@link PropertySet} represents a Summary
            Information; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:NPOI.HPSF.PropertySet.IsDocumentSummaryInformation">
            <summary>
            Gets a value indicating whether this instance is document summary information.
            </summary>
            <value>
            	<c>true</c> if this instance is document summary information; otherwise, <c>false</c>.
            </value>
            Checks whether this {@link PropertySet} is a Document
            Summary Information.
            @return 
            <c>true</c>
             if this {@link PropertySet}
            represents a Document Summary Information, else 
            <c>false</c>
        </member>
        <member name="P:NPOI.HPSF.PropertySet.Properties">
            <summary>
            Convenience method returning the {@link Property} array
            contained in this property Set. It is a shortcut for Getting
            the {@link PropertySet}'s {@link Section}s list and then
            Getting the {@link Property} array from the first {@link
            Section}.
            </summary>
            <value>The properties of the only {@link Section} of this
            {@link PropertySet}.</value>
        </member>
        <member name="M:NPOI.HPSF.PropertySet.GetProperty(System.Int32)">
            <summary>
            Convenience method returning the value of the property with
            the specified ID. If the property is not available,
            <c>null</c> is returned and a subsequent call To {@link
            #WasNull} will return <c>true</c> .
            </summary>
            <param name="id">The property ID</param>
            <returns>The property value</returns>
        </member>
        <member name="M:NPOI.HPSF.PropertySet.GetPropertyBooleanValue(System.Int32)">
            <summary>
            Convenience method returning the value of a bool property
            with the specified ID. If the property is not available,
            <c>false</c> is returned. A subsequent call To {@link
            #WasNull} will return <c>true</c> To let the caller
            distinguish that case from a real property value of
            <c>false</c>.
            </summary>
            <param name="id">The property ID</param>
            <returns>The property value</returns>
        </member>
        <member name="M:NPOI.HPSF.PropertySet.GetPropertyIntValue(System.Int32)">
            <summary>
            Convenience method returning the value of the numeric
            property with the specified ID. If the property is not
            available, 0 is returned. A subsequent call To {@link #WasNull}
            will return <c>true</c> To let the caller distinguish
            that case from a real property value of 0.
            </summary>
            <param name="id">The property ID</param>
            <returns>The propertyIntValue value</returns>
        </member>
        <member name="P:NPOI.HPSF.PropertySet.WasNull">
            <summary>
            Checks whether the property which the last call To {@link
            #GetPropertyIntValue} or {@link #GetProperty} tried To access
            Was available or not. This information might be important for
            callers of {@link #GetPropertyIntValue} since the latter
            returns 0 if the property does not exist. Using {@link
            #WasNull}, the caller can distiguish this case from a
            property's real value of 0.
            </summary>
            <value><c>true</c> if the last call To {@link
            #GetPropertyIntValue} or {@link #GetProperty} tried To access a
            property that Was not available; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:NPOI.HPSF.PropertySet.FirstSection">
            <summary>
            Gets the first section.
            </summary>
            <value>The first section.</value>
        </member>
        <member name="P:NPOI.HPSF.PropertySet.SingleSection">
            <summary>
            If the {@link PropertySet} has only a single section this
            method returns it.
            </summary>
            <value>The singleSection value</value>
        </member>
        <member name="M:NPOI.HPSF.PropertySet.Equals(System.Object)">
            <summary>
            Returns <c>true</c> if the <c>PropertySet</c> is equal
            To the specified parameter, else <c>false</c>.
            </summary>
            <param name="o">the object To Compare this 
            <c>PropertySet</c>
             with</param>
            <returns><c>true</c>
             if the objects are equal, 
            <c>false</c>
            if not</returns>
        </member>
        <member name="M:NPOI.HPSF.PropertySet.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="M:NPOI.HPSF.PropertySet.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="T:NPOI.HPSF.PropertySetFactory">
            <summary>
            Factory class To Create instances of {@link SummaryInformation},
            {@link DocumentSummaryInformation} and {@link PropertySet}.
            @author Rainer Klute 
            <a href="mailto:klute@rainer-klute.de">&lt;klute@rainer-klute.de&gt;</a>
            @since 2002-02-09
            </summary>
        </member>
        <member name="M:NPOI.HPSF.PropertySetFactory.Create(System.IO.Stream)">
            <summary>
            Creates the most specific {@link PropertySet} from an {@link
            InputStream}. This is preferrably a {@link
            DocumentSummaryInformation} or a {@link SummaryInformation}. If
            the specified {@link InputStream} does not contain a property
            Set stream, an exception is thrown and the {@link InputStream}
            is repositioned at its beginning.
            </summary>
            <param name="stream">Contains the property set stream's data.</param>
            <returns>The Created {@link PropertySet}.</returns>
        </member>
        <member name="M:NPOI.HPSF.PropertySetFactory.CreateSummaryInformation">
            <summary>
            Creates a new summary information
            </summary>
            <returns>the new summary information.</returns>
        </member>
        <member name="M:NPOI.HPSF.PropertySetFactory.CreateDocumentSummaryInformation">
            <summary>
            Creates a new document summary information.
            </summary>
            <returns>the new document summary information.</returns>
        </member>
        <member name="T:NPOI.HPSF.ReadingNotSupportedException">
            <summary>
            This exception is thrown when HPSF tries To Read a (yet) unsupported
            variant type.
            @see WritingNotSupportedException
            @see UnsupportedVariantTypeException
            @author Rainer Klute 
            <a href="mailto:klute@rainer-klute.de">&lt;klute@rainer-klute.de&gt;</a>
            @since 2003-08-08
            </summary>
        </member>
        <member name="M:NPOI.HPSF.ReadingNotSupportedException.#ctor(System.Int64,System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HPSF.ReadingNotSupportedException"/> class.
            </summary>
            <param name="variantType">The unsupported variant type</param>
            <param name="value">The value who's variant type is not yet supported</param>
        </member>
        <member name="T:NPOI.HPSF.Section">
            <summary>
            Represents a section in a {@link PropertySet}.
            @author Rainer Klute 
            <a href="mailto:klute@rainer-klute.de">&lt;klute@rainer-klute.de&gt;</a>
            @author Drew Varner (Drew.Varner allUpIn sc.edu)
            @since 2002-02-09
            </summary>
        </member>
        <member name="F:NPOI.HPSF.Section.dictionary">
            Maps property IDs To section-private PID strings. These
            strings can be found in the property with ID 0.
        </member>
        <member name="F:NPOI.HPSF.Section.formatID">
            The section's format ID, {@link #GetFormatID}.
        </member>
        <member name="P:NPOI.HPSF.Section.FormatID">
            <summary>
            Returns the format ID. The format ID is the "type" of the
            section. For example, if the format ID of the first {@link
            Section} Contains the bytes specified by 
            <c>org.apache.poi.hpsf.wellknown.SectionIDMap.SUMMARY_INFORMATION_ID</c>
            the section (and thus the property Set) is a SummaryInformation.
            </summary>
            <value>The format ID.</value>
        </member>
        <member name="P:NPOI.HPSF.Section.OffSet">
            <summary>
            Gets the offset of the section in the stream.
            </summary>
            <value>The offset of the section in the stream</value>
        </member>
        <member name="P:NPOI.HPSF.Section.Size">
            <summary>
            Returns the section's size in bytes.
            </summary>
            <value>The section's size in bytes.</value>
        </member>
        <member name="P:NPOI.HPSF.Section.PropertyCount">
            <summary>
            Returns the number of properties in this section.
            </summary>
            <value>The number of properties in this section.</value> 
        </member>
        <member name="P:NPOI.HPSF.Section.Properties">
            <summary>
            Returns this section's properties.
            </summary>
            <value>This section's properties.</value>
        </member>
        <member name="M:NPOI.HPSF.Section.#ctor">
            <summary>
            Creates an empty and uninitialized {@link Section}.
            </summary>
        </member>
        <member name="M:NPOI.HPSF.Section.#ctor(System.Byte[],System.Int32)">
            <summary>
            Creates a {@link Section} instance from a byte array.
            </summary>
            <param name="src">Contains the complete property Set stream.</param>
            <param name="offset">The position in the stream that points To the
            section's format ID.</param>
        </member>
        <member name="T:NPOI.HPSF.Section.PropertyListEntry">
            Represents an entry in the property list and holds a property's ID and
            its offset from the section's beginning.
        </member>
        <member name="M:NPOI.HPSF.Section.PropertyListEntry.CompareTo(System.Object)">
             Compares this {@link PropertyListEntry} with another one by their
             offsets. A {@link PropertyListEntry} is "smaller" than another one if
             its offset from the section's begin is smaller.
            
             @see Comparable#CompareTo(java.lang.Object)
        </member>
        <member name="M:NPOI.HPSF.Section.GetProperty(System.Int64)">
             Returns the value of the property with the specified ID. If
             the property is not available, <c>null</c> is returned
             and a subsequent call To {@link #wasNull} will return
             <c>true</c>.
            
             @param id The property's ID
            
             @return The property's value
        </member>
        <member name="M:NPOI.HPSF.Section.GetPropertyIntValue(System.Int64)">
             Returns the value of the numeric property with the specified
             ID. If the property is not available, 0 is returned. A
             subsequent call To {@link #wasNull} will return
             <c>true</c> To let the caller distinguish that case from
             a real property value of 0.
            
             @param id The property's ID
            
             @return The property's value
        </member>
        <member name="M:NPOI.HPSF.Section.GetPropertyBooleanValue(System.Int32)">
             Returns the value of the bool property with the specified
             ID. If the property is not available, <c>false</c> Is
             returned. A subsequent call To {@link #wasNull} will return
             <c>true</c> To let the caller distinguish that case from
             a real property value of <c>false</c>.
            
             @param id The property's ID
            
             @return The property's value
        </member>
        <member name="F:NPOI.HPSF.Section.wasNull">
            This member is <c>true</c> if the last call To {@link
            #GetPropertyIntValue} or {@link #GetProperty} tried To access a
            property that was not available, else <c>false</c>.
        </member>
        <member name="P:NPOI.HPSF.Section.WasNull">
            <summary>
            Checks whether the property which the last call To {@link
            #GetPropertyIntValue} or {@link #GetProperty} tried To access
            was available or not. This information might be important for
            callers of {@link #GetPropertyIntValue} since the latter
            returns 0 if the property does not exist. Using {@link
            #wasNull} the caller can distiguish this case from a property's
            real value of 0.
            </summary>
            <value><c>true</c> if the last call To {@link
            #GetPropertyIntValue} or {@link #GetProperty} tried To access a
            property that was not available; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:NPOI.HPSF.Section.GetPIDString(System.Int64)">
            <summary>
            Returns the PID string associated with a property ID. The ID
            is first looked up in the {@link Section}'s private
            dictionary. If it is not found there, the method calls {@link
            SectionIDMap#GetPIDString}.
            </summary>
            <param name="pid">The property ID.</param>
            <returns>The property ID's string value</returns>
        </member>
        <member name="M:NPOI.HPSF.Section.Equals(System.Object)">
            Checks whether this section is equal To another object. The result Is
            <c>false</c> if one of the the following conditions holds:
            
            <ul>
            
            <li>The other object is not a {@link Section}.</li>
            
            <li>The format IDs of the two sections are not equal.</li>
              
            <li>The sections have a different number of properties. However,
            properties with ID 1 (codepage) are not counted.</li>
            
            <li>The other object is not a {@link Section}.</li>
            
            <li>The properties have different values. The order of the properties
            is irrelevant.</li>
            
            </ul>
            
            @param o The object To Compare this section with
            @return <c>true</c> if the objects are equal, <c>false</c> if
            not
        </member>
        <member name="M:NPOI.HPSF.Section.Remove(NPOI.HPSF.Property[],System.Int32)">
            <summary>
            Removes a field from a property array. The resulting array Is
            compactified and returned.
            </summary>
            <param name="pa">The property array.</param>
            <param name="i">The index of the field To be Removed.</param>
            <returns>the compactified array.</returns>
        </member>
        <member name="M:NPOI.HPSF.Section.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="M:NPOI.HPSF.Section.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="P:NPOI.HPSF.Section.Dictionary">
            <summary>
            Gets the section's dictionary. A dictionary allows an application To
            use human-Readable property names instead of numeric property IDs. It
            Contains mappings from property IDs To their associated string
            values. The dictionary is stored as the property with ID 0. The codepage
            for the strings in the dictionary is defined by property with ID 1.
            </summary>
            <value>the dictionary or null
             if the section does not have
            a dictionary.</value>
        </member>
        <member name="P:NPOI.HPSF.Section.Codepage">
            <summary>
            Gets the section's codepage, if any.
            </summary>
            <value>The section's codepage if one is defined, else -1.</value>
        </member>
        <member name="T:NPOI.HPSF.SpecialPropertySet">
            <summary>
            Abstract superclass for the convenience classes {@link
            SummaryInformation} and {@link DocumentSummaryInformation}.
            The motivation behind this class is quite nasty if you look
            behind the scenes, but it serves the application programmer well by
            providing him with the easy-to-use {@link SummaryInformation} and
            {@link DocumentSummaryInformation} classes. When parsing the data a
            property Set stream consists of (possibly coming from an {@link
            java.io.Stream}) we want To Read and process each byte only
            once. Since we don't know in advance which kind of property Set we
            have, we can expect only the most general {@link
            PropertySet}. Creating a special subclass should be as easy as
            calling the special subclass' constructor and pass the general
            {@link PropertySet} in. To make things easy internally, the special
            class just holds a reference To the general {@link PropertySet} and
            delegates all method calls To it.
            A cleaner implementation would have been like this: The {@link
            PropertySetFactory} parses the stream data into some internal
            object first.  Then it Finds out whether the stream is a {@link
            SummaryInformation}, a {@link DocumentSummaryInformation} or a
            general {@link PropertySet}.  However, the current implementation
            went the other way round historically: the convenience classes came
            only late To my mind.
            @author Rainer Klute 
            klute@rainer-klute.de
            @since 2002-02-09
            </summary>
        </member>
        <member name="P:NPOI.HPSF.SpecialPropertySet.PropertySetIDMap">
            The id to name mapping of the properties
             in this set.
        </member>
        <member name="F:NPOI.HPSF.SpecialPropertySet.delegate1">
            The "real" property Set <c>SpecialPropertySet</c>
            delegates To.
        </member>
        <member name="M:NPOI.HPSF.SpecialPropertySet.#ctor(NPOI.HPSF.PropertySet)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HPSF.SpecialPropertySet"/> class.
            </summary>
            <param name="ps">The property Set To be encapsulated by the <c>SpecialPropertySet</c></param>
        </member>
        <member name="M:NPOI.HPSF.SpecialPropertySet.#ctor(NPOI.HPSF.MutablePropertySet)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HPSF.SpecialPropertySet"/> class.
            </summary>
            <param name="ps">The mutable property Set To be encapsulated by the <c>SpecialPropertySet</c></param>
        </member>
        <member name="P:NPOI.HPSF.SpecialPropertySet.ByteOrder">
            <summary>
            gets or sets the "byteOrder" property.
            </summary>
            <value>the byteOrder value To Set</value>
        </member>
        <member name="P:NPOI.HPSF.SpecialPropertySet.Format">
            <summary>
            gets or sets the "format" property
            </summary>
            <value>the format value To Set</value>
        </member>
        <member name="P:NPOI.HPSF.SpecialPropertySet.ClassID">
            <summary>
            gets or sets the property Set stream's low-level "class ID"
            field.
            </summary>
            <value>The property Set stream's low-level "class ID" field</value>
        </member>
        <member name="P:NPOI.HPSF.SpecialPropertySet.SectionCount">
            <summary>
            Returns the number of {@link Section}s in the property
            Set.
            </summary>
            <value>The number of {@link Section}s in the property Set.</value>
        </member>
        <member name="P:NPOI.HPSF.SpecialPropertySet.IsSummaryInformation">
            <summary>
            Checks whether this {@link PropertySet} represents a Summary
            Information.
            </summary>
            <value>
            	<c>true</c> Checks whether this {@link PropertySet} represents a Summary
            Information; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:NPOI.HPSF.SpecialPropertySet.IsDocumentSummaryInformation">
            <summary>
            Gets a value indicating whether this instance is document summary information.
            </summary>
            <value>
            	<c>true</c> if this instance is document summary information; otherwise, <c>false</c>.
            </value>
            Checks whether this {@link PropertySet} is a Document
            Summary Information.
            @return
            <c>true</c>
            if this {@link PropertySet}
            represents a Document Summary Information, else
            <c>false</c>
        </member>
        <member name="P:NPOI.HPSF.SpecialPropertySet.FirstSection">
            <summary>
            Gets the PropertySet's first section.
            </summary>
            <value>The {@link PropertySet}'s first section.</value>
        </member>
        <member name="M:NPOI.HPSF.SpecialPropertySet.AddSection(NPOI.HPSF.Section)">
            <summary>
            Adds a section To this property set.
            </summary>
            <param name="section">The {@link Section} To Add. It will be Appended
            after any sections that are alReady present in the property Set
            and thus become the last section.</param>
        </member>
        <member name="M:NPOI.HPSF.SpecialPropertySet.ClearSections">
            <summary>
            Removes all sections from this property Set.
            </summary>
        </member>
        <member name="P:NPOI.HPSF.SpecialPropertySet.OSVersion">
            <summary>
            gets or sets the "osVersion" property
            </summary>
            <value> the osVersion value To Set</value>
        </member>
        <member name="M:NPOI.HPSF.SpecialPropertySet.GetStream">
            <summary>
            Returns the contents of this property Set stream as an input stream.
            The latter can be used for example To Write the property Set into a POIFS
            document. The input stream represents a snapshot of the property Set.
            If the latter is modified while the input stream is still being
            Read, the modifications will not be reflected in the input stream but in
            the {@link MutablePropertySet} only.
            </summary>
            <returns>the contents of this PropertySet stream</returns>
        </member>
        <member name="M:NPOI.HPSF.SpecialPropertySet.Write(NPOI.POIFS.FileSystem.DirectoryEntry,System.String)">
            <summary>
            Writes a property Set To a document in a POI filesystem directory.
            </summary>
            <param name="dir">The directory in the POI filesystem To Write the document To</param>
            <param name="name">The document's name. If there is alReady a document with the
            same name in the directory the latter will be overwritten.</param>
        </member>
        <member name="M:NPOI.HPSF.SpecialPropertySet.Write(System.IO.Stream)">
            <summary>
            Writes the property Set To an output stream.
            </summary>
            <param name="out1">the output stream To Write the section To</param>
        </member>
        <member name="M:NPOI.HPSF.SpecialPropertySet.Equals(System.Object)">
            <summary>
            Returns <c>true</c> if the <c>PropertySet</c> is equal
            To the specified parameter, else <c>false</c>.
            </summary>
            <param name="o">the object To Compare this
            <c>PropertySet</c>
            with</param>
            <returns>
            	<c>true</c>
            if the objects are equal,
            <c>false</c>
            if not
            </returns>
        </member>
        <member name="P:NPOI.HPSF.SpecialPropertySet.Properties">
            <summary>
            Convenience method returning the {@link Property} array
            contained in this property Set. It is a shortcut for Getting
            the {@link PropertySet}'s {@link Section}s list and then
            Getting the {@link Property} array from the first {@link
            Section}.
            </summary>
            <value>
            The properties of the only {@link Section} of this
            {@link PropertySet}.
            </value>
        </member>
        <member name="M:NPOI.HPSF.SpecialPropertySet.GetProperty(System.Int32)">
            <summary>
            Convenience method returning the value of the property with
            the specified ID. If the property is not available,
            <c>null</c> is returned and a subsequent call To {@link
            #WasNull} will return <c>true</c> .
            </summary>
            <param name="id">The property ID</param>
            <returns>The property value</returns>
        </member>
        <member name="M:NPOI.HPSF.SpecialPropertySet.GetPropertyBooleanValue(System.Int32)">
            <summary>
            Convenience method returning the value of a bool property
            with the specified ID. If the property is not available,
            <c>false</c> is returned. A subsequent call To {@link
            #WasNull} will return <c>true</c> To let the caller
            distinguish that case from a real property value of
            <c>false</c>.
            </summary>
            <param name="id">The property ID</param>
            <returns>The property value</returns>
        </member>
        <member name="M:NPOI.HPSF.SpecialPropertySet.GetPropertyIntValue(System.Int32)">
            <summary>
            Convenience method returning the value of the numeric
            property with the specified ID. If the property is not
            available, 0 is returned. A subsequent call To {@link #WasNull}
            will return <c>true</c> To let the caller distinguish
            that case from a real property value of 0.
            </summary>
            <param name="id">The property ID</param>
            <returns>The propertyIntValue value</returns>
        </member>
        <member name="M:NPOI.HPSF.SpecialPropertySet.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="M:NPOI.HPSF.SpecialPropertySet.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="P:NPOI.HPSF.SpecialPropertySet.WasNull">
            <summary>
            Checks whether the property which the last call To {@link
            #GetPropertyIntValue} or {@link #GetProperty} tried To access
            Was available or not. This information might be important for
            callers of {@link #GetPropertyIntValue} since the latter
            returns 0 if the property does not exist. Using {@link
            #WasNull}, the caller can distiguish this case from a
            property's real value of 0.
            </summary>
            <value>
            	<c>true</c> if the last call To {@link
            #GetPropertyIntValue} or {@link #GetProperty} tried To access a
            property that Was not available; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="T:NPOI.HPSF.SummaryInformation">
            <summary>
            Convenience class representing a Summary Information stream in a
            Microsoft Office document.
            @author Rainer Klute 
            <a href="mailto:klute@rainer-klute.de">&lt;klute@rainer-klute.de&gt;</a>
            @see DocumentSummaryInformation
            @since 2002-02-09
            </summary>
        </member>
        <member name="F:NPOI.HPSF.SummaryInformation.DEFAULT_STREAM_NAME">
            The document name a summary information stream usually has in a POIFS
            filesystem.
        </member>
        <member name="M:NPOI.HPSF.SummaryInformation.#ctor(NPOI.HPSF.PropertySet)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HPSF.SummaryInformation"/> class.
            </summary>
            <param name="ps">A property Set which should be Created from a summary
            information stream.</param>
        </member>
        <member name="P:NPOI.HPSF.SummaryInformation.Title">
            <summary>
            Gets or sets the title.
            </summary>
            <value>The title.</value>
        </member>
        <member name="M:NPOI.HPSF.SummaryInformation.RemoveTitle">
            <summary>
            Removes the title.
            </summary>
        </member>
        <member name="P:NPOI.HPSF.SummaryInformation.Subject">
            <summary>
            Gets or sets the subject.
            </summary>
            <value>The subject.</value>
        </member>
        <member name="M:NPOI.HPSF.SummaryInformation.RemoveSubject">
            <summary>
            Removes the subject.
            </summary>
        </member>
        <member name="P:NPOI.HPSF.SummaryInformation.Author">
            <summary>
            Gets or sets the author.
            </summary>
            <value>The author.</value>
        </member>
        <member name="M:NPOI.HPSF.SummaryInformation.RemoveAuthor">
            <summary>
            Removes the author.
            </summary>
        </member>
        <member name="P:NPOI.HPSF.SummaryInformation.Keywords">
            <summary>
            Gets or sets the keywords.
            </summary>
            <value>The keywords.</value>
        </member>
        <member name="M:NPOI.HPSF.SummaryInformation.RemoveKeywords">
            <summary>
            Removes the keywords.
            </summary>
        </member>
        <member name="P:NPOI.HPSF.SummaryInformation.Comments">
            <summary>
            Gets or sets the comments.
            </summary>
            <value>The comments.</value>
        </member>
        <member name="M:NPOI.HPSF.SummaryInformation.RemoveComments">
            <summary>
            Removes the comments.
            </summary>
        </member>
        <member name="P:NPOI.HPSF.SummaryInformation.Template">
            <summary>
            Gets or sets the template.
            </summary>
            <value>The template.</value>
        </member>
        <member name="M:NPOI.HPSF.SummaryInformation.RemoveTemplate">
            <summary>
            Removes the template.
            </summary>
        </member>
        <member name="P:NPOI.HPSF.SummaryInformation.LastAuthor">
            <summary>
            Gets or sets the last author.
            </summary>
            <value>The last author.</value>
        </member>
        <member name="M:NPOI.HPSF.SummaryInformation.RemoveLastAuthor">
            <summary>
            Removes the last author.
            </summary>
        </member>
        <member name="P:NPOI.HPSF.SummaryInformation.RevNumber">
            <summary>
            Gets or sets the rev number.
            </summary>
            <value>The rev number.</value>
        </member>
        <member name="M:NPOI.HPSF.SummaryInformation.RemoveRevNumber">
            <summary>
            Removes the rev number.
            </summary>
        </member>
        <member name="P:NPOI.HPSF.SummaryInformation.EditTime">
            <summary>
            Returns the Total time spent in editing the document (or 0).
            </summary>
            <value>The Total time spent in editing the document or 0 if the {@link
            SummaryInformation} does not contain this information.</value>
        </member>
        <member name="M:NPOI.HPSF.SummaryInformation.RemoveEditTime">
            <summary>
            Removes the edit time.
            </summary>
        </member>
        <member name="P:NPOI.HPSF.SummaryInformation.LastPrinted">
            <summary>
            Gets or sets the last printed time
            </summary>
            <value>The last printed time</value>
            Returns the last printed time (or <c>null</c>).
        </member>
        <member name="M:NPOI.HPSF.SummaryInformation.RemoveLastPrinted">
            <summary>
            Removes the last printed.
            </summary>
        </member>
        <member name="P:NPOI.HPSF.SummaryInformation.CreateDateTime">
            <summary>
            Gets or sets the create date time.
            </summary>
            <value>The create date time.</value>
        </member>
        <member name="M:NPOI.HPSF.SummaryInformation.RemoveCreateDateTime">
            <summary>
            Removes the create date time.
            </summary>
        </member>
        <member name="P:NPOI.HPSF.SummaryInformation.LastSaveDateTime">
            <summary>
            Gets or sets the last save date time.
            </summary>
            <value>The last save date time.</value>
        </member>
        <member name="M:NPOI.HPSF.SummaryInformation.RemoveLastSaveDateTime">
            <summary>
            Removes the last save date time.
            </summary>
        </member>
        <member name="P:NPOI.HPSF.SummaryInformation.PageCount">
            <summary>
            Gets or sets the page count or 0 if the {@link SummaryInformation} does
            not contain a page count.
            </summary>
            <value>The page count or 0 if the {@link SummaryInformation} does not
            contain a page count.</value>
        </member>
        <member name="M:NPOI.HPSF.SummaryInformation.RemovePageCount">
            <summary>
            Removes the page count.
            </summary>
        </member>
        <member name="P:NPOI.HPSF.SummaryInformation.WordCount">
            <summary>
            Gets or sets the word count or 0 if the {@link SummaryInformation} does
            not contain a word count.
            </summary>
            <value>The word count.</value>
        </member>
        <member name="M:NPOI.HPSF.SummaryInformation.RemoveWordCount">
            <summary>
            Removes the word count.
            </summary>
        </member>
        <member name="P:NPOI.HPSF.SummaryInformation.CharCount">
            <summary>
            Gets or sets the character count or 0 if the {@link SummaryInformation}
            does not contain a char count.
            </summary>
            <value>The character count.</value>
        </member>
        <member name="M:NPOI.HPSF.SummaryInformation.RemoveCharCount">
            <summary>
            Removes the char count.
            </summary>
        </member>
        <member name="P:NPOI.HPSF.SummaryInformation.Thumbnail">
            <summary>
            Gets or sets the thumbnail (or <c>null</c>) <strong>when this
            method is implemented. Please note that the return type is likely To
            Change!</strong>
            <strong>Hint To developers:</strong> Drew Varner &lt;Drew.Varner
            -at- sc.edu&gt; said that this is an image in WMF or Clipboard (BMP?)
            format. However, we won't do any conversion into any image type but
            instead just return a byte array.
            </summary>
            <value>The thumbnail.</value>
        </member>
        <member name="M:NPOI.HPSF.SummaryInformation.RemoveThumbnail">
            <summary>
            Removes the thumbnail.
            </summary>
        </member>
        <member name="P:NPOI.HPSF.SummaryInformation.ApplicationName">
            <summary>
            Gets or sets the name of the application.
            </summary>
            <value>The name of the application.</value>
        </member>
        <member name="M:NPOI.HPSF.SummaryInformation.RemoveApplicationName">
            <summary>
            Removes the name of the application.
            </summary>
        </member>
        <member name="P:NPOI.HPSF.SummaryInformation.Security">
            <summary>
            Gets or sets a security code which is one of the following values:
            <ul>
            	<li>0 if the {@link SummaryInformation} does not contain a
            security field or if there is no security on the document. Use
            {@link PropertySet#wasNull()} To distinguish between the two
            cases!</li>
            	<li>1 if the document is password protected</li>
            	<li>2 if the document is Read-only recommended</li>
            	<li>4 if the document is Read-only enforced</li>
            	<li>8 if the document is locked for annotations</li>
            </ul>
            </summary>
            <value>The security code</value>
        </member>
        <member name="M:NPOI.HPSF.SummaryInformation.RemoveSecurity">
            <summary>
            Removes the security code.
            </summary>
        </member>
        <member name="T:NPOI.HPSF.Thumbnail">
            <summary>
            Class To manipulate data in the Clipboard Variant (Variant#VT_CF VT_CF) format.
            @author Drew Varner (Drew.Varner inOrAround sc.edu)
            @since 2002-04-29
            </summary>
        </member>
        <member name="F:NPOI.HPSF.Thumbnail.OFFSet_CFTAG">
            <summary>
            OffSet in bytes where the Clipboard Format Tag starts in the <c>byte[]</c> returned by SummaryInformation#GetThumbnail()
            </summary>
        </member>
        <member name="F:NPOI.HPSF.Thumbnail.OFFSet_CF">
            <summary>
            OffSet in bytes where the Clipboard Format starts in the <c>byte[]</c> returned by SummaryInformation#GetThumbnail()
            </summary>
            <remarks>This is only valid if the Clipboard Format Tag is CFTAG_WINDOWS</remarks>
        </member>
        <member name="F:NPOI.HPSF.Thumbnail.OFFSet_WMFDATA">
            <summary>
            OffSet in bytes where the Windows Metafile (WMF) image data starts in the <c>byte[]</c> returned by SummaryInformation#GetThumbnail()
            There is only WMF data at this point in the
            <c>byte[]</c> if the Clipboard Format Tag is
            CFTAG_WINDOWS and the Clipboard Format is 
            CF_METAFILEPICT.
            </summary>
            <remarks>Note: The <c>byte[]</c> that starts at
            <c>OFFSet_WMFDATA</c> and ends at
            <c>GetThumbnail().Length - 1</c> forms a complete WMF
            image. It can be saved To disk with a <c>.wmf</c> file
            type and Read using a WMF-capable image viewer.</remarks>
        </member>
        <member name="F:NPOI.HPSF.Thumbnail.CFTAG_WINDOWS">
            <summary>
            Clipboard Format Tag - Windows clipboard format
            </summary>
            <remarks>A <c>DWORD</c> indicating a built-in Windows clipboard format value</remarks>
        </member>
        <member name="F:NPOI.HPSF.Thumbnail.CFTAG_MACINTOSH">
            <summary>
            Clipboard Format Tag - Macintosh clipboard format
            </summary>
            <remarks>A <c>DWORD</c> indicating a Macintosh clipboard format value</remarks>
        </member>
        <member name="F:NPOI.HPSF.Thumbnail.CFTAG_FMTID">
            <summary>
            Clipboard Format Tag - Format ID
            </summary>
            <remarks>A GUID containing a format identifier (FMTID). This is rarely used.</remarks>
        </member>
        <member name="F:NPOI.HPSF.Thumbnail.CFTAG_NODATA">
            <summary>
            Clipboard Format Tag - No Data
            </summary>
            <remarks>A <c>DWORD</c> indicating No data. This is rarely used.</remarks>
        </member>
        <member name="F:NPOI.HPSF.Thumbnail.CF_METAFILEPICT">
            <summary>
            Clipboard Format - Windows metafile format. This is the recommended way To store thumbnails in Property Streams.
            </summary>
            <remarks>Note:This is not the same format used in
            regular WMF images. The clipboard version of this format has an
            extra clipboard-specific header.</remarks>
        </member>
        <member name="F:NPOI.HPSF.Thumbnail.CF_DIB">
            <summary>
            Clipboard Format - Device Independent Bitmap
            </summary>
        </member>
        <member name="F:NPOI.HPSF.Thumbnail.CF_ENHMETAFILE">
            <summary>
            Clipboard Format - Enhanced Windows metafile format
            </summary>
        </member>
        <member name="F:NPOI.HPSF.Thumbnail.CF_BITMAP">
            <summary>
            Clipboard Format - Bitmap
            </summary>
            <remarks>see msdn.microsoft.com/library/en-us/dnw98bk/html/clipboardoperations.asp</remarks>
        </member>
        <member name="F:NPOI.HPSF.Thumbnail.thumbnailData">
            A <c>byte[]</c> To hold a thumbnail image in (
            Variant#VT_CF VT_CF) format.
        </member>
        <member name="M:NPOI.HPSF.Thumbnail.#ctor">
            <summary>
            Default Constructor. If you use it then one you'll have To Add
            the thumbnail <c>byte[]</c> from {@link
            SummaryInformation#GetThumbnail()} To do any useful
            manipulations, otherwise you'll Get a
            <c>NullPointerException</c>.
            </summary>
        </member>
        <member name="M:NPOI.HPSF.Thumbnail.#ctor(System.Byte[])">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HPSF.Thumbnail"/> class.
            </summary>
            <param name="thumbnailData">The thumbnail data.</param>
        </member>
        <member name="P:NPOI.HPSF.Thumbnail.ThumbnailData">
            <summary>
            Gets or sets the thumbnail as a <c>byte[]</c> in {@link
            Variant#VT_CF VT_CF} format.
            </summary>
            <value>The thumbnail value</value>
        </member>
        <member name="P:NPOI.HPSF.Thumbnail.ClipboardFormatTag">
            <summary>
            Returns an <c>int</c> representing the Clipboard
            Format Tag
            Possible return values are:
            <ul>
            	<li>{@link #CFTAG_WINDOWS CFTAG_WINDOWS}</li>
            	<li>{@link #CFTAG_MACINTOSH CFTAG_MACINTOSH}</li>
            	<li>{@link #CFTAG_FMTID CFTAG_FMTID}</li>
            	<li>{@link #CFTAG_NODATA CFTAG_NODATA}</li>
            </ul>
            </summary>
            <returns>A flag indicating the Clipboard Format Tag</returns>
        </member>
        <member name="M:NPOI.HPSF.Thumbnail.GetClipboardFormat">
            <summary>
            Returns an <c>int</c> representing the Clipboard
            Format
            Will throw an exception if the Thumbnail's Clipboard Format
            Tag is not {@link Thumbnail#CFTAG_WINDOWS CFTAG_WINDOWS}.
            Possible return values are:
            <ul>
            	<li>{@link #CF_METAFILEPICT CF_METAFILEPICT}</li>
            	<li>{@link #CF_DIB CF_DIB}</li>
            	<li>{@link #CF_ENHMETAFILE CF_ENHMETAFILE}</li>
            	<li>{@link #CF_BITMAP CF_BITMAP}</li>
            </ul>
            </summary>
            <returns>a flag indicating the Clipboard Format</returns>
        </member>
        <member name="M:NPOI.HPSF.Thumbnail.GetThumbnailAsWMF">
            <summary>
            Returns the Thumbnail as a <c>byte[]</c> of WMF data
            if the Thumbnail's Clipboard Format Tag is {@link
            #CFTAG_WINDOWS CFTAG_WINDOWS} and its Clipboard Format is
            {@link #CF_METAFILEPICT CF_METAFILEPICT}
            This
            <c>byte[]</c> is in the traditional WMF file, not the
            clipboard-specific version with special headers.
            See <a href="http://www.wvware.com/caolan/ora-wmf.html" tarGet="_blank">http://www.wvware.com/caolan/ora-wmf.html</a>
            for more information on the WMF image format.
            @return A WMF image of the Thumbnail
            @throws HPSFException if the Thumbnail isn't CFTAG_WINDOWS and
            CF_METAFILEPICT
            </summary>
            <returns></returns>
        </member>
        <member name="T:NPOI.HPSF.TypeWriter">
            <summary>
            Class for writing little-endian data and more.
            @author Rainer Klute 
            <a href="mailto:klute@rainer-klute.de">&lt;klute@rainer-klute.de&gt;</a>
            @since 2003-02-20 
            </summary>
        </member>
        <member name="M:NPOI.HPSF.TypeWriter.WriteToStream(System.IO.Stream,System.Int16)">
            <summary>
            Writes a two-byte value (short) To an output stream.
            </summary>
            <param name="out1">The stream To Write To..</param>
            <param name="n">The number of bytes that have been written.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.HPSF.TypeWriter.WriteToStream(System.IO.Stream,System.Int32)">
             Writes a four-byte value To an output stream.
            
             @param out The stream To Write To.
             @param n The value To Write.
             @exception IOException if an I/O error occurs
             @return The number of bytes written To the output stream. 
        </member>
        <member name="M:NPOI.HPSF.TypeWriter.WriteToStream(System.IO.Stream,System.UInt32)">
             Writes a four-byte value To an output stream.
            
             @param out The stream To Write To.
             @param n The value To Write.
             @exception IOException if an I/O error occurs
             @return The number of bytes written To the output stream. 
        </member>
        <member name="M:NPOI.HPSF.TypeWriter.WriteToStream(System.IO.Stream,System.Int64)">
             Writes a eight-byte value To an output stream.
            
             @param out The stream To Write To.
             @param n The value To Write.
             @exception IOException if an I/O error occurs
             @return The number of bytes written To the output stream. 
        </member>
        <member name="M:NPOI.HPSF.TypeWriter.WriteUShortToStream(System.IO.Stream,System.Int32)">
             Writes an unsigned two-byte value To an output stream.
            
             @param out The stream To Write To
             @param n The value To Write
             @exception IOException if an I/O error occurs
        </member>
        <member name="M:NPOI.HPSF.TypeWriter.WriteUIntToStream(System.IO.Stream,System.UInt32)">
             Writes an unsigned four-byte value To an output stream.
            
             @param out The stream To Write To.
             @param n The value To Write.
             @return The number of bytes that have been written To the output stream.
             @exception IOException if an I/O error occurs
        </member>
        <member name="M:NPOI.HPSF.TypeWriter.WriteToStream(System.IO.Stream,NPOI.Util.ClassID)">
             Writes a 16-byte {@link ClassID} To an output stream.
            
             @param out The stream To Write To
             @param n The value To Write
             @return The number of bytes written
             @exception IOException if an I/O error occurs
        </member>
        <member name="M:NPOI.HPSF.TypeWriter.WriteToStream(System.IO.Stream,NPOI.HPSF.Property[],System.Int32)">
            Writes an array of {@link Property} instances To an output stream
            according To the Horrible Property  Format.
            
            @param out The stream To Write To
            @param properties The array To Write To the stream
            @param codepage The codepage number To use for writing strings
            @exception IOException if an I/O error occurs
            @throws UnsupportedVariantTypeException if HPSF does not support some
                    variant type.
        </member>
        <member name="M:NPOI.HPSF.TypeWriter.WriteToStream(System.IO.Stream,System.Double)">
             Writes a double value value To an output stream.
            
             @param out The stream To Write To.
             @param n The value To Write.
             @exception IOException if an I/O error occurs
             @return The number of bytes written To the output stream. 
        </member>
        <member name="T:NPOI.HPSF.UnexpectedPropertySetTypeException">
            <summary>
            This exception is thrown if a certain type of property Set Is
            expected (e.g. a Document Summary Information) but the provided
            property Set is not of that type.
            The constructors of this class are analogous To those of its
            superclass and documented there.
            @author Rainer Klute 
            <a href="mailto:klute@rainer-klute.de">&lt;klute@rainer-klute.de&gt;</a>
            @since 2002-02-09 
            </summary>
        </member>
        <member name="M:NPOI.HPSF.UnexpectedPropertySetTypeException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HPSF.UnexpectedPropertySetTypeException"/> class.
            </summary>
        </member>
        <member name="M:NPOI.HPSF.UnexpectedPropertySetTypeException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HPSF.UnexpectedPropertySetTypeException"/> class.
            </summary>
            <param name="msg">The message string.</param>
        </member>
        <member name="M:NPOI.HPSF.UnexpectedPropertySetTypeException.#ctor(System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HPSF.UnexpectedPropertySetTypeException"/> class.
            </summary>
            <param name="reason">The reason, i.e. a throwable that indirectly
            caused this exception.</param>
        </member>
        <member name="M:NPOI.HPSF.UnexpectedPropertySetTypeException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HPSF.UnexpectedPropertySetTypeException"/> class.
            </summary>
            <param name="msg">The message string.</param>
            <param name="reason">The reason, i.e. a throwable that indirectly
            caused this exception.</param>
        </member>
        <member name="T:NPOI.HPSF.UnsupportedVariantTypeException">
            <summary>
            This exception is thrown if HPSF encounters a variant type that isn't
            supported yet. Although a variant type is unsupported the value can still be
            retrieved using the {@link VariantTypeException#GetValue} method.
            Obviously this class should disappear some day.
            @author Rainer Klute 
            <a href="mailto:klute@rainer-klute.de">&lt;klute@rainer-klute.de&gt;</a>
            @since 2003-08-05
            </summary>
        </member>
        <member name="M:NPOI.HPSF.UnsupportedVariantTypeException.#ctor(System.Int64,System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HPSF.UnsupportedVariantTypeException"/> class.
            </summary>
            <param name="variantType">The unsupported variant type</param>
            <param name="value">The value who's variant type is not yet supported</param>
        </member>
        <member name="T:NPOI.HPSF.Util">
            <summary>
            Provides various static utility methods.
            @author Rainer Klute (klute@rainer-klute.de)
            @since 2002-02-09
            </summary>
        </member>
        <member name="M:NPOI.HPSF.Util.Copy(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Copies a part of a byte array into another byte array.
            </summary>
            <param name="src">The source byte array.</param>
            <param name="srcOffSet">OffSet in the source byte array.</param>
            <param name="Length">The number of bytes To Copy.</param>
            <param name="dst">The destination byte array.</param>
            <param name="dstOffSet">OffSet in the destination byte array.</param>
        </member>
        <member name="M:NPOI.HPSF.Util.Cat(System.Byte[][])">
            <summary>
            Concatenates the contents of several byte arrays into a
            single one.
            </summary>
            <param name="byteArrays">The byte arrays To be conCatened.</param>
            <returns>A new byte array containing the conCatenated byte arrays.</returns>
        </member>
        <member name="M:NPOI.HPSF.Util.Copy(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Copies bytes from a source byte array into a new byte
            array.
            </summary>
            <param name="src">Copy from this byte array.</param>
            <param name="offset">Start Copying here.</param>
            <param name="Length">Copy this many bytes.</param>
            <returns>The new byte array. Its Length is number of copied bytes.</returns>
        </member>
        <member name="F:NPOI.HPSF.Util.EPOCH_DIFF">
            The difference between the Windows epoch (1601-01-01
            00:00:00) and the Unix epoch (1970-01-01 00:00:00) in
            milliseconds: 11644473600000L. (Use your favorite spReadsheet
            program To verify the correctness of this value. By the way,
            did you notice that you can tell from the epochs which
            operating system is the modern one? :-))
        </member>
        <member name="M:NPOI.HPSF.Util.FiletimeToDate(System.Int32,System.Int32)">
            <summary>
            Converts a Windows FILETIME into a {@link DateTime}. The Windows
            FILETIME structure holds a DateTime and time associated with a
            file. The structure identifies a 64-bit integer specifying the
            number of 100-nanosecond intervals which have passed since
            January 1, 1601. This 64-bit value is split into the two double
            words stored in the structure.
            </summary>
            <param name="high">The higher double word of the FILETIME structure.</param>
            <param name="low">The lower double word of the FILETIME structure.</param>
            <returns>The Windows FILETIME as a {@link DateTime}.</returns>
        </member>
        <member name="M:NPOI.HPSF.Util.FiletimeToDate(System.Int64)">
            <summary>
            Converts a Windows FILETIME into a {@link DateTime}. The Windows
            FILETIME structure holds a DateTime and time associated with a
            file. The structure identifies a 64-bit integer specifying the
            number of 100-nanosecond intervals which have passed since
            January 1, 1601.
            </summary>
            <param name="filetime">The filetime To Convert.</param>
            <returns>The Windows FILETIME as a {@link DateTime}.</returns>
        </member>
        <member name="M:NPOI.HPSF.Util.DateToFileTime(System.DateTime)">
            <summary>
            Converts a {@link DateTime} into a filetime.
            </summary>
            <param name="dateTime">The DateTime To be Converted</param>
            <returns>The filetime</returns>
        </member>
        <member name="M:NPOI.HPSF.Util.AreEqual(System.Collections.IList,System.Collections.IList)">
            <summary>
            Compares To object arrays with regarding the objects' order. For
            example, [1, 2, 3] and [2, 1, 3] are equal.
            </summary>
            <param name="c1">The first object array.</param>
            <param name="c2">The second object array.</param>
            <returns><c>true</c>
             if the object arrays are equal,
            <c>false</c>
             if they are not.</returns>
        </member>
        <member name="M:NPOI.HPSF.Util.internalEquals(System.Collections.IList,System.Collections.IList)">
            <summary>
            Internals the equals.
            </summary>
            <param name="c1">The c1.</param>
            <param name="c2">The c2.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.HPSF.Util.Pad4(System.Byte[])">
            <summary>
            Pads a byte array with 0x00 bytes so that its Length is a multiple of
            4.
            </summary>
            <param name="ba">The byte array To pad.</param>
            <returns>The padded byte array.</returns>
        </member>
        <member name="M:NPOI.HPSF.Util.Pad4(System.Char[])">
            <summary>
            Pads a character array with 0x0000 characters so that its Length is a
            multiple of 4.
            </summary>
            <param name="ca">The character array To pad.</param>
            <returns>The padded character array.</returns>
        </member>
        <member name="M:NPOI.HPSF.Util.Pad4(System.String)">
            <summary>
            Pads a string with 0x0000 characters so that its Length is a
            multiple of 4.
            </summary>
            <param name="s">The string To pad.</param>
            <returns> The padded string as a character array.</returns>
        </member>
        <member name="T:NPOI.HPSF.Variant">
            <summary>
            The <em>Variant</em> types as defined by Microsoft's COM. I
            found this information in <a href="http://www.marin.clara.net/COM/variant_type_definitions.htm">
            http://www.marin.clara.net/COM/variant_type_definitions.htm</a>.
            In the variant types descriptions the following shortcuts are
            used: <strong> [V]</strong> - may appear in a VARIANT,
            <strong>[T]</strong> - may appear in a TYPEDESC,
            <strong>[P]</strong> - may appear in an OLE property Set,
            <strong>[S]</strong> - may appear in a Safe Array.
            @author Rainer Klute (klute@rainer-klute.de)
            @since 2002-02-09
            </summary>
        </member>
        <member name="F:NPOI.HPSF.Variant.VT_EMPTY">
            [V][P] Nothing, i.e. not a single byte of data.
        </member>
        <member name="F:NPOI.HPSF.Variant.VT_NULL">
            [V][P] SQL style Null.
        </member>
        <member name="F:NPOI.HPSF.Variant.VT_I2">
            [V][T][P][S] 2 byte signed int.
        </member>
        <member name="F:NPOI.HPSF.Variant.VT_I4">
            [V][T][P][S] 4 byte signed int.
        </member>
        <member name="F:NPOI.HPSF.Variant.VT_R4">
            [V][T][P][S] 4 byte real.
        </member>
        <member name="F:NPOI.HPSF.Variant.VT_R8">
            [V][T][P][S] 8 byte real.
        </member>
        <member name="F:NPOI.HPSF.Variant.VT_CY">
            [V][T][P][S] currency. <span style="background-color:
            #ffff00">How long is this? How is it To be
            interpreted?</span>
        </member>
        <member name="F:NPOI.HPSF.Variant.VT_DATE">
            [V][T][P][S] DateTime. <span style="background-color:
            #ffff00">How long is this? How is it To be
            interpreted?</span>
        </member>
        <member name="F:NPOI.HPSF.Variant.VT_BSTR">
            [V][T][P][S] OLE Automation string. <span
            style="background-color: #ffff00">How long is this? How is it
            To be interpreted?</span>
        </member>
        <member name="F:NPOI.HPSF.Variant.VT_DISPATCH">
            [V][T][P][S] IDispatch *. <span style="background-color:
            #ffff00">How long is this? How is it To be
            interpreted?</span>
        </member>
        <member name="F:NPOI.HPSF.Variant.VT_ERROR">
            [V][T][S] SCODE. <span style="background-color: #ffff00">How
            long is this? How is it To be interpreted?</span>
        </member>
        <member name="F:NPOI.HPSF.Variant.VT_BOOL">
            [V][T][P][S] True=-1, False=0.
        </member>
        <member name="F:NPOI.HPSF.Variant.VT_VARIANT">
            [V][T][P][S] VARIANT *. <span style="background-color:
            #ffff00">How long is this? How is it To be
            interpreted?</span>
        </member>
        <member name="F:NPOI.HPSF.Variant.VT_UNKNOWN">
            [V][T][S] IUnknown *. <span style="background-color:
            #ffff00">How long is this? How is it To be
            interpreted?</span>
        </member>
        <member name="F:NPOI.HPSF.Variant.VT_DECIMAL">
            [V][T][S] 16 byte fixed point.
        </member>
        <member name="F:NPOI.HPSF.Variant.VT_I1">
            [T] signed char.
        </member>
        <member name="F:NPOI.HPSF.Variant.VT_UI1">
            [V][T][P][S] unsigned char.
        </member>
        <member name="F:NPOI.HPSF.Variant.VT_UI2">
            [T][P] unsigned short.
        </member>
        <member name="F:NPOI.HPSF.Variant.VT_UI4">
            [T][P] unsigned int.
        </member>
        <member name="F:NPOI.HPSF.Variant.VT_I8">
            [T][P] signed 64-bit int.
        </member>
        <member name="F:NPOI.HPSF.Variant.VT_UI8">
            [T][P] unsigned 64-bit int.
        </member>
        <member name="F:NPOI.HPSF.Variant.VT_INT">
            [T] signed machine int.
        </member>
        <member name="F:NPOI.HPSF.Variant.VT_UINT">
            [T] unsigned machine int.
        </member>
        <member name="F:NPOI.HPSF.Variant.VT_VOID">
            [T] C style void.
        </member>
        <member name="F:NPOI.HPSF.Variant.VT_HRESULT">
            [T] Standard return type. <span style="background-color:
            #ffff00">How long is this? How is it To be
            interpreted?</span>
        </member>
        <member name="F:NPOI.HPSF.Variant.VT_PTR">
            [T] pointer type. <span style="background-color:
            #ffff00">How long is this? How is it To be
            interpreted?</span>
        </member>
        <member name="F:NPOI.HPSF.Variant.VT_SAFEARRAY">
            [T] (use VT_ARRAY in VARIANT).
        </member>
        <member name="F:NPOI.HPSF.Variant.VT_CARRAY">
            [T] C style array. <span style="background-color:
            #ffff00">How long is this? How is it To be
            interpreted?</span>
        </member>
        <member name="F:NPOI.HPSF.Variant.VT_USERDEFINED">
            [T] user defined type. <span style="background-color:
            #ffff00">How long is this? How is it To be
            interpreted?</span>
        </member>
        <member name="F:NPOI.HPSF.Variant.VT_LPSTR">
            [T][P] null terminated string.
        </member>
        <member name="F:NPOI.HPSF.Variant.VT_LPWSTR">
            [T][P] wide (Unicode) null terminated string.
        </member>
        <member name="F:NPOI.HPSF.Variant.VT_FILETIME">
            [P] FILETIME. The FILETIME structure holds a DateTime and time
            associated with a file. The structure identifies a 64-bit
            integer specifying the number of 100-nanosecond intervals which
            have passed since January 1, 1601. This 64-bit value is split
            into the two dwords stored in the structure.
        </member>
        <member name="F:NPOI.HPSF.Variant.VT_BLOB">
            [P] Length prefixed bytes.
        </member>
        <member name="F:NPOI.HPSF.Variant.VT_STREAM">
            [P] Name of the stream follows.
        </member>
        <member name="F:NPOI.HPSF.Variant.VT_STORAGE">
            [P] Name of the storage follows.
        </member>
        <member name="F:NPOI.HPSF.Variant.VT_STREAMED_OBJECT">
            [P] Stream Contains an object. <span
            style="background-color: #ffff00"> How long is this? How is it
            To be interpreted?</span>
        </member>
        <member name="F:NPOI.HPSF.Variant.VT_STORED_OBJECT">
            [P] Storage Contains an object. <span
            style="background-color: #ffff00"> How long is this? How is it
            To be interpreted?</span>
        </member>
        <member name="F:NPOI.HPSF.Variant.VT_BLOB_OBJECT">
            [P] Blob Contains an object. <span style="background-color:
            #ffff00">How long is this? How is it To be
            interpreted?</span>
        </member>
        <member name="F:NPOI.HPSF.Variant.VT_CF">
            [P] Clipboard format. <span style="background-color:
            #ffff00">How long is this? How is it To be
            interpreted?</span>
        </member>
        <member name="F:NPOI.HPSF.Variant.VT_CLSID">
             [P] A Class ID.
            
             It consists of a 32 bit unsigned integer indicating the size
             of the structure, a 32 bit signed integer indicating (Clipboard
             Format Tag) indicating the type of data that it Contains, and
             then a byte array containing the data.
            
             The valid Clipboard Format Tags are:
            
             <ul>
              <li>{@link Thumbnail#CFTAG_WINDOWS}</li>
              <li>{@link Thumbnail#CFTAG_MACINTOSH}</li>
              <li>{@link Thumbnail#CFTAG_NODATA}</li>
              <li>{@link Thumbnail#CFTAG_FMTID}</li>
             </ul>
            
             <pre>typedef struct tagCLIPDATA {
             // cbSize is the size of the buffer pointed To
             // by pClipData, plus sizeof(ulClipFmt)
             ULONG              cbSize;
             long               ulClipFmt;
             BYTE*              pClipData;
             } CLIPDATA;</pre>
            
             See <a
             href="msdn.microsoft.com/library/en-us/com/stgrstrc_0uwk.asp"
             tarGet="_blank">
             msdn.microsoft.com/library/en-us/com/stgrstrc_0uwk.asp</a>.
        </member>
        <member name="F:NPOI.HPSF.Variant.VT_VECTOR">
            [P] simple counted array. <span style="background-color:
            #ffff00">How long is this? How is it To be
            interpreted?</span>
        </member>
        <member name="F:NPOI.HPSF.Variant.VT_ARRAY">
            [V] SAFEARRAY*. <span style="background-color: #ffff00">How
            long is this? How is it To be interpreted?</span>
        </member>
        <member name="F:NPOI.HPSF.Variant.VT_BYREF">
            [V] void* for local use. <span style="background-color:
            #ffff00">How long is this? How is it To be
            interpreted?</span>
        </member>
        <member name="F:NPOI.HPSF.Variant.VT_RESERVED">
            FIXME (3): Document this!
        </member>
        <member name="F:NPOI.HPSF.Variant.VT_ILLEGAL">
            FIXME (3): Document this!
        </member>
        <member name="F:NPOI.HPSF.Variant.VT_ILLEGALMASKED">
            FIXME (3): Document this!
        </member>
        <member name="F:NPOI.HPSF.Variant.VT_TYPEMASK">
            FIXME (3): Document this!
        </member>
        <member name="F:NPOI.HPSF.Variant.numberToName">
            Maps the numbers denoting the variant types To their corresponding
            variant type names.
        </member>
        <member name="F:NPOI.HPSF.Variant.Length_UNKNOWN">
            Denotes a variant type with a Length that is unknown To HPSF yet.
        </member>
        <member name="F:NPOI.HPSF.Variant.Length_VARIABLE">
            Denotes a variant type with a variable Length.
        </member>
        <member name="F:NPOI.HPSF.Variant.Length_0">
            Denotes a variant type with a Length of 0 bytes.
        </member>
        <member name="F:NPOI.HPSF.Variant.Length_2">
            Denotes a variant type with a Length of 2 bytes.
        </member>
        <member name="F:NPOI.HPSF.Variant.Length_4">
            Denotes a variant type with a Length of 4 bytes.
        </member>
        <member name="F:NPOI.HPSF.Variant.Length_8">
            Denotes a variant type with a Length of 8 bytes.
        </member>
        <member name="M:NPOI.HPSF.Variant.GetVariantName(System.Int64)">
            <summary>
            Returns the variant type name associated with a variant type
            number.
            </summary>
            <param name="variantType">The variant type number.</param>
            <returns>The variant type name or the string "unknown variant type"</returns>
        </member>
        <member name="M:NPOI.HPSF.Variant.GetVariantLength(System.Int64)">
            <summary>
            Returns a variant type's Length.
            </summary>
            <param name="variantType">The variant type number.</param>
            <returns>The Length of the variant type's data in bytes. If the Length Is
            variable, i.e. the Length of a string, -1 is returned. If HPSF does not
            know the Length, -2 is returned. The latter usually indicates an
            unsupported variant type.</returns>
        </member>
        <member name="T:NPOI.HPSF.VariantSupport">
            <summary>
            Supports Reading and writing of variant data.
            <strong>FIXME (3):</strong>
             Reading and writing should be made more
            uniform than it is now. The following items should be resolved:
            Reading requires a Length parameter that is 4 byte greater than the
            actual data, because the variant type field is included.
            Reading Reads from a byte array while writing Writes To an byte array
            output stream.
            @author Rainer Klute 
            <a href="mailto:klute@rainer-klute.de">&lt;klute@rainer-klute.de&gt;</a>
            @since 2003-08-08
            </summary>
        </member>
        <member name="P:NPOI.HPSF.VariantSupport.IsLogUnsupportedTypes">
            <summary>
            Checks whether logging of unsupported variant types warning is turned
            on or off.
            </summary>
            <value>
            	<c>true</c> if logging is turned on; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="F:NPOI.HPSF.VariantSupport.unsupportedMessage">
            Keeps a list of the variant types an "unsupported" message has alReady
            been issued for.
        </member>
        <member name="M:NPOI.HPSF.VariantSupport.WriteUnsupportedTypeMessage(NPOI.HPSF.UnsupportedVariantTypeException)">
            <summary>
            Writes a warning To System.err that a variant type Is
            unsupported by HPSF. Such a warning is written only once for each variant
            type. Log messages can be turned on or off by
            </summary>
            <param name="ex">The exception To log</param>
        </member>
        <member name="F:NPOI.HPSF.VariantSupport.SUPPORTED_TYPES">
            HPSF is able To Read these {@link Variant} types.
        </member>
        <member name="M:NPOI.HPSF.VariantSupport.IsSupportedType(System.Int32)">
            <summary>
            Checks whether HPSF supports the specified variant type. Unsupported
            types should be implemented included in the {@link #SUPPORTED_TYPES}
            array.
            </summary>
            <param name="variantType">the variant type To check</param>
            <returns>
            	<c>true</c> if HPFS supports this type,otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NPOI.HPSF.VariantSupport.Read(System.Byte[],System.Int32,System.Int32,System.Int64,System.Int32)">
            <summary>
            Reads a variant type from a byte array
            </summary>
            <param name="src">The byte array</param>
            <param name="offset">The offset in the byte array where the variant starts</param>
            <param name="Length">The Length of the variant including the variant type field</param>
            <param name="type">The variant type To Read</param>
            <param name="codepage">The codepage To use for non-wide strings</param>
            <returns>A Java object that corresponds best To the variant field. For
            example, a VT_I4 is returned as a {@link long}, a VT_LPSTR as a
            {@link String}.</returns>
        </member>
        <member name="M:NPOI.HPSF.VariantSupport.Write(System.IO.Stream,System.Int64,System.Object,System.Int32)">
            <summary>
            Writes a variant value To an output stream. This method ensures that
            always a multiple of 4 bytes is written.
            If the codepage is UTF-16, which is encouraged, strings
            <strong>must</strong> always be written as {@link Variant#VT_LPWSTR}
            strings, not as {@link Variant#VT_LPSTR} strings. This method ensure this
            by Converting strings appropriately, if needed.
            </summary>
            <param name="out1">The stream To Write the value To.</param>
            <param name="type">The variant's type.</param>
            <param name="value">The variant's value.</param>
            <param name="codepage">The codepage To use To Write non-wide strings</param>
            <returns>The number of entities that have been written. In many cases an
            "entity" is a byte but this is not always the case.</returns>
        </member>
        <member name="T:NPOI.HPSF.VariantTypeException">
            <summary>
            This exception is thrown if HPSF encounters a problem with a variant type.
            Concrete subclasses specifiy the problem further.
            @author Rainer Klute 
            <a href="mailto:klute@rainer-klute.de">&lt;klute@rainer-klute.de&gt;</a>
            @since 2004-06-21
            </summary>
        </member>
        <member name="M:NPOI.HPSF.VariantTypeException.#ctor(System.Int64,System.Object,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HPSF.VariantTypeException"/> class.
            </summary>
            <param name="variantType">The variant type causing the problem</param>
            <param name="value">The value who's variant type causes the problem</param>
            <param name="msg">A message text describing the problem</param>
        </member>
        <member name="P:NPOI.HPSF.VariantTypeException.VariantType">
            <summary>
            Gets the offending variant type
            </summary>
            <value>the offending variant type.</value>
        </member>
        <member name="P:NPOI.HPSF.VariantTypeException.Value">
            <summary>
            Returns the value who's variant type caused the problem.
            </summary>
            <value>the value who's variant type caused the problem.</value>
        </member>
        <member name="T:NPOI.HPSF.Wellknown.PropertyIDMap">
            <summary>
            This is a dictionary which maps property ID values To property
            ID strings.
            The methods {@link #GetSummaryInformationProperties} and {@link
            #GetDocumentSummaryInformationProperties} return singleton {@link
            PropertyIDMap}s. An application that wants To extend these maps
            should treat them as unmodifiable, copy them and modifiy the
            copies.
            @author Rainer Klute 
            <a href="mailto:klute@rainer-klute.de">&lt;klute@rainer-klute.de&gt;</a>
            @since 2002-02-09
            </summary>
        </member>
        <member name="F:NPOI.HPSF.Wellknown.PropertyIDMap.PID_TITLE">
            ID of the property that denotes the document's title 
        </member>
        <member name="F:NPOI.HPSF.Wellknown.PropertyIDMap.PID_SUBJECT">
            ID of the property that denotes the document's subject 
        </member>
        <member name="F:NPOI.HPSF.Wellknown.PropertyIDMap.PID_AUTHOR">
            ID of the property that denotes the document's author 
        </member>
        <member name="F:NPOI.HPSF.Wellknown.PropertyIDMap.PID_KEYWORDS">
            ID of the property that denotes the document's keywords 
        </member>
        <member name="F:NPOI.HPSF.Wellknown.PropertyIDMap.PID_COMMENTS">
            ID of the property that denotes the document's comments 
        </member>
        <member name="F:NPOI.HPSF.Wellknown.PropertyIDMap.PID_TEMPLATE">
            ID of the property that denotes the document's template 
        </member>
        <member name="F:NPOI.HPSF.Wellknown.PropertyIDMap.PID_LASTAUTHOR">
            ID of the property that denotes the document's last author 
        </member>
        <member name="F:NPOI.HPSF.Wellknown.PropertyIDMap.PID_REVNUMBER">
            ID of the property that denotes the document's revision number 
        </member>
        <member name="F:NPOI.HPSF.Wellknown.PropertyIDMap.PID_EDITTIME">
            ID of the property that denotes the document's edit time 
        </member>
        <member name="F:NPOI.HPSF.Wellknown.PropertyIDMap.PID_LASTPRINTED">
            ID of the property that denotes the DateTime and time the document was
            last printed 
        </member>
        <member name="F:NPOI.HPSF.Wellknown.PropertyIDMap.PID_Create_DTM">
            ID of the property that denotes the DateTime and time the document was
            Created. 
        </member>
        <member name="F:NPOI.HPSF.Wellknown.PropertyIDMap.PID_LASTSAVE_DTM">
            ID of the property that denotes the DateTime and time the document was
            saved 
        </member>
        <member name="F:NPOI.HPSF.Wellknown.PropertyIDMap.PID_PAGECOUNT">
            ID of the property that denotes the number of pages in the
            document 
        </member>
        <member name="F:NPOI.HPSF.Wellknown.PropertyIDMap.PID_WORDCOUNT">
            ID of the property that denotes the number of words in the
            document 
        </member>
        <member name="F:NPOI.HPSF.Wellknown.PropertyIDMap.PID_CHARCOUNT">
            ID of the property that denotes the number of characters in the
            document 
        </member>
        <member name="F:NPOI.HPSF.Wellknown.PropertyIDMap.PID_THUMBNAIL">
            ID of the property that denotes the document's thumbnail 
        </member>
        <member name="F:NPOI.HPSF.Wellknown.PropertyIDMap.PID_APPNAME">
            ID of the property that denotes the application that Created the
            document 
        </member>
        <member name="F:NPOI.HPSF.Wellknown.PropertyIDMap.PID_SECURITY">
            ID of the property that denotes whether Read/Write access To the
            document is allowed or whether is should be opened as Read-only. It can
            have the following values:
            
            <table>
             <tbody>
              <tr>
               <th>Value</th>
               <th>Description</th>
              </tr>
              <tr>
               <th>0</th>
               <th>No restriction</th>
              </tr>
              <tr>
               <th>2</th>
               <th>Read-only recommended</th>
              </tr>
              <tr>
               <th>4</th>
               <th>Read-only enforced</th>
              </tr>
             </tbody>
            </table>
        </member>
        <member name="F:NPOI.HPSF.Wellknown.PropertyIDMap.PID_DICTIONARY">
            The entry is a dictionary.
        </member>
        <member name="F:NPOI.HPSF.Wellknown.PropertyIDMap.PID_CODEPAGE">
            The entry denotes a code page.
        </member>
        <member name="F:NPOI.HPSF.Wellknown.PropertyIDMap.PID_CATEGORY">
            The entry is a string denoting the category the file belongs
            To, e.g. review, memo, etc. This is useful To Find documents of
            same type.
        </member>
        <member name="F:NPOI.HPSF.Wellknown.PropertyIDMap.PID_PRESFORMAT">
            TarGet format for power point presentation, e.g. 35mm,
            printer, video etc.
        </member>
        <member name="F:NPOI.HPSF.Wellknown.PropertyIDMap.PID_BYTECOUNT">
            Number of bytes.
        </member>
        <member name="F:NPOI.HPSF.Wellknown.PropertyIDMap.PID_LINECOUNT">
            Number of lines.
        </member>
        <member name="F:NPOI.HPSF.Wellknown.PropertyIDMap.PID_PARCOUNT">
            Number of paragraphs.
        </member>
        <member name="F:NPOI.HPSF.Wellknown.PropertyIDMap.PID_SLIDECOUNT">
            Number of slides in a power point presentation.
        </member>
        <member name="F:NPOI.HPSF.Wellknown.PropertyIDMap.PID_NOTECOUNT">
            Number of slides with notes.
        </member>
        <member name="F:NPOI.HPSF.Wellknown.PropertyIDMap.PID_HIDDENCOUNT">
            Number of hidden slides.
        </member>
        <member name="F:NPOI.HPSF.Wellknown.PropertyIDMap.PID_MMCLIPCOUNT">
            Number of multimedia clips, e.g. sound or video.
        </member>
        <member name="F:NPOI.HPSF.Wellknown.PropertyIDMap.PID_SCALE">
            This entry is Set To -1 when scaling of the thumbnail Is
            desired. Otherwise the thumbnail should be cropped.
        </member>
        <member name="F:NPOI.HPSF.Wellknown.PropertyIDMap.PID_HEADINGPAIR">
            This entry denotes an internally used property. It is a
            vector of variants consisting of pairs of a string (VT_LPSTR)
            and a number (VT_I4). The string is a heading name, and the
            number tells how many document parts are under that
            heading.
        </member>
        <member name="F:NPOI.HPSF.Wellknown.PropertyIDMap.PID_DOCPARTS">
            This entry Contains the names of document parts (word: names
            of the documents in the master document, excel: sheet names,
            power point: slide titles, binder: document names).
        </member>
        <member name="F:NPOI.HPSF.Wellknown.PropertyIDMap.PID_MANAGER">
            This entry Contains the name of the project manager.
        </member>
        <member name="F:NPOI.HPSF.Wellknown.PropertyIDMap.PID_COMPANY">
            This entry Contains the company name.
        </member>
        <member name="F:NPOI.HPSF.Wellknown.PropertyIDMap.PID_LINKSDIRTY">
            If this entry is -1 the links are dirty and should be
            re-evaluated.
        </member>
        <member name="F:NPOI.HPSF.Wellknown.PropertyIDMap.PID_MAX">
            The highest well-known property ID. Applications are free To use higher values for custom purposes.
        </member>
        <member name="F:NPOI.HPSF.Wellknown.PropertyIDMap.summaryInformationProperties">
            Contains the summary information property ID values and
            associated strings. See the overall HPSF documentation for
            details!
        </member>
        <member name="F:NPOI.HPSF.Wellknown.PropertyIDMap.documentSummaryInformationProperties">
            Contains the summary information property ID values and
            associated strings. See the overall HPSF documentation for
            details!
        </member>
        <member name="M:NPOI.HPSF.Wellknown.PropertyIDMap.#ctor(System.Int32,System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HPSF.Wellknown.PropertyIDMap"/> class.
            </summary>
            <param name="initialCapacity">initialCapacity The initial capacity as defined for
            {@link HashMap}</param>
            <param name="loadFactor">The load factor as defined for {@link HashMap}</param>
        </member>
        <member name="M:NPOI.HPSF.Wellknown.PropertyIDMap.#ctor(System.Collections.IDictionary)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HPSF.Wellknown.PropertyIDMap"/> class.
            </summary>
            <param name="map">The instance To be Created is backed by this map.</param>
        </member>
        <member name="M:NPOI.HPSF.Wellknown.PropertyIDMap.Put(System.Int64,System.String)">
            <summary>
            Puts a ID string for an ID into the {@link
            PropertyIDMap}.
            </summary>
            <param name="id">The ID string.</param>
            <param name="idString">The id string.</param>
            <returns>As specified by the {@link java.util.Map} interface, this method
            returns the previous value associated with the specified id</returns>
        </member>
        <member name="M:NPOI.HPSF.Wellknown.PropertyIDMap.Get(System.Int64)">
            <summary>
            Gets the ID string for an ID from the {@link
            PropertyIDMap}.
            </summary>
            <param name="id">The ID.</param>
            <returns>The ID string associated with id</returns>
        </member>
        <member name="P:NPOI.HPSF.Wellknown.PropertyIDMap.SummaryInformationProperties">
            <summary>
            Gets the Summary Information properties singleton
            </summary>
            <returns></returns>
        </member>
        <member name="P:NPOI.HPSF.Wellknown.PropertyIDMap.DocumentSummaryInformationProperties">
            <summary>
            Gets the Document Summary Information properties
            singleton.
            </summary>
            <returns>The Document Summary Information properties singleton.</returns>
        </member>
        <member name="T:NPOI.HPSF.Wellknown.SectionIDMap">
            <summary>
            Maps section format IDs To {@link PropertyIDMap}s. It Is
            initialized with two well-known section format IDs: those of the
            <tt>\005SummaryInformation</tt> stream and the
            <tt>\005DocumentSummaryInformation</tt> stream.
            If you have a section format ID you can use it as a key To query
            this map.  If you Get a {@link PropertyIDMap} returned your section
            is well-known and you can query the {@link PropertyIDMap} for PID
            strings. If you Get back <c>null</c> you are on your own.
            This {@link java.util.Map} expects the byte arrays of section format IDs
            as keys. A key maps To a {@link PropertyIDMap} describing the
            property IDs in sections with the specified section format ID.
            @author Rainer Klute (klute@rainer-klute.de)
            @since 2002-02-09
            </summary>
        </member>
        <member name="F:NPOI.HPSF.Wellknown.SectionIDMap.SUMMARY_INFORMATION_ID">
            The SummaryInformation's section's format ID.
        </member>
        <member name="F:NPOI.HPSF.Wellknown.SectionIDMap.DOCUMENT_SUMMARY_INFORMATION_ID1">
            The DocumentSummaryInformation's first and second sections' format
            ID.
        </member>
        <member name="F:NPOI.HPSF.Wellknown.SectionIDMap.UNDEFINED">
            A property without a known name is described by this string. 
        </member>
        <member name="F:NPOI.HPSF.Wellknown.SectionIDMap.defaultMap">
            The default section ID map. It maps section format IDs To
            {@link PropertyIDMap}s.
        </member>
        <member name="M:NPOI.HPSF.Wellknown.SectionIDMap.GetInstance">
            <summary>
            Returns the singleton instance of the default {@link
            SectionIDMap}.
            </summary>
            <returns>The instance value</returns>
        </member>
        <member name="M:NPOI.HPSF.Wellknown.SectionIDMap.GetPIDString(System.Byte[],System.Int64)">
            <summary>
            Returns the property ID string that is associated with a
            given property ID in a section format ID's namespace.
            </summary>
            <param name="sectionFormatID">Each section format ID has its own name
            space of property ID strings and thus must be specified.</param>
            <param name="pid">The property ID</param>
            <returns>The well-known property ID string associated with the
            property ID pid in the name space spanned by sectionFormatID If the pid
            sectionFormatID combination is not well-known, the
            string "[undefined]" is returned.
            </returns>
        </member>
        <member name="M:NPOI.HPSF.Wellknown.SectionIDMap.Get(System.Byte[])">
            <summary>
            Returns the {@link PropertyIDMap} for a given section format
            ID.
            </summary>
            <param name="sectionFormatID">The section format ID.</param>
            <returns>the property ID map</returns>
        </member>
        <member name="M:NPOI.HPSF.Wellknown.SectionIDMap.Get(System.Object)">
            <summary>
            Returns the {@link PropertyIDMap} for a given section format
            ID.
            </summary>
            <param name="sectionFormatID">A section format ID as a 
            <tt>byte[]</tt></param>
            <returns>the property ID map</returns>
        </member>
        <member name="M:NPOI.HPSF.Wellknown.SectionIDMap.Put(System.Byte[],NPOI.HPSF.Wellknown.PropertyIDMap)">
            <summary>
            Associates a section format ID with a {@link
            PropertyIDMap}.
            </summary>
            <param name="sectionFormatID">the section format ID</param>
            <param name="propertyIDMap">The property ID map.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.HPSF.Wellknown.SectionIDMap.Put(System.Object,System.Object)">
            <summary>
            Puts the specified key.
            </summary>
            <param name="key">This parameter remains undocumented since the method Is
            deprecated.</param>
            <param name="value">This parameter remains undocumented since the method Is
            deprecated.</param>
            <returns>The return value remains undocumented since the method Is
            deprecated.</returns>
        </member>
        <member name="T:NPOI.HPSF.WritingNotSupportedException">
            <summary>
            This exception is thrown when trying To Write a (yet) unsupported variant
            type.
            @see ReadingNotSupportedException
            @see UnsupportedVariantTypeException
            @author Rainer Klute 
            <a href="mailto:klute@rainer-klute.de">&lt;klute@rainer-klute.de&gt;</a>
            @since 2003-08-08
            </summary>
        </member>
        <member name="M:NPOI.HPSF.WritingNotSupportedException.#ctor(System.Int64,System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HPSF.WritingNotSupportedException"/> class.
            </summary>
            <param name="variantType">The unsupported variant type.</param>
            <param name="value">The value</param>
        </member>
        <member name="T:NPOI.HPSF.Extractor.HPSFPropertiesExtractor">
            <summary>
            Extracts all of the HPSF properties, both
            build in and custom, returning them in
            textual form.
            </summary>
        </member>
        <member name="P:NPOI.HPSF.Extractor.HPSFPropertiesExtractor.DocumentSummaryInformationText">
            <summary>
            Gets the document summary information text.
            </summary>
            <value>The document summary information text.</value>
        </member>
        <member name="P:NPOI.HPSF.Extractor.HPSFPropertiesExtractor.SummaryInformationText">
            <summary>
            Gets the summary information text.
            </summary>
            <value>The summary information text.</value>
        </member>
        <member name="M:NPOI.HPSF.Extractor.HPSFPropertiesExtractor.GetPropertiesText(NPOI.HPSF.SpecialPropertySet)">
            <summary>
            Gets the properties text.
            </summary>
            <param name="ps">The ps.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.HPSF.Extractor.HPSFPropertiesExtractor.GetPropertyValueText(System.Object)">
            <summary>
            Gets the property value text.
            </summary>
            <param name="val">The val.</param>
            <returns></returns>
        </member>
        <member name="P:NPOI.HPSF.Extractor.HPSFPropertiesExtractor.Text">
            <summary>
            Return the text of all the properties defined in
            the document.
            </summary>
            <value>All the text from the document.</value>
        </member>
        <member name="P:NPOI.HPSF.Extractor.HPSFPropertiesExtractor.MetadataTextExtractor">
            <summary>
            Returns another text extractor, which is able to
            output the textual content of the document
            metadata / properties, such as author and title.
            </summary>
            <value>The metadata text extractor.</value>
        </member>
        <member name="T:NPOI.HPSF.Extractor.HPSFPropertiesExtractor.PropertiesOnlyDocument">
            <summary>
            So we can get at the properties of any
            random OLE2 document.
            </summary>
        </member>
        <member name="T:NPOI.HSSF.EventModel.ERFListener">
            An ERFListener Is registered with the EventRecordFactory.
            An ERFListener listens for Records coming from the stream
            via the EventRecordFactory
            
            @see EventRecordFactory
            @author Andrew C. Oliver acoliver@apache.org
        </member>
        <member name="M:NPOI.HSSF.EventModel.ERFListener.ProcessRecord(NPOI.HSSF.Record.Record)">
            Process a Record.  This method Is called by the 
            EventRecordFactory when a record Is returned.
            @return bool specifying whether the effort was a success.
        </member>
        <member name="T:NPOI.HSSF.EventModel.EventRecordFactory">
            Event-based record factory.  As opposed to RecordFactory
            this refactored version throws record events as it comes
            accross the records.  I throws the "lazily" one record behind
            to ensure that ContinueRecords are Processed first.
            
            @author Andrew C. Oliver (acoliver@apache.org) - probably to blame for the bugs (so yank his chain on the list)
            @author Marc Johnson (mjohnson at apache dot org) - methods taken from RecordFactory
            @author Glen Stampoultzis (glens at apache.org) - methods taken from RecordFactory
            @author Csaba Nagy (ncsaba at yahoo dot com)
        </member>
        <member name="M:NPOI.HSSF.EventModel.EventRecordFactory.#ctor(NPOI.HSSF.EventModel.ERFListener,System.Collections.ArrayList)">
            Create an EventRecordFactory
            @param abortable specifies whether the return from the listener 
            handler functions are obeyed.  False means they are ignored. True
            means the event loop exits on error.
        </member>
        <member name="M:NPOI.HSSF.EventModel.EventRecordFactory.ProcessRecord(NPOI.HSSF.Record.Record)">
            sends the record event to all registered listeners.
            @param record the record to be thrown.
            @return <c>false</c> to abort.  This aborts
            out of the event loop should the listener return false
        </member>
        <member name="M:NPOI.HSSF.EventModel.EventRecordFactory.ProcessRecords(System.IO.Stream)">
             Create an array of records from an input stream
            
             @param in the InputStream from which the records will be
                       obtained
            
             @exception RecordFormatException on error Processing the
                        InputStream
        </member>
        <member name="T:NPOI.HSSF.EventModel.ModelFactory">
            ModelFactory Creates workbook and sheet models based upon 
            events thrown by them there events from the EventRecordFactory.
            
            @see org.apache.poi.hssf.eventmodel.EventRecordFactory
            @author Andrew C. Oliver acoliver@apache.org
        </member>
        <member name="M:NPOI.HSSF.EventModel.ModelFactory.#ctor">
            Constructor for ModelFactory.  Does practically nothing.
        </member>
        <member name="M:NPOI.HSSF.EventModel.ModelFactory.RegisterListener(NPOI.HSSF.EventModel.ModelFactoryListener)">
            register a ModelFactoryListener so that it can receive 
            Models as they are created.
        </member>
        <member name="M:NPOI.HSSF.EventModel.ModelFactory.Run(System.IO.Stream)">
            Start Processing the Workbook stream into Model events.
        </member>
        <member name="M:NPOI.HSSF.EventModel.ModelFactory.ThrowEvent(NPOI.HSSF.Model.Model)">
            Throws the model as an event to the listeners
            @param model to be thrown
        </member>
        <member name="T:NPOI.HSSF.EventModel.ModelFactoryListener">
            ModelFactoryListener Is registered with the 
            ModelFactory.  It receives Models.
            
            @author Andrew C. Oliver acoliver@apache.org
        </member>
        <member name="M:NPOI.HSSF.EventModel.ModelFactoryListener.Process(NPOI.HSSF.Model.Model)">
            Process a model.  Called by the ModelFactory
            @param model to be Processed
            @return abortable - currently ignored (may be implemented in the future)
        </member>
        <member name="T:NPOI.HSSF.EventUserModel.AbortableHSSFListener">
             Interface for use with the HSSFRequest and HSSFEventFactory.  Users should Create
             a listener supporting this interface and register it with the HSSFRequest (associating
             it with Record SID's).
            
             @see org.apache.poi.hssf.eventusermodel.HSSFEventFactory
             @see org.apache.poi.hssf.eventusermodel.HSSFRequest
             @see org.apache.poi.hssf.eventusermodel.HSSFUserException
            
             @author Carey Sublette (careysub@earthling.net)
            
        </member>
        <member name="M:NPOI.HSSF.EventUserModel.AbortableHSSFListener.ProcessRecord(NPOI.HSSF.Record.Record)">
             This method, inherited from HSSFListener Is implemented as a stub.
             It Is never called by HSSFEventFActory or HSSFRequest.
            
        </member>
        <member name="M:NPOI.HSSF.EventUserModel.AbortableHSSFListener.abortableProcessRecord(NPOI.HSSF.Record.Record)">
             Process an HSSF Record. Called when a record occurs in an HSSF file. 
             Provides two options for halting the Processing of the HSSF file.
            
             The return value provides a means of non-error termination with a 
             user-defined result code. A value of zero must be returned to 
             continue Processing, any other value will halt Processing by
             <c>HSSFEventFactory</c> with the code being passed back by 
             its abortable Process events methods.
             
             Error termination can be done by throwing the HSSFUserException.
            
             Note that HSSFEventFactory will not call the inherited Process 
            
             @return result code of zero for continued Processing.
            
             @throws HSSFUserException User code can throw this to abort 
             file Processing by HSSFEventFactory and return diagnostic information.
        </member>
        <member name="T:NPOI.HSSF.EventUserModel.DummyRecord.LastCellOfRowDummyRecord">
            A dummy record to indicate that we've now had the last
             cell record for this row.
        </member>
        <member name="P:NPOI.HSSF.EventUserModel.DummyRecord.LastCellOfRowDummyRecord.Row">
            Returns the (0 based) number of the row we are
             currently working on.
        </member>
        <member name="P:NPOI.HSSF.EventUserModel.DummyRecord.LastCellOfRowDummyRecord.LastColumnNumber">
            Returns the (0 based) number of the last column
             seen for this row. You should have alReady been
             called with that record.
            This Is -1 in the case of there being no columns
             for the row.
        </member>
        <member name="T:NPOI.HSSF.EventUserModel.DummyRecord.MissingCellDummyRecord">
            A dummy record for when we're missing a cell in a row,
             but still want to trigger something
        </member>
        <member name="T:NPOI.HSSF.EventUserModel.DummyRecord.MissingRowDummyRecord">
            A dummy record for when we're missing a row, but still
             want to trigger something
        </member>
        <member name="T:NPOI.HSSF.EventUserModel.EventWorkbookBuilder">
            <summary>
            When working with the EventUserModel, if you want to
            Process formulas, you need an instance of
            Workbook to pass to a HSSFWorkbook,
            to finally give to HSSFFormulaParser,
            and this will build you stub ones.
            Since you're working with the EventUserModel, you
            wouldn't want to Get a full Workbook and
             HSSFWorkbook, as they would eat too much memory.
            Instead, you should collect a few key records as they
            go past, then call this once you have them to build a
            stub Workbook, and from that a stub
            HSSFWorkbook, to use with the HSSFFormulaParser.
            The records you should collect are:
            ExternSheetRecord
            BoundSheetRecord
            You should probably also collect SSTRecord,
            but it's not required to pass this in.
            To help, this class includes a HSSFListener wrapper
            that will do the collecting for you.
            </summary>
        </member>
        <member name="M:NPOI.HSSF.EventUserModel.EventWorkbookBuilder.CreateStubHSSFWorkbook(NPOI.HSSF.Model.Workbook)">
            <summary>
            Wraps up your stub Workbook as a stub
            HSSFWorkbook, ready for passing to
            HSSFFormulaParser
            </summary>
            <param name="workbook">The stub workbook.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.EventUserModel.EventWorkbookBuilder.CreateStubWorkbook(NPOI.HSSF.Record.ExternSheetRecord[],NPOI.HSSF.Record.BoundSheetRecord[],NPOI.HSSF.Record.SSTRecord)">
            <summary>
            Creates a stub Workbook from the supplied records,
            suitable for use with the {@link HSSFFormulaParser}
            </summary>
            <param name="externs">The ExternSheetRecords in your file</param>
            <param name="bounds">The BoundSheetRecords in your file</param>
            <param name="sst">TThe SSTRecord in your file.</param>
            <returns>A stub Workbook suitable for use with HSSFFormulaParser</returns>
        </member>
        <member name="M:NPOI.HSSF.EventUserModel.EventWorkbookBuilder.CreateStubWorkbook(NPOI.HSSF.Record.ExternSheetRecord[],NPOI.HSSF.Record.BoundSheetRecord[])">
            <summary>
            Creates a stub workbook from the supplied records,
            suitable for use with the HSSFFormulaParser
            </summary>
            <param name="externs">The ExternSheetRecords in your file</param>
            <param name="bounds">A stub Workbook suitable for use with HSSFFormulaParser</param>
            <returns>A stub Workbook suitable for use with {@link HSSFFormulaParser}</returns>
        </member>
        <member name="T:NPOI.HSSF.EventUserModel.EventWorkbookBuilder.SheetRecordCollectingListener">
            <summary>
            A wrapping HSSFListener which will collect
            BoundSheetRecords and {@link ExternSheetRecord}s as
            they go past, so you can Create a Stub {@link Workbook} from
            them once required.
            </summary>
        </member>
        <member name="M:NPOI.HSSF.EventUserModel.EventWorkbookBuilder.SheetRecordCollectingListener.#ctor(NPOI.HSSF.EventUserModel.HSSFListener)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HSSF.EventUserModel.EventWorkbookBuilder.SheetRecordCollectingListener"/> class.
            </summary>
            <param name="childListener">The child listener.</param>
        </member>
        <member name="M:NPOI.HSSF.EventUserModel.EventWorkbookBuilder.SheetRecordCollectingListener.GetBoundSheetRecords">
            <summary>
            Gets the bound sheet records.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.EventUserModel.EventWorkbookBuilder.SheetRecordCollectingListener.GetExternSheetRecords">
            <summary>
            Gets the extern sheet records.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.EventUserModel.EventWorkbookBuilder.SheetRecordCollectingListener.GetSSTRecord">
            <summary>
            Gets the SST record.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.EventUserModel.EventWorkbookBuilder.SheetRecordCollectingListener.GetStubHSSFWorkbook">
            <summary>
            Gets the stub HSSF workbook.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.EventUserModel.EventWorkbookBuilder.SheetRecordCollectingListener.GetStubWorkbook">
            <summary>
            Gets the stub workbook.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.EventUserModel.EventWorkbookBuilder.SheetRecordCollectingListener.ProcessRecord(NPOI.HSSF.Record.Record)">
            <summary>
            Process this record ourselves, and then
            pass it on to our child listener
            </summary>
            <param name="record">The record.</param>
        </member>
        <member name="M:NPOI.HSSF.EventUserModel.EventWorkbookBuilder.SheetRecordCollectingListener.ProcessRecordInternally(NPOI.HSSF.Record.Record)">
            <summary>
            Process the record ourselves, but do not
            pass it on to the child Listener.
            </summary>
            <param name="record">The record.</param>
        </member>
        <member name="T:NPOI.HSSF.EventUserModel.EventWorkbookBuilder.StubHSSFWorkbook">
            Let us at the {@link Workbook} constructor on
             {@link HSSFWorkbook}
        </member>
        <member name="T:NPOI.HSSF.EventUserModel.FormatTrackingHSSFListener">
            A proxy HSSFListener that keeps track of the document
             formatting records, and provides an easy way to look
             up the format strings used by cells from their ids.
        </member>
        <member name="M:NPOI.HSSF.EventUserModel.FormatTrackingHSSFListener.ProcessRecord(NPOI.HSSF.Record.Record)">
            Process this record ourselves, and then
             pass it on to our child listener
        </member>
        <member name="M:NPOI.HSSF.EventUserModel.FormatTrackingHSSFListener.ProcessRecordInternally(NPOI.HSSF.Record.Record)">
            Process the record ourselves, but do not
             pass it on to the child Listener.
            @param record
        </member>
        <member name="M:NPOI.HSSF.EventUserModel.FormatTrackingHSSFListener.FormatNumberDateCell(NPOI.HSSF.Record.CellValueRecordInterface)">
            Formats the given numeric of date Cell's contents
             as a String, in as close as we can to the way 
             that Excel would do so.
            Uses the various format records to manage this.
            
            TODO - move this to a central class in such a
             way that hssf.usermodel can make use of it too
        </member>
        <member name="M:NPOI.HSSF.EventUserModel.FormatTrackingHSSFListener.GetFormatString(System.Int32)">
            Returns the format string, eg $##.##, for the
             given number format index.
        </member>
        <member name="M:NPOI.HSSF.EventUserModel.FormatTrackingHSSFListener.GetFormatString(NPOI.HSSF.Record.CellValueRecordInterface)">
            Returns the format string, eg $##.##, used
             by your cell 
        </member>
        <member name="M:NPOI.HSSF.EventUserModel.FormatTrackingHSSFListener.GetFormatIndex(NPOI.HSSF.Record.CellValueRecordInterface)">
            Returns the index of the format string, used by your cell,
             or -1 if none found
        </member>
        <member name="T:NPOI.HSSF.EventUserModel.HSSFEventFactory">
            <summary>
            Low level event based HSSF Reader.  Pass either a DocumentInputStream to
            Process events along with a request object or pass a POIFS POIFSFileSystem to
            ProcessWorkbookEvents along with a request.
            This will cause your file to be Processed a record at a time.  Each record with
            a static id matching one that you have registed in your HSSFRequest will be passed
            to your associated HSSFListener.
            @author Andrew C. Oliver (acoliver at apache dot org)
            @author Carey Sublette  (careysub@earthling.net)
            </summary>
        </member>
        <member name="M:NPOI.HSSF.EventUserModel.HSSFEventFactory.#ctor">
            <summary>
            Creates a new instance of HSSFEventFactory
            </summary>
        </member>
        <member name="M:NPOI.HSSF.EventUserModel.HSSFEventFactory.ProcessWorkbookEvents(NPOI.HSSF.EventUserModel.HSSFRequest,NPOI.POIFS.FileSystem.POIFSFileSystem)">
            <summary>
            Processes a file into essentially record events.
            </summary>
            <param name="req">an Instance of HSSFRequest which has your registered listeners</param>
            <param name="fs">a POIFS filesystem containing your workbook</param>
        </member>
        <member name="M:NPOI.HSSF.EventUserModel.HSSFEventFactory.AbortableProcessWorkbookEvents(NPOI.HSSF.EventUserModel.HSSFRequest,NPOI.POIFS.FileSystem.POIFSFileSystem)">
            <summary>
            Processes a file into essentially record events.
            </summary>
            <param name="req">an Instance of HSSFRequest which has your registered listeners</param>
            <param name="fs">a POIFS filesystem containing your workbook</param>
            <returns>numeric user-specified result code.</returns>
        </member>
        <member name="M:NPOI.HSSF.EventUserModel.HSSFEventFactory.ProcessEvents(NPOI.HSSF.EventUserModel.HSSFRequest,System.IO.Stream)">
            <summary>
            Processes a DocumentInputStream into essentially Record events.
            If an 
            <c>AbortableHSSFListener</c>
             causes a halt to Processing during this call
            the method will return just as with 
            <c>abortableProcessEvents</c>
            , but no
            user code or 
            <c>HSSFUserException</c>
             will be passed back.
            </summary>
            <param name="req">an Instance of HSSFRequest which has your registered listeners</param>
            <param name="in1">a DocumentInputStream obtained from POIFS's POIFSFileSystem object</param>
        </member>
        <member name="M:NPOI.HSSF.EventUserModel.HSSFEventFactory.AbortableProcessEvents(NPOI.HSSF.EventUserModel.HSSFRequest,System.IO.Stream)">
            <summary>
            Processes a DocumentInputStream into essentially Record events.
            </summary>
            <param name="req">an Instance of HSSFRequest which has your registered listeners</param>
            <param name="in1">a DocumentInputStream obtained from POIFS's POIFSFileSystem object</param>
            <returns>numeric user-specified result code.</returns>
        </member>
        <member name="M:NPOI.HSSF.EventUserModel.HSSFEventFactory.GenericProcessEvents(NPOI.HSSF.EventUserModel.HSSFRequest,NPOI.HSSF.Record.RecordInputStream)">
            <summary>
            Processes a DocumentInputStream into essentially Record events.
            </summary>
            <param name="req">an Instance of HSSFRequest which has your registered listeners</param>
            <param name="in1">a DocumentInputStream obtained from POIFS's POIFSFileSystem object</param>
            <returns>numeric user-specified result code.</returns>
        </member>
        <member name="T:NPOI.HSSF.EventUserModel.HSSFListener">
            <summary>
            Interface for use with the HSSFRequest and HSSFEventFactory.  Users should Create
            a listener supporting this interface and register it with the HSSFRequest (associating
            it with Record SID's).
            @author  acoliver@apache.org
            </summary>
        </member>
        <member name="M:NPOI.HSSF.EventUserModel.HSSFListener.ProcessRecord(NPOI.HSSF.Record.Record)">
            <summary>
            Process an HSSF Record. Called when a record occurs in an HSSF file.
            </summary>
            <param name="record">The record.</param>
        </member>
        <member name="T:NPOI.HSSF.EventUserModel.HSSFRecordStream">
            <summary>
            A stream based way to Get at complete records, with
            as low a memory footprint as possible.
            This handles Reading from a RecordInputStream, turning
            the data into full records, Processing continue records
            etc.
            Most users should use HSSFEventFactory 
            HSSFListener and have new records pushed to
            them, but this does allow for a "pull" style of coding. 
            </summary>
        </member>
        <member name="F:NPOI.HSSF.EventUserModel.HSSFRecordStream.hitEOS">
            Have we run out of records on the stream? 
        </member>
        <member name="F:NPOI.HSSF.EventUserModel.HSSFRecordStream.complete">
            Have we returned all the records there are? 
        </member>
        <member name="F:NPOI.HSSF.EventUserModel.HSSFRecordStream.bonusRecords">
            Sometimes we end up with a bunch of
             records. When we do, these should
             be returned before the next normal
             record Processing occurs (i.e. before
             we Check for continue records and
             return rec)
        </member>
        <member name="F:NPOI.HSSF.EventUserModel.HSSFRecordStream.rec">
            The next record to return, which may need to have its
             continue records passed to it before we do
        </member>
        <member name="F:NPOI.HSSF.EventUserModel.HSSFRecordStream.lastRec">
            The most recent record that we gave to the user
        </member>
        <member name="F:NPOI.HSSF.EventUserModel.HSSFRecordStream.lastDrawingRecord">
            The most recent DrawingRecord seen
        </member>
        <member name="M:NPOI.HSSF.EventUserModel.HSSFRecordStream.NextRecord">
            <summary>
            Returns the next (complete) record from the
            stream, or null if there are no more.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.EventUserModel.HSSFRecordStream.GetBonusRecord">
            <summary>
            If there are any "bonus" records, that should
            be returned before Processing new ones,
            grabs the next and returns it.
            If not, returns null;
            </summary>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.EventUserModel.HSSFRecordStream.GetNextRecord">
            <summary>
            Returns the next available record, or null if
            this pass didn't return a record that's
            suitable for returning (eg was a continue record).
            </summary>
            <returns></returns>
        </member>
        <member name="T:NPOI.HSSF.EventUserModel.HSSFRequest">
            <summary>
            An HSSFRequest object should be constructed registering an instance or multiple
            instances of HSSFListener with each Record.sid you wish to listen for.
            @author  Andrew C. Oliver (acoliver at apache dot org)
            @author Carey Sublette (careysub@earthling.net)
            </summary>
        </member>
        <member name="M:NPOI.HSSF.EventUserModel.HSSFRequest.#ctor">
            <summary>
            Creates a new instance of HSSFRequest
            </summary>
        </member>
        <member name="M:NPOI.HSSF.EventUserModel.HSSFRequest.AddListener(NPOI.HSSF.EventUserModel.HSSFListener,System.Int16)">
            <summary>
            Add an event listener for a particular record type.  The trick Is you have to know
            what the records are for or just start with our examples and build on them.  Alternatively,
            you CAN call AddListenerForAllRecords and you'll recieve ALL record events in one listener,
            but if you like to squeeze every last byte of efficiency out of life you my not like this.
            (its sure as heck what I plan to do)
            </summary>
            <param name="lsnr">for the event</param>
            <param name="sid">identifier for the record type this Is the .sid static member on the individual records</param>
        </member>
        <member name="M:NPOI.HSSF.EventUserModel.HSSFRequest.AddListenerForAllRecords(NPOI.HSSF.EventUserModel.HSSFListener)">
            <summary>
            This Is the equivilent of calling AddListener(myListener, sid) for EVERY
            record in the org.apache.poi.hssf.record package. This Is for lazy
            people like me. You can call this more than once with more than one listener, but
            that seems like a bad thing to do from a practice-perspective Unless you have a
            compelling reason to do so (like maybe you send the event two places or log it or
            something?).
            </summary>
            <param name="lsnr">a single listener to associate with ALL records</param>
        </member>
        <member name="M:NPOI.HSSF.EventUserModel.HSSFRequest.ProcessRecord(NPOI.HSSF.Record.Record)">
            <summary>
            Called by HSSFEventFactory, passes the Record to each listener associated with
            a record.sid.
            Exception and return value Added 2002-04-19 by Carey Sublette
            </summary>
            <param name="rec">The record.</param>
            <returns>numeric user-specified result code. If zero continue Processing.</returns>
        </member>
        <member name="T:NPOI.HSSF.EventUserModel.HSSFUserException">
            <summary>
            This exception Is provided as a way for API users to throw
            exceptions from their event handling code. By doing so they
            abort file Processing by the HSSFEventFactory and by
            catching it from outside the HSSFEventFactory.ProcessEvents
            method they can diagnose the cause for the abort.
            The HSSFUserException supports a nested "reason"
            throwable, i.e. an exception that caused this one to be thrown.
            The HSSF package does not itself throw any of these
            exceptions.
            </summary>
            <remarks>
            @author Rainer Klute (klute@rainer-klute.de)
            @author Carey Sublette (careysub@earthling.net)
            </remarks>
        </member>
        <member name="M:NPOI.HSSF.EventUserModel.HSSFUserException.#ctor">
            <summary>
            Creates a new HSSFUserException
            </summary>
        </member>
        <member name="M:NPOI.HSSF.EventUserModel.HSSFUserException.#ctor(System.String)">
            <summary>
            Creates a new HSSFUserException with a message
            string.
            </summary>
            <param name="msg">The MSG.</param>
        </member>
        <member name="M:NPOI.HSSF.EventUserModel.HSSFUserException.#ctor(System.Exception)">
            <summary>
            Creates a new HSSFUserException with a reason.
            </summary>
            <param name="reason">The reason.</param>
        </member>
        <member name="M:NPOI.HSSF.EventUserModel.HSSFUserException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new HSSFUserException with a message string
            and a reason.
            </summary>
            <param name="msg">The MSG.</param>
            <param name="reason">The reason.</param>
        </member>
        <member name="T:NPOI.HSSF.EventUserModel.MissingRecordAwareHSSFListener">
            <summary>
            A HSSFListener which tracks rows and columns, and will
            trigger your HSSFListener for all rows and cells,
            even the ones that aren't actually stored in the file.
            This allows your code to have a more "Excel" like
            view of the data in the file, and not have to worry
            (as much) about if a particular row/cell Is in the
            file, or was skipped from being written as it was
            blank.
            </summary>
        </member>
        <member name="M:NPOI.HSSF.EventUserModel.MissingRecordAwareHSSFListener.#ctor(NPOI.HSSF.EventUserModel.HSSFListener)">
            <summary>
            Constructs a new MissingRecordAwareHSSFListener, which
            will fire ProcessRecord on the supplied child
            HSSFListener for all Records, and missing records.
            </summary>
            <param name="listener">The HSSFListener to pass records on to</param>
        </member>
        <member name="M:NPOI.HSSF.EventUserModel.MissingRecordAwareHSSFListener.ProcessRecord(NPOI.HSSF.Record.Record)">
            <summary>
            Process an HSSF Record. Called when a record occurs in an HSSF file.
            </summary>
            <param name="record"></param>
        </member>
        <member name="T:NPOI.HSSF.Extractor.EventBasedExcelExtractor">
            <summary>
            A text extractor for Excel files, that is based
            on the hssf eventusermodel api.
            It will typically use less memory than
            ExcelExtractor, but may not provide
            the same richness of formatting.
            Returns the textual content of the file, suitable for
            indexing by something like Lucene, but not really
            intended for display to the user.
            </summary>
        </member>
        <member name="P:NPOI.HSSF.Extractor.EventBasedExcelExtractor.DocSummaryInformation">
            <summary>
            Would return the document information metadata for the document,
            if we supported it
            </summary>
            <value>The doc summary information.</value>
        </member>
        <member name="P:NPOI.HSSF.Extractor.EventBasedExcelExtractor.SummaryInformation">
            <summary>
            Would return the summary information metadata for the document,
            if we supported it
            </summary>
            <value>The summary information.</value>
        </member>
        <member name="P:NPOI.HSSF.Extractor.EventBasedExcelExtractor.IncludeSheetNames">
            <summary>
            Should sheet names be included? Default is true
            </summary>
            <param name="includeSheetNames">if set to <c>true</c> [include sheet names].</param>
        </member>
        <member name="P:NPOI.HSSF.Extractor.EventBasedExcelExtractor.FormulasNotResults">
            <summary>
            Should we return the formula itself, and not
            the result it produces? Default is false
            </summary>
            <param name="formulasNotResults">if set to <c>true</c> [formulas not results].</param>
        </member>
        <member name="P:NPOI.HSSF.Extractor.EventBasedExcelExtractor.Text">
            <summary>
            Retreives the text contents of the file
            </summary>
            <value>All the text from the document.</value>
        </member>
        <member name="M:NPOI.HSSF.Extractor.EventBasedExcelExtractor.TriggerExtraction">
            <summary>
            Triggers the extraction.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.Extractor.EventBasedExcelExtractor.TextListener.ProcessRecord(NPOI.HSSF.Record.Record)">
            <summary>
            Process an HSSF Record. Called when a record occurs in an HSSF file.
            </summary>
            <param name="record"></param>
        </member>
        <member name="M:NPOI.HSSF.Extractor.EventBasedExcelExtractor.TextListener.FormatNumberDateCell(NPOI.HSSF.Record.CellValueRecordInterface,System.Double)">
            <summary>
            Formats a number or date cell, be that a real number, or the
            answer to a formula
            </summary>
            <param name="cell">The cell.</param>
            <param name="value">The value.</param>
            <returns></returns>
        </member>
        <member name="T:NPOI.HSSF.Extractor.ExcelExtractor">
            <summary>
            A text extractor for Excel files.
            Returns the textual content of the file, suitable for
            indexing by something like Lucene, but not really
            intended for display to the user.
            </summary>
        </member>
        <member name="M:NPOI.HSSF.Extractor.ExcelExtractor.#ctor(NPOI.HSSF.UserModel.HSSFWorkbook)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HSSF.Extractor.ExcelExtractor"/> class.
            </summary>
            <param name="wb">The wb.</param>
        </member>
        <member name="M:NPOI.HSSF.Extractor.ExcelExtractor.#ctor(NPOI.POIFS.FileSystem.POIFSFileSystem)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HSSF.Extractor.ExcelExtractor"/> class.
            </summary>
            <param name="fs">The fs.</param>
        </member>
        <member name="P:NPOI.HSSF.Extractor.ExcelExtractor.IncludeSheetNames">
            <summary>
            Should sheet names be included? Default is true
            </summary>
            <param name="includeSheetNames">if set to <c>true</c> [include sheet names].</param>
        </member>
        <member name="P:NPOI.HSSF.Extractor.ExcelExtractor.FormulasNotResults">
            <summary>
            Should we return the formula itself, and not
            the result it produces? Default is false
            </summary>
            <param name="formulasNotResults">if set to <c>true</c> [formulas not results].</param>
        </member>
        <member name="P:NPOI.HSSF.Extractor.ExcelExtractor.IncludeCellComments">
            <summary>
            Should cell comments be included? Default is false
            </summary>
            <param name="includeCellComments">if set to <c>true</c> [include cell comments].</param>
        </member>
        <member name="P:NPOI.HSSF.Extractor.ExcelExtractor.IncludeBlankCells">
            <summary>
            Should blank cells be output? Default is to only
            output cells that are present in the file and are
            non-blank.
            </summary>
            <param name="includeBlankCells">if set to <c>true</c> [include blank cells].</param>
        </member>
        <member name="P:NPOI.HSSF.Extractor.ExcelExtractor.Text">
            <summary>
            Retreives the text contents of the file
            </summary>
            <value>All the text from the document.</value>
        </member>
        <member name="M:NPOI.HSSF.Extractor.ExcelExtractor.ExtractHeaderFooter(NPOI.SS.UserModel.HeaderFooter)">
            <summary>
            Extracts the header footer.
            </summary>
            <param name="hf">The header or footer</param>
            <returns></returns>
        </member>
        <member name="T:NPOI.HSSF.Model.AbstractShape">
            <summary>
            An abstract shape Is the lowlevel model for a shape.
            @author Glen Stampoultzis (glens at apache.org)
            </summary>
        </member>
        <member name="M:NPOI.HSSF.Model.AbstractShape.CreateShape(NPOI.HSSF.UserModel.HSSFShape,System.Int32)">
            <summary>
            Create a new shape object used to Create the escher records.
            </summary>
            <param name="hssfShape">The simple shape this Is based on.</param>
            <param name="shapeId">The shape id.</param>
            <returns></returns>
        </member>
        <member name="P:NPOI.HSSF.Model.AbstractShape.SpContainer">
            <summary>
            The shape container and it's children that can represent this
            shape.
            </summary>
            <value>The sp container.</value>
        </member>
        <member name="P:NPOI.HSSF.Model.AbstractShape.ObjRecord">
            <summary>
            The object record that Is associated with this shape.
            </summary>
            <value>The obj record.</value>
        </member>
        <member name="M:NPOI.HSSF.Model.AbstractShape.CreateAnchor(NPOI.HSSF.UserModel.HSSFAnchor)">
            <summary>
            Creates an escher anchor record from a HSSFAnchor.
            </summary>
            <param name="userAnchor">The high level anchor to Convert.</param>
            <returns>An escher anchor record.</returns>
        </member>
        <member name="M:NPOI.HSSF.Model.AbstractShape.AddStandardOptions(NPOI.HSSF.UserModel.HSSFShape,NPOI.DDF.EscherOptRecord)">
            <summary>
            Add standard properties to the opt record.  These properties effect
            all records.
            </summary>
            <param name="shape">The user model shape.</param>
            <param name="opt">The opt record to Add the properties to.</param>
            <returns>The number of options Added.</returns>
        </member>
        <member name="T:NPOI.HSSF.Model.CommentShape">
            <summary>
            Represents a cell comment.
            This class Converts highlevel model data from HSSFComment
            to low-level records.
            @author Yegor Kozlov
            </summary>
        </member>
        <member name="M:NPOI.HSSF.Model.CommentShape.#ctor(NPOI.HSSF.UserModel.HSSFComment,System.Int32)">
            <summary>
            Creates the low-level records for a comment.
            </summary>
            <param name="hssfShape">The highlevel shape.</param>
            <param name="shapeId">The shape id to use for this shape.</param>
        </member>
        <member name="M:NPOI.HSSF.Model.CommentShape.CreateNoteRecord(NPOI.HSSF.UserModel.HSSFComment,System.Int32)">
            <summary>
            Creates the low level NoteRecord
            which holds the comment attributes.
            </summary>
            <param name="shape">The shape.</param>
            <param name="shapeId">The shape id.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.Model.CommentShape.AddStandardOptions(NPOI.HSSF.UserModel.HSSFShape,NPOI.DDF.EscherOptRecord)">
            <summary>
            Sets standard escher options for a comment.
            This method is responsible for Setting default background,
            shading and other comment properties.
            </summary>
            <param name="shape">The highlevel shape.</param>
            <param name="opt">The escher records holding the proerties</param>
            <returns>The number of escher options added</returns>
        </member>
        <member name="P:NPOI.HSSF.Model.CommentShape.NoteRecord">
            <summary>
            Gets the NoteRecord holding the comment attributes
            </summary>
            <value>The NoteRecord</value>
        </member>
        <member name="M:NPOI.HSSF.Model.ConvertAnchor.CreateAnchor(NPOI.HSSF.UserModel.HSSFAnchor)">
            <summary>
            Creates the anchor.
            </summary>
            <param name="userAnchor">The user anchor.</param>
            <returns></returns>
        </member>
        <member name="T:NPOI.HSSF.Model.DrawingManager">
             Provides utilities to manage drawing Groups.
            
             @author Glen Stampoultzis (glens at apache.org)
        </member>
        <member name="M:NPOI.HSSF.Model.DrawingManager.AllocateShapeId(System.Int16)">
             Allocates new shape id for the new drawing Group id.
            
             @return a new shape id.
        </member>
        <member name="T:NPOI.HSSF.Model.DrawingManager2">
             Provides utilities to manage drawing Groups.
            
             @author Glen Stampoultzis (glens at apache.org)
        </member>
        <member name="M:NPOI.HSSF.Model.DrawingManager2.ClearDrawingGroups">
            Clears the cached list of drawing Groups
        </member>
        <member name="M:NPOI.HSSF.Model.DrawingManager2.AllocateShapeId(System.Int16)">
             Allocates new shape id for the new drawing Group id.
            
             @return a new shape id.
        </member>
        <member name="M:NPOI.HSSF.Model.DrawingManager2.AllocateShapeId(System.Int16,NPOI.DDF.EscherDgRecord)">
             Allocates new shape id for the new drawing group id.
            
             @return a new shape id.
        </member>
        <member name="M:NPOI.HSSF.Model.DrawingManager2.FindNewDrawingGroupId">
            Finds the next available (1 based) drawing Group id
        </member>
        <member name="T:NPOI.HSSF.Model.HSSFFormulaParser">
            HSSF wrapper for the {@link FormulaParser} and {@link FormulaRenderer} 
            
            @author Josh Micich
        </member>
        <member name="M:NPOI.HSSF.Model.HSSFFormulaParser.Parse(System.String,NPOI.HSSF.UserModel.HSSFWorkbook)">
            Convenience method for parsing cell formulas. see {@link #parse(String, HSSFWorkbook, int)}
        </member>
        <member name="M:NPOI.HSSF.Model.HSSFFormulaParser.Parse(System.String,NPOI.HSSF.UserModel.HSSFWorkbook,NPOI.SS.Formula.FormulaType)">
            @param formulaType a constant from {@link FormulaType}
            @return the parsed formula tokens
        </member>
        <member name="M:NPOI.HSSF.Model.HSSFFormulaParser.Parse(System.String,NPOI.HSSF.UserModel.HSSFWorkbook,NPOI.SS.Formula.FormulaType,System.Int32)">
             @param formula     the formula to parse
             @param workbook    the parent workbook
             @param formulaType a constant from {@link FormulaType}
             @param sheetIndex  the 0-based index of the sheet this formula belongs to.
             The sheet index is required to resolve sheet-level names. <code>-1</code> means that
             the scope of the name will be ignored and  the parser will match named ranges only by name
            
             @return the parsed formula tokens
        </member>
        <member name="M:NPOI.HSSF.Model.HSSFFormulaParser.ToFormulaString(NPOI.HSSF.UserModel.HSSFWorkbook,NPOI.HSSF.Record.Formula.Ptg[])">
            Static method to convert an array of {@link Ptg}s in RPN order
            to a human readable string format in infix mode.
            @param book  used for defined names and 3D references
            @param ptgs  must not be <c>null</c>
            @return a human readable String
        </member>
        <member name="T:NPOI.HSSF.Model.LineShape">
            <summary>
            Represents a line shape and Creates all the line specific low level records.
            @author Glen Stampoultzis (glens at apache.org)
            </summary>
        </member>
        <member name="M:NPOI.HSSF.Model.LineShape.#ctor(NPOI.HSSF.UserModel.HSSFSimpleShape,System.Int32)">
            <summary>
            Creates the line shape from the highlevel user shape.  All low level
            records are Created at this point.
            </summary>
            <param name="hssfShape">The user model shape</param>
            <param name="shapeId">The identifier to use for this shape.</param>
        </member>
        <member name="M:NPOI.HSSF.Model.LineShape.CreateSpContainer(NPOI.HSSF.UserModel.HSSFSimpleShape,System.Int32)">
            <summary>
            Creates the lowerlevel escher records for this shape.
            </summary>
            <param name="hssfShape">The HSSF shape.</param>
            <param name="shapeId">The shape id.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.Model.LineShape.CreateObjRecord(NPOI.HSSF.UserModel.HSSFShape,System.Int32)">
            <summary>
            Creates the low level OBJ record for this shape.
            </summary>
            <param name="hssfShape">The HSSF shape.</param>
            <param name="shapeId">The shape id.</param>
            <returns></returns>
        </member>
        <member name="P:NPOI.HSSF.Model.LineShape.SpContainer">
            <summary>
            The shape container and it's children that can represent this
            shape.
            </summary>
            <value></value>
        </member>
        <member name="P:NPOI.HSSF.Model.LineShape.ObjRecord">
            <summary>
            The object record that is associated with this shape.
            </summary>
            <value></value>
        </member>
        <member name="T:NPOI.HSSF.Model.LinkTable">
             Link Table (OOO pdf reference: 4.10.3 ) <p/>
            
             The main data of all types of references is stored in the Link Table inside the Workbook Globals
             Substream (4.2.5). The Link Table itself is optional and occurs only, if  there are any
             references in the document.
              <p/>
            
              In BIFF8 the Link Table consists of
              <ul>
              <li>zero or more EXTERNALBOOK Blocks<p/>
              	each consisting of
              	<ul>
              	<li>exactly one EXTERNALBOOK (0x01AE) record</li>
              	<li>zero or more EXTERNALNAME (0x0023) records</li>
              	<li>zero or more CRN Blocks<p/>
            			each consisting of
              		<ul>
              		<li>exactly one XCT (0x0059)record</li>
              		<li>zero or more CRN (0x005A) records (documentation says one or more)</li>
              		</ul>
              	</li>
              	</ul>
              </li>
              <li>zero or one EXTERNSHEET (0x0017) record</li>
              <li>zero or more DEFINEDNAME (0x0018) records</li>
              </ul>
            
            
             @author Josh Micich
        </member>
        <member name="M:NPOI.HSSF.Model.LinkTable.ExternalBookBlock.GetIndexOfName(System.String)">
            Performs case-insensitive search
            @return -1 if not found
        </member>
        <member name="P:NPOI.HSSF.Model.LinkTable.RecordCount">
            TODO - would not be required if calling code used RecordStream or similar
        </member>
        <member name="M:NPOI.HSSF.Model.LinkTable.GetIndexToInternalSheet(System.Int32)">
            @param extRefIndex as from a {@link Ref3DPtg} or {@link Area3DPtg}
            @return -1 if the reference is to an external book
        </member>
        <member name="M:NPOI.HSSF.Model.LinkTable.FindFirstRecordLocBySid(System.Int16)">
            copied from Workbook
        </member>
        <member name="T:NPOI.HSSF.Model.Model">
            enclosing_type describe the purpose here
            
            @author Andrew C. Oliver androliv@cisco.com
        </member>
        <member name="T:NPOI.HSSF.Model.ParseNode">
            Represents a syntactic element from a formula by encapsulating the corresponding <tt>Ptg</tt>
            token.  Each <tt>ParseNode</tt> may have child <tt>ParseNode</tt>s in the case when the wrapped
            <tt>Ptg</tt> is non-atomic.
            
            @author Josh Micich
        </member>
        <member name="M:NPOI.HSSF.Model.ParseNode.ToTokenArray(NPOI.HSSF.Model.ParseNode)">
            <summary>
            Collects the array of Ptg
             tokens for the specified tree.
            </summary>
            <param name="rootNode">The root node.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.Model.ParseNode.CollectIfPtgs(NPOI.HSSF.Model.ParseNode.TokenCollector)">
            <summary>
            The IF() function Gets marked up with two or three tAttr tokens.
            Similar logic will be required for CHOOSE() when it is supported
            See excelfileformat.pdf sec 3.10.5 "tAttr (19H)
            </summary>
            <param name="temp">The temp.</param>
        </member>
        <member name="T:NPOI.HSSF.Model.PictureShape">
            <summary>
            Represents a picture shape and Creates all specific low level records.
            @author Glen Stampoultzis (glens at apache.org)
            </summary>
        </member>
        <member name="M:NPOI.HSSF.Model.PictureShape.#ctor(NPOI.HSSF.UserModel.HSSFSimpleShape,System.Int32)">
            <summary>
            Creates the line shape from the highlevel user shape.  All low level
            records are Created at this point.
            </summary>
            <param name="hssfShape">The user model shape.</param>
            <param name="shapeId">The identifier to use for this shape.</param>
        </member>
        <member name="M:NPOI.HSSF.Model.PictureShape.CreateSpContainer(NPOI.HSSF.UserModel.HSSFSimpleShape,System.Int32)">
            <summary>
            Creates the lowerlevel escher records for this shape.
            </summary>
            <param name="hssfShape">The HSSF shape.</param>
            <param name="shapeId">The shape id.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.Model.PictureShape.CreateObjRecord(NPOI.HSSF.UserModel.HSSFShape,System.Int32)">
            <summary>
            Creates the low level OBJ record for this shape.
            </summary>
            <param name="hssfShape">The HSSFShape.</param>
            <param name="shapeId">The shape id.</param>
            <returns></returns>
        </member>
        <member name="P:NPOI.HSSF.Model.PictureShape.SpContainer">
            <summary>
            The shape container and it's children that can represent this
            shape.
            </summary>
            <value></value>
        </member>
        <member name="P:NPOI.HSSF.Model.PictureShape.ObjRecord">
            <summary>
            The object record that is associated with this shape.
            </summary>
            <value></value>
        </member>
        <member name="M:NPOI.HSSF.Model.PolygonShape.#ctor(NPOI.HSSF.UserModel.HSSFPolygon,System.Int32)">
            <summary>
            Creates the low evel records for an polygon.
            </summary>
            <param name="hssfShape">The highlevel shape.</param>
            <param name="shapeId">The shape id to use for this shape.</param>
        </member>
        <member name="M:NPOI.HSSF.Model.PolygonShape.CreateSpContainer(NPOI.HSSF.UserModel.HSSFPolygon,System.Int32)">
            <summary>
            Creates the lowerlevel escher records for this shape.
            </summary>
            <param name="hssfShape">The HSSF shape.</param>
            <param name="shapeId">The shape id.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.Model.PolygonShape.CreateObjRecord(NPOI.HSSF.UserModel.HSSFShape,System.Int32)">
            <summary>
            Creates the lowerlevel OBJ records for this shape.
            </summary>
            <param name="hssfShape">The HSSF shape.</param>
            <param name="shapeId">The shape id.</param>
            <returns></returns>
        </member>
        <member name="P:NPOI.HSSF.Model.PolygonShape.SpContainer">
            <summary>
            The shape container and it's children that can represent this
            shape.
            </summary>
            <value></value>
        </member>
        <member name="P:NPOI.HSSF.Model.PolygonShape.ObjRecord">
            <summary>
            The object record that is associated with this shape.
            </summary>
            <value></value>
        </member>
        <member name="T:NPOI.HSSF.Model.RecordOrderer">
            Finds correct insert positions for records in workbook streams<p/>
            
            See OOO excelfileformat.pdf sec. 4.2.5 'Record Order in a BIFF8 Workbook Stream'
            
            @author Josh Micich
        </member>
        <member name="M:NPOI.HSSF.Model.RecordOrderer.AddNewSheetRecord(System.Collections.Generic.List{NPOI.HSSF.Record.RecordBase},NPOI.HSSF.Record.RecordBase)">
            Adds the specified new record in the correct place in sheet records list
            
        </member>
        <member name="M:NPOI.HSSF.Model.RecordOrderer.FindInsertPosForNewCondFormatTable(System.Collections.Generic.List{NPOI.HSSF.Record.RecordBase})">
            Find correct position to add new CFHeader record
        </member>
        <member name="M:NPOI.HSSF.Model.RecordOrderer.FindDataValidationTableInsertPos(System.Collections.Generic.List{NPOI.HSSF.Record.RecordBase})">
            Finds the index where the sheet validations header record should be inserted
            @param records the records for this sheet
            
            + WINDOW2
            o SCL
            o PANE
            oo SELECTION
            o STANDARDWIDTH
            oo MERGEDCELLS
            o LABELRANGES
            o PHONETICPR
            o Conditional Formatting Table
            o Hyperlink Table
            o Data Validity Table
            o SHEETLAYOUT
            o SHEETPROTECTION
            o RANGEPROTECTION
            + EOF
        </member>
        <member name="M:NPOI.HSSF.Model.RecordOrderer.GetDimensionsIndex(System.Collections.Generic.List{NPOI.HSSF.Record.RecordBase})">
            DIMENSIONS record is always present
        </member>
        <member name="M:NPOI.HSSF.Model.RecordOrderer.IsEndOfRowBlock(System.Int32)">
            @return <c>true</c> if the specified record ID terminates a sequence of Row block records
            It is assumed that at least one row or cell value record has been found prior to the current 
            record
        </member>
        <member name="M:NPOI.HSSF.Model.RecordOrderer.IsRowBlockRecord(System.Int32)">
            @return <c>true</c> if the specified record id normally appears in the row blocks section 
            of the sheet records
        </member>
        <member name="T:NPOI.HSSF.Model.RecordStream">
            <summary>
            Simplifies iteration over a sequence of Record objects.
            @author Josh Micich
            </summary>
        </member>
        <member name="M:NPOI.HSSF.Model.RecordStream.HasNext">
            <summary>
            Determines whether this instance has next.
            </summary>
            <returns>
            	<c>true</c> if this instance has next; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NPOI.HSSF.Model.RecordStream.GetNext">
            <summary>
            Gets the next record
            </summary>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.Model.RecordStream.PeekNextSid">
            <summary>
            Peeks the next sid.
            </summary>
            <returns>-1 if at end of records</returns>
        </member>
        <member name="M:NPOI.HSSF.Model.RecordStream.PeekNextClass">
            <summary>
            Peeks the next class.
            </summary>
            <returns>the class of the next Record.return null if this stream Is exhausted.</returns>
        </member>
        <member name="T:NPOI.HSSF.Model.RowBlocksReader">
            Segregates the 'Row Blocks' section of a single sheet into plain row/cell records and 
            shared formula records.
            
            @author Josh Micich
        </member>
        <member name="M:NPOI.HSSF.Model.RowBlocksReader.#ctor(NPOI.HSSF.Model.RecordStream)">
            Also collects any loose MergeCellRecords and puts them in the supplied
            mergedCellsTable
        </member>
        <member name="P:NPOI.HSSF.Model.RowBlocksReader.LooseMergedCells">
            Some unconventional apps place {@link MergeCellsRecord}s within the row block.  They 
            actually should be in the {@link MergedCellsTable} which is much later (see bug 45699).
            @return any loose  <tt>MergeCellsRecord</tt>s found
        </member>
        <member name="P:NPOI.HSSF.Model.RowBlocksReader.PlainRecordStream">
            @return a {@link RecordStream} containing all the non-{@link SharedFormulaRecord} 
            non-{@link ArrayRecord} and non-{@link TableRecord} Records.
        </member>
        <member name="T:NPOI.HSSF.Model.Sheet">
            <summary>
            Low level model implementation of a Sheet (one workbook Contains many sheets)
            This file Contains the low level binary records starting at the sheets BOF and
            ending with the sheets EOF.  Use HSSFSheet for a high level representation.
            
            The structures of the highlevel API use references to this to perform most of their
            operations.  Its probably Unwise to use these low level structures directly Unless you
            really know what you're doing.  I recommend you Read the Microsoft Excel 97 Developer's
            Kit (Microsoft Press) and the documentation at http://sc.openoffice.org/excelfileformat.pdf
            before even attempting to use this.
            </summary>
            <remarks>
            @author  Andrew C. Oliver (acoliver at apache dot org)
            @author  Glen Stampoultzis (glens at apache.org)
            @author  Shawn Laubach (slaubach at apache dot org) Gridlines, Headers, Footers, PrintSetup, and Setting Default Column Styles
            @author Jason Height (jheight at chariot dot net dot au) Clone support. DBCell and Index Record writing support
            @author  Brian Sanders (kestrel at burdell dot org) Active Cell support
            @author  Jean-Pierre Paris (jean-pierre.paris at m4x dot org) (Just a little)
            </remarks>
        </member>
        <member name="F:NPOI.HSSF.Model.Sheet._mergedCellsTable">
            java object always present, but if empty no BIFF records are written 
        </member>
        <member name="F:NPOI.HSSF.Model.Sheet._dimensions">
            the DimensionsRecord is always present 
        </member>
        <member name="F:NPOI.HSSF.Model.Sheet._isUncalced">
            Add an UncalcedRecord if not true indicating formulas have not been calculated 
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.CloneSheet">
            <summary>
            Clones the low level records of this sheet and returns the new sheet instance.
            This method is implemented by Adding methods for deep cloning to all records that
            can be Added to a sheet. The Record object does not implement Cloneable.
            When Adding a new record, implement a public Clone method if and only if the record
            belongs to a sheet.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.GetValueRecords">
            <summary>
            get the NEXT value record (from LOC).  The first record that is a value record
            (starting at LOC) will be returned.
            This method is "loc" sensitive.  Meaning you need to set LOC to where you
            want it to start searching.  If you don't know do this: setLoc(getDimsLoc).
            When adding several rows you can just start at the last one by leaving loc
            at what this sets it to.  For this method, set loc to dimsloc to start with,
            subsequent calls will return values in (physical) sequence or NULL when you get to the end.
            </summary>
            <returns>the next value record or NULL if there are no more</returns>
            <see cref="!:SetLoc(int)"/>
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.CreateSheet(NPOI.HSSF.Model.RecordStream)">
            <summary>
            Creates the sheet.
            </summary>
            <param name="rs">The stream.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.#ctor(NPOI.HSSF.Model.RecordStream)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HSSF.Model.Sheet"/> class.
            </summary>
            <param name="rs">The stream.</param>
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.CreateSheet">
            <summary>
            Creates a sheet with all the usual records minus values and the "index"
            record (not required).  Sets the location pointer to where the first value
            records should go.  Use this to Create a sheet from "scratch".
            </summary>
            <returns>Sheet object with all values Set to defaults</returns>
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.AddMergedRegion(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Adds the merged region.
            </summary>
            <param name="rowFrom">the row index From </param>
            <param name="colFrom">The column index From.</param>
            <param name="rowTo">The row index To</param>
            <param name="colTo">The column To.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.RemoveMergedRegion(System.Int32)">
            <summary>
            Removes the merged region.
            </summary>
            <param name="index">The index.</param>
        </member>
        <member name="P:NPOI.HSSF.Model.Sheet.ColumnInfos">
            <summary>
            Gets the column infos.
            </summary>
            <value>The column infos.</value>
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.GetMergedRegionAt(System.Int32)">
            <summary>
            Gets the merged region at.
            </summary>
            <param name="index">The index.</param>
            <returns></returns>
        </member>
        <member name="P:NPOI.HSSF.Model.Sheet.NumMergedRegions">
            <summary>
            Gets the number of merged regions.
            </summary>
            <value>The number merged regions.</value>
        </member>
        <member name="P:NPOI.HSSF.Model.Sheet.NumConditionalFormattings">
            <summary>
            Gets the number of conditional formattings.
            </summary>
            <value>The number of conditional formattings.</value>
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.SetDimensions(System.Int32,System.Int16,System.Int32,System.Int16)">
            <summary>
            Per an earlier reported bug in working with Andy Khan's excel Read library.  This
            Sets the values in the sheet's DimensionsRecord object to be correct.  Excel doesn't
            really care, but we want to play nice with other libraries.
            </summary>
            <param name="firstrow">The first row.</param>
            <param name="firstcol">The first column.</param>
            <param name="lastrow">The last row.</param>
            <param name="lastcol">The last column.</param>
        </member>
        <member name="P:NPOI.HSSF.Model.Sheet.PreOffset">
            <summary>
            Gets or Sets the preoffset when using DBCELL records (currently Unused) - this Is
            the position of this sheet within the whole file.
            </summary>
            <value>the offset of the sheet's BOF within the file.</value>
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.CreateRow(System.Int32)">
            <summary>
            Create a row record.  (does not Add it to the records contained in this sheet)
            </summary>
            <param name="row">row number</param>
            <returns>RowRecord Created for the passed in row number</returns>
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.CreateLabelSST(System.Int32,System.Int16,System.Int32)">
            <summary>
            Create a LABELSST Record (does not Add it to the records contained in this sheet)
            </summary>
            <param name="row">the row the LabelSST Is a member of</param>
            <param name="col">the column the LabelSST defines</param>
            <param name="index">the index of the string within the SST (use workbook AddSSTString method)</param>
            <returns>LabelSSTRecord newly Created containing your SST Index, row,col.</returns>
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.CreateNumber(System.Int32,System.Int16,System.Double)">
            <summary>
            Create a NUMBER Record (does not Add it to the records contained in this sheet)
            </summary>
            <param name="row">the row the NumberRecord is a member of</param>
            <param name="col">the column the NumberRecord defines</param>
            <param name="value">value for the number record</param>
            <returns>NumberRecord for that row, col containing that value as Added to the sheet</returns>
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.CreateBlank(System.Int32,System.Int16)">
            <summary>
            Create a BLANK record (does not Add it to the records contained in this sheet)
            </summary>
            <param name="row">the row the BlankRecord is a member of</param>
            <param name="col">the column the BlankRecord is a member of</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.AddValueRecord(System.Int32,NPOI.HSSF.Record.CellValueRecordInterface)">
            <summary>
            Adds a value record to the sheet's contained binary records
            (i.e. LabelSSTRecord or NumberRecord).
            This method is "loc" sensitive.  Meaning you need to Set LOC to where you
            want it to start searching.  If you don't know do this: SetLoc(GetDimsLoc).
            When Adding several rows you can just start at the last one by leaving loc
            at what this Sets it to.
            </summary>
            <param name="row">the row to Add the cell value to</param>
            <param name="col">the cell value record itself.</param>
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.RemoveValueRecord(System.Int32,NPOI.HSSF.Record.CellValueRecordInterface)">
            <summary>
            Remove a value record from the records array.
            This method is not loc sensitive, it Resets loc to = dimsloc so no worries.
            </summary>
            <param name="row">the row of the value record you wish to Remove</param>
            <param name="col">a record supporting the CellValueRecordInterface.</param>
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.ReplaceValueRecord(NPOI.HSSF.Record.CellValueRecordInterface)">
            <summary>
            Replace a value record from the records array.
            This method is not loc sensitive, it Resets loc to = dimsloc so no worries.
            </summary>
            <param name="newval">a record supporting the CellValueRecordInterface.  this will Replace
            the cell value with the same row and column.  If there Isn't one, one will
            be Added.</param>
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.AddRow(NPOI.HSSF.Record.RowRecord)">
            <summary>
            Adds a row record to the sheet
            This method is "loc" sensitive.  Meaning you need to Set LOC to where you
            want it to start searching.  If you don't know do this: SetLoc(GetDimsLoc).
            When Adding several rows you can just start at the last one by leaving loc
            at what this Sets it to.
            </summary>
            <param name="row">the row record to be Added</param>
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.RemoveRow(NPOI.HSSF.Record.RowRecord)">
            <summary>
            Removes a row record
            This method is not loc sensitive, it Resets loc to = dimsloc so no worries.
            </summary>
            <param name="row">the row record to Remove</param>
        </member>
        <member name="P:NPOI.HSSF.Model.Sheet.NextRow">
            <summary>
            Get the NEXT RowRecord (from LOC).  The first record that is a Row record
            (starting at LOC) will be returned.
            This method is "loc" sensitive.  Meaning you need to Set LOC to where you
            want it to start searching.  If you don't know do this: SetLoc(GetDimsLoc).
            When Adding several rows you can just start at the last one by leaving loc
            at what this Sets it to.  For this method, Set loc to dimsloc to start with.
            subsequent calls will return rows in (physical) sequence or NULL when you Get to the end.
            </summary>
            <value>RowRecord representing the next row record or NULL if there are no more</value>
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.GetRow(System.Int32)">
            <summary>
            Get the NEXT (from LOC) RowRecord where rownumber matches the given rownum.
            The first record that is a Row record (starting at LOC) that has the
            same rownum as the given rownum will be returned.
            This method is "loc" sensitive.  Meaning you need to Set LOC to where you
            want it to start searching.  If you don't know do this: SetLoc(GetDimsLoc).
            When Adding several rows you can just start at the last one by leaving loc
            at what this Sets it to.  For this method, Set loc to dimsloc to start with.
            subsequent calls will return rows in (physical) sequence or NULL when you Get to the end.
            </summary>
            <param name="rownum">which row to return (careful with LOC)</param>
            <returns>RowRecord representing the next row record or NULL if there are no more</returns>
        </member>
        <member name="P:NPOI.HSSF.Model.Sheet.PageSettings">
            <summary>
            Gets the page settings.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.CreateBOF">
            <summary>
            Creates the BOF record
            </summary>
            <returns>record containing a BOFRecord</returns>
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.CreateIndex">
            <summary>
            Creates the Index record  - not currently used
            </summary>
            <returns>record containing a IndexRecord</returns>
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.CreateCalcMode">
            <summary>
            Creates the CalcMode record and Sets it to 1 (automatic formula caculation)
            </summary>
            <returns>record containing a CalcModeRecord</returns>
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.CreateCalcCount">
            <summary>
            Creates the CalcCount record and Sets it to 0x64 (default number of iterations)
            </summary>
            <returns>record containing a CalcCountRecord</returns>
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.CreateRefMode">
            <summary>
            Creates the RefMode record and Sets it to A1 Mode (default reference mode)
            </summary>
            <returns>record containing a RefModeRecord</returns>
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.CreateIteration">
            <summary>
            Creates the Iteration record and Sets it to false (don't iteratively calculate formulas)
            </summary>
            <returns>record containing a IterationRecord</returns>
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.CreateDelta">
            <summary>
            Creates the Delta record and Sets it to 0.0010 (default accuracy)
            </summary>
            <returns>record containing a DeltaRecord</returns>
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.CreateSaveRecalc">
            <summary>
            Creates the SaveRecalc record and Sets it to true (recalculate before saving)
            </summary>
            <returns>record containing a SaveRecalcRecord</returns>
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.CreatePrintHeaders">
            <summary>
            Creates the PrintHeaders record and Sets it to false (we don't Create headers yet so why print them)
            </summary>
            <returns>record containing a PrintHeadersRecord</returns>
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.CreatePrintGridlines">
            <summary>
            Creates the PrintGridlines record and Sets it to false (that makes for ugly sheets).  As far as I can
            tell this does the same thing as the GridsetRecord
            </summary>
            <returns>record containing a PrintGridlinesRecord</returns>
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.CreateGridset">
            <summary>
            Creates the GridSet record and Sets it to true (user has mucked with the gridlines)
            </summary>
            <returns>record containing a GridsetRecord</returns>
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.CreateGuts">
            <summary>
            Creates the Guts record and Sets leftrow/topcol guttter and rowlevelmax/collevelmax to 0
            </summary>
            <returns>record containing a GutsRecordRecord</returns>
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.CreateDefaultRowHeight">
            <summary>
            Creates the DefaultRowHeight Record and Sets its options to 0 and rowheight to 0xff
            </summary>
            <see cref="T:NPOI.HSSF.Record.DefaultRowHeightRecord"/>
            <see cref="T:NPOI.HSSF.Record.Record"/>
            <returns>record containing a DefaultRowHeightRecord</returns>
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.CreateWSBool">
            Creates the WSBoolRecord and Sets its values to defaults
            @see org.apache.poi.hssf.record.WSBoolRecord
            @see org.apache.poi.hssf.record.Record
            @return record containing a WSBoolRecord
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.CreateHeader">
            Creates the Header Record and Sets it to nothing/0 Length
            @see org.apache.poi.hssf.record.HeaderRecord
            @see org.apache.poi.hssf.record.Record
            @return record containing a HeaderRecord
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.CreateFooter">
            Creates the Footer Record and Sets it to nothing/0 Length
            @see org.apache.poi.hssf.record.FooterRecord
            @see org.apache.poi.hssf.record.Record
            @return record containing a FooterRecord
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.CreateHCenter">
            Creates the HCenter Record and Sets it to false (don't horizontally center)
            @see org.apache.poi.hssf.record.HCenterRecord
            @see org.apache.poi.hssf.record.Record
            @return record containing a HCenterRecord
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.CreateVCenter">
            Creates the VCenter Record and Sets it to false (don't horizontally center)
            @see org.apache.poi.hssf.record.VCenterRecord
            @see org.apache.poi.hssf.record.Record
            @return record containing a VCenterRecord
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.CreatePrintSetup">
            Creates the PrintSetup Record and Sets it to defaults and marks it invalid
            @see org.apache.poi.hssf.record.PrintSetupRecord
            @see org.apache.poi.hssf.record.Record
            @return record containing a PrintSetupRecord
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.CreateDefaultColWidth">
            Creates the DefaultColWidth Record and Sets it to 8
            @see org.apache.poi.hssf.record.DefaultColWidthRecord
            @see org.apache.poi.hssf.record.Record
            @return record containing a DefaultColWidthRecord
        </member>
        <member name="P:NPOI.HSSF.Model.Sheet.DefaultColumnWidth">
            Get the default column width for the sheet (if the columns do not define their own width)
            @return default column width
        </member>
        <member name="P:NPOI.HSSF.Model.Sheet.DefaultRowHeight">
            Get the default row height for the sheet (if the rows do not define their own height)
            @return  default row height
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.GetColumnWidth(System.Int32)">
            Get the width of a given column in Units of 1/256th of a Char width
            @param column index
            @see org.apache.poi.hssf.record.DefaultColWidthRecord
            @see org.apache.poi.hssf.record.ColumnInfoRecord
            @see #SetColumnWidth(short,short)
            @return column width in Units of 1/256th of a Char width
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.GetXFIndexForColAt(System.Int16)">
            Get the index to the ExtendedFormatRecord "associated" with
            the column at specified 0-based index. (In this case, an
            ExtendedFormatRecord index is actually associated with a
            ColumnInfoRecord which spans 1 or more columns)
            <br/>
            Returns the index to the default ExtendedFormatRecord (0xF)
            if no ColumnInfoRecord exists that includes the column
            index specified.
            @param column
            @return index of ExtendedFormatRecord associated with
            ColumnInfoRecord that includes the column index or the
            index of the default ExtendedFormatRecord (0xF)
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.SetColumnWidth(System.Int32,System.Int32)">
            Set the width for a given column in 1/256th of a Char width Units
            @param column - the column number
            @param width (in Units of 1/256th of a Char width)
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.IsColumnHidden(System.Int32)">
            Get the hidden property for a given column.
            @param column index
            @see org.apache.poi.hssf.record.DefaultColWidthRecord
            @see org.apache.poi.hssf.record.ColumnInfoRecord
            @see #SetColumnHidden(short,bool)
            @return whether the column is hidden or not.
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.SetColumnHidden(System.Int32,System.Boolean)">
            Get the hidden property for a given column.
            @param column - the column number
            @param hidden - whether the column is hidden or not
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.GroupColumnRange(System.Int32,System.Int32,System.Boolean)">
            Creates an outline Group for the specified columns.
            @param fromColumn    Group from this column (inclusive)
            @param toColumn      Group to this column (inclusive)
            @param indent        if true the Group will be indented by one level,
                                 if false indenting will be Removed by one level.
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.CreateDimensions">
            Creates the Dimensions Record and Sets it to bogus values (you should Set this yourself
            or let the high level API do it for you)
            @see org.apache.poi.hssf.record.DimensionsRecord
            @see org.apache.poi.hssf.record.Record
            @return record containing a DimensionsRecord
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.CreateWindowTwo">
            Creates the WindowTwo Record and Sets it to:  
            options        = 0x6b6 
            toprow         = 0 
            leftcol        = 0 
            headercolor    = 0x40 
            pagebreakzoom  = 0x0 
            normalzoom     = 0x0 
            @see org.apache.poi.hssf.record.WindowTwoRecord
            @see org.apache.poi.hssf.record.Record
            @return record containing a WindowTwoRecord
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.CreateSelection">
            <summary>
            Creates the Selection record and Sets it to nothing selected
            </summary>
            <returns>record containing a SelectionRecord</returns>
        </member>
        <member name="P:NPOI.HSSF.Model.Sheet.TopRow">
            <summary>
            Gets or sets the top row.
            </summary>
            <value>The top row.</value>
        </member>
        <member name="P:NPOI.HSSF.Model.Sheet.LeftCol">
            <summary>
            Gets or sets the left col.
            </summary>
            <value>The left col.</value>
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.SetActiveCell(System.Int32,System.Int32)">
            <summary>
            Sets the active cell.
            </summary>
            <param name="row">The row.</param>
            <param name="column">The column.</param>
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.SetActiveCellRange(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Sets the active cell range.
            </summary>
            <param name="firstrow">The firstrow.</param>
            <param name="lastrow">The lastrow.</param>
            <param name="firstcolumn">The firstcolumn.</param>
            <param name="lastcolumn">The lastcolumn.</param>
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.SetActiveCellRange(System.Collections.Generic.List{NPOI.SS.Util.CellRangeAddress8Bit},System.Int32,System.Int32,System.Int32)">
            <summary>
            Sets the active cell range.
            </summary>
            <param name="cellranges">The cellranges.</param>
            <param name="activeRange">The index of the active range.</param>
            <param name="activeRow">The active row in the active range</param>
            <param name="activeColumn">The active column in the active range</param>
        </member>
        <member name="P:NPOI.HSSF.Model.Sheet.ActiveCellRow">
            <summary>
            Returns the active row
            </summary>
            <value>the active row index</value>
            @see org.apache.poi.hssf.record.SelectionRecord
        </member>
        <member name="P:NPOI.HSSF.Model.Sheet.ActiveCellCol">
            <summary>
            Gets or sets the active cell col.
            </summary>
            <value>the active column index</value>
            @see org.apache.poi.hssf.record.SelectionRecord
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.CreateEOF">
            <summary>
            Creates the EOF record
            </summary>
            <returns>record containing a EOFRecord</returns>
        </member>
        <member name="P:NPOI.HSSF.Model.Sheet.GridsetRecord">
            <summary>
            Gets the gridset record for this sheet.
            </summary>
            <value>The gridset record.</value>
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.FindFirstRecordBySid(System.Int16)">
            <summary>
            Returns the first occurance of a record matching a particular sid.
            </summary>
            <param name="sid">The sid.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.SetSCLRecord(NPOI.HSSF.Record.SCLRecord)">
            <summary>
            Sets the SCL record or Creates it in the correct place if it does not
            already exist.
            </summary>
            <param name="sclRecord">The record to set.</param>
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.FindFirstRecordLocBySid(System.Int16)">
            Finds the first occurance of a record matching a particular sid and
            returns it's position.
            @param sid   the sid to search for
            @return  the record position of the matching record or -1 if no match
                     is made.
        </member>
        <member name="P:NPOI.HSSF.Model.Sheet.Header">
            <summary>
            Gets or sets the header.
            </summary>
            <value>the HeaderRecord.</value>
        </member>
        <member name="P:NPOI.HSSF.Model.Sheet.IsAutoTabColor">
            <summary>
            Gets or sets a value indicating whether this instance is auto tab color.
            </summary>
            <value>
            	<c>true</c> if this instance is auto tab color; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:NPOI.HSSF.Model.Sheet.Footer">
            <summary>
            Gets or sets the footer.
            </summary>
            <value>FooterRecord for the sheet.</value>
        </member>
        <member name="P:NPOI.HSSF.Model.Sheet.PrintSetup">
            Returns the PrintSetupRecord.
            @return PrintSetupRecord for the sheet.
        </member>
        <member name="P:NPOI.HSSF.Model.Sheet.IsGridsPrinted">
            @return <code>true</code> if gridlines are printed
        </member>
        <member name="P:NPOI.HSSF.Model.Sheet.PrintGridlines">
            Returns the PrintGridlinesRecord.
            @return PrintGridlinesRecord for the sheet.
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.SetSelected(System.Boolean)">
            Sets whether the sheet is selected
            @param sel True to select the sheet, false otherwise.
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.CreateFreezePane(System.Int32,System.Int32,System.Int32,System.Int32)">
            Creates a split (freezepane). Any existing freezepane or split pane Is overwritten.
            @param colSplit      Horizonatal position of split.
            @param rowSplit      Vertical position of split.
            @param topRow        Top row visible in bottom pane
            @param leftmostColumn   Left column visible in right pane.
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.CreateSplitPane(System.Int32,System.Int32,System.Int32,System.Int32,NPOI.SS.UserModel.PanePosition)">
            Creates a split pane. Any existing freezepane or split pane is overwritten.
            @param xSplitPos      Horizonatal position of split (in 1/20th of a point).
            @param ySplitPos      Vertical position of split (in 1/20th of a point).
            @param topRow        Top row visible in bottom pane
            @param leftmostColumn   Left column visible in right pane.
            @param activePane    Active pane.  One of: PANE_LOWER_RIGHT,
                                 PANE_UPPER_RIGHT, PANE_LOWER_LEFT, PANE_UPPER_LEFT
            @see #PANE_LOWER_LEFT
            @see #PANE_LOWER_RIGHT
            @see #PANE_UPPER_LEFT
            @see #PANE_UPPER_RIGHT
        </member>
        <member name="P:NPOI.HSSF.Model.Sheet.PaneInformation">
            Returns the information regarding the currently configured pane (split or freeze).
            @return null if no pane configured, or the pane information.
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.CreateProtect">
            Creates a Protect record with protect Set to false.
            @see org.apache.poi.hssf.record.ProtectRecord
            @see org.apache.poi.hssf.record.Record
            @return a ProtectRecord
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.CreateObjectProtect">
            Creates an ObjectProtect record with protect Set to false.
            @see org.apache.poi.hssf.record.ObjectProtectRecord
            @see org.apache.poi.hssf.record.Record
            @return an ObjectProtectRecord
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.CreateScenarioProtect">
            Creates a ScenarioProtect record with protect Set to false.
            @see org.apache.poi.hssf.record.ScenarioProtectRecord
            @see org.apache.poi.hssf.record.Record
            @return a ScenarioProtectRecord
        </member>
        <member name="P:NPOI.HSSF.Model.Sheet.Protect">
            Returns the ProtectRecord.
            If one is not contained in the sheet, then one is Created.
        </member>
        <member name="P:NPOI.HSSF.Model.Sheet.Password">
            Returns the PasswordRecord.
            If one is not contained in the sheet, then one is Created.
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.CreatePassword">
            Creates a Password record with password Set to 00.
            @see org.apache.poi.hssf.record.PasswordRecord
            @see org.apache.poi.hssf.record.Record
            @return a PasswordRecord
        </member>
        <member name="P:NPOI.HSSF.Model.Sheet.DisplayGridlines">
            Returns if gridlines are Displayed.
            @return whether gridlines are Displayed
        </member>
        <member name="P:NPOI.HSSF.Model.Sheet.DisplayFormulas">
            Returns if formulas are Displayed.
            @return whether formulas are Displayed
        </member>
        <member name="P:NPOI.HSSF.Model.Sheet.DisplayRowColHeadings">
            Returns if RowColHeadings are Displayed.
            @return whether RowColHeadings are Displayed
        </member>
        <member name="P:NPOI.HSSF.Model.Sheet.IsUncalced">
            @return whether an Uncalced record must be Inserted or not at generation
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.AggregateDrawingRecords(NPOI.HSSF.Model.DrawingManager2,System.Boolean)">
            Finds the DrawingRecord for our sheet, and
             attaches it to the DrawingManager (which knows about
             the overall DrawingGroup for our workbook).
            If requested, will Create a new DrawRecord
             if none currently exist
            @param drawingManager The DrawingManager2 for our workbook
            @param CreateIfMissing Should one be Created if missing?
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.Preserialize">
            Perform any work necessary before the sheet is about to be Serialized.
            For instance the escher aggregates size needs to be calculated before
            serialization so that the dgg record (which occurs first) can be written.
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.ShiftBreaks(NPOI.HSSF.Record.PageBreakRecord,System.Int16,System.Int16,System.Int32)">
            Shifts all the page breaks in the range "count" number of rows/columns
            @param breaks The page record to be Shifted
            @param start Starting "main" value to Shift breaks
            @param stop Ending "main" value to Shift breaks
            @param count number of Units (rows/columns) to Shift by
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.ShiftRowBreaks(System.Int32,System.Int32,System.Int32)">
            Shifts the horizontal page breaks for the indicated count
            @param startingRow
            @param endingRow
            @param count
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.ShiftColumnBreaks(System.Int16,System.Int16,System.Int16)">
            Shifts the vertical page breaks for the indicated count
            @param startingCol
            @param endingCol
            @param count
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.ProtectSheet(System.String,System.Boolean,System.Boolean)">
            protect a spReadsheet with a password (not encypted, just Sets protect
            flags and the password.
            @param password to Set
            @param objects are protected
            @param scenarios are protected
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.UpdateFormulasAfterCellShift(NPOI.HSSF.Record.Formula.FormulaShifter,System.Int32)">
            Updates formulas in cells and conditional formats due to moving of cells
            @param externSheetIndex the externSheet index of this sheet
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.UnprotectSheet(System.Boolean,System.Boolean,System.Boolean)">
            Unprotect objects in the sheet (will not protect them, but any Set to false are
            Unprotected.
            @param sheet is Unprotected (false = Unprotect)
            @param objects are Unprotected (false = Unprotect)
            @param scenarios are Unprotected (false = Unprotect)
        </member>
        <member name="P:NPOI.HSSF.Model.Sheet.IsProtected">
            @return {sheet is protected, objects are proteced, scenarios are protected}
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.GetSizeOfInitialSheetRecords(System.Int32)">
            'initial sheet records' are between INDEX and the 'Row Blocks'
            @param bofRecordIndex index of record after which INDEX record is to be placed
            @return count of bytes from end of INDEX record to first ROW record.
        </member>
        <member name="M:NPOI.HSSF.Model.Sheet.GetNoteRecords">
            Get the {@link NoteRecord}s (related to cell comments) for this sheet
            @return never <code>null</code>, typically empty array
        </member>
        <member name="M:NPOI.HSSF.Model.SimpleFilledShape.#ctor(NPOI.HSSF.UserModel.HSSFSimpleShape,System.Int32)">
            <summary>
            Creates the low evel records for an oval.
            </summary>
            <param name="hssfShape">The highlevel shape.</param>
            <param name="shapeId">The shape id to use for this shape.</param>
        </member>
        <member name="M:NPOI.HSSF.Model.SimpleFilledShape.CreateSpContainer(NPOI.HSSF.UserModel.HSSFSimpleShape,System.Int32)">
            <summary>
            Creates the lowerlevel escher records for this shape.
            </summary>
            <param name="hssfShape">The HSSF shape.</param>
            <param name="shapeId">The shape id.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.Model.SimpleFilledShape.CreateObjRecord(NPOI.HSSF.UserModel.HSSFShape,System.Int32)">
            <summary>
            Creates the lowerlevel OBJ records for this shape.
            </summary>
            <param name="hssfShape">The HSSF shape.</param>
            <param name="shapeId">The shape id.</param>
            <returns></returns>
        </member>
        <member name="P:NPOI.HSSF.Model.SimpleFilledShape.SpContainer">
            <summary>
            The shape container and it's children that can represent this
            shape.
            </summary>
            <value></value>
        </member>
        <member name="P:NPOI.HSSF.Model.SimpleFilledShape.ObjRecord">
            <summary>
            The object record that is associated with this shape.
            </summary>
            <value></value>
        </member>
        <member name="T:NPOI.HSSF.Model.TextboxShape">
            <summary>
            Represents an textbox shape and Converts between the highlevel records
            and lowlevel records for an oval.
            @author Glen Stampoultzis (glens at apache.org)
            </summary>
        </member>
        <member name="M:NPOI.HSSF.Model.TextboxShape.#ctor(NPOI.HSSF.UserModel.HSSFTextbox,System.Int32)">
            <summary>
            Creates the low evel records for a textbox.
            </summary>
            <param name="hssfShape">The highlevel shape.</param>
            <param name="shapeId">The shape id to use for this shape.</param>
        </member>
        <member name="M:NPOI.HSSF.Model.TextboxShape.CreateObjRecord(NPOI.HSSF.UserModel.HSSFTextbox,System.Int32)">
            <summary>
            Creates the lowerlevel OBJ records for this shape.
            </summary>
            <param name="hssfShape">The HSSF shape.</param>
            <param name="shapeId">The shape id.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.Model.TextboxShape.CreateSpContainer(NPOI.HSSF.UserModel.HSSFTextbox,System.Int32)">
            <summary>
            Creates the lowerlevel escher records for this shape.
            </summary>
            <param name="hssfShape">The HSSF shape.</param>
            <param name="shapeId">The shape id.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.Model.TextboxShape.CreateTextObjectRecord(NPOI.HSSF.UserModel.HSSFTextbox,System.Int32)">
            <summary>
            Textboxes also have an extra TXO record associated with them that most
            other shapes dont have.
            </summary>
            <param name="hssfShape">The HSSF shape.</param>
            <param name="shapeId">The shape id.</param>
            <returns></returns>
        </member>
        <member name="P:NPOI.HSSF.Model.TextboxShape.SpContainer">
            <summary>
            The shape container and it's children that can represent this
            shape.
            </summary>
            <value></value>
        </member>
        <member name="P:NPOI.HSSF.Model.TextboxShape.ObjRecord">
            <summary>
            The object record that is associated with this shape.
            </summary>
            <value></value>
        </member>
        <member name="P:NPOI.HSSF.Model.TextboxShape.TextObjectRecord">
            <summary>
            The TextObject record that is associated with this shape.
            </summary>
            <value></value>
        </member>
        <member name="P:NPOI.HSSF.Model.TextboxShape.EscherTextbox">
            <summary>
            Gets the EscherTextbox record.
            </summary>
            <value>The EscherTextbox record.</value>
        </member>
        <member name="T:NPOI.HSSF.Model.Workbook">
             Low level model implementation of a Workbook.  Provides creational methods
             for Settings and objects contained in the workbook object.
             
             This file Contains the low level binary records starting at the workbook's BOF and
             ending with the workbook's EOF.  Use HSSFWorkbook for a high level representation.
             
             The structures of the highlevel API use references to this to perform most of their
             operations.  Its probably Unwise to use these low level structures directly Unless you
             really know what you're doing.  I recommend you Read the Microsoft Excel 97 Developer's
             Kit (Microsoft Press) and the documentation at http://sc.openoffice.org/excelfileformat.pdf
             before even attempting to use this.
            
            
             @author  Luc Girardin (luc dot girardin at macrofocus dot com)
             @author  Sergei Kozello (sergeikozello at mail.ru)
             @author  Shawn Laubach (slaubach at apache dot org) (Data Formats)
             @author  Andrew C. Oliver (acoliver at apache dot org)
             @author  Brian Sanders (bsanders at risklabs dot com) - custom palette
             @author  Dan Sherman (dsherman at Isisph.com)
             @author  Glen Stampoultzis (glens at apache.org)
             @see org.apache.poi.hssf.usermodel.HSSFWorkbook
             @version 1.0-pre
        </member>
        <member name="F:NPOI.HSSF.Model.Workbook.MAX_SENSITIVE_SHEET_NAME_LEN">
            Excel silently truncates long sheet names to 31 chars.
            This constant is used to ensure uniqueness in the first 31 chars
        </member>
        <member name="F:NPOI.HSSF.Model.Workbook.CODEPAGE">
            constant used to Set the "codepage" wherever "codepage" is Set in records
            (which is duplciated in more than one record)
        </member>
        <member name="F:NPOI.HSSF.Model.Workbook.records">
            this Contains the Worksheet record objects
        </member>
        <member name="F:NPOI.HSSF.Model.Workbook.sst">
            this Contains a reference to the SSTRecord so that new stings can be Added
            to it.
        </member>
        <member name="F:NPOI.HSSF.Model.Workbook.boundsheets">
            holds the "boundsheet" records (aka bundlesheet) so that they can have their
            reference to their "BOF" marker
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.#ctor">
            Creates new Workbook with no intitialization --useless right now
            @see #CreateWorkbook(List)
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.CreateWorkbook(System.Collections.Generic.List{NPOI.HSSF.Record.Record})">
             Read support  for low level
             API.  Pass in an array of Record objects, A Workbook
             object is constructed and passed back with all of its initialization Set
             to the passed in records and references to those records held. Unlike Sheet
             workbook does not use an offset (its assumed to be 0) since its first in a file.
             If you need an offset then construct a new array with a 0 offset or Write your
             own ;-p.
            
             @param recs an array of Record objects
             @return Workbook object
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.CreateWorkbook">
            Creates an empty workbook object with three blank sheets and all the empty
            fields.  Use this to Create a workbook from scratch.
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.GetSpecificBuiltinRecord(System.Byte,System.Int32)">
            Retrieves the Builtin NameRecord that matches the name and index
            There shouldn't be too many names to make the sequential search too slow
            @param name byte representation of the builtin name to match
            @param sheetIndex Index to match
            @return null if no builtin NameRecord matches
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.RemoveBuiltinRecord(System.Byte,System.Int32)">
            Removes the specified Builtin NameRecord that matches the name and index
            @param name byte representation of the builtin to match
            @param sheetIndex zero-based sheet reference
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.GetFontRecordAt(System.Int32)">
             Gets the font record at the given index in the font table.  Remember
             "There is No Four" (someone at M$ must have gone to Rocky Horror one too
             many times)
            
             @param idx the index to look at (0 or greater but NOT 4)
             @return FontRecord located at the given index
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.CreateNewFont">
             Creates a new font record and Adds it to the "font table".  This causes the
             boundsheets to move down one, extended formats to move down (so this function moves
             those pointers as well)
            
             @return FontRecord that was just Created
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.CloneDrawings(NPOI.HSSF.Model.Sheet)">
             Check if the cloned sheet has drawings. If yes, then allocate a new drawing group ID and
             re-generate shape IDs
            
             @param sheet the cloned sheet
        </member>
        <member name="P:NPOI.HSSF.Model.Workbook.NumberOfFontRecords">
             Gets the number of font records
            
             @return   number of font records in the "font table"
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.SetSheetBof(System.Int32,System.Int32)">
             Sets the BOF for a given sheet
            
             @param sheetnum the number of the sheet to Set the positing of the bof for
             @param pos the actual bof position
        </member>
        <member name="P:NPOI.HSSF.Model.Workbook.BackupRecord">
            Returns the position of the backup record.
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.SetSheetName(System.Int32,System.String)">
             Sets the name for a given sheet.  If the boundsheet record doesn't exist and
             its only one more than we have, go ahead and Create it.  If its > 1 more than
             we have, except
            
             @param sheetnum the sheet number (0 based)
             @param sheetname the name for the sheet
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.ContainsSheetName(System.String,System.Int32)">
             Determines whether a workbook Contains the provided sheet name.
            
             @param name the name to test (case insensitive match)
             @param excludeSheetIdx the sheet to exclude from the Check or -1 to include all sheets in the Check.
             @return true if the sheet Contains the name, false otherwise.
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.SetSheetName(System.Int32,System.String,System.Int16)">
             Sets the name for a given sheet forcing the encoding. This is STILL A BAD IDEA.
             Poi now automatically detects Unicode
            
            @deprecated 3-Jan-06 Simply use SetSheetNam e(int sheetnum, String sheetname)
             @param sheetnum the sheet number (0 based)
             @param sheetname the name for the sheet
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.SetSheetOrder(System.String,System.Int32)">
             Sets the order of appearance for a given sheet.
            
             @param sheetname the name of the sheet to reorder
             @param pos the position that we want to Insert the sheet into (0 based)
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.GetSheetName(System.Int32)">
             Gets the name for a given sheet.
            
             @param sheetnum the sheet number (0 based)
             @return sheetname the name for the sheet
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.IsSheetHidden(System.Int32)">
             Gets the hidden flag for a given sheet.
            
             @param sheetnum the sheet number (0 based)
             @return True if sheet is hidden
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.IsSheetVeryHidden(System.Int32)">
             Gets the hidden flag for a given sheet.
             Note that a sheet could instead be 
              set to be very hidden, which is different
              ({@link #isSheetVeryHidden(int)})
            
             @param sheetnum the sheet number (0 based)
             @return True if sheet is hidden
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.SetSheetHidden(System.Int32,System.Boolean)">
            Hide or Unhide a sheet
            
            @param sheetnum The sheet number
            @param hidden True to mark the sheet as hidden, false otherwise
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.SetSheetHidden(System.Int32,System.Int32)">
            Hide or unhide a sheet.
             0 = not hidden
             1 = hidden
             2 = very hidden.
            
            @param sheetnum The sheet number
            @param hidden 0 for not hidden, 1 for hidden, 2 for very hidden
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.GetSheetIndex(System.String)">
            Get the sheet's index
            @param name  sheet name
            @return sheet index or -1 if it was not found.
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.CheckSheets(System.Int32)">
            if we're trying to Address one more sheet than we have, go ahead and Add it!  if we're
            trying to Address >1 more than we have throw an exception!
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.FixTabIdRecord">
             make the tabid record look like the current situation.
            
        </member>
        <member name="P:NPOI.HSSF.Model.Workbook.NumSheets">
             returns the number of boundsheet objects contained in this workbook.
            
             @return number of BoundSheet records
        </member>
        <member name="P:NPOI.HSSF.Model.Workbook.NumExFormats">
             Get the number of ExtendedFormat records contained in this workbook.
            
             @return int count of ExtendedFormat records
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.GetFontIndex(NPOI.HSSF.Record.FontRecord)">
            Retrieves the index of the given font
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.GetStyleRecord(System.Int32)">
            Returns the StyleRecord for the given
             xfIndex, or null if that ExtendedFormat doesn't
             have a Style set.
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.GetExFormatAt(System.Int32)">
             Gets the ExtendedFormatRecord at the given 0-based index
            
             @param index of the Extended format record (0-based)
             @return ExtendedFormatRecord at the given index
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.CreateCellXF">
             Creates a new Cell-type Extneded Format Record and Adds it to the end of
              ExtendedFormatRecords collection
            
             @return ExtendedFormatRecord that was Created
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.AddSSTString(NPOI.HSSF.Record.UnicodeString)">
             Adds a string to the SST table and returns its index (if its a duplicate
             just returns its index and update the counts) ASSUMES compressed Unicode
             (meaning 8bit)
            
             @param string the string to be Added to the SSTRecord
            
             @return index of the string within the SSTRecord
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.GetSSTString(System.Int32)">
            given an index into the SST table, this function returns the corresponding String value
            @return String containing the SST String
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.InsertSST">
            use this function to Add a Shared String Table to an existing sheet (say
            generated by a different java api) without an sst....
            @see #CreateSST()
            @see org.apache.poi.hssf.record.SSTRecord
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.Serialize(System.Int32,System.Byte[])">
            Serializes all records int the worksheet section into a big byte array. Use
            this to Write the Workbook out.
            @param offset of the data to be written
            @param data array of bytes to Write this to
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.CreateBOF">
            Creates the BOF record
            @see org.apache.poi.hssf.record.BOFRecord
            @see org.apache.poi.hssf.record.Record
            @return record containing a BOFRecord
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.CreateInterfaceHdr">
            Creates the InterfaceHdr record
            @see org.apache.poi.hssf.record.InterfaceHdrRecord
            @see org.apache.poi.hssf.record.Record
            @return record containing a InterfaceHdrRecord
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.CreateMMS">
            Creates an MMS record
            @see org.apache.poi.hssf.record.MMSRecord
            @see org.apache.poi.hssf.record.Record
            @return record containing a MMSRecord
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.CreateInterfaceEnd">
            Creates the InterfaceEnd record
            @see org.apache.poi.hssf.record.InterfaceEndRecord
            @see org.apache.poi.hssf.record.Record
            @return record containing a InterfaceEndRecord
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.CreateWriteAccess">
            Creates the WriteAccess record containing the logged in user's name
            @see org.apache.poi.hssf.record.WriteAccessRecord
            @see org.apache.poi.hssf.record.Record
            @return record containing a WriteAccessRecord
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.CreateCodepage">
            Creates the Codepage record containing the constant stored in CODEPAGE
            @see org.apache.poi.hssf.record.CodepageRecord
            @see org.apache.poi.hssf.record.Record
            @return record containing a CodepageRecord
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.CreateDSF">
            Creates the DSF record containing a 0 since HSSF can't even Create Dual Stream Files
            @see org.apache.poi.hssf.record.DSFRecord
            @see org.apache.poi.hssf.record.Record
            @return record containing a DSFRecord
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.CreateTabId">
            Creates the TabId record containing an array of 0,1,2.  This release of HSSF
            always has the default three sheets, no less, no more.
            @see org.apache.poi.hssf.record.TabIdRecord
            @see org.apache.poi.hssf.record.Record
            @return record containing a TabIdRecord
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.CreateFnGroupCount">
            Creates the FnGroupCount record containing the Magic number constant of 14.
            @see org.apache.poi.hssf.record.FnGroupCountRecord
            @see org.apache.poi.hssf.record.Record
            @return record containing a FnGroupCountRecord
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.CreateWindowProtect">
            Creates the WindowProtect record with protect Set to false.
            @see org.apache.poi.hssf.record.WindowProtectRecord
            @see org.apache.poi.hssf.record.Record
            @return record containing a WindowProtectRecord
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.CreateProtect">
            Creates the Protect record with protect Set to false.
            @see org.apache.poi.hssf.record.ProtectRecord
            @see org.apache.poi.hssf.record.Record
            @return record containing a ProtectRecord
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.CreatePassword">
            Creates the Password record with password Set to 0.
            @see org.apache.poi.hssf.record.PasswordRecord
            @see org.apache.poi.hssf.record.Record
            @return record containing a PasswordRecord
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.CreateProtectionRev4">
            Creates the ProtectionRev4 record with protect Set to false.
            @see org.apache.poi.hssf.record.ProtectionRev4Record
            @see org.apache.poi.hssf.record.Record
            @return record containing a ProtectionRev4Record
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.CreatePasswordRev4">
            Creates the PasswordRev4 record with password Set to 0.
            @see org.apache.poi.hssf.record.PasswordRev4Record
            @see org.apache.poi.hssf.record.Record
            @return record containing a PasswordRev4Record
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.CreateWindowOne">
            Creates the WindowOne record with the following magic values: 
            horizontal hold - 0x168 
            vertical hold   - 0x10e 
            width           - 0x3a5c 
            height          - 0x23be 
            options         - 0x38 
            selected tab    - 0 
            Displayed tab   - 0 
            num selected tab- 0 
            tab width ratio - 0x258 
            @see org.apache.poi.hssf.record.WindowOneRecord
            @see org.apache.poi.hssf.record.Record
            @return record containing a WindowOneRecord
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.CreateBackup">
            Creates the Backup record with backup Set to 0. (loose the data, who cares)
            @see org.apache.poi.hssf.record.BackupRecord
            @see org.apache.poi.hssf.record.Record
            @return record containing a BackupRecord
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.CreateHideObj">
            Creates the HideObj record with hide object Set to 0. (don't hide)
            @see org.apache.poi.hssf.record.HideObjRecord
            @see org.apache.poi.hssf.record.Record
            @return record containing a HideObjRecord
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.CreateDateWindow1904">
            Creates the DateWindow1904 record with windowing Set to 0. (don't window)
            @see org.apache.poi.hssf.record.DateWindow1904Record
            @see org.apache.poi.hssf.record.Record
            @return record containing a DateWindow1904Record
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.CreatePrecision">
            Creates the Precision record with precision Set to true. (full precision)
            @see org.apache.poi.hssf.record.PrecisionRecord
            @see org.apache.poi.hssf.record.Record
            @return record containing a PrecisionRecord
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.CreateRefreshAll">
            Creates the RefreshAll record with refreshAll Set to true. (refresh all calcs)
            @see org.apache.poi.hssf.record.RefreshAllRecord
            @see org.apache.poi.hssf.record.Record
            @return record containing a RefreshAllRecord
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.CreateBookBool">
            Creates the BookBool record with saveLinkValues Set to 0. (don't save link values)
            @see org.apache.poi.hssf.record.BookBoolRecord
            @see org.apache.poi.hssf.record.Record
            @return record containing a BookBoolRecord
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.CreateFont">
             Creates a Font record with the following magic values: 
             fontheight           = 0xc8
             attributes           = 0x0
             color palette index  = 0x7fff
             bold weight          = 0x190
             Font Name Length     = 5 
             Font Name            = Arial 
            
             @see org.apache.poi.hssf.record.FontRecord
             @see org.apache.poi.hssf.record.Record
             @return record containing a FontRecord
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.CreateFormat(System.Int32)">
            Creates a FormatRecord object
            @param id    the number of the format record to Create (meaning its position in
                   a file as M$ Excel would Create it.)
            @return record containing a FormatRecord
            @see org.apache.poi.hssf.record.FormatRecord
            @see org.apache.poi.hssf.record.Record
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.CreateExtendedFormat(System.Int32)">
             Creates an ExtendedFormatRecord object
             @param id    the number of the extended format record to Create (meaning its position in
                    a file as MS Excel would Create it.)
            
             @return record containing an ExtendedFormatRecord
             @see org.apache.poi.hssf.record.ExtendedFormatRecord
             @see org.apache.poi.hssf.record.Record
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.CreateExtendedFormat">
            Creates an default cell type ExtendedFormatRecord object.
            @return ExtendedFormatRecord with intial defaults (cell-type)
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.CreateStyleRecord(System.Int32)">
            Creates a new StyleRecord, for the given Extended
             Format index, and adds it onto the end of the
             records collection
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.CreateStyle(System.Int32)">
            Creates a StyleRecord object
            @param id        the number of the style record to Create (meaning its position in
                             a file as MS Excel would Create it.
            @return record containing a StyleRecord
            @see org.apache.poi.hssf.record.StyleRecord
            @see org.apache.poi.hssf.record.Record
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.CreatePalette">
            Creates a palette record initialized to the default palette
            @return a PaletteRecord instance populated with the default colors
            @see org.apache.poi.hssf.record.PaletteRecord
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.CreateUseSelFS">
            Creates the UseSelFS object with the use natural language flag Set to 0 (false)
            @return record containing a UseSelFSRecord
            @see org.apache.poi.hssf.record.UseSelFSRecord
            @see org.apache.poi.hssf.record.Record
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.CreateBoundSheet(System.Int32)">
            Create a "bound sheet" or "bundlesheet" (depending who you ask) record
            Always Sets the sheet's bof to 0.  You'll need to Set that yourself.
            @param id either sheet 0,1 or 2.
            @return record containing a BoundSheetRecord
            @see org.apache.poi.hssf.record.BoundSheetRecord
            @see org.apache.poi.hssf.record.Record
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.CreateCountry">
            Creates the Country record with the default country Set to 1
            and current country Set to 7 in case of russian locale ("ru_RU") and 1 otherwise
            @return record containing a CountryRecord
            @see org.apache.poi.hssf.record.CountryRecord
            @see org.apache.poi.hssf.record.Record
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.CreateSST">
            Creates the SST record with no strings and the Unique/num string Set to 0
            @return record containing a SSTRecord
            @see org.apache.poi.hssf.record.SSTRecord
            @see org.apache.poi.hssf.record.Record
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.CreateExtendedSST">
             Creates the ExtendedSST record with numstrings per bucket Set to 0x8.  HSSF
             doesn't yet know what to do with this thing, but we Create it with nothing in
             it hardly just to make Excel happy and our sheets look like Excel's
            
             @return record containing an ExtSSTRecord
             @see org.apache.poi.hssf.record.ExtSSTRecord
             @see org.apache.poi.hssf.record.Record
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.CreateEOF">
            Creates the EOF record
            @see org.apache.poi.hssf.record.EOFRecord
            @see org.apache.poi.hssf.record.Record
            @return record containing a EOFRecord
        </member>
        <member name="P:NPOI.HSSF.Model.Workbook.OrCreateLinkTable">
            lazy initialization
            Note - creating the link table causes creation of 1 EXTERNALBOOK and 1 EXTERNALSHEET record
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.FindSheetNameFromExternSheet(System.Int32)">
            Finds the sheet name by his extern sheet index
            @param num extern sheet index
            @return sheet name
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.GetSheetIndexFromExternSheetIndex(System.Int32)">
            Finds the sheet index for a particular external sheet number.
            @param externSheetNumber     The external sheet number to Convert
            @return  The index to the sheet found.
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.CheckExternSheet(System.Int32)">
            returns the extern sheet number for specific sheet number ,
             if this sheet doesn't exist in extern sheet , Add it
            @param sheetNumber sheet number
            @return index to extern sheet
        </member>
        <member name="P:NPOI.HSSF.Model.Workbook.NumNames">
            Gets the total number of names
            @return number of names
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.GetNameRecord(System.Int32)">
            Gets the name record
            @param index name index
            @return name record
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.CreateName">
            Creates new name
            @return new name record
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.AddName(NPOI.HSSF.Record.NameRecord)">
            Creates new name
            @return new name record
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.CreateBuiltInName(System.Byte,System.Int32)">
            Generates a NameRecord to represent a built-in region
            @return a new NameRecord Unless the index is invalid
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.RemoveName(System.Int32)">
            Removes the name
            @param namenum name index
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.GetFormat(System.String,System.Boolean)">
            Returns a format index that matches the passed in format.  It does not tie into HSSFDataFormat.
            @param format the format string
            @param CreateIfNotFound Creates a new format if format not found
            @return the format id of a format that matches or -1 if none found and CreateIfNotFound
        </member>
        <member name="P:NPOI.HSSF.Model.Workbook.Formats">
            Returns the list of FormatRecords in the workbook.
            @return ArrayList of FormatRecords in the notebook
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.CreateFormat(System.String)">
            Creates a FormatRecord, Inserts it, and returns the index code.
            @param format the format string
            @return the index code of the format record.
            @see org.apache.poi.hssf.record.FormatRecord
            @see org.apache.poi.hssf.record.Record
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.FindFirstRecordBySid(System.Int16)">
            Returns the first occurance of a record matching a particular sid.
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.FindFirstRecordLocBySid(System.Int16)">
            Returns the index of a record matching a particular sid.
            @param sid   The sid of the record to match
            @return      The index of -1 if no match made.
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.FindNextRecordBySid(System.Int16,System.Int32)">
            Returns the next occurance of a record matching a particular sid.
        </member>
        <member name="P:NPOI.HSSF.Model.Workbook.IsUsing1904DateWindowing">
             Whether date windowing is based on 1/2/1904 or 1/1/1900.
             Some versions of Excel (Mac) can save workbooks using 1904 date windowing.
            
             @return true if using 1904 date windowing
        </member>
        <member name="P:NPOI.HSSF.Model.Workbook.CustomPalette">
            Returns the custom palette in use for this workbook; if a custom palette record
            does not exist, then it is Created.
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.FindDrawingGroup">
            Finds the primary drawing Group, if one already exists
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.CreateDrawingGroup">
            Creates a primary drawing Group record.  If it already 
             exists then it's modified.
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.RemoveFontRecord(NPOI.HSSF.Record.FontRecord)">
            Removes the given font record from the
             file's list. This will make all 
             subsequent font indicies drop by one,
             so you'll need to update those yourself!
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.RemoveExFormatRecord(NPOI.HSSF.Record.ExtendedFormatRecord)">
            Removes the given ExtendedFormatRecord record from the
             file's list. This will make all 
             subsequent font indicies drop by one,
             so you'll need to update those yourself!
        </member>
        <member name="P:NPOI.HSSF.Model.Workbook.IsWriteProtected">
            is the workbook protected with a password (not encrypted)?
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.WriteProtectWorkbook(System.String,System.String)">
            protect a workbook with a password (not encypted, just Sets Writeprotect
            flags and the password.
            @param password to Set
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.UnwriteProtectWorkbook">
            Removes the Write protect flag
        </member>
        <member name="M:NPOI.HSSF.Model.Workbook.ResolveNameXText(System.Int32,System.Int32)">
            @param reFindex Index to REF entry in EXTERNSHEET record in the Link Table
            @param definedNameIndex zero-based to DEFINEDNAME or EXTERNALNAME record
            @return the string representation of the defined or external name
        </member>
        <member name="T:NPOI.HSSF.Model.WorkbookRecordList">
            <summary>
            List for records in Workbook
            </summary>
        </member>
        <member name="P:NPOI.HSSF.Model.WorkbookRecordList.Records">
            <summary>
            Gets or sets the records.
            </summary>
            <value>The records.</value>
        </member>
        <member name="P:NPOI.HSSF.Model.WorkbookRecordList.Count">
            <summary>
            Gets the count.
            </summary>
            <value>The count.</value>
        </member>
        <member name="P:NPOI.HSSF.Model.WorkbookRecordList.Item(System.Int32)">
            <summary>
            Gets the <see cref="T:NPOI.HSSF.Record.Record"/> at the specified index.
            </summary>
            <value></value>
        </member>
        <member name="M:NPOI.HSSF.Model.WorkbookRecordList.Add(System.Int32,NPOI.HSSF.Record.Record)">
            <summary>
            Adds the specified pos.
            </summary>
            <param name="pos">The pos.</param>
            <param name="r">The r.</param>
        </member>
        <member name="M:NPOI.HSSF.Model.WorkbookRecordList.Remove(NPOI.HSSF.Record.Record)">
            <summary>
            Removes the specified record.
            </summary>
            <param name="record">The record.</param>
        </member>
        <member name="M:NPOI.HSSF.Model.WorkbookRecordList.Remove(System.Int32)">
            <summary>
            Removes the specified position.
            </summary>
            <param name="pos">The position.</param>
        </member>
        <member name="P:NPOI.HSSF.Model.WorkbookRecordList.Protpos">
            <summary>
            Gets or sets the protpos.
            </summary>
            <value>The protpos.</value>
        </member>
        <member name="P:NPOI.HSSF.Model.WorkbookRecordList.Bspos">
            <summary>
            Gets or sets the bspos.
            </summary>
            <value>The bspos.</value>
        </member>
        <member name="P:NPOI.HSSF.Model.WorkbookRecordList.Tabpos">
            <summary>
            Gets or sets the tabpos.
            </summary>
            <value>The tabpos.</value>
        </member>
        <member name="P:NPOI.HSSF.Model.WorkbookRecordList.Fontpos">
            <summary>
            Gets or sets the fontpos.
            </summary>
            <value>The fontpos.</value>
        </member>
        <member name="P:NPOI.HSSF.Model.WorkbookRecordList.Xfpos">
            <summary>
            Gets or sets the xfpos.
            </summary>
            <value>The xfpos.</value>
        </member>
        <member name="P:NPOI.HSSF.Model.WorkbookRecordList.Backuppos">
            <summary>
            Gets or sets the backuppos.
            </summary>
            <value>The backuppos.</value>
        </member>
        <member name="P:NPOI.HSSF.Model.WorkbookRecordList.Palettepos">
            <summary>
            Gets or sets the palettepos.
            </summary>
            <value>The palettepos.</value>
        </member>
        <member name="P:NPOI.HSSF.Model.WorkbookRecordList.Namepos">
            <summary>
            Gets or sets the namepos.
            </summary>
            <value>The namepos.</value>
        </member>
        <member name="P:NPOI.HSSF.Model.WorkbookRecordList.Supbookpos">
            <summary>
            Gets or sets the supbookpos.
            </summary>
            <value>The supbookpos.</value>
        </member>
        <member name="P:NPOI.HSSF.Model.WorkbookRecordList.ExternsheetPos">
            <summary>
            Gets or sets the externsheet pos.
            </summary>
            <value>The externsheet pos.</value>
        </member>
        <member name="T:NPOI.HSSF.Record.AbstractEscherHolderRecord">
             The escher container record is used to hold escher records.  It is abstract and
             must be subclassed for maximum benefit.
            
             @author Glen Stampoultzis (glens at apache.org)
             @author Michael Zalewski (zalewski at optonline.net)
        </member>
        <member name="M:NPOI.HSSF.Record.AbstractEscherHolderRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
             Constructs a Bar record and Sets its fields appropriately.
            
             @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.AbstractEscherHolderRecord.RecordSize">
            Size of record (including 4 byte header)
        </member>
        <member name="M:NPOI.HSSF.Record.AbstractEscherHolderRecord.CloneViaReserialise">
            Clone the current record, via a call to serialise
             it, and another to Create a new record from the
             bytes.
            May only be used for classes which don't have
             internal counts / ids in them. For those which
             do, a full record-aware serialise is needed, which
             allocates new ids / counts as needed.
        </member>
        <member name="M:NPOI.HSSF.Record.AbstractEscherHolderRecord.GetEscherContainer">
            If we have a EscherContainerRecord as one of our
             children (and most top level escher holders do),
             then return that.
        </member>
        <member name="M:NPOI.HSSF.Record.AbstractEscherHolderRecord.FindFirstWithId(System.Int16)">
            Descends into all our children, returning the
             first EscherRecord with the given id, or null
             if none found
        </member>
        <member name="M:NPOI.HSSF.Record.AbstractEscherHolderRecord.Join(NPOI.HSSF.Record.AbstractEscherHolderRecord)">
            Big drawing Group records are split but it's easier to deal with them
            as a whole Group so we need to join them toGether.
        </member>
        <member name="M:NPOI.HSSF.Record.AbstractEscherHolderRecord.Decode">
            Convert raw data to escher records.
        </member>
        <member name="T:NPOI.HSSF.Record.Aggregates.CFRecordsAggregate">
            <summary>
            
            </summary>
            CFRecordsAggregate - aggregates Conditional Formatting records CFHeaderRecord
            and number of up to three CFRuleRecord records toGether to simplify
            access to them.
            @author Dmitriy Kumshayev
        </member>
        <member name="F:NPOI.HSSF.Record.Aggregates.CFRecordsAggregate.MAX_CONDTIONAL_FORMAT_RULES">
            Excel allows up to 3 conditional formating rules 
        </member>
        <member name="F:NPOI.HSSF.Record.Aggregates.CFRecordsAggregate.rules">
            List of CFRuleRecord objects 
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.CFRecordsAggregate.CreateCFAggregate(NPOI.HSSF.Model.RecordStream)">
            <summary>
            Create CFRecordsAggregate from a list of CF Records
            </summary>
            <param name="rs">list of Record objects</param>
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.CFRecordsAggregate.CreateCFAggregate(System.Collections.IList,System.Int32)">
            <summary>
            Create CFRecordsAggregate from a list of CF Records
            </summary>
            <param name="recs">list of Record objects</param>
            <param name="pOffset">position of CFHeaderRecord object in the list of Record objects</param>
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.CFRecordsAggregate.CloneCFAggregate">
            <summary>
            Create a deep Clone of the record
            </summary>
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.CFRecordsAggregate.Serialize(System.Int32,System.Byte[])">
            <summary>
            called by the class that is responsible for writing this sucker.
            Subclasses should implement this so that their data is passed back in a
            byte array.
            </summary>
            <param name="offset">The offset to begin writing at</param>
            <param name="data">The data byte array containing instance data</param>
            <returns> number of bytes written</returns>
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.CFRecordsAggregate.UpdateFormulasAfterCellShift(NPOI.HSSF.Record.Formula.FormulaShifter,System.Int32)">
            @return <c>false</c> if this whole {@link CFHeaderRecord} / {@link CFRuleRecord}s should be deleted
        </member>
        <member name="P:NPOI.HSSF.Record.Aggregates.CFRecordsAggregate.RecordSize">
            @return sum of sizes of all aggregated records
        </member>
        <member name="T:NPOI.HSSF.Record.Aggregates.ColumnInfoRecordsAggregate">
            <summary>
            @author Glen Stampoultzis
            </summary>
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.ColumnInfoRecordsAggregate.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HSSF.Record.Aggregates.ColumnInfoRecordsAggregate"/> class.
            </summary>
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.ColumnInfoRecordsAggregate.#ctor(NPOI.HSSF.Model.RecordStream)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HSSF.Record.Aggregates.ColumnInfoRecordsAggregate"/> class.
            </summary>
            <param name="rs">The rs.</param>
        </member>
        <member name="P:NPOI.HSSF.Record.Aggregates.ColumnInfoRecordsAggregate.Sid">
            It's an aggregate... just made something up 
        </member>
        <member name="P:NPOI.HSSF.Record.Aggregates.ColumnInfoRecordsAggregate.NumColumns">
            <summary>
            Gets the num columns.
            </summary>
            <value>The num columns.</value>
        </member>
        <member name="P:NPOI.HSSF.Record.Aggregates.ColumnInfoRecordsAggregate.RecordSize">
            <summary>
            Gets the size of the record.
            </summary>
            <value>The size of the record.</value>
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.ColumnInfoRecordsAggregate.Clone">
            Performs a deep Clone of the record
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.ColumnInfoRecordsAggregate.InsertColumn(NPOI.HSSF.Record.ColumnInfoRecord)">
            <summary>
            Inserts a column into the aggregate (at the end of the list).
            </summary>
            <param name="col">The column.</param>
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.ColumnInfoRecordsAggregate.InsertColumn(System.Int32,NPOI.HSSF.Record.ColumnInfoRecord)">
            <summary>
            Inserts a column into the aggregate (at the position specified
            by index
            </summary>
            <param name="idx">The index.</param>
            <param name="col">The columninfo.</param>
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.ColumnInfoRecordsAggregate.Serialize(System.Int32,System.Byte[])">
            <summary>
            called by the class that is responsible for writing this sucker.
            Subclasses should implement this so that their data is passed back in a
            byte array.
            </summary>
            <param name="offset">offset to begin writing at</param>
            <param name="data">byte array containing instance data</param>
            <returns>number of bytes written</returns>
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.ColumnInfoRecordsAggregate.VisitContainedRecords(NPOI.HSSF.Record.Aggregates.RecordVisitor)">
            <summary>
            Visit each of the atomic BIFF records contained in this {@link RecordAggregate} in the order
            that they should be written to file.  Implementors may or may not return the actual
            Records being used to manage POI's internal implementation.  Callers should not
            assume either way, and therefore only attempt to modify those Records after cloning
            </summary>
            <param name="rv"></param>
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.ColumnInfoRecordsAggregate.FindStartOfColumnOutlineGroup(System.Int32)">
            <summary>
            Finds the start of column outline group.
            </summary>
            <param name="idx">The idx.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.ColumnInfoRecordsAggregate.FindEndOfColumnOutlineGroup(System.Int32)">
            <summary>
            Finds the end of column outline group.
            </summary>
            <param name="idx">The idx.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.ColumnInfoRecordsAggregate.GetColInfo(System.Int32)">
            <summary>
            Gets the col info.
            </summary>
            <param name="idx">The idx.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.ColumnInfoRecordsAggregate.IsColumnGroupCollapsed(System.Int32)">
            <summary>
            Determines whether [is column group collapsed] [the specified idx].
            </summary>
            <param name="idx">The idx.</param>
            <returns>
            	<c>true</c> if [is column group collapsed] [the specified idx]; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.ColumnInfoRecordsAggregate.IsColumnGroupHiddenByParent(System.Int32)">
            <summary>
            Determines whether [is column group hidden by parent] [the specified idx].
            </summary>
            <param name="idx">The idx.</param>
            <returns>
            	<c>true</c> if [is column group hidden by parent] [the specified idx]; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.ColumnInfoRecordsAggregate.CollapseColumn(System.Int32)">
            <summary>
            Collapses the column.
            </summary>
            <param name="columnNumber">The column number.</param>
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.ColumnInfoRecordsAggregate.ExpandColumn(System.Int32)">
            <summary>
            Expands the column.
            </summary>
            <param name="columnNumber">The column number.</param>
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.ColumnInfoRecordsAggregate.SetColumnInfoFields(NPOI.HSSF.Record.ColumnInfoRecord,System.Nullable{System.Int16},System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{System.Boolean})">
            Sets all non null fields into the <c>ci</c> parameter.
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.ColumnInfoRecordsAggregate.AttemptMergeColInfoRecords(System.Int32)">
            <summary>
            Attempts to merge the col info record at the specified index
            with either or both of its neighbours
            </summary>
            <param name="colInfoIx">The col info ix.</param>
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.ColumnInfoRecordsAggregate.MergeColInfoRecords(NPOI.HSSF.Record.ColumnInfoRecord,NPOI.HSSF.Record.ColumnInfoRecord)">
            merges two column info records (if they are adjacent and have the same formatting, etc)
            @return <c>false</c> if the two column records could not be merged
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.ColumnInfoRecordsAggregate.SetGroupHidden(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Sets all adjacent columns of the same outline level to the specified hidden status.
            </summary>
            <param name="pIdx">the col info index of the start of the outline group.</param>
            <param name="level">The level.</param>
            <param name="hidden">The hidden.</param>
            <returns>the column index of the last column in the outline group</returns>
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.ColumnInfoRecordsAggregate.SetColumn(System.Int32,System.Nullable{System.Int16},System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{System.Boolean})">
            <summary>
            Sets the column.
            </summary>
            <param name="targetColumnIx">The target column ix.</param>
            <param name="xfIndex">Index of the xf.</param>
            <param name="width">The width.</param>
            <param name="level">The level.</param>
            <param name="hidden">The hidden.</param>
            <param name="collapsed">The collapsed.</param>
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.ColumnInfoRecordsAggregate.SetColumnInfoFields(NPOI.HSSF.Record.ColumnInfoRecord,System.Int16,System.Int16,System.Int32,System.Boolean,System.Boolean)">
            Sets all non null fields into the <c>ci</c> parameter.
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.ColumnInfoRecordsAggregate.CollapseColInfoRecords(System.Int32)">
            <summary>
            Collapses the col info records.
            </summary>
            <param name="columnIdx">The column index.</param>
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.ColumnInfoRecordsAggregate.GroupColumnRange(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Creates an outline Group for the specified columns.
            </summary>
            <param name="fromColumnIx">Group from this column (inclusive)</param>
            <param name="toColumnIx">Group to this column (inclusive)</param>
            <param name="indent">if true the Group will be indented by one level;if false indenting will be Removed by one level.</param>
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.ColumnInfoRecordsAggregate.FindColumnInfo(System.Int32)">
            <summary>
            Finds the ColumnInfoRecord
             which contains the specified columnIndex
            </summary>
            <param name="columnIndex">index of the column (not the index of the ColumnInfoRecord)</param>
            <returns>        /// <c>null</c>
             if no column info found for the specified column
             </returns>
        </member>
        <member name="P:NPOI.HSSF.Record.Aggregates.ColumnInfoRecordsAggregate.MaxOutlineLevel">
            <summary>
            Gets the max outline level.
            </summary>
            <value>The max outline level.</value>
        </member>
        <member name="T:NPOI.HSSF.Record.Aggregates.ConditionalFormattingTable">
            Holds all the conditional formatting for a workbook sheet.<p/>
            
            See OOO exelfileformat.pdf sec 4.12 'Conditional Formatting Table'
            
            @author Josh Micich
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.ConditionalFormattingTable.#ctor">
            Creates an empty ConditionalFormattingTable
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.ConditionalFormattingTable.Add(NPOI.HSSF.Record.Aggregates.CFRecordsAggregate)">
            @return index of the newly added CF header aggregate
        </member>
        <member name="T:NPOI.HSSF.Record.Aggregates.DataValidityTable">
            <summary>
            Manages the DVALRecord and DVRecords for a single sheet
            See OOO excelfileformat.pdf section 4.14
            @author Josh Micich
            </summary>
        </member>
        <member name="F:NPOI.HSSF.Record.Aggregates.DataValidityTable._validationList">
            The list of data validations for the current sheet.
            Note - this may be empty (contrary to OOO documentation)
        </member>
        <member name="T:NPOI.HSSF.Record.Aggregates.FormulaRecordAggregate">
            <summary>
            The formula record aggregate is used to join toGether the formula record and it's
            (optional) string record and (optional) Shared Formula Record (template Reads, excel optimization).
            @author Glen Stampoultzis (glens at apache.org)
            </summary>
        </member>
        <member name="F:NPOI.HSSF.Record.Aggregates.FormulaRecordAggregate._stringRecord">
            caches the calculated result of the formula 
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.FormulaRecordAggregate.#ctor(NPOI.HSSF.Record.FormulaRecord,NPOI.HSSF.Record.StringRecord,NPOI.HSSF.Record.Aggregates.SharedValueManager)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HSSF.Record.Aggregates.FormulaRecordAggregate"/> class.
            </summary>
            <param name="formulaRec">The formula rec.</param>
            <param name="stringRec">The string rec.</param>
            <param name="svm">The SVM.</param>
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.FormulaRecordAggregate.Serialize(System.Int32,System.Byte[])">
            <summary>
            called by the class that is responsible for writing this sucker.
            Subclasses should implement this so that their data is passed back in a
            byte array.
            </summary>
            <param name="offset">offset to begin writing at</param>
            <param name="data">byte array containing instance data.</param>
            <returns>number of bytes written</returns>
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.FormulaRecordAggregate.VisitContainedRecords(NPOI.HSSF.Record.Aggregates.RecordVisitor)">
            <summary>
            Visit each of the atomic BIFF records contained in this {@link RecordAggregate} in the order
            that they should be written to file.  Implementors may or may not return the actual
            {@link Record}s being used to manage POI's internal implementation.  Callers should not
            assume either way, and therefore only attempt to modify those {@link Record}s after cloning
            </summary>
            <param name="rv"></param>
        </member>
        <member name="P:NPOI.HSSF.Record.Aggregates.FormulaRecordAggregate.RecordSize">
            <summary>
            Get the current Serialized size of the record. Should include the sid and recLength (4 bytes).
            </summary>
            <value>The size of the record.</value>
        </member>
        <member name="P:NPOI.HSSF.Record.Aggregates.FormulaRecordAggregate.Sid">
            <summary>
            return the non static version of the id for this record.
            </summary>
            <value>The sid.</value>
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.FormulaRecordAggregate.HandleMissingSharedFormulaRecord(NPOI.HSSF.Record.FormulaRecord)">
            <summary>
            Sometimes the shared formula flag "seems" to be erroneously set (because the corresponding
            SharedFormulaRecord does not exist). Normally this would leave no way of determining
            the Ptg tokens for the formula.  However as it turns out in these
            cases, Excel encodes the unshared Ptg tokens in the right place (inside the FormulaRecord). 
            So the the only thing that needs to be done is to ignore the erroneous
            shared formula flag.
            
            This method may also be used for setting breakpoints to help diagnose issues regarding the
            abnormally-set 'shared formula' flags.
            </summary>
            <param name="formula">The formula.</param>
        </member>
        <member name="P:NPOI.HSSF.Record.Aggregates.FormulaRecordAggregate.FormulaRecord">
            <summary>
            Gets or sets the formula record.
            </summary>
            <value>The formula record.</value>
        </member>
        <member name="P:NPOI.HSSF.Record.Aggregates.FormulaRecordAggregate.StringRecord">
            <summary>
            Gets or sets the string record.
            </summary>
            <value>The string record.</value>
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.FormulaRecordAggregate.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with the current <see cref="T:System.Object"/>.</param>
            <returns>
            true if the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>; otherwise, false.
            </returns>
            <exception cref="T:System.NullReferenceException">
            The <paramref name="obj"/> parameter is null.
            </exception>
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.FormulaRecordAggregate.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="P:NPOI.HSSF.Record.Aggregates.FormulaRecordAggregate.StringValue">
            <summary>
            Gets the string value.
            </summary>
            <value>The string value.</value>
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.FormulaRecordAggregate.SetCachedStringResult(System.String)">
            <summary>
            Sets the cached string result.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.FormulaRecordAggregate.SetCachedBooleanResult(System.Boolean)">
            <summary>
            Sets the cached boolean result.
            </summary>
            <param name="value">if set to <c>true</c> [value].</param>
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.FormulaRecordAggregate.SetCachedErrorResult(System.Int32)">
            <summary>
            Sets the cached error result.
            </summary>
            <param name="errorCode">The error code.</param>
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.FormulaRecordAggregate.NotifyFormulaChanging">
            Should be called by any code which is either deleting this formula cell, or changing
            its type.  This method gives the aggregate a chance to unlink any shared formula
            that may be involved with this cell formula.
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.FormulaRecordAggregate.SetParsedExpression(NPOI.HSSF.Record.Formula.Ptg[])">
            Also checks for a related shared formula and unlinks it if found
        </member>
        <member name="T:NPOI.HSSF.Record.Aggregates.MergedCellsTable">
            
            @author Josh Micich
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.MergedCellsTable.#ctor">
            <summary>
            Creates an empty aggregate
            </summary>
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.MergedCellsTable.Read(NPOI.HSSF.Model.RecordStream)">
            Reads zero or more consecutive {@link MergeCellsRecord}s
            @param rs
        </member>
        <member name="T:NPOI.HSSF.Record.Aggregates.PageSettingsBlock">
            Groups the page settings records for a worksheet.<p/>
            
            See OOO excelfileformat.pdf sec 4.4 'Page Settings Block'
            
            @author Josh Micich
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.PageSettingsBlock.#ctor">
            Creates a PageSettingsBlock with default settings
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.PageSettingsBlock.IsComponentRecord(System.Int32)">
            @return <c>true</c> if the specified Record sid is one belonging to the 
            'Page Settings Block'.
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.PageSettingsBlock.SetColumnBreak(System.Int32,System.Int32,System.Int32)">
             Sets a page break at the indicated column
            
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.PageSettingsBlock.RemoveColumnBreak(System.Int32)">
             Removes a page break at the indicated column
            
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.PageSettingsBlock.CreateHeader">
            Creates the Header Record and sets it to nothing/0 length
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.PageSettingsBlock.CreateFooter">
            Creates the Footer Record and sets it to nothing/0 length
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.PageSettingsBlock.CreateHCenter">
            Creates the HCenter Record and sets it to false (don't horizontally center)
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.PageSettingsBlock.CreateVCenter">
            Creates the VCenter Record and sets it to false (don't horizontally center)
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.PageSettingsBlock.CreatePrintSetup">
            Creates the PrintSetup Record and sets it to defaults and marks it invalid
            @see org.apache.poi.hssf.record.PrintSetupRecord
            @see org.apache.poi.hssf.record.Record
            @return record containing a PrintSetupRecord
        </member>
        <member name="P:NPOI.HSSF.Record.Aggregates.PageSettingsBlock.Header">
            Returns the HeaderRecord.
            @return HeaderRecord for the sheet.
        </member>
        <member name="P:NPOI.HSSF.Record.Aggregates.PageSettingsBlock.Footer">
            Returns the FooterRecord.
            @return FooterRecord for the sheet.
        </member>
        <member name="P:NPOI.HSSF.Record.Aggregates.PageSettingsBlock.PrintSetup">
            Returns the PrintSetupRecord.
            @return PrintSetupRecord for the sheet.
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.PageSettingsBlock.GetMargin(NPOI.SS.UserModel.MarginType)">
            Gets the size of the margin in inches.
            @param margin which margin to Get
            @return the size of the margin
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.PageSettingsBlock.SetMargin(NPOI.SS.UserModel.MarginType,System.Double)">
            Sets the size of the margin in inches.
            @param margin which margin to Get
            @param size the size of the margin
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.PageSettingsBlock.ShiftBreaks(NPOI.HSSF.Record.PageBreakRecord,System.Int32,System.Int32,System.Int32)">
            Shifts all the page breaks in the range "count" number of rows/columns
            @param breaks The page record to be shifted
            @param start Starting "main" value to shift breaks
            @param stop Ending "main" value to shift breaks
            @param count number of units (rows/columns) to shift by
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.PageSettingsBlock.SetRowBreak(System.Int32,System.Int16,System.Int16)">
            Sets a page break at the indicated row
            @param row
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.PageSettingsBlock.RemoveRowBreak(System.Int32)">
            Removes a page break at the indicated row
            @param row
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.PageSettingsBlock.IsRowBroken(System.Int32)">
            Queries if the specified row has a page break
            @param row
            @return true if the specified row has a page break
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.PageSettingsBlock.IsColumnBroken(System.Int32)">
             Queries if the specified column has a page break
            
             @return <c>true</c> if the specified column has a page break
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.PageSettingsBlock.ShiftRowBreaks(System.Int32,System.Int32,System.Int32)">
            Shifts the horizontal page breaks for the indicated count
            @param startingRow
            @param endingRow
            @param count
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.PageSettingsBlock.ShiftColumnBreaks(System.Int16,System.Int16,System.Int16)">
            Shifts the vertical page breaks for the indicated count
            @param startingCol
            @param endingCol
            @param count
        </member>
        <member name="P:NPOI.HSSF.Record.Aggregates.PageSettingsBlock.RowBreaks">
            @return all the horizontal page breaks, never <c>null</c>
        </member>
        <member name="P:NPOI.HSSF.Record.Aggregates.PageSettingsBlock.NumRowBreaks">
            @return the number of row page breaks
        </member>
        <member name="P:NPOI.HSSF.Record.Aggregates.PageSettingsBlock.ColumnBreaks">
            @return all the column page breaks, never <c>null</c>
        </member>
        <member name="P:NPOI.HSSF.Record.Aggregates.PageSettingsBlock.NumColumnBreaks">
            @return the number of column page breaks
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.RecordVisitor.VisitRecord(NPOI.HSSF.Record.Record)">
            Implementors may call non-mutating methods on Record r.
            @param r must not be <c>null</c>
        </member>
        <member name="T:NPOI.HSSF.Record.Aggregates.RecordAggregate">
            <tt>RecordAggregate</tt>s are groups of of BIFF <tt>Record</tt>s that are typically stored 
            together and/or updated together.  Workbook / Sheet records are typically stored in a sequential
            list, which does not provide much structure to coordinate updates.
            
            @author Josh Micich
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.RecordAggregate.VisitContainedRecords(NPOI.HSSF.Record.Aggregates.RecordVisitor)">
            Visit each of the atomic BIFF records contained in this {@link RecordAggregate} in the order
            that they should be written to file.  Implementors may or may not return the actual 
            {@link Record}s being used to manage POI's internal implementation.  Callers should not
            assume either way, and therefore only attempt to modify those {@link Record}s after cloning
        </member>
        <member name="T:NPOI.HSSF.Record.Aggregates.PositionTrackingVisitor">
            A wrapper for {@link RecordVisitor} which accumulates the sizes of all
            records visited.
        </member>
        <member name="T:NPOI.HSSF.Record.Aggregates.RowRecordsAggregate">
            
             @author  andy
             @author Jason Height (jheight at chariot dot net dot au)
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.RowRecordsAggregate.#ctor">
            Creates a new instance of ValueRecordsAggregate 
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.RowRecordsAggregate.#ctor(NPOI.HSSF.Model.RecordStream,NPOI.HSSF.Record.Aggregates.SharedValueManager)">
            @param rs record stream with all {@link SharedFormulaRecord}
            {@link ArrayRecord}, {@link TableRecord} {@link MergeCellsRecord} Records removed
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.RowRecordsAggregate.AddUnknownRecord(NPOI.HSSF.Record.Record)">
            Handles UnknownRecords which appear within the row/cell records
        </member>
        <member name="P:NPOI.HSSF.Record.Aggregates.RowRecordsAggregate.RowBlockCount">
            Returns the number of row blocks.
            <p/>The row blocks are goupings of rows that contain the DBCell record
            after them
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.RowRecordsAggregate.GetRowCountForBlock(System.Int32)">
            Returns the number of physical rows within a block
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.RowRecordsAggregate.GetStartRowNumberForBlock(System.Int32)">
            Returns the physical row number of the first row in a block
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.RowRecordsAggregate.GetEndRowNumberForBlock(System.Int32)">
            Returns the physical row number of the end row in a block
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.RowRecordsAggregate.CreateRow(System.Int32)">
             Create a row record.
            
             @param row number
             @return RowRecord Created for the passed in row number
             @see org.apache.poi.hssf.record.RowRecord
        </member>
        <member name="T:NPOI.HSSF.Record.Aggregates.SharedValueManager">
            <summary>
            Manages various auxiliary records while constructing a RowRecordsAggregate
            @author Josh Micich
            </summary>
        </member>
        <member name="F:NPOI.HSSF.Record.Aggregates.SharedValueManager.SharedFormulaGroup._firstCell">
            Coordinates of the first cell having a formula that uses this shared formula.
            This is often <i>but not always</i> the top left cell in the range covered by
            {@link #_sfr}
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.SharedValueManager.SharedFormulaGroup.IsFirstCell(System.Int32,System.Int32)">
            Note - the 'first cell' of a shared formula group is not always the top-left cell
            of the enclosing range.
            @return <code>true</code> if the specified coordinates correspond to the 'first cell'
            of this shared formula group.
        </member>
        <member name="F:NPOI.HSSF.Record.Aggregates.SharedValueManager._groups">
            cached for optimization purposes 
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.SharedValueManager.Create(NPOI.HSSF.Record.SharedFormulaRecord[],NPOI.SS.Util.CellReference[],NPOI.HSSF.Record.ArrayRecord[],NPOI.HSSF.Record.TableRecord[])">
            @param firstCells
            @param recs list of sheet records (possibly Contains records for other parts of the Excel file)
            @param startIx index of first row/cell record for current sheet
            @param endIx one past index of last row/cell record for current sheet.  It is important
            that this code does not inadvertently collect <tt>SharedFormulaRecord</tt>s from any other
            sheet (which could happen if endIx is chosen poorly).  (see bug 44449)
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.SharedValueManager.LinkSharedFormulaRecord(NPOI.SS.Util.CellReference,NPOI.HSSF.Record.Aggregates.FormulaRecordAggregate)">
            @param firstCell as extracted from the {@link ExpPtg} from the cell's formula.
            @return never <code>null</code>
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.SharedValueManager.GetRecordForFirstCell(NPOI.HSSF.Record.Aggregates.FormulaRecordAggregate)">
             Gets the {@link SharedValueRecordBase} record if it should be encoded immediately after the
             formula record Contained in the specified {@link FormulaRecordAggregate} agg.  Note - the
             shared value record always appears after the first formula record in the group.  For arrays
             and tables the first formula is always the in the top left cell.  However, since shared
             formula groups can be sparse and/or overlap, the first formula may not actually be in the
             top left cell.
            
             @return the SHRFMLA, TABLE or ARRAY record for the formula cell, if it is the first cell of
             a table or array region. <code>null</code> if the formula cell is not shared/array/table,
             or if the specified formula is not the the first in the group.
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.SharedValueManager.Unlink(NPOI.HSSF.Record.SharedFormulaRecord)">
            Converts all {@link FormulaRecord}s handled by <tt>sharedFormulaRecord</tt>
            to plain unshared formulas
        </member>
        <member name="T:NPOI.HSSF.Record.Aggregates.ValueRecordsAggregate">
            
             Aggregate value records toGether.  Things are easier to handle that way.
            
             @author  andy
             @author  Glen Stampoultzis (glens at apache.org)
             @author Jason Height (jheight at chariot dot net dot au)
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.ValueRecordsAggregate.#ctor">
            Creates a new instance of ValueRecordsAggregate 
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.ValueRecordsAggregate.HandleMissingSharedFormulaRecord(NPOI.HSSF.Record.FormulaRecord)">
            Sometimes the shared formula flag "seems" to be erroneously Set, in which case there is no 
            call to <tt>SharedFormulaRecord.ConvertSharedFormulaRecord</tt> and hence the 
            <tt>ParsedExpression</tt> field of this <tt>FormulaRecord</tt> will not Get updated.<br/>
            As it turns out, this is not a problem, because in these circumstances, the existing value
            for <tt>ParsedExpression</tt> is perfectly OK.<p/>
            
            This method may also be used for Setting breakpoints to help diagnose Issues regarding the
            abnormally-Set 'shared formula' flags. 
            (see TestValueRecordsAggregate.testSpuriousSharedFormulaFlag()).<p/>
            
            The method currently does nothing but do not delete it without Finding a nice home for this 
            comment.
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.ValueRecordsAggregate.GetRowCellBlockSize(System.Int32,System.Int32)">
            Tallies a count of the size of the cell records
            that are attached to the rows in the range specified.
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.ValueRecordsAggregate.RowHasCells(System.Int32)">
            Returns true if the row has cells attached to it 
        </member>
        <member name="M:NPOI.HSSF.Record.Aggregates.ValueRecordsAggregate.SerializeCellRow(System.Int32,System.Int32,System.Byte[])">
            Serializes the cells that are allocated to a certain row range
        </member>
        <member name="T:NPOI.HSSF.Record.ArrayRecord">
            ARRAY (0x0221)<p/>
            
            Treated in a similar way to SharedFormulaRecord
            
            @author Josh Micich
        </member>
        <member name="T:NPOI.HSSF.Record.AutoFilter.DOPERRecord">
            <summary>
            DOPER Structure for AutoFilter record
            </summary>
            <remarks>author: Tony Qu</remarks>
        </member>
        <member name="P:NPOI.HSSF.Record.AutoFilter.DOPERRecord.RK">
            <summary>
            get or set the RK record
            </summary>
        </member>
        <member name="P:NPOI.HSSF.Record.AutoFilter.DOPERRecord.LengthOfString">
            <summary>
            Gets or sets Length of the string (the string is stored in the rgch field that follows the DOPER structures)
            </summary>
        </member>
        <member name="P:NPOI.HSSF.Record.AutoFilter.DOPERRecord.IsBooleanValue">
            <summary>
            Whether the bBoolErr field contains a Boolean value
            </summary>
        </member>
        <member name="P:NPOI.HSSF.Record.AutoFilter.DOPERRecord.IsErrorValue">
            <summary>
            Whether the bBoolErr field contains a Error value
            </summary>
        </member>
        <member name="P:NPOI.HSSF.Record.AutoFilter.DOPERRecord.BooleanValue">
            <summary>
            Get or sets the boolean value
            </summary>
        </member>
        <member name="P:NPOI.HSSF.Record.AutoFilter.DOPERRecord.ErrorValue">
            <summary>
            Get or sets the boolean value
            </summary>
        </member>
        <member name="T:NPOI.HSSF.Record.BackupRecord">
            Title:        Backup Record 
            Description:  bool specifying whether
                          the GUI should store a backup of the file.
            REFERENCE:  PG 287 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
            @author Andrew C. Oliver (acoliver at apache dot org)
            @version 2.0-pre
        </member>
        <member name="M:NPOI.HSSF.Record.BackupRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Constructs a BackupRecord and Sets its fields appropriately
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.BackupRecord.Backup">
             Get the backup flag
            
             @return short 0/1 (off/on)
        </member>
        <member name="T:NPOI.HSSF.Record.BlankRecord">
            Title:        Blank cell record 
            Description:  Represents a column in a row with no value but with styling.
            REFERENCE:  PG 287 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
            @author Andrew C. Oliver (acoliver at apache dot org)
            @author Jason Height (jheight at chariot dot net dot au)
            @version 2.0-pre
        </member>
        <member name="M:NPOI.HSSF.Record.BlankRecord.#ctor">
            Creates a new instance of BlankRecord 
        </member>
        <member name="M:NPOI.HSSF.Record.BlankRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Constructs a BlankRecord and Sets its fields appropriately
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.BlankRecord.Row">
             Get the row this cell occurs on
            
             @return the row
        </member>
        <member name="P:NPOI.HSSF.Record.BlankRecord.Column">
             Get the column this cell defines within the row
            
             @return the column
        </member>
        <member name="P:NPOI.HSSF.Record.BlankRecord.XFIndex">
             Set the index of the extended format record to style this cell with
            
             @param xf - the 0-based index of the extended format
             @see org.apache.poi.hssf.record.ExtendedFormatRecord
        </member>
        <member name="P:NPOI.HSSF.Record.BlankRecord.Sid">
            return the non static version of the id for this record.
        </member>
        <member name="M:NPOI.HSSF.Record.BlankRecord.Serialize(NPOI.Util.IO.LittleEndianOutput)">
             called by the class that is responsible for writing this sucker.
             Subclasses should implement this so that their data is passed back in a
             byte array.
            
             @return byte array containing instance data
        </member>
        <member name="T:NPOI.HSSF.Record.BookBoolRecord">
            Title:        Save External Links record (BookBool)
            Description:  Contains a flag specifying whether the Gui should save externally
                          linked values from other workbooks. 
            REFERENCE:  PG 289 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
            @author Andrew C. Oliver (acoliver at apache dot org)
            @version 2.0-pre
        </member>
        <member name="M:NPOI.HSSF.Record.BookBoolRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Constructs a BookBoolRecord and Sets its fields appropriately
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.BookBoolRecord.SaveLinkValues">
             Get the save ext links flag
            
             @return short 0/1 (off/on)
        </member>
        <member name="T:NPOI.HSSF.Record.BoolErrRecord">
            Creates new BoolErrRecord. 
            REFERENCE:  PG ??? Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
            @author Michael P. Harhen
            @author Jason Height (jheight at chariot dot net dot au)
            @version 2.0-pre
        </member>
        <member name="M:NPOI.HSSF.Record.BoolErrRecord.#ctor">
            Creates new BoolErrRecord 
        </member>
        <member name="M:NPOI.HSSF.Record.BoolErrRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
             Constructs a BoolErr record and Sets its fields appropriately.
            
             @param in the RecordInputstream to Read the record from
        </member>
        <member name="M:NPOI.HSSF.Record.BoolErrRecord.SetValue(System.Boolean)">
             Set the bool value for the cell
            
             @param value   representing the bool value
        </member>
        <member name="M:NPOI.HSSF.Record.BoolErrRecord.SetValue(System.Byte)">
             Set the error value for the cell
            
             @param value     error representing the error value
                              this value can only be 0,7,15,23,29,36 or 42
                              see bugzilla bug 16560 for an explanation
        </member>
        <member name="P:NPOI.HSSF.Record.BoolErrRecord.BooleanValue">
             Get the value for the cell
            
             @return bool representing the bool value
        </member>
        <member name="P:NPOI.HSSF.Record.BoolErrRecord.ErrorValue">
             Get the error value for the cell
            
             @return byte representing the error value
        </member>
        <member name="P:NPOI.HSSF.Record.BoolErrRecord.IsBoolean">
             Indicates whether the call holds a boolean value
            
             @return boolean true if the cell holds a boolean value
        </member>
        <member name="P:NPOI.HSSF.Record.BoolErrRecord.IsError">
             Indicates whether the call holds an error value
            
             @return bool true if the cell holds an error value
        </member>
        <member name="T:NPOI.HSSF.Record.BottomMarginRecord">
             Record for the bottom margin.
             NOTE: This source was automatically generated.
            
             @author Shawn Laubach (slaubach at apache dot org)
        </member>
        <member name="M:NPOI.HSSF.Record.BottomMarginRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
             Constructs a BottomMargin record and Sets its fields appropriately.
            
             @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.BottomMarginRecord.RecordSize">
            Size of record (exluding 4 byte header)
        </member>
        <member name="P:NPOI.HSSF.Record.BottomMarginRecord.Margin">
            Get the margin field for the BottomMargin record.
        </member>
        <member name="T:NPOI.HSSF.Record.BoundSheetRecord">
            Title:        Bound Sheet Record (aka BundleSheet) 
            Description:  Defines a sheet within a workbook.  Basically stores the sheetname
                          and tells where the Beginning of file record Is within the HSSF
                          file. 
            REFERENCE:  PG 291 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
            @author Andrew C. Oliver (acoliver at apache dot org)
            @author Sergei Kozello (sergeikozello at mail.ru)
            @version 2.0-pre
        </member>
        <member name="M:NPOI.HSSF.Record.BoundSheetRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
             Constructs a BoundSheetRecord and Sets its fields appropriately
            
             @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.BoundSheetRecord.PositionOfBof">
             Get the offset in bytes of the Beginning of File Marker within the HSSF Stream part of the POIFS file
            
             @return offset in bytes
        </member>
        <member name="P:NPOI.HSSF.Record.BoundSheetRecord.IsVeryHidden">
            Is the sheet very hidden? Different from (normal) hidden 
        </member>
        <member name="P:NPOI.HSSF.Record.BoundSheetRecord.Sheetname">
            Get the sheetname for this sheet.  (this appears in the tabs at the bottom)
            @return sheetname the name of the sheet
        </member>
        <member name="M:NPOI.HSSF.Record.BoundSheetRecord.OrderByBofPosition(System.Collections.ArrayList)">
            Converts a List of {@link BoundSheetRecord}s to an array and sorts by the position of their
            BOFs.
        </member>
        <member name="T:NPOI.HSSF.Record.CalcCountRecord">
            Title:        Calc Count Record
            Description:  Specifies the maximum times the gui should perform a formula
                          recalculation.  For instance: in the case a formula includes
                          cells that are themselves a result of a formula and a value
                          Changes.  This Is essentially a failsafe against an infinate
                          loop in the event the formulas are not independant. 
            REFERENCE:  PG 292 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
            @author Andrew C. Oliver (acoliver at apache dot org)
            @author Jason Height (jheight at chariot dot net dot au)
            @version 2.0-pre
            @see org.apache.poi.hssf.record.CalcModeRecord
        </member>
        <member name="M:NPOI.HSSF.Record.CalcCountRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
             Constructs a CalcCountRecord and Sets its fields appropriately
             @param in the RecordInputstream to Read the record from
            
        </member>
        <member name="P:NPOI.HSSF.Record.CalcCountRecord.Iterations">
            Get the number of iterations to perform
            @return iterations
        </member>
        <member name="T:NPOI.HSSF.Record.CalcModeRecord">
            Title:        Calc Mode Record
            Description:  Tells the gui whether to calculate formulas
                          automatically, manually or automatically
                          except for tables.
            REFERENCE:  PG 292 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
            @author Andrew C. Oliver (acoliver at apache dot org)
            @author Jason Height (jheight at chariot dot net dot au)
            @version 2.0-pre
            @see org.apache.poi.hssf.record.CalcCountRecord
        </member>
        <member name="F:NPOI.HSSF.Record.CalcModeRecord.MANUAL">
            manually calculate formulas (0)
        </member>
        <member name="F:NPOI.HSSF.Record.CalcModeRecord.AUTOMATIC">
            automatically calculate formulas (1)
        </member>
        <member name="F:NPOI.HSSF.Record.CalcModeRecord.AUTOMATIC_EXCEPT_TABLES">
            automatically calculate formulas except for tables (-1)
        </member>
        <member name="M:NPOI.HSSF.Record.CalcModeRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Constructs a CalcModeRecord and Sets its fields appropriately
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="M:NPOI.HSSF.Record.CalcModeRecord.SetCalcMode(System.Int16)">
             Set the calc mode flag for formulas
            
             @see #MANUAL
             @see #AUTOMATIC
             @see #AUTOMATIC_EXCEPT_TABLES
            
             @param calcmode one of the three flags above
        </member>
        <member name="M:NPOI.HSSF.Record.CalcModeRecord.GetCalcMode">
             Get the calc mode flag for formulas
            
             @see #MANUAL
             @see #AUTOMATIC
             @see #AUTOMATIC_EXCEPT_TABLES
            
             @return calcmode one of the three flags above
        </member>
        <member name="P:NPOI.HSSF.Record.CellRecord.XFIndex">
             get the index to the ExtendedFormat
            
             @see org.apache.poi.hssf.record.ExtendedFormatRecord
             @return index to the XF record
        </member>
        <member name="M:NPOI.HSSF.Record.CellRecord.AppendValueText(System.Text.StringBuilder)">
            Append specific debug info (used by {@link #toString()} for the value
            contained in this record. Trailing new-line should not be Appended
            (superclass does that).
        </member>
        <member name="P:NPOI.HSSF.Record.CellRecord.RecordName">
            Gets the debug info BIFF record type name (used by {@link #toString()}.
        </member>
        <member name="M:NPOI.HSSF.Record.CellRecord.SerializeValue(NPOI.Util.IO.LittleEndianOutput)">
            writes out the value data for this cell record
        </member>
        <member name="P:NPOI.HSSF.Record.CellRecord.ValueDataSize">
            @return the size (in bytes) of the value data for this cell record
        </member>
        <member name="T:NPOI.HSSF.Record.CFHeaderRecord">
            Conditional Formatting Header record (CFHEADER)
            
            @author Dmitriy Kumshayev
        </member>
        <member name="M:NPOI.HSSF.Record.CFHeaderRecord.#ctor">
            Creates new CFHeaderRecord 
        </member>
        <member name="M:NPOI.HSSF.Record.CFHeaderRecord.Serialize(System.Int32,System.Byte[])">
            @return byte array containing instance data
        </member>
        <member name="T:NPOI.HSSF.Record.CFRuleRecord">
            Conditional Formatting Rule Record.
            @author Dmitriy Kumshayev
        </member>
        <member name="M:NPOI.HSSF.Record.CFRuleRecord.#ctor(System.Byte,NPOI.HSSF.Record.ComparisonOperator)">
            Creates new CFRuleRecord 
        </member>
        <member name="P:NPOI.HSSF.Record.CFRuleRecord.ParsedExpression1">
             get the stack of the 1st expression as a list
            
             @return list of tokens (casts stack to a list and returns it!)
             this method can return null is we are unable to create Ptgs from 
            	 existing excel file
             callers should check for null!
        </member>
        <member name="P:NPOI.HSSF.Record.CFRuleRecord.ParsedExpression2">
             get the stack of the 2nd expression as a list
            
             @return list of tokens (casts stack to a list and returns it!)
             this method can return null is we are unable to create Ptgs from 
            	 existing excel file
             callers should check for null!
        </member>
        <member name="M:NPOI.HSSF.Record.CFRuleRecord.Create(NPOI.HSSF.UserModel.HSSFWorkbook,System.String)">
            Creates a new comparison operation rule
        </member>
        <member name="M:NPOI.HSSF.Record.CFRuleRecord.Create(NPOI.HSSF.UserModel.HSSFWorkbook,NPOI.HSSF.Record.ComparisonOperator,System.String,System.String)">
            Creates a new comparison operation rule
        </member>
        <member name="P:NPOI.HSSF.Record.CFRuleRecord.Options">
             Get the option flags
            
             @return bit mask
        </member>
        <member name="M:NPOI.HSSF.Record.CFRuleRecord.GetParsedExpression1">
             Get the stack of the 1st expression as a list
            
             @return list of tokens (casts stack to a list and returns it!)
             this method can return null Is we are Unable to Create Ptgs from 
            	 existing excel file
             callers should Check for null!
        </member>
        <member name="M:NPOI.HSSF.Record.CFRuleRecord.GetFormulaSize(NPOI.HSSF.Record.Formula.Ptg[])">
            @param ptgs may be <c>null</c>
            @return encoded size of the formula
        </member>
        <member name="M:NPOI.HSSF.Record.CFRuleRecord.Serialize(System.Int32,System.Byte[])">
             called by the class that Is responsible for writing this sucker.
             Subclasses should implement this so that their data Is passed back in a
             byte array.
            
             @param offset to begin writing at
             @param data byte array containing instance data
             @return number of bytes written
        </member>
        <!-- Badly formed XML comment ignored for member "M:NPOI.HSSF.Record.CFRuleRecord.ParseFormula(System.String,NPOI.HSSF.UserModel.HSSFWorkbook)" -->
        <member name="T:NPOI.HSSF.Record.CF.BorderFormatting">
            Border Formatting Block of the Conditional Formatting Rule Record.
            
            @author Dmitriy Kumshayev
        </member>
        <member name="F:NPOI.HSSF.Record.CF.BorderFormatting.BORDER_NONE">
            No border
        </member>
        <member name="F:NPOI.HSSF.Record.CF.BorderFormatting.BORDER_THIN">
            Thin border
        </member>
        <member name="F:NPOI.HSSF.Record.CF.BorderFormatting.BORDER_MEDIUM">
            Medium border
        </member>
        <member name="F:NPOI.HSSF.Record.CF.BorderFormatting.BORDER_DASHED">
            dash border
        </member>
        <member name="F:NPOI.HSSF.Record.CF.BorderFormatting.BORDER_HAIR">
            dot border
        </member>
        <member name="F:NPOI.HSSF.Record.CF.BorderFormatting.BORDER_THICK">
            Thick border
        </member>
        <member name="F:NPOI.HSSF.Record.CF.BorderFormatting.BORDER_DOUBLE">
            double-line border
        </member>
        <member name="F:NPOI.HSSF.Record.CF.BorderFormatting.BORDER_DOTTED">
            hair-line border
        </member>
        <member name="F:NPOI.HSSF.Record.CF.BorderFormatting.BORDER_MEDIUM_DASHED">
            Medium dashed border
        </member>
        <member name="F:NPOI.HSSF.Record.CF.BorderFormatting.BORDER_DASH_DOT">
            dash-dot border
        </member>
        <member name="F:NPOI.HSSF.Record.CF.BorderFormatting.BORDER_MEDIUM_DASH_DOT">
            medium dash-dot border
        </member>
        <member name="F:NPOI.HSSF.Record.CF.BorderFormatting.BORDER_DASH_DOT_DOT">
            dash-dot-dot border
        </member>
        <member name="F:NPOI.HSSF.Record.CF.BorderFormatting.BORDER_MEDIUM_DASH_DOT_DOT">
            medium dash-dot-dot border
        </member>
        <member name="F:NPOI.HSSF.Record.CF.BorderFormatting.BORDER_SLANTED_DASH_DOT">
            slanted dash-dot border
        </member>
        <member name="M:NPOI.HSSF.Record.CF.BorderFormatting.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Creates new FontFormatting 
        </member>
        <member name="P:NPOI.HSSF.Record.CF.BorderFormatting.BorderLeft">
            Get the type of border to use for the left border of the cell
            @return border type
            @see #BORDER_NONE
            @see #BORDER_THIN
            @see #BORDER_MEDIUM
            @see #BORDER_DASHED
            @see #BORDER_DOTTED
            @see #BORDER_THICK
            @see #BORDER_DOUBLE
            @see #BORDER_HAIR
            @see #BORDER_MEDIUM_DASHED
            @see #BORDER_DASH_DOT
            @see #BORDER_MEDIUM_DASH_DOT
            @see #BORDER_DASH_DOT_DOT
            @see #BORDER_MEDIUM_DASH_DOT_DOT
            @see #BORDER_SLANTED_DASH_DOT
        </member>
        <member name="P:NPOI.HSSF.Record.CF.BorderFormatting.BorderRight">
            Get the type of border to use for the right border of the cell
            @return border type
            @see #BORDER_NONE
            @see #BORDER_THIN
            @see #BORDER_MEDIUM
            @see #BORDER_DASHED
            @see #BORDER_DOTTED
            @see #BORDER_THICK
            @see #BORDER_DOUBLE
            @see #BORDER_HAIR
            @see #BORDER_MEDIUM_DASHED
            @see #BORDER_DASH_DOT
            @see #BORDER_MEDIUM_DASH_DOT
            @see #BORDER_DASH_DOT_DOT
            @see #BORDER_MEDIUM_DASH_DOT_DOT
            @see #BORDER_SLANTED_DASH_DOT
        </member>
        <member name="P:NPOI.HSSF.Record.CF.BorderFormatting.BorderTop">
            Get the type of border to use for the top border of the cell
            @return border type
            @see #BORDER_NONE
            @see #BORDER_THIN
            @see #BORDER_MEDIUM
            @see #BORDER_DASHED
            @see #BORDER_DOTTED
            @see #BORDER_THICK
            @see #BORDER_DOUBLE
            @see #BORDER_HAIR
            @see #BORDER_MEDIUM_DASHED
            @see #BORDER_DASH_DOT
            @see #BORDER_MEDIUM_DASH_DOT
            @see #BORDER_DASH_DOT_DOT
            @see #BORDER_MEDIUM_DASH_DOT_DOT
            @see #BORDER_SLANTED_DASH_DOT
        </member>
        <member name="P:NPOI.HSSF.Record.CF.BorderFormatting.BorderBottom">
            Get the type of border to use for the bottom border of the cell
            @return border type
            @see #BORDER_NONE
            @see #BORDER_THIN
            @see #BORDER_MEDIUM
            @see #BORDER_DASHED
            @see #BORDER_DOTTED
            @see #BORDER_THICK
            @see #BORDER_DOUBLE
            @see #BORDER_HAIR
            @see #BORDER_MEDIUM_DASHED
            @see #BORDER_DASH_DOT
            @see #BORDER_MEDIUM_DASH_DOT
            @see #BORDER_DASH_DOT_DOT
            @see #BORDER_MEDIUM_DASH_DOT_DOT
            @see #BORDER_SLANTED_DASH_DOT
        </member>
        <member name="P:NPOI.HSSF.Record.CF.BorderFormatting.BorderDiagonal">
            Get the type of border to use for the diagonal border of the cell
            @return border type
            @see #BORDER_NONE
            @see #BORDER_THIN
            @see #BORDER_MEDIUM
            @see #BORDER_DASHED
            @see #BORDER_DOTTED
            @see #BORDER_THICK
            @see #BORDER_DOUBLE
            @see #BORDER_HAIR
            @see #BORDER_MEDIUM_DASHED
            @see #BORDER_DASH_DOT
            @see #BORDER_MEDIUM_DASH_DOT
            @see #BORDER_DASH_DOT_DOT
            @see #BORDER_MEDIUM_DASH_DOT_DOT
            @see #BORDER_SLANTED_DASH_DOT
        </member>
        <member name="P:NPOI.HSSF.Record.CF.BorderFormatting.LeftBorderColor">
            Get the color to use for the left border
            @see org.apache.poi.hssf.usermodel.HSSFPalette#GetColor(short)
            @param color The index of the color definition
        </member>
        <member name="P:NPOI.HSSF.Record.CF.BorderFormatting.RightBorderColor">
            Get the color to use for the right border
            @see org.apache.poi.hssf.usermodel.HSSFPalette#GetColor(short)
            @param color The index of the color definition
        </member>
        <member name="P:NPOI.HSSF.Record.CF.BorderFormatting.TopBorderColor">
            Get the color to use for the top border
            @see org.apache.poi.hssf.usermodel.HSSFPalette#GetColor(short)
            @param color The index of the color definition
        </member>
        <member name="P:NPOI.HSSF.Record.CF.BorderFormatting.BottomBorderColor">
            Get the color to use for the bottom border
            @see org.apache.poi.hssf.usermodel.HSSFPalette#GetColor(short)
            @param color The index of the color definition
        </member>
        <member name="P:NPOI.HSSF.Record.CF.BorderFormatting.DiagonalBorderColor">
            Get the color to use for the diagonal border
            @see org.apache.poi.hssf.usermodel.HSSFPalette#GetColor(short)
            @param color The index of the color definition
        </member>
        <member name="P:NPOI.HSSF.Record.CF.BorderFormatting.IsForwardDiagonalOn">
            @return true if forward diagonal Is on
        </member>
        <member name="P:NPOI.HSSF.Record.CF.BorderFormatting.IsBackwardDiagonalOn">
            @return true if backward diagonal Is on
        </member>
        <member name="T:NPOI.HSSF.Record.CF.CellRangeUtil">
            
            @author Dmitriy Kumshayev
        </member>
        <member name="F:NPOI.HSSF.Record.CF.CellRangeUtil.INSIDE">
            first range is within the second range 
        </member>
        <member name="F:NPOI.HSSF.Record.CF.CellRangeUtil.ENCLOSES">
            first range encloses or is equal to the second 
        </member>
        <member name="M:NPOI.HSSF.Record.CF.CellRangeUtil.Intersect(NPOI.SS.Util.CellRangeAddress,NPOI.SS.Util.CellRangeAddress)">
            Intersect this range with the specified range.
            
            @param crB - the specified range
            @return code which reflects how the specified range is related to this range.<br/>
            Possible return codes are:	
            		NO_INTERSECTION - the specified range is outside of this range;<br/> 
            		OVERLAP - both ranges partially overlap;<br/>
            		INSIDE - the specified range is inside of this one<br/>
            		ENCLOSES - the specified range encloses (possibly exactly the same as) this range<br/>
        </member>
        <member name="M:NPOI.HSSF.Record.CF.CellRangeUtil.MergeCellRanges(NPOI.SS.Util.CellRangeAddress[])">
            Do all possible cell merges between cells of the list so that:
            	if a cell range is completely inside of another cell range, it s removed from the list 
            	if two cells have a shared border, merge them into one bigger cell range
            @param cellRangeList
            @return updated List of cell ranges
        </member>
        <member name="M:NPOI.HSSF.Record.CF.CellRangeUtil.MergeRanges(NPOI.SS.Util.CellRangeAddress,NPOI.SS.Util.CellRangeAddress)">
            @return the new range(s) to replace the supplied ones.  <c>null</c> if no merge is possible
        </member>
        <member name="M:NPOI.HSSF.Record.CF.CellRangeUtil.SliceUp(NPOI.SS.Util.CellRangeAddress,NPOI.SS.Util.CellRangeAddress)">
            @param crB never a full row or full column range
            @return an array including <b>this</b> <tt>CellRange</tt> and all parts of <tt>range</tt> 
            outside of this range  
        </member>
        <member name="M:NPOI.HSSF.Record.CF.CellRangeUtil.Contains(NPOI.SS.Util.CellRangeAddress,NPOI.SS.Util.CellRangeAddress)">
             Check if the specified range is located inside of this cell range.
             
            @param crB
            @return true if this cell range Contains the argument range inside if it's area
        </member>
        <member name="M:NPOI.HSSF.Record.CF.CellRangeUtil.HasExactSharedBorder(NPOI.SS.Util.CellRangeAddress,NPOI.SS.Util.CellRangeAddress)">
            Check if the specified cell range has a shared border with the current range.
            
            @return <c>true</c> if the ranges have a complete shared border (i.e.
            the two ranges toher make a simple rectangular region.
        </member>
        <member name="M:NPOI.HSSF.Record.CF.CellRangeUtil.CreateEnclosingCellRange(NPOI.SS.Util.CellRangeAddress,NPOI.SS.Util.CellRangeAddress)">
            Create an enclosing CellRange for the two cell ranges.
            
            @return enclosing CellRange
        </member>
        <!-- Badly formed XML comment ignored for member "M:NPOI.HSSF.Record.CF.CellRangeUtil.lt(System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:NPOI.HSSF.Record.CF.CellRangeUtil.le(System.Int32,System.Int32)" -->
        <member name="M:NPOI.HSSF.Record.CF.CellRangeUtil.gt(System.Int32,System.Int32)">
            @return true if a > b
        </member>
        <member name="M:NPOI.HSSF.Record.CF.CellRangeUtil.ge(System.Int32,System.Int32)">
            @return true if a >= b
        </member>
        <member name="T:NPOI.HSSF.Record.CF.FontFormatting">
            Font Formatting Block of the Conditional Formatting Rule Record.
            
            @author Dmitriy Kumshayev
        </member>
        <member name="F:NPOI.HSSF.Record.CF.FontFormatting.SS_NONE">
            Escapement type - None 
        </member>
        <member name="F:NPOI.HSSF.Record.CF.FontFormatting.SS_SUPER">
            Escapement type - Superscript 
        </member>
        <member name="F:NPOI.HSSF.Record.CF.FontFormatting.SS_SUB">
            Escapement type - Subscript 
        </member>
        <member name="F:NPOI.HSSF.Record.CF.FontFormatting.U_NONE">
            Underline type - None 
        </member>
        <member name="F:NPOI.HSSF.Record.CF.FontFormatting.U_SINGLE">
            Underline type - Single 
        </member>
        <member name="F:NPOI.HSSF.Record.CF.FontFormatting.U_DOUBLE">
            Underline type - double 
        </member>
        <member name="F:NPOI.HSSF.Record.CF.FontFormatting.U_SINGLE_ACCOUNTING">
            Underline type - Single Accounting 
        </member>
        <member name="F:NPOI.HSSF.Record.CF.FontFormatting.U_DOUBLE_ACCOUNTING">
            Underline type - double Accounting 
        </member>
        <member name="F:NPOI.HSSF.Record.CF.FontFormatting.FONT_WEIGHT_NORMAL">
            Normal boldness (not bold) 
        </member>
        <member name="F:NPOI.HSSF.Record.CF.FontFormatting.FONT_WEIGHT_BOLD">
            Bold boldness (bold)
        </member>
        <member name="M:NPOI.HSSF.Record.CF.FontFormatting.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Creates new FontFormatting 
        </member>
        <member name="P:NPOI.HSSF.Record.CF.FontFormatting.FontHeight">
             Gets the height of the font in 1/20th point Units
            
             @return fontheight (in points/20); or -1 if not modified
        </member>
        <member name="P:NPOI.HSSF.Record.CF.FontFormatting.IsItalic">
             Get whether the font Is to be italics or not
            
             @return italics - whether the font Is italics or not
             @see #GetAttributes()
        </member>
        <member name="P:NPOI.HSSF.Record.CF.FontFormatting.IsStruckout">
             Get whether the font Is to be stricken out or not
            
             @return strike - whether the font Is stricken out or not
             @see #GetAttributes()
        </member>
        <member name="M:NPOI.HSSF.Record.CF.FontFormatting.SetFontWeight(System.Int16)">
             Set the font weight (100-1000dec or 0x64-0x3e8).  Default Is
             0x190 for normal and 0x2bc for bold
            
             @param bw - a number between 100-1000 for the fonts "boldness"
        </member>
        <member name="P:NPOI.HSSF.Record.CF.FontFormatting.FontWeight">
             Get the font weight for this font (100-1000dec or 0x64-0x3e8).  Default Is
             0x190 for normal and 0x2bc for bold
            
             @return bw - a number between 100-1000 for the fonts "boldness"
        </member>
        <member name="P:NPOI.HSSF.Record.CF.FontFormatting.IsBold">
             Get whether the font weight Is Set to bold or not
            
             @return bold - whether the font Is bold or not
        </member>
        <member name="P:NPOI.HSSF.Record.CF.FontFormatting.EscapementType">
             Get the type of base or subscript for the font
            
             @return base or subscript option
             @see org.apache.poi.hssf.usermodel.HSSFFontFormatting#SS_NONE
             @see org.apache.poi.hssf.usermodel.HSSFFontFormatting#SS_SUPER
             @see org.apache.poi.hssf.usermodel.HSSFFontFormatting#SS_SUB
        </member>
        <member name="P:NPOI.HSSF.Record.CF.FontFormatting.UnderlineType">
             Get the type of Underlining for the font
            
             @return font Underlining type
            
             @see org.apache.poi.hssf.usermodel.HSSFFontFormatting#U_NONE
             @see org.apache.poi.hssf.usermodel.HSSFFontFormatting#U_SINGLE
             @see org.apache.poi.hssf.usermodel.HSSFFontFormatting#U_DOUBLE
             @see org.apache.poi.hssf.usermodel.HSSFFontFormatting#U_SINGLE_ACCOUNTING
             @see org.apache.poi.hssf.usermodel.HSSFFontFormatting#U_DOUBLE_ACCOUNTING
        </member>
        <member name="T:NPOI.HSSF.Record.CF.PatternFormatting">
            Pattern Formatting Block of the Conditional Formatting Rule Record.
            
            @author Dmitriy Kumshayev
        </member>
        <member name="F:NPOI.HSSF.Record.CF.PatternFormatting.NO_Fill">
             No background 
        </member>
        <member name="F:NPOI.HSSF.Record.CF.PatternFormatting.SOLID_FOREGROUND">
             Solidly Filled 
        </member>
        <member name="F:NPOI.HSSF.Record.CF.PatternFormatting.FINE_DOTS">
             Small fine dots 
        </member>
        <member name="F:NPOI.HSSF.Record.CF.PatternFormatting.ALT_BARS">
             Wide dots 
        </member>
        <member name="F:NPOI.HSSF.Record.CF.PatternFormatting.SPARSE_DOTS">
             SParse dots 
        </member>
        <member name="F:NPOI.HSSF.Record.CF.PatternFormatting.THICK_HORZ_BANDS">
             Thick horizontal bands 
        </member>
        <member name="F:NPOI.HSSF.Record.CF.PatternFormatting.THICK_VERT_BANDS">
             Thick vertical bands 
        </member>
        <member name="F:NPOI.HSSF.Record.CF.PatternFormatting.THICK_BACKWARD_DIAG">
             Thick backward facing diagonals 
        </member>
        <member name="F:NPOI.HSSF.Record.CF.PatternFormatting.THICK_FORWARD_DIAG">
             Thick forward facing diagonals 
        </member>
        <member name="F:NPOI.HSSF.Record.CF.PatternFormatting.BIG_SPOTS">
             Large spots 
        </member>
        <member name="F:NPOI.HSSF.Record.CF.PatternFormatting.BRICKS">
             Brick-like layout 
        </member>
        <member name="F:NPOI.HSSF.Record.CF.PatternFormatting.THIN_HORZ_BANDS">
             Thin horizontal bands 
        </member>
        <member name="F:NPOI.HSSF.Record.CF.PatternFormatting.THIN_VERT_BANDS">
             Thin vertical bands 
        </member>
        <member name="F:NPOI.HSSF.Record.CF.PatternFormatting.THIN_BACKWARD_DIAG">
             Thin backward diagonal 
        </member>
        <member name="F:NPOI.HSSF.Record.CF.PatternFormatting.THIN_FORWARD_DIAG">
             Thin forward diagonal 
        </member>
        <member name="F:NPOI.HSSF.Record.CF.PatternFormatting.SQUARES">
             Squares 
        </member>
        <member name="F:NPOI.HSSF.Record.CF.PatternFormatting.DIAMONDS">
             Diamonds 
        </member>
        <member name="F:NPOI.HSSF.Record.CF.PatternFormatting.LESS_DOTS">
             Less Dots 
        </member>
        <member name="F:NPOI.HSSF.Record.CF.PatternFormatting.LEAST_DOTS">
             Least Dots 
        </member>
        <member name="M:NPOI.HSSF.Record.CF.PatternFormatting.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Creates new FontFormatting 
        </member>
        <member name="P:NPOI.HSSF.Record.CF.PatternFormatting.FillPattern">
            Get the Fill pattern 
            @return Fill pattern
        </member>
        <member name="P:NPOI.HSSF.Record.CF.PatternFormatting.FillBackgroundColor">
            Get the background Fill color
            @see org.apache.poi.hssf.usermodel.HSSFPalette#GetColor(short)
            @return Fill color
        </member>
        <member name="P:NPOI.HSSF.Record.CF.PatternFormatting.FillForegroundColor">
            Get the foreground Fill color
            @see org.apache.poi.hssf.usermodel.HSSFPalette#GetColor(short)
            @return Fill color
        </member>
        <member name="T:NPOI.HSSF.Record.Chart.AreaFormatRecord">
                 * The area format record is used to define the colours and patterns for an area.
                 * NOTE: This source is automatically generated please do not modify this file.  Either subclass or
                 *       Remove the record in src/records/definitions.
            
                 * @author Glen Stampoultzis (glens at apache.org)
        </member>
        <member name="M:NPOI.HSSF.Record.Chart.AreaFormatRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
             Constructs a AreaFormat record and s its fields appropriately.
            
             @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.AreaFormatRecord.DataSize">
            Size of record (exluding 4 byte header)
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.AreaFormatRecord.ForegroundColor">
            the foreground color field for the AreaFormat record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.AreaFormatRecord.BackgroundColor">
            the background color field for the AreaFormat record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.AreaFormatRecord.Pattern">
            the pattern field for the AreaFormat record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.AreaFormatRecord.FormatFlags">
            the format flags field for the AreaFormat record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.AreaFormatRecord.ForecolorIndex">
            the forecolor index field for the AreaFormat record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.AreaFormatRecord.BackcolorIndex">
            the backcolor index field for the AreaFormat record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.AreaFormatRecord.IsAutomatic">
            automatic formatting
            @return  the automatic field value.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.AreaFormatRecord.IsInvert">
            swap foreground and background colours when data is negative
            @return  the invert field value.
        </member>
        <member name="T:NPOI.HSSF.Record.Chart.AreaRecord">
                 * The area record is used to define a area chart.
                 * NOTE: This source is automatically generated please do not modify this file.  Either subclass or
                 *       Remove the record in src/records/definitions.
            
                 * @author Glen Stampoultzis (glens at apache.org)
        </member>
        <member name="M:NPOI.HSSF.Record.Chart.AreaRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
             Constructs a Area record and s its fields appropriately.
            
             @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.AreaRecord.DataSize">
            Size of record (exluding 4 byte header)
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.AreaRecord.FormatFlags">
            the format flags field for the Area record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.AreaRecord.IsStacked">
            series is stacked
            @return  the stacked field value.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.AreaRecord.IsDisplayAsPercentage">
            results Displayed as percentages
            @return  the Display as percentage field value.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.AreaRecord.IsShadow">
            Display a shadow for the chart
            @return  the shadow field value.
        </member>
        <member name="T:NPOI.HSSF.Record.Chart.AxisLineFormatRecord">
                 * The axis line format record defines the axis type details.
                 * NOTE: This source is automatically generated please do not modify this file.  Either subclass or
                 *       Remove the record in src/records/definitions.
            
                 * @author Glen Stampoultzis (glens at apache.org)
        </member>
        <member name="M:NPOI.HSSF.Record.Chart.AxisLineFormatRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
             Constructs a AxisLineFormat record and Sets its fields appropriately.
            
             @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.AxisLineFormatRecord.DataSize">
            Size of record (exluding 4 byte header)
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.AxisLineFormatRecord.AxisType">
             Get the axis type field for the AxisLineFormat record.
            
             @return  One of 
                    AXIS_TYPE_AXIS_LINE
                    AXIS_TYPE_MAJOR_GRID_LINE
                    AXIS_TYPE_MINOR_GRID_LINE
                    AXIS_TYPE_WALLS_OR_FLOOR
        </member>
        <member name="T:NPOI.HSSF.Record.Chart.AxisOptionsRecord">
                 * The axis options record provides Unit information and other various tidbits about the axis.
                 * NOTE: This source is automatically generated please do not modify this file.  Either subclass or
                 *       Remove the record in src/records/definitions.
            
                 * @author Andrew C. Oliver(acoliver at apache.org)
        </member>
        <member name="M:NPOI.HSSF.Record.Chart.AxisOptionsRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
             Constructs a AxisOptions record and Sets its fields appropriately.
            
             @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.AxisOptionsRecord.DataSize">
            Size of record (exluding 4 byte header)
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.AxisOptionsRecord.MinimumCategory">
            Get the minimum category field for the AxisOptions record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.AxisOptionsRecord.MaximumCategory">
            Get the maximum category field for the AxisOptions record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.AxisOptionsRecord.MajorUnitValue">
            Get the major Unit value field for the AxisOptions record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.AxisOptionsRecord.MajorUnit">
            Get the major Unit field for the AxisOptions record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.AxisOptionsRecord.MinorUnitValue">
            Get the minor Unit value field for the AxisOptions record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.AxisOptionsRecord.MinorUnit">
            Get the minor Unit field for the AxisOptions record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.AxisOptionsRecord.BaseUnit">
            Get the base Unit field for the AxisOptions record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.AxisOptionsRecord.CrossingPoint">
            Get the crossing point field for the AxisOptions record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.AxisOptionsRecord.Options">
            Get the options field for the AxisOptions record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.AxisOptionsRecord.IsDefaultMinimum">
            use the default minimum category
            @return  the default minimum field value.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.AxisOptionsRecord.IsDefaultMaximum">
            use the default maximum category
            @return  the default maximum field value.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.AxisOptionsRecord.IsDefaultMajor">
            use the default major Unit
            @return  the default major field value.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.AxisOptionsRecord.IsDefaultMinorUnit">
            use the default minor Unit
            @return  the default minor Unit field value.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.AxisOptionsRecord.IsDate">
            this is a date axis
            @return  the IsDate field value.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.AxisOptionsRecord.IsDefaultBase">
            use the default base Unit
            @return  the default base field value.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.AxisOptionsRecord.IsDefaultCross">
            use the default crossing point
            @return  the default cross field value.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.AxisOptionsRecord.IsDefaultDateSettings">
            use default date Setttings for this axis
            @return  the default date Settings field value.
        </member>
        <member name="T:NPOI.HSSF.Record.Chart.AxisParentRecord">
                 * The axis size and location
                 * NOTE: This source is automatically generated please do not modify this file.  Either subclass or
                 *       Remove the record in src/records/definitions.
            
                 * @author Glen Stampoultzis (glens at apache.org)
        </member>
        <member name="M:NPOI.HSSF.Record.Chart.AxisParentRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
             Constructs a AxisParent record and s its fields appropriately.
            
             @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.AxisParentRecord.DataSize">
            Size of record (exluding 4 byte header)
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.AxisParentRecord.AxisType">
              the axis type field for the AxisParent record.
            
             @return  One of 
                    AXIS_TYPE_MAIN
                    AXIS_TYPE_SECONDARY
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.AxisParentRecord.X">
            the x field for the AxisParent record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.AxisParentRecord.Y">
            the y field for the AxisParent record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.AxisParentRecord.Width">
            the width field for the AxisParent record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.AxisParentRecord.Height">
            the height field for the AxisParent record.
        </member>
        <member name="T:NPOI.HSSF.Record.Chart.AxisRecord">
                 * The axis record defines the type of an axis.
                 * NOTE: This source is automatically generated please do not modify this file.  Either subclass or
                 *       Remove the record in src/records/definitions.
            
                 * @author Glen Stampoultzis (glens at apache.org)
        </member>
        <member name="M:NPOI.HSSF.Record.Chart.AxisRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
             Constructs a Axis record and Sets its fields appropriately.
            
             @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.AxisRecord.DataSize">
            Size of record (exluding 4 byte header)
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.AxisRecord.AxisType">
             Get the axis type field for the Axis record.
            
             @return  One of 
                    AXIS_TYPE_CATEGORY_OR_X_AXIS
                    AXIS_TYPE_VALUE_AXIS
                    AXIS_TYPE_SERIES_AXIS
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.AxisRecord.Reserved1">
            Get the reserved1 field for the Axis record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.AxisRecord.Reserved2">
            Get the reserved2 field for the Axis record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.AxisRecord.Reserved3">
            Get the reserved3 field for the Axis record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.AxisRecord.Reserved4">
            Get the reserved4 field for the Axis record.
        </member>
        <member name="T:NPOI.HSSF.Record.Chart.AxisUsedRecord">
                 * The number of axes used on a chart.
                 * NOTE: This source is automatically generated please do not modify this file.  Either subclass or
                 *       Remove the record in src/records/definitions.
            
                 * @author Glen Stampoultzis (glens at apache.org)
        </member>
        <member name="M:NPOI.HSSF.Record.Chart.AxisUsedRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
             Constructs a AxisUsed record and Sets its fields appropriately.
            
             @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.AxisUsedRecord.DataSize">
            Size of record (exluding 4 byte header)
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.AxisUsedRecord.NumAxis">
            Get the num axis field for the AxisUsed record.
        </member>
        <member name="T:NPOI.HSSF.Record.Chart.BarRecord">
                 * The bar record is used to define a bar chart.
                 * NOTE: This source is automatically generated please do not modify this file.  Either subclass or
                 *       Remove the record in src/records/definitions.
            
                 * @author Glen Stampoultzis (glens at apache.org)
        </member>
        <member name="M:NPOI.HSSF.Record.Chart.BarRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
             Constructs a Bar record and s its fields appropriately.
            
             @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.BarRecord.DataSize">
            Size of record (exluding 4 byte header)
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.BarRecord.BarSpace">
            the bar space field for the Bar record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.BarRecord.CategorySpace">
            the category space field for the Bar record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.BarRecord.FormatFlags">
            the format flags field for the Bar record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.BarRecord.IsHorizontal">
            true to Display horizontal bar charts, false for vertical
            @return  the horizontal field value.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.BarRecord.IsStacked">
            stack Displayed values
            @return  the stacked field value.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.BarRecord.IsDisplayAsPercentage">
            Display chart values as a percentage
            @return  the Display as percentage field value.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.BarRecord.IsShadow">
            Display a shadow for the chart
            @return  the shadow field value.
        </member>
        <member name="T:NPOI.HSSF.Record.Chart.BeginRecord">
             The begin record defines the start of a block of records for a (grpahing
             data object. This record is matched with a corresponding EndRecord.
            
             @see EndRecord
            
             @author Glen Stampoultzis (glens at apache.org)
        </member>
        <member name="M:NPOI.HSSF.Record.Chart.BeginRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Constructs a BeginRecord record and Sets its fields appropriately.
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="T:NPOI.HSSF.Record.Chart.CategorySeriesAxisRecord">
                 * This record refers to a category or series axis and is used to specify label/tickmark frequency.
                 * NOTE: This source is automatically generated please do not modify this file.  Either subclass or
                 *       Remove the record in src/records/definitions.
            
                 * @author Glen Stampoultzis (glens at apache.org)
        </member>
        <member name="M:NPOI.HSSF.Record.Chart.CategorySeriesAxisRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
             Constructs a CategorySeriesAxis record and Sets its fields appropriately.
            
             @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.CategorySeriesAxisRecord.DataSize">
            Size of record (exluding 4 byte header)
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.CategorySeriesAxisRecord.CrossingPoint">
            Get the crossing point field for the CategorySeriesAxis record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.CategorySeriesAxisRecord.LabelFrequency">
            Get the label frequency field for the CategorySeriesAxis record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.CategorySeriesAxisRecord.TickMarkFrequency">
            Get the tick mark frequency field for the CategorySeriesAxis record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.CategorySeriesAxisRecord.Options">
            Get the options field for the CategorySeriesAxis record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.CategorySeriesAxisRecord.IsValueAxisCrossing">
            Set true to indicate axis crosses between categories and false to cross axis midway
            @return  the value axis crossing field value.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.CategorySeriesAxisRecord.IsCrossesFarRight">
            axis crosses at the far right
            @return  the crosses far right field value.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.CategorySeriesAxisRecord.IsReversed">
            categories are Displayed in reverse order
            @return  the reversed field value.
        </member>
        <member name="T:NPOI.HSSF.Record.Chart.CatLabRecord">
            CATLAB - Category Labels (0x0856)<br/>
            
            @author Patrick Cheng
        </member>
        <member name="T:NPOI.HSSF.Record.Chart.ChartEndBlockRecord">
            ENDBLOCK - Chart Future Record Type End Block (0x0853)<br/>
            
            @author Patrick Cheng
        </member>
        <member name="T:NPOI.HSSF.Record.Chart.ChartEndObjectRecord">
            ENDOBJECT - Chart Future Record Type End Object (0x0855)<br/>
            
            @author Patrick Cheng
        </member>
        <member name="T:NPOI.HSSF.Record.Chart.ChartFRTInfoRecord">
            CHARTFRTINFO - Chart Future Record Type Info (0x0850)<br/>
            
            @author Patrick Cheng
        </member>
        <member name="T:NPOI.HSSF.Record.Chart.ChartRecord">
                 * The chart record is used to define the location and size of a chart.
                 * NOTE: This source is automatically generated please do not modify this file.  Either subclass or
                 *       Remove the record in src/records/definitions.
            
                 * @author Glen Stampoultzis (glens at apache.org)
        </member>
        <member name="M:NPOI.HSSF.Record.Chart.ChartRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
             Constructs a Chart record and Sets its fields appropriately.
            
             @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.ChartRecord.DataSize">
            Size of record (exluding 4 byte header)
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.ChartRecord.X">
            Get the x field for the Chart record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.ChartRecord.Y">
            Get the y field for the Chart record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.ChartRecord.Width">
            Get the width field for the Chart record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.ChartRecord.Height">
            Get the height field for the Chart record.
        </member>
        <member name="T:NPOI.HSSF.Record.Chart.ChartStartBlockRecord">
            STARTBLOCK - Chart Future Record Type Start Block (0x0852)<br/>
            
            @author Patrick Cheng
        </member>
        <member name="T:NPOI.HSSF.Record.Chart.ChartStartObjectRecord">
            STARTOBJECT - Chart Future Record Type Start Object (0x0854)<br/>
            
            @author Patrick Cheng
        </member>
        <member name="T:NPOI.HSSF.Record.Chart.ChartTitleFormatRecord">
            Describes the formatting runs associated with a chart title.
        </member>
        <member name="T:NPOI.HSSF.Record.Chart.DataFormatRecord">
                 * The data format record is used to index into a series.
                 * NOTE: This source is automatically generated please do not modify this file.  Either subclass or
                 *       Remove the record in src/records/definitions.
            
                 * @author Glen Stampoultzis (glens at apache.org)
        </member>
        <member name="M:NPOI.HSSF.Record.Chart.DataFormatRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
             Constructs a DataFormat record and Sets its fields appropriately.
            
             @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.DataFormatRecord.DataSize">
            Size of record (exluding 4 byte header)
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.DataFormatRecord.PointNumber">
            Get the point number field for the DataFormat record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.DataFormatRecord.SeriesIndex">
            Get the series index field for the DataFormat record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.DataFormatRecord.SeriesNumber">
            Get the series number field for the DataFormat record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.DataFormatRecord.FormatFlags">
            Get the format flags field for the DataFormat record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.DataFormatRecord.UseExcel4Colors">
            Set true to use excel 4 colors.
            @return  the use excel 4 colors field value.
        </member>
        <member name="T:NPOI.HSSF.Record.Chart.DataLabelExtensionRecord">
            DATALABEXT - Chart Data Label Extension (0x086A) <br/>
            
            @author Patrick Cheng
        </member>
        <member name="T:NPOI.HSSF.Record.Chart.DatRecord">
                 * The dat record is used to store options for the chart.
                 * NOTE: This source is automatically generated please do not modify this file.  Either subclass or
                 *       Remove the record in src/records/definitions.
            
                 * @author Glen Stampoultzis (glens at apache.org)
        </member>
        <member name="M:NPOI.HSSF.Record.Chart.DatRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
             Constructs a Dat record and Sets its fields appropriately.
            
             @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.DatRecord.DataSize">
            Size of record (exluding 4 byte header)
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.DatRecord.Options">
            Get the options field for the Dat record.
        </member>
        <member name="M:NPOI.HSSF.Record.Chart.DatRecord.SetHorizontalBorder(System.Boolean)">
            Sets the horizontal border field value.
            has a horizontal border
        </member>
        <member name="M:NPOI.HSSF.Record.Chart.DatRecord.IsHorizontalBorder">
            has a horizontal border
            @return  the horizontal border field value.
        </member>
        <member name="M:NPOI.HSSF.Record.Chart.DatRecord.SetVerticalBorder(System.Boolean)">
            Sets the vertical border field value.
            has vertical border
        </member>
        <member name="M:NPOI.HSSF.Record.Chart.DatRecord.IsVerticalBorder">
            has vertical border
            @return  the vertical border field value.
        </member>
        <member name="M:NPOI.HSSF.Record.Chart.DatRecord.SetBorder(System.Boolean)">
            Sets the border field value.
            data table has a border
        </member>
        <member name="M:NPOI.HSSF.Record.Chart.DatRecord.IsBorder">
            data table has a border
            @return  the border field value.
        </member>
        <member name="M:NPOI.HSSF.Record.Chart.DatRecord.SetShowSeriesKey(System.Boolean)">
            Sets the show series key field value.
            shows the series key
        </member>
        <member name="M:NPOI.HSSF.Record.Chart.DatRecord.IsShowSeriesKey">
            shows the series key
            @return  the show series key field value.
        </member>
        <member name="T:NPOI.HSSF.Record.Chart.DefaultDataLabelTextPropertiesRecord">
                 * The default data label text properties record identifies the text Charistics of the preceeding text record.
                 * NOTE: This source is automatically generated please do not modify this file.  Either subclass or
                 *       Remove the record in src/records/definitions.
            
                 * @author Glen Stampoultzis (glens at apache.org)
        </member>
        <member name="M:NPOI.HSSF.Record.Chart.DefaultDataLabelTextPropertiesRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
             Constructs a DefaultDataLabelTextProperties record and Sets its fields appropriately.
            
             @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.DefaultDataLabelTextPropertiesRecord.DataSize">
            Size of record (exluding 4 byte header)
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.DefaultDataLabelTextPropertiesRecord.CategoryDataType">
             Get the category data type field for the DefaultDataLabelTextProperties record.
            
             @return  One of 
                    CATEGORY_DATA_TYPE_SHOW_LABELS_CharISTIC
                    CATEGORY_DATA_TYPE_VALUE_AND_PERCENTAGE_CharISTIC
                    CATEGORY_DATA_TYPE_ALL_TEXT_CharISTIC
        </member>
        <member name="T:NPOI.HSSF.Record.Chart.EndRecord">
             The end record defines the end of a block of records for a (Graphing)
             data object. This record is matched with a corresponding BeginRecord.
            
             @see BeginRecord
            
             @author Glen Stampoultzis (glens at apache.org)
        </member>
        <member name="M:NPOI.HSSF.Record.Chart.EndRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Constructs a EndRecord record and Sets its fields appropriately.
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="T:NPOI.HSSF.Record.Chart.FontBasisRecord">
                 * The font basis record stores various font metrics.
                 * NOTE: This source is automatically generated please do not modify this file.  Either subclass or
                 *       Remove the record in src/records/definitions.
            
                 * @author Glen Stampoultzis (glens at apache.org)
        </member>
        <member name="M:NPOI.HSSF.Record.Chart.FontBasisRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
             Constructs a FontBasis record and Sets its fields appropriately.
            
             @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.FontBasisRecord.DataSize">
            Size of record (exluding 4 byte header)
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.FontBasisRecord.XBasis">
            Get the x Basis field for the FontBasis record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.FontBasisRecord.YBasis">
            Get the y Basis field for the FontBasis record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.FontBasisRecord.HeightBasis">
            Get the height basis field for the FontBasis record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.FontBasisRecord.Scale">
            Get the scale field for the FontBasis record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.FontBasisRecord.IndexToFontTable">
            Get the index to font table field for the FontBasis record.
        </member>
        <member name="T:NPOI.HSSF.Record.Chart.FontIndexRecord">
                 * The font index record indexes into the font table for the text record.
                 * NOTE: This source is automatically generated please do not modify this file.  Either subclass or
                 *       Remove the record in src/records/definitions.
            
                 * @author Glen Stampoultzis (glens at apache.org)
        </member>
        <member name="M:NPOI.HSSF.Record.Chart.FontIndexRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
             Constructs a FontIndex record and Sets its fields appropriately.
            
             @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.FontIndexRecord.DataSize">
            Size of record (exluding 4 byte header)
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.FontIndexRecord.FontIndex">
            Get the font index field for the FontIndex record.
        </member>
        <member name="T:NPOI.HSSF.Record.Chart.FrameRecord">
                 * The frame record indicates whether there is a border around the Displayed text of a chart.
                 * NOTE: This source is automatically generated please do not modify this file.  Either subclass or
                 *       Remove the record in src/records/definitions.
            
                 * @author Glen Stampoultzis (glens at apache.org)
        </member>
        <member name="M:NPOI.HSSF.Record.Chart.FrameRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
             Constructs a Frame record and Sets its fields appropriately.
            
             @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.FrameRecord.DataSize">
            Size of record (exluding 4 byte header)
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.FrameRecord.BorderType">
             Get the border type field for the Frame record.
            
             @return  One of 
                    BORDER_TYPE_REGULAR
                    BORDER_TYPE_SHADOW
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.FrameRecord.Options">
            Get the options field for the Frame record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.FrameRecord.IsAutoSize">
            excel calculates the size automatically if true
            @return  the auto size field value.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.FrameRecord.IsAutoPosition">
            excel calculates the position automatically
            @return  the auto position field value.
        </member>
        <member name="T:NPOI.HSSF.Record.Chart.LegendRecord">
                 * Defines a legend for a chart.
                 * NOTE: This source is automatically generated please do not modify this file.  Either subclass or
                 *       Remove the record in src/records/definitions.
            
                 * @author Andrew C. Oliver (acoliver at apache.org)
        </member>
        <member name="M:NPOI.HSSF.Record.Chart.LegendRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
             Constructs a Legend record and Sets its fields appropriately.
            
             @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.LegendRecord.DataSize">
            Size of record (exluding 4 byte header)
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.LegendRecord.XAxisUpperLeft">
            Get the x axis upper left field for the Legend record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.LegendRecord.YAxisUpperLeft">
            Get the y axis upper left field for the Legend record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.LegendRecord.XSize">
            Get the x size field for the Legend record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.LegendRecord.YSize">
            Get the y size field for the Legend record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.LegendRecord.Type">
             Get the type field for the Legend record.
            
             @return  One of 
                    TYPE_BOTTOM
                    TYPE_CORNER
                    TYPE_TOP
                    TYPE_RIGHT
                    TYPE_LEFT
                    TYPE_UNDOCKED
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.LegendRecord.Spacing">
             Get the spacing field for the Legend record.
            
             @return  One of 
                    SPACING_CLOSE
                    SPACING_MEDIUM
                    SPACING_OPEN
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.LegendRecord.Options">
            Get the options field for the Legend record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.LegendRecord.IsAutoPosition">
            automatic positioning (1=docked)
            @return  the auto position field value.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.LegendRecord.IsAutoSeries">
            excel 5 only (true)
            @return  the auto series field value.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.LegendRecord.IsAutoXPositioning">
            position of legend on the x axis is automatic
            @return  the auto x positioning field value.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.LegendRecord.IsAutoYPositioning">
            position of legend on the y axis is automatic
            @return  the auto y positioning field value.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.LegendRecord.IsVertical">
            vertical or horizontal legend (1 or 0 respectively).  Always 0 if not automatic.
            @return  the vertical field value.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.LegendRecord.IsDataTable">
            1 if chart Contains data table
            @return  the data table field value.
        </member>
        <member name="T:NPOI.HSSF.Record.Chart.LineFormatRecord">
                 * Describes a line format record.  The line format record controls how a line on a chart appears.
                 * NOTE: This source is automatically generated please do not modify this file.  Either subclass or
                 *       Remove the record in src/records/definitions.
            
                 * @author Glen Stampoultzis (glens at apache.org)
        </member>
        <member name="M:NPOI.HSSF.Record.Chart.LineFormatRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
             Constructs a LineFormat record and Sets its fields appropriately.
            
             @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.LineFormatRecord.DataSize">
            Size of record (exluding 4 byte header)
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.LineFormatRecord.LineColor">
            Get the line color field for the LineFormat record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.LineFormatRecord.LinePattern">
             Get the line pattern field for the LineFormat record.
            
             @return  One of 
                    LINE_PATTERN_SOLID
                    LINE_PATTERN_DASH
                    LINE_PATTERN_DOT
                    LINE_PATTERN_DASH_DOT
                    LINE_PATTERN_DASH_DOT_DOT
                    LINE_PATTERN_NONE
                    LINE_PATTERN_DARK_GRAY_PATTERN
                    LINE_PATTERN_MEDIUM_GRAY_PATTERN
                    LINE_PATTERN_LIGHT_GRAY_PATTERN
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.LineFormatRecord.Weight">
             Get the weight field for the LineFormat record.
            
             @return  One of 
                    WEIGHT_HAIRLINE
                    WEIGHT_NARROW
                    WEIGHT_MEDIUM
                    WEIGHT_WIDE
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.LineFormatRecord.Format">
            Get the format field for the LineFormat record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.LineFormatRecord.ColourPaletteIndex">
            Get the colour palette index field for the LineFormat record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.LineFormatRecord.IsAuto">
            automatic format
            @return  the auto field value.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.LineFormatRecord.IsDrawTicks">
            draw tick marks
            @return  the draw ticks field value.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.LineFormatRecord.IsUnknown">
            book marks this as reserved = 0 but it seems to do something
            @return  the Unknown field value.
        </member>
        <member name="T:NPOI.HSSF.Record.Chart.LinkedDataRecord">
                 * Describes a linked data record.  This record referes to the series data or text.
                 * NOTE: This source is automatically generated please do not modify this file.  Either subclass or
                 *       Remove the record in src/records/definitions.
            
                 * @author Glen Stampoultzis (glens at apache.org)
        </member>
        <member name="M:NPOI.HSSF.Record.Chart.LinkedDataRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
             Constructs a LinkedData record and Sets its fields appropriately.
            
             @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.LinkedDataRecord.DataSize">
            Size of record (exluding 4 byte header)
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.LinkedDataRecord.LinkType">
             Get the link type field for the LinkedData record.
            
             @return  One of 
                    LINK_TYPE_TITLE_OR_TEXT
                    LINK_TYPE_VALUES
                    LINK_TYPE_CATEGORIES
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.LinkedDataRecord.ReferenceType">
             Get the reference type field for the LinkedData record.
            
             @return  One of 
                    REFERENCE_TYPE_DEFAULT_CATEGORIES
                    REFERENCE_TYPE_DIRECT
                    REFERENCE_TYPE_WORKSHEET
                    REFERENCE_TYPE_NOT_USED
                    REFERENCE_TYPE_ERROR_REPORTED
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.LinkedDataRecord.Options">
            Get the options field for the LinkedData record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.LinkedDataRecord.IndexNumberFmtRecord">
            Get the index number fmt record field for the LinkedData record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.LinkedDataRecord.FormulaOfLink">
            Get the formula of link field for the LinkedData record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.LinkedDataRecord.IsCustomNumberFormat">
            true if this object has a custom number format
            @return  the custom number format field value.
        </member>
        <member name="T:NPOI.HSSF.Record.Chart.NumberFormatIndexRecord">
                 * The number format index record indexes format table.  This applies to an axis.
                 * NOTE: This source is automatically generated please do not modify this file.  Either subclass or
                 *       Remove the record in src/records/definitions.
            
                 * @author Glen Stampoultzis (glens at apache.org)
        </member>
        <member name="M:NPOI.HSSF.Record.Chart.NumberFormatIndexRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
             Constructs a NumberFormatIndex record and Sets its fields appropriately.
            
             @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.NumberFormatIndexRecord.DataSize">
            Size of record (exluding 4 byte header)
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.NumberFormatIndexRecord.FormatIndex">
            Get the format index field for the NumberFormatIndex record.
        </member>
        <member name="T:NPOI.HSSF.Record.Chart.ObjectLinkRecord">
                 * Links text to an object on the chart or identifies it as the title.
                 * NOTE: This source is automatically generated please do not modify this file.  Either subclass or
                 *       Remove the record in src/records/definitions.
            
                 * @author Andrew C. Oliver (acoliver at apache.org)
        </member>
        <member name="M:NPOI.HSSF.Record.Chart.ObjectLinkRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
             Constructs a ObjectLink record and Sets its fields appropriately.
            
             @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.ObjectLinkRecord.DataSize">
            Size of record (exluding 4 byte header)
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.ObjectLinkRecord.AnchorId">
             Get the anchor id field for the ObjectLink record.
            
             @return  One of 
                    ANCHOR_ID_CHART_TITLE
                    ANCHOR_ID_Y_AXIS
                    ANCHOR_ID_X_AXIS
                    ANCHOR_ID_SERIES_OR_POINT
                    ANCHOR_ID_Z_AXIS
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.ObjectLinkRecord.Link1">
            Get the link 1 field for the ObjectLink record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.ObjectLinkRecord.Link2">
            Get the link 2 field for the ObjectLink record.
        </member>
        <member name="T:NPOI.HSSF.Record.Chart.PlotAreaRecord">
                 * preceeds and identifies a frame as belonging to the plot area.
                 * NOTE: This source is automatically generated please do not modify this file.  Either subclass or
                 *       Remove the record in src/records/definitions.
            
                 * @author Andrew C. Oliver (acoliver at apache.org)
        </member>
        <member name="M:NPOI.HSSF.Record.Chart.PlotAreaRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
             Constructs a PlotArea record and Sets its fields appropriately.
            
             @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.PlotAreaRecord.DataSize">
            Size of record (exluding 4 byte header)
        </member>
        <member name="T:NPOI.HSSF.Record.Chart.PlotGrowthRecord">
                 * The plot growth record specifies the scaling factors used when a font is scaled.
                 * NOTE: This source is automatically generated please do not modify this file.  Either subclass or
                 *       Remove the record in src/records/definitions.
            
                 * @author Glen Stampoultzis (glens at apache.org)
        </member>
        <member name="M:NPOI.HSSF.Record.Chart.PlotGrowthRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
             Constructs a PlotGrowth record and Sets its fields appropriately.
            
             @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.PlotGrowthRecord.DataSize">
            Size of record (exluding 4 byte header)
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.PlotGrowthRecord.HorizontalScale">
            Get the horizontalScale field for the PlotGrowth record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.PlotGrowthRecord.VerticalScale">
            Get the verticalScale field for the PlotGrowth record.
        </member>
        <member name="T:NPOI.HSSF.Record.Chart.SeriesChartGroupIndexRecord">
                 * The series chart Group index record stores the index to the CHARTFORMAT record (0 based).
                 * NOTE: This source is automatically generated please do not modify this file.  Either subclass or
                 *       Remove the record in src/records/definitions.
            
                 * @author Glen Stampoultzis (glens at apache.org)
        </member>
        <member name="M:NPOI.HSSF.Record.Chart.SeriesChartGroupIndexRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
             Constructs a SeriesChartGroupIndex record and Sets its fields appropriately.
            
             @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.SeriesChartGroupIndexRecord.DataSize">
            Size of record (exluding 4 byte header)
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.SeriesChartGroupIndexRecord.ChartGroupIndex">
            Get the chart Group index field for the SeriesChartGroupIndex record.
        </member>
        <member name="T:NPOI.HSSF.Record.Chart.SeriesIndexRecord">
                 * links a series to its position in the series list.
                 * NOTE: This source is automatically generated please do not modify this file.  Either subclass or
                 *       Remove the record in src/records/definitions.
            
                 * @author Andrew C. Oliver (acoliver at apache.org)
        </member>
        <member name="M:NPOI.HSSF.Record.Chart.SeriesIndexRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
             Constructs a SeriesIndex record and Sets its fields appropriately.
            
             @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.SeriesIndexRecord.DataSize">
            Size of record (exluding 4 byte header)
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.SeriesIndexRecord.Index">
            Get the index field for the SeriesIndex record.
        </member>
        <member name="T:NPOI.HSSF.Record.Chart.SeriesLabelsRecord">
                 * The series label record defines the type of label associated with the data format record.
                 * NOTE: This source is automatically generated please do not modify this file.  Either subclass or
                 *       Remove the record in src/records/definitions.
            
                 * @author Glen Stampoultzis (glens at apache.org)
        </member>
        <member name="M:NPOI.HSSF.Record.Chart.SeriesLabelsRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
             Constructs a SeriesLabels record and Sets its fields appropriately.
            
             @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.SeriesLabelsRecord.DataSize">
            Size of record (exluding 4 byte header)
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.SeriesLabelsRecord.FormatFlags">
            Get the format flags field for the SeriesLabels record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.SeriesLabelsRecord.IsShowActual">
            show actual value of the data point
            @return  the show actual field value.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.SeriesLabelsRecord.IsShowPercent">
            show value as percentage of total (pie charts only)
            @return  the show percent field value.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.SeriesLabelsRecord.IsLabelAsPercentage">
            show category label/value as percentage (pie charts only)
            @return  the label as percentage field value.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.SeriesLabelsRecord.IsSmoothedLine">
            show smooth line
            @return  the smoothed line field value.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.SeriesLabelsRecord.IsShowLabel">
            Display category label
            @return  the show label field value.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.SeriesLabelsRecord.IsShowBubbleSizes">
            ??
            @return  the show bubble sizes field value.
        </member>
        <member name="T:NPOI.HSSF.Record.Chart.SeriesListRecord">
                 * The series list record defines the series Displayed as an overlay to the main chart record.
                 * NOTE: This source is automatically generated please do not modify this file.  Either subclass or
                 *       Remove the record in src/records/definitions.
            
                 * @author Glen Stampoultzis (glens at apache.org)
        </member>
        <member name="M:NPOI.HSSF.Record.Chart.SeriesListRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
             Constructs a SeriesList record and Sets its fields appropriately.
            
             @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.SeriesListRecord.DataSize">
            Size of record (exluding 4 byte header)
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.SeriesListRecord.SeriesNumbers">
            Get the series numbers field for the SeriesList record.
        </member>
        <member name="T:NPOI.HSSF.Record.Chart.SeriesRecord">
                 * The series record describes the overall data for a series.
                 * NOTE: This source is automatically generated please do not modify this file.  Either subclass or
                 *       Remove the record in src/records/definitions.
            
                 * @author Glen Stampoultzis (glens at apache.org)
        </member>
        <member name="M:NPOI.HSSF.Record.Chart.SeriesRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
             Constructs a Series record and Sets its fields appropriately.
            
             @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.SeriesRecord.DataSize">
            Size of record (exluding 4 byte header)
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.SeriesRecord.CategoryDataType">
             Get the category data type field for the Series record.
            
             @return  One of 
                    CATEGORY_DATA_TYPE_DATES
                    CATEGORY_DATA_TYPE_NUMERIC
                    CATEGORY_DATA_TYPE_SEQUENCE
                    CATEGORY_DATA_TYPE_TEXT
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.SeriesRecord.ValuesDataType">
             Get the values data type field for the Series record.
            
             @return  One of 
                    VALUES_DATA_TYPE_DATES
                    VALUES_DATA_TYPE_NUMERIC
                    VALUES_DATA_TYPE_SEQUENCE
                    VALUES_DATA_TYPE_TEXT
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.SeriesRecord.NumCategories">
            Get the num categories field for the Series record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.SeriesRecord.NumValues">
            Get the num values field for the Series record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.SeriesRecord.BubbleSeriesType">
             Get the bubble series type field for the Series record.
            
             @return  One of 
                    BUBBLE_SERIES_TYPE_DATES
                    BUBBLE_SERIES_TYPE_NUMERIC
                    BUBBLE_SERIES_TYPE_SEQUENCE
                    BUBBLE_SERIES_TYPE_TEXT
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.SeriesRecord.NumBubbleValues">
            Get the num bubble values field for the Series record.
        </member>
        <member name="T:NPOI.HSSF.Record.Chart.SeriesTextRecord">
                 * Defines a series name
                 * NOTE: This source is automatically generated please do not modify this file.  Either subclass or
                 *       Remove the record in src/records/definitions.
            
                 * @author Andrew C. Oliver (acoliver at apache.org)
        </member>
        <member name="F:NPOI.HSSF.Record.Chart.SeriesTextRecord.MAX_LEN">
            the actual text cannot be longer than 255 characters 
        </member>
        <member name="M:NPOI.HSSF.Record.Chart.SeriesTextRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
             Constructs a SeriesText record and Sets its fields appropriately.
            
             @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.SeriesTextRecord.DataSize">
            Size of record (exluding 4 byte header)
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.SeriesTextRecord.Id">
            Get the id field for the SeriesText record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.SeriesTextRecord.Text">
            Get the text field for the SeriesText record.
        </member>
        <member name="T:NPOI.HSSF.Record.Chart.SeriesToChartGroupRecord">
                 * Indicates the chart-group index for a series.  The order probably defines the mapping.  So the 0th record probably means the 0th series.  The only field in this of course defines which chart Group the 0th series (for instance) would map to.  Confusing?  Well thats because it Is.  (p 522 BCG)
                 * NOTE: This source is automatically generated please do not modify this file.  Either subclass or
                 *       Remove the record in src/records/definitions.
            
                 * @author Andrew C. Oliver (acoliver at apache.org)
        </member>
        <member name="M:NPOI.HSSF.Record.Chart.SeriesToChartGroupRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
             Constructs a SeriesToChartGroup record and Sets its fields appropriately.
            
             @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.SeriesToChartGroupRecord.DataSize">
            Size of record (exluding 4 byte header)
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.SeriesToChartGroupRecord.ChartGroupIndex">
            Get the chart Group index field for the SeriesToChartGroup record.
        </member>
        <member name="T:NPOI.HSSF.Record.Chart.SheetPropertiesRecord">
                 * Describes a chart sheet properties record.
                 * NOTE: This source is automatically generated please do not modify this file.  Either subclass or
                 *       Remove the record in src/records/definitions.
            
                 * @author Glen Stampoultzis (glens at apache.org)
        </member>
        <member name="M:NPOI.HSSF.Record.Chart.SheetPropertiesRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
             Constructs a SheetProperties record and Sets its fields appropriately.
            
             @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.SheetPropertiesRecord.DataSize">
            Size of record (exluding 4 byte header)
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.SheetPropertiesRecord.Flags">
            Get the flags field for the SheetProperties record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.SheetPropertiesRecord.Empty">
             Get the empty field for the SheetProperties record.
            
             @return  One of 
                    EMPTY_NOT_PLOTTED
                    EMPTY_ZERO
                    EMPTY_INTERPOLATED
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.SheetPropertiesRecord.IsChartTypeManuallyFormatted">
            Has the chart type been manually formatted?
            @return  the chart type manually formatted field value.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.SheetPropertiesRecord.IsPlotVisibleOnly">
            Only show visible cells on the chart.
            @return  the plot visible only field value.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.SheetPropertiesRecord.IsDoNotSizeWithWindow">
            Do not size the chart when the window Changes size
            @return  the do not size with window field value.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.SheetPropertiesRecord.IsDefaultPlotDimensions">
            Indicates that the default area dimensions should be used.
            @return  the default plot dimensions field value.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.SheetPropertiesRecord.IsAutoPlotArea">
            ??
            @return  the auto plot area field value.
        </member>
        <member name="T:NPOI.HSSF.Record.Chart.ValueRangeRecord">
                 * The value range record defines the range of the value axis.
                 * NOTE: This source is automatically generated please do not modify this file.  Either subclass or
                 *       Remove the record in src/records/definitions.
            
                 * @author Glen Stampoultzis (glens at apache.org)
        </member>
        <member name="M:NPOI.HSSF.Record.Chart.ValueRangeRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
             Constructs a ValueRange record and Sets its fields appropriately.
            
             @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.ValueRangeRecord.DataSize">
            Size of record (exluding 4 byte header)
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.ValueRangeRecord.MinimumAxisValue">
            Get the minimum axis value field for the ValueRange record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.ValueRangeRecord.MaximumAxisValue">
            Get the maximum axis value field for the ValueRange record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.ValueRangeRecord.MajorIncrement">
            Get the major increment field for the ValueRange record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.ValueRangeRecord.MinorIncrement">
            Get the minor increment field for the ValueRange record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.ValueRangeRecord.CategoryAxisCross">
            Get the category axis cross field for the ValueRange record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.ValueRangeRecord.Options">
            Get the options field for the ValueRange record.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.ValueRangeRecord.IsAutomaticMinimum">
            automatic minimum value selected
            @return  the automatic minimum field value.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.ValueRangeRecord.IsAutomaticMaximum">
            automatic maximum value selected
            @return  the automatic maximum field value.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.ValueRangeRecord.IsAutomaticMajor">
            automatic major Unit selected
            @return  the automatic major field value.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.ValueRangeRecord.IsAutomaticMinor">
            automatic minor Unit selected
            @return  the automatic minor field value.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.ValueRangeRecord.IsAutomaticCategoryCrossing">
            category crossing point is automatically selected
            @return  the automatic category crossing field value.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.ValueRangeRecord.IsLogarithmicScale">
            use logarithmic scale
            @return  the logarithmic scale field value.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.ValueRangeRecord.IsValuesInReverse">
            values are reverses in graph
            @return  the values in reverse field value.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.ValueRangeRecord.IsCrossCategoryAxisAtMaximum">
            category axis to cross at maximum value
            @return  the cross category axis at maximum field value.
        </member>
        <member name="P:NPOI.HSSF.Record.Chart.ValueRangeRecord.IsReserved">
            reserved, must equal 1 (excel dev. guide says otherwise)
            @return  the reserved field value.
        </member>
        <member name="T:NPOI.HSSF.Record.ChartFormatRecord">
             Class ChartFormatRecord
            
            
             @author Glen Stampoultzis (glens at apache.org)
             @version %I%, %G%
        </member>
        <member name="M:NPOI.HSSF.Record.ChartFormatRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Constructs a ChartFormatRecord record and Sets its fields appropriately.
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="T:NPOI.HSSF.Record.TextRecord">
                 * The text record is used to define text stored on a chart.
                 * NOTE: This source is automatically generated please do not modify this file.  Either subclass or
                 *       Remove the record in src/records/definitions.
            
                 * @author Glen Stampoultzis (glens at apache.org)
        </member>
        <member name="M:NPOI.HSSF.Record.TextRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
             Constructs a Text record and Sets its fields appropriately.
            
             @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.TextRecord.DataSize">
            Size of record (exluding 4 byte header)
        </member>
        <member name="P:NPOI.HSSF.Record.TextRecord.HorizontalAlignment">
             Get the horizontal alignment field for the Text record.
            
             @return  One of 
                    HORIZONTAL_ALIGNMENT_LEFT
                    HORIZONTAL_ALIGNMENT_CENTER
                    HORIZONTAL_ALIGNMENT_BOTTOM
                    HORIZONTAL_ALIGNMENT_JUSTIFY
        </member>
        <member name="P:NPOI.HSSF.Record.TextRecord.VerticalAlignment">
             Get the vertical alignment field for the Text record.
            
             @return  One of 
                    VERTICAL_ALIGNMENT_TOP
                    VERTICAL_ALIGNMENT_CENTER
                    VERTICAL_ALIGNMENT_BOTTOM
                    VERTICAL_ALIGNMENT_JUSTIFY
        </member>
        <member name="P:NPOI.HSSF.Record.TextRecord.DisplayMode">
             Get the Display mode field for the Text record.
            
             @return  One of 
                    DISPLAY_MODE_TRANSPARENT
                    DISPLAY_MODE_OPAQUE
        </member>
        <member name="P:NPOI.HSSF.Record.TextRecord.RgbColor">
            Get the rgbColor field for the Text record.
        </member>
        <member name="P:NPOI.HSSF.Record.TextRecord.X">
            Get the x field for the Text record.
        </member>
        <member name="P:NPOI.HSSF.Record.TextRecord.Y">
            Get the y field for the Text record.
        </member>
        <member name="P:NPOI.HSSF.Record.TextRecord.Width">
            Set the width field for the Text record.
        </member>
        <member name="P:NPOI.HSSF.Record.TextRecord.Height">
            Get the height field for the Text record.
        </member>
        <member name="P:NPOI.HSSF.Record.TextRecord.Options1">
            Get the options1 field for the Text record.
        </member>
        <member name="P:NPOI.HSSF.Record.TextRecord.IndexOfColorValue">
            Get the index of color value field for the Text record.
        </member>
        <member name="P:NPOI.HSSF.Record.TextRecord.Options2">
            Get the options2 field for the Text record.
        </member>
        <member name="P:NPOI.HSSF.Record.TextRecord.TextRotation">
            Get the text rotation field for the Text record.
        </member>
        <member name="P:NPOI.HSSF.Record.TextRecord.IsAutoColor">
            true = automaticly selected colour, false = user-selected
            @return  the auto color field value.
        </member>
        <member name="P:NPOI.HSSF.Record.TextRecord.ShowKey">
            true = draw legend
            @return  the show key field value.
        </member>
        <member name="P:NPOI.HSSF.Record.TextRecord.ShowValue">
            false = text is category label
            @return  the show value field value.
        </member>
        <member name="P:NPOI.HSSF.Record.TextRecord.IsVertical">
            Sets the vertical field value.
            true = text is vertical
        </member>
        <member name="P:NPOI.HSSF.Record.TextRecord.IsAutoGeneratedText">
            
            @return  the auto generated text field value.
        </member>
        <member name="P:NPOI.HSSF.Record.TextRecord.IsGenerated">
            
            @return  the generated field value.
        </member>
        <member name="P:NPOI.HSSF.Record.TextRecord.IsAutoLabelDeleted">
            
            @return  the auto label deleted field value.
        </member>
        <member name="P:NPOI.HSSF.Record.TextRecord.IsAutoBackground">
            
            @return  the auto background field value.
        </member>
        <member name="P:NPOI.HSSF.Record.TextRecord.Rotation">
            
            @return  the rotation field value.
        </member>
        <member name="P:NPOI.HSSF.Record.TextRecord.ShowCategoryLabelAsPercentage">
            
            @return  the show category label as percentage field value.
        </member>
        <member name="P:NPOI.HSSF.Record.TextRecord.ShowValueAsPercentage">
            
            @return  the show value as percentage field value.
        </member>
        <member name="P:NPOI.HSSF.Record.TextRecord.ShowBubbleSizes">
            
            @return  the show bubble sizes field value.
        </member>
        <member name="P:NPOI.HSSF.Record.TextRecord.ShowLabel">
            
            @return  the show label field value.
        </member>
        <member name="P:NPOI.HSSF.Record.TextRecord.DataLabelPlacement">
            
            @return  the data label placement field value.
        </member>
        <member name="T:NPOI.HSSF.Record.TickRecord">
                 * The Tick record defines how tick marks and label positioning/formatting
                 * NOTE: This source is automatically generated please do not modify this file.  Either subclass or
                 *       Remove the record in src/records/definitions.
            
                 * @author Andrew C. Oliver(acoliver at apache.org)
        </member>
        <member name="M:NPOI.HSSF.Record.TickRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
             Constructs a Tick record and Sets its fields appropriately.
            
             @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.TickRecord.DataSize">
            Size of record (exluding 4 byte header)
        </member>
        <member name="P:NPOI.HSSF.Record.TickRecord.MajorTickType">
            Get the major tick type field for the Tick record.
        </member>
        <member name="P:NPOI.HSSF.Record.TickRecord.MinorTickType">
            Get the minor tick type field for the Tick record.
        </member>
        <member name="P:NPOI.HSSF.Record.TickRecord.LabelPosition">
            Get the label position field for the Tick record.
        </member>
        <member name="P:NPOI.HSSF.Record.TickRecord.Background">
            Get the background field for the Tick record.
        </member>
        <member name="P:NPOI.HSSF.Record.TickRecord.LabelColorRgb">
            Get the label color rgb field for the Tick record.
        </member>
        <member name="P:NPOI.HSSF.Record.TickRecord.Zero1">
            Get the zero 1 field for the Tick record.
        </member>
        <member name="P:NPOI.HSSF.Record.TickRecord.Zero2">
            Get the zero 2 field for the Tick record.
        </member>
        <member name="P:NPOI.HSSF.Record.TickRecord.Options">
            Get the options field for the Tick record.
        </member>
        <member name="P:NPOI.HSSF.Record.TickRecord.TickColor">
            Get the tick color field for the Tick record.
        </member>
        <member name="P:NPOI.HSSF.Record.TickRecord.Zero3">
            Get the zero 3 field for the Tick record.
        </member>
        <member name="P:NPOI.HSSF.Record.TickRecord.IsAutoTextColor">
            use the quote Unquote automatic color for text
            @return  the auto text color field value.
        </member>
        <member name="P:NPOI.HSSF.Record.TickRecord.IsAutoTextBackground">
            use the quote Unquote automatic color for text background
            @return  the auto text background field value.
        </member>
        <member name="P:NPOI.HSSF.Record.TickRecord.Rotation">
            rotate text (0=none, 1=normal, 2=90 degrees counterclockwise, 3=90 degrees clockwise)
            @return  the rotation field value.
        </member>
        <member name="P:NPOI.HSSF.Record.TickRecord.IsAutorotate">
            automatically rotate the text
            @return  the autorotate field value.
        </member>
        <member name="T:NPOI.HSSF.Record.UnitsRecord">
                 * The Units record describes Units.
                 * NOTE: This source is automatically generated please do not modify this file.  Either subclass or
                 *       Remove the record in src/records/definitions.
            
                 * @author Glen Stampoultzis (glens at apache.org)
        </member>
        <member name="M:NPOI.HSSF.Record.UnitsRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
             Constructs a Units record and Sets its fields appropriately.
            
             @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.UnitsRecord.DataSize">
            Size of record (exluding 4 byte header)
        </member>
        <member name="P:NPOI.HSSF.Record.UnitsRecord.Units">
            Get the Units field for the Units record.
        </member>
        <member name="T:NPOI.HSSF.Record.CodepageRecord">
            Title: Codepage Record
            Description:  the default CharSet. for the workbook
            REFERENCE:  PG 293 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
            @author Andrew C. Oliver (acoliver at apache dot org)
            @version 2.0-pre
        </member>
        <member name="F:NPOI.HSSF.Record.CodepageRecord.CODEPAGE">
            the likely correct value for CODEPAGE (at least for US versions).  We could use
            some help with international versions (which we do not have access to documentation
            for)
        </member>
        <member name="M:NPOI.HSSF.Record.CodepageRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Constructs a CodepageRecord and Sets its fields appropriately
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.CodepageRecord.Codepage">
             Get the codepage for this workbook
            
             @see #CODEPAGE
             @return codepage - the codepage to Set
        </member>
        <member name="T:NPOI.HSSF.Record.ColumnInfoRecord">
            Title: COLINFO Record<p/>
            Description:  Defines with width and formatting for a range of columns<p/>
            REFERENCE:  PG 293 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)<p/>
            @author Andrew C. Oliver (acoliver at apache dot org)
            @version 2.0-pre
        </member>
        <member name="M:NPOI.HSSF.Record.ColumnInfoRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Constructs a ColumnInfo record and Sets its fields appropriately
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="M:NPOI.HSSF.Record.ColumnInfoRecord.FormatMatches(NPOI.HSSF.Record.ColumnInfoRecord)">
            @return true if the format, options and column width match
        </member>
        <member name="P:NPOI.HSSF.Record.ColumnInfoRecord.FirstColumn">
            Get the first column this record defines formatting info for
            @return the first column index (0-based)
        </member>
        <member name="P:NPOI.HSSF.Record.ColumnInfoRecord.LastColumn">
            Get the last column this record defines formatting info for
            @return the last column index (0-based)
        </member>
        <member name="P:NPOI.HSSF.Record.ColumnInfoRecord.ColumnWidth">
            Get the columns' width in 1/256 of a Char width
            @return column width
        </member>
        <member name="P:NPOI.HSSF.Record.ColumnInfoRecord.XFIndex">
            Get the columns' default format info
            @return the extended format index
            @see org.apache.poi.hssf.record.ExtendedFormatRecord
        </member>
        <member name="P:NPOI.HSSF.Record.ColumnInfoRecord.Options">
            Get the options bitfield - use the bitSetters instead
            @return the bitfield raw value
        </member>
        <member name="P:NPOI.HSSF.Record.ColumnInfoRecord.IsHidden">
            Get whether or not these cells are hidden
            @return whether the cells are hidden.
            @see #SetOptions(short)
        </member>
        <member name="P:NPOI.HSSF.Record.ColumnInfoRecord.OutlineLevel">
            Get the outline level for the cells
            @see #SetOptions(short)
            @return outline level for the cells
        </member>
        <member name="P:NPOI.HSSF.Record.ColumnInfoRecord.IsCollapsed">
            Get whether the cells are collapsed
            @return wether the cells are collapsed
            @see #SetOptions(short)
        </member>
        <member name="T:NPOI.HSSF.Record.CountryRecord">
             Title:        Country Record (aka WIN.INI country)
             Description:  used for localization.  Currently HSSF always Sets this to 1
             and it seems to work fine even in Germany.  (es geht's auch fuer Deutschland)
            
             REFERENCE:  PG 298 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
             @author Andrew C. Oliver (acoliver at apache dot org)
             @version 2.0-pre
        </member>
        <member name="M:NPOI.HSSF.Record.CountryRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Constructs a CountryRecord and Sets its fields appropriately
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.CountryRecord.DefaultCountry">
             Gets the default country
            
             @return country ID (1 = US)
        </member>
        <member name="P:NPOI.HSSF.Record.CountryRecord.CurrentCountry">
             Gets the current country
            
             @return country ID (1 = US)
        </member>
        <member name="T:NPOI.HSSF.Record.CRNCountRecord">
             XCT ?CRN Count 
            
             REFERENCE:  5.114
            
             @author Josh Micich
        </member>
        <member name="P:NPOI.HSSF.Record.CRNCountRecord.Sid">
            return the non static version of the id for this record.
        </member>
        <member name="T:NPOI.HSSF.Record.CRNRecord">
             Title:       CRN  
             Description: This record stores the contents of an external cell or cell range 
             REFERENCE:  5.23
            
             @author josh micich
        </member>
        <member name="P:NPOI.HSSF.Record.CRNRecord.Sid">
            return the non static version of the id for this record.
        </member>
        <member name="P:NPOI.HSSF.Record.CustomField.Size">
            @return  The size of this field in bytes.  This operation Is not valid
                     Until after the call to <c>FillField()</c>
        </member>
        <member name="M:NPOI.HSSF.Record.CustomField.FillField(NPOI.HSSF.Record.RecordInputStream)">
            Populates this fields data from the byte array passed in1.
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="M:NPOI.HSSF.Record.CustomField.ToString(System.Text.StringBuilder)">
             Appends the string representation of this field to the supplied
             StringBuilder.
            
             @param str   The string buffer to Append to.
        </member>
        <member name="M:NPOI.HSSF.Record.CustomField.SerializeField(System.Int32,System.Byte[])">
            Converts this field to it's byte array form.
            @param offset    The offset into the byte array to start writing to.
            @param data      The data array to Write to.
            @return  The number of bytes written.
        </member>
        <member name="T:NPOI.HSSF.Record.DateWindow1904Record">
            Title:        Date Window 1904 Flag record 
            Description:  Flag specifying whether 1904 date windowing Is used.
                          (tick toc tick toc...BOOM!) 
            REFERENCE:  PG 280 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
            @author Andrew C. Oliver (acoliver at apache dot org)
            @version 2.0-pre
        </member>
        <member name="M:NPOI.HSSF.Record.DateWindow1904Record.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Constructs a DateWindow1904 record and Sets its fields appropriately.
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.DateWindow1904Record.Windowing">
            Gets whether or not to use 1904 date windowing (which means you'll be screwed in 2004)
            @return window flag - 0/1 (false,true)
        </member>
        <member name="T:NPOI.HSSF.Record.DBCellRecord">
            Title:        DBCell Record
            Description:  Used by Excel and other MS apps to quickly Find rows in the sheets.
            REFERENCE:  PG 299/440 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
            @author Andrew C. Oliver (acoliver at apache dot org)
            @author Jason Height
            @version 2.0-pre
        </member>
        <member name="M:NPOI.HSSF.Record.DBCellRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Constructs a DBCellRecord and Sets its fields appropriately
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="M:NPOI.HSSF.Record.DBCellRecord.#ctor(System.Int32,System.Int16[])">
            offset from the start of this DBCellRecord to the start of the first cell in
            the next DBCell block.
        </member>
        <member name="P:NPOI.HSSF.Record.DBCellRecord.RowOffset">
             Gets offset from the start of this DBCellRecord to the start of the first cell in
             the next DBCell block.
            
             @return rowoffset to the start of the first cell in the next DBCell block
        </member>
        <member name="M:NPOI.HSSF.Record.DBCellRecord.GetCellOffsetAt(System.Int32)">
             return the cell offset in the array
            
             @param index of the cell offset to retrieve
             @return celloffset from the celloffset array
        </member>
        <member name="P:NPOI.HSSF.Record.DBCellRecord.NumCellOffsets">
             Get the number of cell offsets in the celloffset array
            
             @return number of cell offsets
        </member>
        <member name="M:NPOI.HSSF.Record.DBCellRecord.CalculateSizeOfRecords(System.Int32,System.Int32)">
            @returns the size of the Group of <tt>DBCellRecord</tt>s needed to encode
            the specified number of blocks and rows
        </member>
        <member name="T:NPOI.HSSF.Record.DefaultColWidthRecord">
            Title:        Default Column Width Record
            Description:  Specifies the default width for columns that have no specific
                          width Set.
            REFERENCE:  PG 302 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
            @author Andrew C. Oliver (acoliver at apache dot org)
            @author Jason Height (jheight at chariot dot net dot au)
            @version 2.0-pre
        </member>
        <member name="M:NPOI.HSSF.Record.DefaultColWidthRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Constructs a DefaultColumnWidth record and Sets its fields appropriately.
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.DefaultColWidthRecord.ColWidth">
            Get the default column width
            @return defaultwidth for columns
        </member>
        <member name="T:NPOI.HSSF.Record.DefaultRowHeightRecord">
            Title:        Default Row Height Record
            Description:  Row height for rows with Undefined or not explicitly defined
                          heights.
            REFERENCE:  PG 301 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
            @author Andrew C. Oliver (acoliver at apache dot org)
            @author Jason Height (jheight at chariot dot net dot au)
            @version 2.0-pre
        </member>
        <member name="M:NPOI.HSSF.Record.DefaultRowHeightRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            <summary>
            Constructs a DefaultRowHeight record and Sets its fields appropriately.
            </summary>
            <param name="in1">the RecordInputstream to Read the record from</param>
        </member>
        <member name="P:NPOI.HSSF.Record.DefaultRowHeightRecord.IsDefaultHeightChanged">
            <summary>
            A bit that specifies whether the default settings for the row height have been changed.
            </summary>
        </member>
        <member name="P:NPOI.HSSF.Record.DefaultRowHeightRecord.IsZeroHeight">
            <summary>
            A bit that specifies whether empty rows have a height of zero.
            </summary>
        </member>
        <member name="P:NPOI.HSSF.Record.DefaultRowHeightRecord.RowHeight">
            <summary>
            Get the default row height
            </summary>
        </member>
        <member name="T:NPOI.HSSF.Record.DeltaRecord">
            Title:        Delta Record
            Description:  controls the accuracy of the calculations
            REFERENCE:  PG 303 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
            @author Andrew C. Oliver (acoliver at apache dot org)
            @author Jason Height (jheight at chariot dot net dot au)
            @version 2.0-pre
        </member>
        <member name="M:NPOI.HSSF.Record.DeltaRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Constructs a Delta record and Sets its fields appropriately.
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.DeltaRecord.MaxChange">
            Get the maximum Change
            @return maxChange - maximum rounding error
        </member>
        <member name="T:NPOI.HSSF.Record.DimensionsRecord">
            Title:        Dimensions Record
            Description:  provides the minumum and maximum bounds
                          of a sheet.
            REFERENCE:  PG 303 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
            @author Andrew C. Oliver (acoliver at apache dot org)
            @author Jason Height (jheight at chariot dot net dot au)
            @version 2.0-pre
        </member>
        <member name="M:NPOI.HSSF.Record.DimensionsRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Constructs a Dimensions record and Sets its fields appropriately.
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.DimensionsRecord.FirstRow">
            Get the first row number for the sheet
            @return row - first row on the sheet
        </member>
        <member name="P:NPOI.HSSF.Record.DimensionsRecord.LastRow">
            Get the last row number for the sheet
            @return row - last row on the sheet
        </member>
        <member name="P:NPOI.HSSF.Record.DimensionsRecord.FirstCol">
            Get the first column number for the sheet
            @return column - first column on the sheet
        </member>
        <member name="P:NPOI.HSSF.Record.DimensionsRecord.LastCol">
            Get the last col number for the sheet
            @return column - last column on the sheet
        </member>
        <member name="M:NPOI.HSSF.Record.DrawingGroupRecord.ProcessChildRecords">
            Process the bytes into escher records.
            (Not done by default in case we break things,
             Unless you Set the "poi.deSerialize.escher" 
             system property)
        </member>
        <member name="P:NPOI.HSSF.Record.DrawingGroupRecord.RecordSize">
            Size of record (including 4 byte headers for all sections)
        </member>
        <member name="T:NPOI.HSSF.Record.DrawingRecordForBiffViewer">
            This Is purely for the biff viewer.  During normal operations we don't want
            to be seeing this.
        </member>
        <member name="T:NPOI.HSSF.Record.DSFRecord">
            Title: double Stream Flag Record
            Description:  tells if this Is a double stream file. (always no for HSSF generated files)
                          double Stream files contain both BIFF8 and BIFF7 workbooks.
            REFERENCE:  PG 305 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
            @author Andrew C. Oliver (acoliver at apache dot org)
            @version 2.0-pre
        </member>
        <member name="M:NPOI.HSSF.Record.DSFRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Constructs a DBCellRecord and Sets its fields appropriately.
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.DSFRecord.Dsf">
            Get the DSF flag
            @return dsfflag (0-off,1-on)
        </member>
        <member name="T:NPOI.HSSF.Record.DVALRecord">
            Title:        DATAVALIDATIONS Record
            Description:  used in data validation ;
                          This record Is the list header of all data validation records (0x01BE) in the current sheet.
            @author Dragos Buleandra (dragos.buleandra@trade2b.ro)
        </member>
        <member name="F:NPOI.HSSF.Record.DVALRecord.field_1_options">
            Options of the DVAL 
        </member>
        <member name="F:NPOI.HSSF.Record.DVALRecord.field_2_horiz_pos">
            Horizontal position of the dialog 
        </member>
        <member name="F:NPOI.HSSF.Record.DVALRecord.field_3_vert_pos">
            Vertical position of the dialog 
        </member>
        <member name="F:NPOI.HSSF.Record.DVALRecord.field_cbo_id">
            Object ID of the drop down arrow object for list boxes ;
            in our case this will be always FFFF , Until
            MSODrawingGroup and MSODrawing records are implemented 
        </member>
        <member name="F:NPOI.HSSF.Record.DVALRecord.field_5_dv_no">
            Number of following DV Records 
        </member>
        <member name="M:NPOI.HSSF.Record.DVALRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
             Constructs a DVAL record and Sets its fields appropriately.
            
             @param in the RecordInputstream to Read the record from
        </member>
        <member name="M:NPOI.HSSF.Record.DVALRecord.SetOptions(System.Int16)">
            @param field_1_options the options of the dialog
        </member>
        <member name="M:NPOI.HSSF.Record.DVALRecord.SetHorizontalPos(System.Int32)">
            @param field_2_horiz_pos the Horizontal position of the dialog
        </member>
        <member name="M:NPOI.HSSF.Record.DVALRecord.SetVerticalPos(System.Int32)">
            @param field_3_vert_pos the Vertical position of the dialog
        </member>
        <member name="M:NPOI.HSSF.Record.DVALRecord.SetObjectID(System.Int32)">
            Set the object ID of the drop down arrow object for list boxes
            @param cboID - Object ID
        </member>
        <member name="M:NPOI.HSSF.Record.DVALRecord.SetDVRecNo(System.Int32)">
            Set the number of following DV records
            @param dvNo - the DV records number
        </member>
        <member name="P:NPOI.HSSF.Record.DVALRecord.Options">
            @return the field_1_options
        </member>
        <member name="M:NPOI.HSSF.Record.DVALRecord.GetHorizontalPos">
            @return the Horizontal position of the dialog
        </member>
        <member name="M:NPOI.HSSF.Record.DVALRecord.GetVerticalPos">
            @return the the Vertical position of the dialog
        </member>
        <member name="M:NPOI.HSSF.Record.DVALRecord.GetObjectID">
            Get Object ID of the drop down arrow object for list boxes
        </member>
        <member name="M:NPOI.HSSF.Record.DVALRecord.GetDVRecNo">
            Get number of following DV records
        </member>
        <member name="T:NPOI.HSSF.Record.DVRecord">
            Title:        DATAVALIDATION Record (0x01BE)<p/>
            Description:  This record stores data validation Settings and a list of cell ranges
                          which contain these Settings. The data validation Settings of a sheet
                          are stored in a sequential list of DV records. This list Is followed by
                          DVAL record(s)
            @author Dragos Buleandra (dragos.buleandra@trade2b.ro)
            @version 2.0-pre
        </member>
        <member name="F:NPOI.HSSF.Record.DVRecord._option_flags">
            Option flags 
        </member>
        <member name="F:NPOI.HSSF.Record.DVRecord._promptTitle">
            Title of the prompt box 
        </member>
        <member name="F:NPOI.HSSF.Record.DVRecord._errorTitle">
            Title of the error box 
        </member>
        <member name="F:NPOI.HSSF.Record.DVRecord._promptText">
            Text of the prompt box 
        </member>
        <member name="F:NPOI.HSSF.Record.DVRecord._errorText">
            Text of the error box 
        </member>
        <member name="F:NPOI.HSSF.Record.DVRecord._not_used_1">
            Not used - Excel seems to always write 0x3FE0 
        </member>
        <member name="F:NPOI.HSSF.Record.DVRecord._formula1">
            Formula data for first condition (RPN token array without size field) 
        </member>
        <member name="F:NPOI.HSSF.Record.DVRecord._not_used_2">
            Not used - Excel seems to always write 0x0000 
        </member>
        <member name="F:NPOI.HSSF.Record.DVRecord._formula2">
            Formula data for second condition (RPN token array without size field) 
        </member>
        <member name="F:NPOI.HSSF.Record.DVRecord._regions">
            Cell range address list with all affected ranges 
        </member>
        <member name="F:NPOI.HSSF.Record.DVRecord.opt_data_type">
            Option flags field
            @see org.apache.poi.hssf.util.HSSFDataValidation utility class
        </member>
        <member name="M:NPOI.HSSF.Record.DVRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
             Constructs a DV record and Sets its fields appropriately.
            
             @param in the RecordInputstream to Read the record from
        </member>
        <member name="M:NPOI.HSSF.Record.DVRecord.ResolveTitleText(System.String)">
            When entered via the UI, Excel translates empty string into "\0"
            While it is possible to encode the title/text as empty string (Excel doesn't exactly crash),
            the resulting tool-tip text / message box looks wrong.  It is best to do the same as the 
            Excel UI and encode 'not present' as "\0". 
        </member>
        <member name="P:NPOI.HSSF.Record.DVRecord.DataType">
            Get the condition data type
            @return the condition data type
            @see org.apache.poi.hssf.util.HSSFDataValidation utility class
        </member>
        <member name="P:NPOI.HSSF.Record.DVRecord.ErrorStyle">
            Get the condition error style
            @return the condition error style
            @see org.apache.poi.hssf.util.HSSFDataValidation utility class
        </member>
        <member name="P:NPOI.HSSF.Record.DVRecord.ListExplicitFormula">
            return true if in list validations the string list Is explicitly given in the formula, false otherwise
            @return true if in list validations the string list Is explicitly given in the formula, false otherwise
            @see org.apache.poi.hssf.util.HSSFDataValidation utility class
        </member>
        <member name="P:NPOI.HSSF.Record.DVRecord.EmptyCellAllowed">
            return true if empty values are allowed in cells, false otherwise
            @return if empty values are allowed in cells, false otherwise
            @see org.apache.poi.hssf.util.HSSFDataValidation utility class
        </member>
        <member name="P:NPOI.HSSF.Record.DVRecord.ShowPromptOnCellSelected">
            return true if a prompt window should appear when cell Is selected, false otherwise
            @return if a prompt window should appear when cell Is selected, false otherwise
            @see org.apache.poi.hssf.util.HSSFDataValidation utility class
        </member>
        <member name="P:NPOI.HSSF.Record.DVRecord.ShowErrorOnInvalidValue">
            return true if an error window should appear when an invalid value Is entered in the cell, false otherwise
            @return if an error window should appear when an invalid value Is entered in the cell, false otherwise
            @see org.apache.poi.hssf.util.HSSFDataValidation utility class
        </member>
        <member name="P:NPOI.HSSF.Record.DVRecord.ConditionOperator">
            Get the condition operator
            @return the condition operator
            @see org.apache.poi.hssf.util.HSSFDataValidation utility class
        </member>
        <member name="P:NPOI.HSSF.Record.DVRecord.OptionFlags">
            Gets the option flags field.
            @return options - the option flags field
        </member>
        <member name="M:NPOI.HSSF.Record.DVRecord.Clone">
            Clones the object. Uses serialisation, as the
             contents are somewhat complex
        </member>
        <member name="T:NPOI.HSSF.Record.EscherAggregate">
             This class Is used to aggregate the MSODRAWING and OBJ record
             combinations.  This Is necessary due to the bizare way in which
             these records are Serialized.  What happens Is that you Get a
             combination of MSODRAWING -> OBJ -> MSODRAWING -> OBJ records
             but the escher records are Serialized _across_ the MSODRAWING
             records.
             
             It Gets even worse when you start looking at TXO records.
             
             So what we do with this class Is aggregate lazily.  That Is
             we don't aggregate the MSODRAWING -> OBJ records Unless we
             need to modify them.
            
            
             @author Glen Stampoultzis (glens at apache.org)
        </member>
        <member name="F:NPOI.HSSF.Record.EscherAggregate.shapeToObj">
            Maps shape container objects to their OBJ records 
        </member>
        <member name="F:NPOI.HSSF.Record.EscherAggregate.tailRec">
            list of "tail" records that need to be Serialized after all drawing Group records
        </member>
        <member name="P:NPOI.HSSF.Record.EscherAggregate.Sid">
            @return  Returns the current sid.
        </member>
        <member name="M:NPOI.HSSF.Record.EscherAggregate.Children(System.Byte[],System.Int16,System.Int32)">
             Unused since this Is an aggregate record.  Use CreateAggregate().
            
             @see #CreateAggregate
        </member>
        <member name="M:NPOI.HSSF.Record.EscherAggregate.ToString">
            Calculates the string representation of this record.  This Is
            simply a dump of all the records.
        </member>
        <member name="M:NPOI.HSSF.Record.EscherAggregate.CreateAggregate(System.Collections.IList,System.Int32,NPOI.HSSF.Model.DrawingManager2)">
            Collapses the drawing records into an aggregate.
        </member>
        <member name="M:NPOI.HSSF.Record.EscherAggregate.Serialize(System.Int32,System.Byte[])">
             Serializes this aggregate to a byte array.  Since this Is an aggregate
             record it will effectively Serialize the aggregated records.
            
             @param offset    The offset into the start of the array.
             @param data      The byte array to Serialize to.
             @return          The number of bytes Serialized.
        </member>
        <member name="M:NPOI.HSSF.Record.EscherAggregate.GetEscherRecordSize(System.Collections.IList)">
            How many bytes do the raw escher records contain.
            @param records   List of escher records
            @return  the number of bytes
        </member>
        <member name="P:NPOI.HSSF.Record.EscherAggregate.RecordSize">
            The number of bytes required to Serialize this record.
        </member>
        <member name="M:NPOI.HSSF.Record.EscherAggregate.AssoicateShapeToObjRecord(NPOI.DDF.EscherRecord,NPOI.HSSF.Record.Record)">
            Associates an escher record to an OBJ record or a TXO record.
        </member>
        <member name="M:NPOI.HSSF.Record.EscherAggregate.ConvertRecordsToUserModel">
            Converts the Records into UserModel
             objects on the bound HSSFPatriarch
        </member>
        <member name="T:NPOI.HSSF.Record.ExtendedFormatRecord">
             Title:        Extended Format Record
             Description:  Probably one of the more complex records.  There are two breeds:
                           Style and Cell.
            
                           It should be noted that fields in the extended format record are
                           somewhat arbitrary.  Almost all of the fields are bit-level, but
                           we name them as best as possible by functional Group.  In some
                           places this Is better than others.
            
            
             REFERENCE:  PG 426 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
             @author Andrew C. Oliver (acoliver at apache dot org)
             @version 2.0-pre
        </member>
        <member name="M:NPOI.HSSF.Record.ExtendedFormatRecord.#ctor">
             Constructor ExtendedFormatRecord
            
            
        </member>
        <member name="M:NPOI.HSSF.Record.ExtendedFormatRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Constructs an ExtendedFormat record and Sets its fields appropriately.
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="M:NPOI.HSSF.Record.ExtendedFormatRecord.CloneStyleFrom(NPOI.HSSF.Record.ExtendedFormatRecord)">
            Clones all the style information from another
             ExtendedFormatRecord, onto this one. This 
             will then hold all the same style options.
             
            If The source ExtendedFormatRecord comes from
             a different Workbook, you will need to sort
             out the font and format indicies yourself!
        </member>
        <member name="P:NPOI.HSSF.Record.ExtendedFormatRecord.FontIndex">
             Get the index to the FONT record (which font to use 0 based)
            
            
             @return index to the font
             @see org.apache.poi.hssf.record.FontRecord
        </member>
        <member name="P:NPOI.HSSF.Record.ExtendedFormatRecord.FormatIndex">
              Get the index to the Format record (which FORMAT to use 0-based)
            
            
             @return index to the format record
             @see org.apache.poi.hssf.record.FormatRecord
        </member>
        <member name="P:NPOI.HSSF.Record.ExtendedFormatRecord.CellOptions">
             Gets the options bitmask - you can also use corresponding option bit Getters
             (see other methods that reference this one)
            
            
             @return options bitmask
            
        </member>
        <member name="P:NPOI.HSSF.Record.ExtendedFormatRecord.IsLocked">
             Get whether the cell Is locked or not
            
            
             @return locked - if the cell Is locked
             @see #GetCellOptions()
        </member>
        <member name="P:NPOI.HSSF.Record.ExtendedFormatRecord.IsHidden">
             Get whether the cell Is hidden or not
            
            
             @return hidden - if the cell Is hidden
             @see #GetCellOptions()
        </member>
        <member name="P:NPOI.HSSF.Record.ExtendedFormatRecord.XFType">
             Get whether the cell Is a cell or style XFRecord
            
            
             @return type - cell or style (0/1)
             @see #XF_STYLE
             @see #XF_CELL
             @see #GetCellOptions()
        </member>
        <member name="P:NPOI.HSSF.Record.ExtendedFormatRecord._123Prefix">
             Get some old holdover from lotus 123.  Who cares, its all over for Lotus.
             RIP Lotus.
            
             @return prefix - the lotus thing
             @see #GetCellOptions()
        </member>
        <member name="P:NPOI.HSSF.Record.ExtendedFormatRecord.ParentIndex">
             for cell XF types this Is the parent style (usually 0/normal).  For
             style this should be NULL.
            
             @return index of parent XF
             @see #NULL
             @see #GetCellOptions()
        </member>
        <member name="P:NPOI.HSSF.Record.ExtendedFormatRecord.AlignmentOptions">
             Get the alignment options bitmask.  See corresponding bitGetter methods
             that reference this one.
            
            
             @return options     - the bitmask
        </member>
        <member name="P:NPOI.HSSF.Record.ExtendedFormatRecord.Alignment">
             Get the horizontal alignment of the cell.
            
            
             @return align - how to align the cell (see constants)
             @see #GENERAL
             @see #LEFT
             @see #CENTER
             @see #RIGHT
             @see #Fill
             @see #JUSTIFY
             @see #CENTER_SELECTION
             @see #GetAlignmentOptions()
        </member>
        <member name="P:NPOI.HSSF.Record.ExtendedFormatRecord.WrapText">
             Get whether to wrap the text in the cell
            
            
             @return wrapped - whether or not to wrap the cell text
             @see #GetAlignmentOptions()
        </member>
        <member name="P:NPOI.HSSF.Record.ExtendedFormatRecord.VerticalAlignment">
             Get the vertical alignment of text in the cell
            
            
             @return where to align the text
             @see #VERTICAL_TOP
             @see #VERTICAL_CENTER
             @see #VERTICAL_BOTTOM
             @see #VERTICAL_JUSTIFY
            
             @see #GetAlignmentOptions()
        </member>
        <member name="P:NPOI.HSSF.Record.ExtendedFormatRecord.JustifyLast">
             Dunno.  Docs just say this Is for far east versions..  (I'm guessing it
             justifies for right-to-left Read languages)
            
            
             @return justify
             @see #GetAlignmentOptions()
        </member>
        <member name="P:NPOI.HSSF.Record.ExtendedFormatRecord.Rotation">
             Get the degree of rotation.  (I've not actually seen this used anywhere)
            
            
             @return rotation - the degree of rotation
             @see #GetAlignmentOptions()
        </member>
        <member name="P:NPOI.HSSF.Record.ExtendedFormatRecord.IndentionOptions">
             Get the indent options bitmask  (see corresponding bit Getters that reference
             this field)
            
            
             @return options bitmask
            
        </member>
        <member name="P:NPOI.HSSF.Record.ExtendedFormatRecord.Indent">
             Get indention (not sure of the Units, think its spaces)
            
             @return indent - how far to indent the cell
             @see #GetIndentionOptions()
        </member>
        <member name="P:NPOI.HSSF.Record.ExtendedFormatRecord.ShrinkToFit">
             Get whether to shrink the text to fit
            
            
             @return shrink - shrink to fit or not
             @see #GetIndentionOptions()
        </member>
        <member name="P:NPOI.HSSF.Record.ExtendedFormatRecord.MergeCells">
             Get whether to merge cells
            
            
             @return merge - merge cells or not
             @see #GetIndentionOptions()
        </member>
        <member name="P:NPOI.HSSF.Record.ExtendedFormatRecord.ReadingOrder">
             Get the Reading order for far east versions (0 - Context, 1 - Left to right,
             2 - right to left) - We could use some help with support for the far east.
            
             @return order - the Reading order (0,1,2)
             @see #GetIndentionOptions()
        </member>
        <member name="P:NPOI.HSSF.Record.ExtendedFormatRecord.IsIndentNotParentFormat">
             Get whether or not to use the format in this XF instead of the parent XF.
            
            
             @return parent - true if this XF has a different format value than its parent,
                             false otherwise.
             @see #GetIndentionOptions()
        </member>
        <member name="P:NPOI.HSSF.Record.ExtendedFormatRecord.IsIndentNotParentFont">
             Get whether or not to use the font in this XF instead of the parent XF.
            
            
             @return font   - true if this XF has a different font value than its parent,
                             false otherwise.
             @see #GetIndentionOptions()
        </member>
        <member name="P:NPOI.HSSF.Record.ExtendedFormatRecord.IsIndentNotParentAlignment">
             Get whether or not to use the alignment in this XF instead of the parent XF.
            
            
             @return alignment true if this XF has a different alignment value than its parent,
                              false otherwise.
             @see #GetIndentionOptions()
        </member>
        <member name="P:NPOI.HSSF.Record.ExtendedFormatRecord.IsIndentNotParentBorder">
             Get whether or not to use the border in this XF instead of the parent XF.
            
            
             @return border - true if this XF has a different border value than its parent,
                             false otherwise.
             @see #GetIndentionOptions()
        </member>
        <member name="P:NPOI.HSSF.Record.ExtendedFormatRecord.IsIndentNotParentPattern">
             Get whether or not to use the pattern in this XF instead of the parent XF.
             (foregrount/background)
            
             @return pattern- true if this XF has a different pattern value than its parent,
                             false otherwise.
             @see #GetIndentionOptions()
        </member>
        <member name="P:NPOI.HSSF.Record.ExtendedFormatRecord.IsIndentNotParentCellOptions">
             Get whether or not to use the locking/hidden in this XF instead of the parent XF.
            
            
             @return options- true if this XF has a different locking or hidden value than its parent,
                             false otherwise.
             @see #GetIndentionOptions()
        </member>
        <member name="P:NPOI.HSSF.Record.ExtendedFormatRecord.BorderOptions">
             Get the border options bitmask (see the corresponding bit Getter methods
             that reference back to this one)
            
             @return options - the bit mask to Set
            
        </member>
        <member name="P:NPOI.HSSF.Record.ExtendedFormatRecord.BorderLeft">
             Get the borderline style for the left border
            
            
             @return border - type of border for the left side of the cell
             @see     #NONE
             @see     #THIN
             @see     #MEDIUM
             @see     #DASHED
             @see     #DOTTED
             @see     #THICK
             @see     #double
             @see     #HAIR
             @see     #MEDIUM_DASHED
             @see     #DASH_DOT
             @see     #MEDIUM_DASH_DOT
             @see     #DASH_DOT_DOT
             @see     #MEDIUM_DASH_DOT_DOT
             @see     #SLANTED_DASH_DOT
             @see #BorderOptions
        </member>
        <member name="P:NPOI.HSSF.Record.ExtendedFormatRecord.BorderRight">
             Get the borderline style for the right border
            
            
             @return  border - type of border for the right side of the cell
             @see     #NONE
             @see     #THIN
             @see     #MEDIUM
             @see     #DASHED
             @see     #DOTTED
             @see     #THICK
             @see     #double
             @see     #HAIR
             @see     #MEDIUM_DASHED
             @see     #DASH_DOT
             @see     #MEDIUM_DASH_DOT
             @see     #DASH_DOT_DOT
             @see     #MEDIUM_DASH_DOT_DOT
             @see     #SLANTED_DASH_DOT
             @see #BorderOptions
        </member>
        <member name="P:NPOI.HSSF.Record.ExtendedFormatRecord.BorderTop">
             Get the borderline style for the top border
            
            
             @return border - type of border for the top of the cell
             @see     #NONE
             @see     #THIN
             @see     #MEDIUM
             @see     #DASHED
             @see     #DOTTED
             @see     #THICK
             @see     #double
             @see     #HAIR
             @see     #MEDIUM_DASHED
             @see     #DASH_DOT
             @see     #MEDIUM_DASH_DOT
             @see     #DASH_DOT_DOT
             @see     #MEDIUM_DASH_DOT_DOT
             @see     #SLANTED_DASH_DOT
             @see #BorderOptions
        </member>
        <member name="P:NPOI.HSSF.Record.ExtendedFormatRecord.BorderBottom">
             Get the borderline style for the bottom border
            
            
             @return border - type of border for the bottom of the cell
             @see     #NONE
             @see     #THIN
             @see     #MEDIUM
             @see     #DASHED
             @see     #DOTTED
             @see     #THICK
             @see     #double
             @see     #HAIR
             @see     #MEDIUM_DASHED
             @see     #DASH_DOT
             @see     #MEDIUM_DASH_DOT
             @see     #DASH_DOT_DOT
             @see     #MEDIUM_DASH_DOT_DOT
             @see     #SLANTED_DASH_DOT
             @see #BorderOptions
        </member>
        <member name="P:NPOI.HSSF.Record.ExtendedFormatRecord.PaletteOptions">
             Get the palette options bitmask (see the individual bit Getter methods that
             reference this one)
            
            
             @return options - the bitmask
            
        </member>
        <member name="P:NPOI.HSSF.Record.ExtendedFormatRecord.LeftBorderPaletteIdx">
             Get the palette index for the left border color
            
            
             @return border - palette index
             @see #PaletteOptions
        </member>
        <member name="P:NPOI.HSSF.Record.ExtendedFormatRecord.RightBorderPaletteIdx">
             Get the palette index for the right border color
            
            
             @return border - palette index
             @see #PaletteOptions
        </member>
        <member name="P:NPOI.HSSF.Record.ExtendedFormatRecord.Diag">
             Not sure what this Is for (maybe Fill lines?) 1 = down, 2 = up, 3 = both, 0 for none..
            
            
             @return diag - whatever it Is that this Is.
             @see #PaletteOptions
        </member>
        <member name="P:NPOI.HSSF.Record.ExtendedFormatRecord.AdtlPaletteOptions">
             Get the Additional palette options bitmask (see individual bit Getter methods
             that reference this method)
            
            
             @return options - bitmask to Set
            
        </member>
        <member name="P:NPOI.HSSF.Record.ExtendedFormatRecord.TopBorderPaletteIdx">
             Get the palette index for the top border
            
            
             @return border - palette index
             @see #AdtlPaletteOptions
        </member>
        <member name="P:NPOI.HSSF.Record.ExtendedFormatRecord.BottomBorderPaletteIdx">
             Get the palette index for the bottom border
            
            
             @return border - palette index
             @see #AdtlPaletteOptions
        </member>
        <member name="P:NPOI.HSSF.Record.ExtendedFormatRecord.AdtlDiag">
             Get for diagonal borders?  No idea (its a palette color for the other function
             we didn't know what was?)
            
            
             @return diag - the palette index?
             @see #AdtlPaletteOptions
        </member>
        <member name="P:NPOI.HSSF.Record.ExtendedFormatRecord.AdtlDiagLineStyle">
             Get the diagonal border line style?  Who the heck ever heard of a diagonal border?
            
            
             @return diag - the line style
             @see     #NONE
             @see     #THIN
             @see     #MEDIUM
             @see     #DASHED
             @see     #DOTTED
             @see     #THICK
             @see     #double
             @see     #HAIR
             @see     #MEDIUM_DASHED
             @see     #DASH_DOT
             @see     #MEDIUM_DASH_DOT
             @see     #DASH_DOT_DOT
             @see     #MEDIUM_DASH_DOT_DOT
             @see     #SLANTED_DASH_DOT
             @see #AdtlPaletteOptions
        </member>
        <member name="P:NPOI.HSSF.Record.ExtendedFormatRecord.AdtlFillPattern">
             Get the Additional Fill pattern
            
             @see #NO_Fill
             @see #SOLID_Fill
             @see #FINE_DOTS
             @see #ALT_BARS
             @see #SParse_DOTS
             @see #THICK_HORZ_BANDS
             @see #THICK_VERT_BANDS
             @see #THICK_BACKWARD_DIAG
             @see #THICK_FORWARD_DIAG
             @see #BIG_SPOTS
             @see #BRICKS
             @see #THIN_HORZ_BANDS
             @see #THIN_VERT_BANDS
             @see #THIN_BACKWARD_DIAG
             @see #THIN_FORWARD_DIAG
             @see #SQUARES
             @see #DIAMONDS
            
             @return Fill - Fill pattern??
             @see #AdtlPaletteOptions
        </member>
        <member name="P:NPOI.HSSF.Record.ExtendedFormatRecord.FillPaletteOptions">
             Get the Fill palette options bitmask (see indivdual bit Getters that
             reference this method)
            
             @return options
            
        </member>
        <member name="P:NPOI.HSSF.Record.ExtendedFormatRecord.FillForeground">
             Get the foreground palette color index
            
            
             @return color - palette index
             @see #FillPaletteOptions
        </member>
        <member name="P:NPOI.HSSF.Record.ExtendedFormatRecord.FillBackground">
             Get the background palette color index
            
             @return color palette index
             @see #FillPaletteOptions
        </member>
        <member name="M:NPOI.HSSF.Record.ExtendedFormatRecord.Equals(System.Object)">
            Will consider two different records with the same
             contents as Equals, as the various indexes
             that matter are embedded in the records
        </member>
        <member name="T:NPOI.HSSF.Record.ExternalNameRecord">
            EXTERNALNAME<p/>
            
            @author Josh Micich
        </member>
        <member name="F:NPOI.HSSF.Record.ExternalNameRecord._ddeValues">
            'rgoper' / 'Last received results of the DDE link'
            (seems to be only applicable to DDE links)<br/>
            Logically this is a 2-D array, which has been flattened into 1-D array here.
        </member>
        <member name="F:NPOI.HSSF.Record.ExternalNameRecord._nColumns">
            (logical) number of columns in the {@link #_ddeValues} array
        </member>
        <member name="F:NPOI.HSSF.Record.ExternalNameRecord._nRows">
            (logical) number of rows in the {@link #_ddeValues} array
        </member>
        <member name="P:NPOI.HSSF.Record.ExternalNameRecord.IsBuiltInName">
            Convenience Function to determine if the name Is a built-in name
        </member>
        <member name="P:NPOI.HSSF.Record.ExternalNameRecord.IsAutomaticLink">
            For OLE and DDE, links can be either 'automatic' or 'manual'
        </member>
        <member name="P:NPOI.HSSF.Record.ExternalNameRecord.IsPicureLink">
            only for OLE and DDE
        </member>
        <member name="P:NPOI.HSSF.Record.ExternalNameRecord.IsStdDocumentNameIdentifier">
            DDE links only. If <c>true</c>, this denotes the 'StdDocumentName'
        </member>
        <member name="P:NPOI.HSSF.Record.ExternalNameRecord.Text">
            @return the standard String representation of this name
        </member>
        <member name="F:NPOI.HSSF.Record.RefSubRecord._extBookIndex">
            index to External Book Block (which starts with a EXTERNALBOOK record) 
        </member>
        <member name="M:NPOI.HSSF.Record.RefSubRecord.#ctor(System.Int32,System.Int32,System.Int32)">
            a Constructor for making new sub record
        </member>
        <member name="M:NPOI.HSSF.Record.RefSubRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="M:NPOI.HSSF.Record.RefSubRecord.Serialize(System.Int32,System.Byte[])">
             called by the class that is responsible for writing this sucker.
             Subclasses should implement this so that their data is passed back in a
             byte array.
            
             @param offset to begin writing at
             @param data byte array containing instance data
             @return number of bytes written
        </member>
        <member name="T:NPOI.HSSF.Record.ExternSheetRecord">
            Title:        Extern Sheet 
            Description:  A List of Inndexes to SupBook 
            REFERENCE:  
            @author Libin Roman (Vista Portal LDT. Developer)
            @version 1.0-pre
        </member>
        <member name="M:NPOI.HSSF.Record.ExternSheetRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Constructs a Extern Sheet record and Sets its fields appropriately.
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="M:NPOI.HSSF.Record.ExternSheetRecord.AddRef(System.Int32,System.Int32,System.Int32)">
            @return index of newly added ref
        </member>
        <member name="P:NPOI.HSSF.Record.ExternSheetRecord.NumOfREFRecords">
            returns the number of REF Records, which is in model
            @return number of REF records
        </member>
        <member name="P:NPOI.HSSF.Record.ExternSheetRecord.NumOfRefs">
            @return number of REF structures
        </member>
        <member name="M:NPOI.HSSF.Record.ExternSheetRecord.AddREFRecord(NPOI.HSSF.Record.RefSubRecord)">
            Adds REF struct (ExternSheetSubRecord)
            @param rec REF struct
        </member>
        <member name="M:NPOI.HSSF.Record.ExternSheetRecord.FindRefIndexFromExtBookIndex(System.Int32)">
            @return -1 if not found
        </member>
        <member name="M:NPOI.HSSF.Record.ExternSheetRecord.Serialize(System.Int32,System.Byte[])">
             called by the class that Is responsible for writing this sucker.
             Subclasses should implement this so that their data Is passed back in a
             byte array.
            
             @param offset to begin writing at
             @param data byte array containing instance data
             @return number of bytes written
        </member>
        <member name="P:NPOI.HSSF.Record.ExternSheetRecord.Sid">
            return the non static version of the id for this record.
        </member>
        <member name="T:NPOI.HSSF.Record.ExternSheetSubRecord">
            Title:        A sub Record for Extern Sheet 
            Description:  Defines a named range within a workbook. 
            REFERENCE:  
            @author Libin Roman (Vista Portal LDT. Developer)
            @version 1.0-pre
        </member>
        <member name="M:NPOI.HSSF.Record.ExternSheetSubRecord.#ctor">
            a Constractor for making new sub record
        </member>
        <member name="M:NPOI.HSSF.Record.ExternSheetSubRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
             Constructs a Extern Sheet Sub Record record and Sets its fields appropriately.
            
             @param in the RecordInputstream to Read the record from
        </member>
        <member name="M:NPOI.HSSF.Record.ExternSheetSubRecord.SetIndexToSupBook(System.Int16)">
            Sets the Index to the sup book
            @param index sup book index
        </member>
        <member name="M:NPOI.HSSF.Record.ExternSheetSubRecord.GetIndexToSupBook">
            Gets the index to sup book
            @return sup book index
        </member>
        <member name="M:NPOI.HSSF.Record.ExternSheetSubRecord.SetIndexToFirstSupBook(System.Int16)">
            Sets the index to first sheet in supbook
            @param index index to first sheet
        </member>
        <member name="M:NPOI.HSSF.Record.ExternSheetSubRecord.GetIndexToFirstSupBook">
            Gets the index to first sheet from supbook
            @return index to first supbook
        </member>
        <member name="M:NPOI.HSSF.Record.ExternSheetSubRecord.SetIndexToLastSupBook(System.Int16)">
            Sets the index to last sheet in supbook
            @param index index to last sheet
        </member>
        <member name="M:NPOI.HSSF.Record.ExternSheetSubRecord.GetIndexToLastSupBook">
            Gets the index to last sheet in supbook
            @return index to last supbook
        </member>
        <member name="M:NPOI.HSSF.Record.ExternSheetSubRecord.Serialize(System.Int32,System.Byte[])">
             called by the class that Is responsible for writing this sucker.
             Subclasses should implement this so that their data Is passed back in a
             byte array.
            
             @param offset to begin writing at
             @param data byte array containing instance data
             @return number of bytes written
        </member>
        <member name="P:NPOI.HSSF.Record.ExternSheetSubRecord.RecordSize">
            returns the record size
        </member>
        <member name="P:NPOI.HSSF.Record.ExternSheetSubRecord.Sid">
            return the non static version of the id for this record.
        </member>
        <member name="T:NPOI.HSSF.Record.ExtSSTInfoSubRecord">
            Extended SST table info subrecord
            Contains the elements of "info" in the SST's array field
            @author Andrew C. Oliver (acoliver at apache dot org)
            @version 2.0-pre
            @see org.apache.poi.hssf.record.ExtSSTRecord
        </member>
        <member name="M:NPOI.HSSF.Record.ExtSSTInfoSubRecord.#ctor">
            Creates new ExtSSTInfoSubRecord 
        </member>
        <member name="T:NPOI.HSSF.Record.ExtSSTRecord">
            Title:        Extended Static String Table
            Description: This record Is used for a quick Lookup into the SST record. This
                         record breaks the SST table into a Set of buckets. The offsets
                         to these buckets within the SST record are kept as well as the
                         position relative to the start of the SST record.
            REFERENCE:  PG 313 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
            @author Andrew C. Oliver (acoliver at apache dot org)
            @author Jason Height (jheight at apache dot org)
            @version 2.0-pre
            @see org.apache.poi.hssf.record.ExtSSTInfoSubRecord
        </member>
        <member name="M:NPOI.HSSF.Record.ExtSSTRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Constructs a EOFRecord record and Sets its fields appropriately.
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.ExtSSTRecord.RecordSize">
            Returns the size of this record 
        </member>
        <member name="M:NPOI.HSSF.Record.ExtSSTRecord.GetRecordSizeForStrings(System.Int32)">
            Given a number of strings (in the sst), returns the size of the extsst record
        </member>
        <member name="T:NPOI.HSSF.Record.FileSharingRecord">
            Title:        FILESHARING
            Description:  stores the encrypted Readonly for a workbook (Write protect) 
            This functionality Is accessed from the options dialog box available when performing 'Save As'.<p/>
            REFERENCE:  PG 314 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)<p/>
            @author Andrew C. Oliver (acoliver at apache dot org)
        </member>
        <member name="M:NPOI.HSSF.Record.FileSharingRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Constructs a FileSharing record and Sets its fields appropriately.
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.FileSharingRecord.IsReadOnly">
             Get the Readonly
            
             @return short  representing if this Is Read only (1 = true)
        </member>
        <member name="P:NPOI.HSSF.Record.FileSharingRecord.Password">
            @returns password hashed with hashPassword() (very lame)
        </member>
        <member name="P:NPOI.HSSF.Record.FileSharingRecord.UsernameLength">
            @returns byte representing the Length of the username field
        </member>
        <member name="P:NPOI.HSSF.Record.FileSharingRecord.Username">
            @returns username of the user that Created the file
        </member>
        <member name="M:NPOI.HSSF.Record.FileSharingRecord.Clone">
            Clone this record.
        </member>
        <member name="T:NPOI.HSSF.Record.FnGroupCountRecord">
            Title: Function Group Count Record
            Description:  Number of built in function Groups in the current version of the
                          SpReadsheet (probably only used on Windoze)
            REFERENCE:  PG 315 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
            @author Andrew C. Oliver (acoliver at apache dot org)
            @version 2.0-pre
        </member>
        <member name="F:NPOI.HSSF.Record.FnGroupCountRecord.COUNT">
            suggested default (14 dec)
        </member>
        <member name="M:NPOI.HSSF.Record.FnGroupCountRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Constructs a FnGroupCount record and Sets its fields appropriately.
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.FnGroupCountRecord.Count">
             Get the number of built-in functions
            
             @return number of built-in functions
        </member>
        <member name="T:NPOI.HSSF.Record.FontRecord">
            Title:        Font Record - descrbes a font in the workbook (index = 0-3,5-infinity - skip 4)
            Description:  An element in the Font Table
            REFERENCE:  PG 315 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
            @author Andrew C. Oliver (acoliver at apache dot org)
            @version 2.0-pre
        </member>
        <member name="M:NPOI.HSSF.Record.FontRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
             Constructs a Font record and Sets its fields appropriately.
            
             @param in the RecordInputstream to Read the record from
        </member>
        <member name="M:NPOI.HSSF.Record.FontRecord.CloneStyleFrom(NPOI.HSSF.Record.FontRecord)">
            Clones all the font style information from another
             FontRecord, onto this one. This 
             will then hold all the same font style options.
        </member>
        <member name="P:NPOI.HSSF.Record.FontRecord.IsItalic">
             Set the font to be italics or not
            
             @param italics - whether the font Is italics or not
             @see #SetAttributes(short)
        </member>
        <member name="P:NPOI.HSSF.Record.FontRecord.IsStrikeout">
             Set the font to be stricken out or not
            
             @param strike - whether the font Is stricken out or not
             @see #SetAttributes(short)
        </member>
        <member name="P:NPOI.HSSF.Record.FontRecord.IsMacoutlined">
             whether to use the mac outline font style thing (mac only) - Some mac person
             should comment this instead of me doing it (since I have no idea)
            
             @param mac - whether to do that mac font outline thing or not
             @see #SetAttributes(short)
        </member>
        <member name="P:NPOI.HSSF.Record.FontRecord.IsMacshadowed">
             whether to use the mac shado font style thing (mac only) - Some mac person
             should comment this instead of me doing it (since I have no idea)
            
             @param mac - whether to do that mac font shadow thing or not
             @see #SetAttributes(short)
        </member>
        <member name="P:NPOI.HSSF.Record.FontRecord.Underline">
             Set the type of Underlining for the font
            
             @param u  base or subscript option
            
             @see #U_NONE
             @see #U_SINGLE
             @see #U_DOUBLE
             @see #U_SINGLE_ACCOUNTING
             @see #U_DOUBLE_ACCOUNTING
        </member>
        <member name="P:NPOI.HSSF.Record.FontRecord.Family">
             Set the font family (TODO)
            
             @param f family
        </member>
        <member name="P:NPOI.HSSF.Record.FontRecord.CharSet">
             Set the Char Set
            
             @param charSet - CharSet
        </member>
        <member name="P:NPOI.HSSF.Record.FontRecord.FontNameLength">
             Set the Length of the fontname string
            
             @param len  Length of the font name
             @see #SetFontName(String)
        </member>
        <member name="P:NPOI.HSSF.Record.FontRecord.FontName">
             Set the name of the font
            
             @param fn - name of the font (i.e. "Arial")
        </member>
        <member name="P:NPOI.HSSF.Record.FontRecord.FontHeight">
             Gets the height of the font in 1/20th point Units
            
             @return fontheight (in points/20)
        </member>
        <member name="P:NPOI.HSSF.Record.FontRecord.Attributes">
             Get the font attributes (see individual bit Getters that reference this method)
            
             @return attribute - the bitmask
        </member>
        <member name="P:NPOI.HSSF.Record.FontRecord.ColorPaletteIndex">
             Get the font's color palette index
            
             @return cpi - font color index
        </member>
        <member name="P:NPOI.HSSF.Record.FontRecord.BoldWeight">
             Get the bold weight for this font (100-1000dec or 0x64-0x3e8).  Default Is
             0x190 for normal and 0x2bc for bold
            
             @return bw - a number between 100-1000 for the fonts "boldness"
        </member>
        <member name="P:NPOI.HSSF.Record.FontRecord.SuperSubScript">
             Get the type of base or subscript for the font
            
             @return base or subscript option
             @see #SS_NONE
             @see #SS_SUPER
             @see #SS_SUB
        </member>
        <member name="M:NPOI.HSSF.Record.FontRecord.SameProperties(NPOI.HSSF.Record.FontRecord)">
            Does this FontRecord have all the same font
             properties as the supplied FontRecord?
            Note that {@link #equals(Object)} will check
             for exact objects, while this will check
             for exact contents, because normally the
             font record's position makes a big
             difference too.  
        </member>
        <member name="M:NPOI.HSSF.Record.FontRecord.Equals(System.Object)">
            Only returns two for the same exact object -
             creating a second FontRecord with the same
             properties won't be considered equal, as 
             the record's position in the record stream
             matters.
        </member>
        <member name="T:NPOI.HSSF.Record.FooterRecord">
            Title:        Footer Record 
            Description:  Specifies the footer for a sheet
            REFERENCE:  PG 317 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
            @author Andrew C. Oliver (acoliver at apache dot org)
            @author Shawn Laubach (slaubach at apache dot org) Modified 3/14/02
            @author Jason Height (jheight at chariot dot net dot au)
            @version 2.0-pre
        </member>
        <member name="M:NPOI.HSSF.Record.FooterRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HSSF.Record.FooterRecord"/> class.
            </summary>
            <param name="in1">the RecordInputstream to Read the record from</param>
        </member>
        <member name="P:NPOI.HSSF.Record.FooterRecord.IsMultibyte">
            <summary>
            the Unicode flag
            </summary>
            <value>
            	<c>true</c> if footer string has at least one multibyte Char; otherwise, <c>false</c>.
            </value> 
        </member>
        <member name="P:NPOI.HSSF.Record.FooterRecord.FooterLength">
            <summary>
            Gets or sets the length of the footer string.
            </summary>
            <value>The length of the footer string.</value>
            <see cref="P:NPOI.HSSF.Record.FooterRecord.Footer"></see>
        </member>
        <member name="P:NPOI.HSSF.Record.FooterRecord.Footer">
            <summary>
            Gets or sets the footer string.
            </summary>
            <value>The footer string to Display.</value>
            <see cref="P:NPOI.HSSF.Record.FooterRecord.FooterLength"/>
        </member>
        <member name="M:NPOI.HSSF.Record.FooterRecord.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="M:NPOI.HSSF.Record.FooterRecord.Serialize(System.Int32,System.Byte[])">
            <summary>
            Serializes the specified off set.
            </summary>
            <param name="offset">The off set.</param>
            <param name="data">The data.</param>
            <returns></returns>
        </member>
        <member name="P:NPOI.HSSF.Record.FooterRecord.RecordSize">
            <summary>
            gives the current Serialized size of the record. Should include the sid and recLength (4 bytes).
            </summary>
            <value></value>
        </member>
        <member name="P:NPOI.HSSF.Record.FooterRecord.Sid">
            <summary>
            </summary>
            <value></value>
            return the non static version of the id for this record.
        </member>
        <member name="T:NPOI.HSSF.Record.FormatRecord">
             Title:        Format Record
             Description:  describes a number format -- those goofy strings like $(#,###)
            
             REFERENCE:  PG 317 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
             @author Andrew C. Oliver (acoliver at apache dot org)
             @author Shawn M. Laubach (slaubach at apache dot org)  
             @version 2.0-pre
        </member>
        <member name="M:NPOI.HSSF.Record.FormatRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Constructs a Format record and Sets its fields appropriately.
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="M:NPOI.HSSF.Record.FormatRecord.SetIndexCode(System.Int16)">
             Set the format index code (for built in formats)
            
             @param index  the format index code
             @see org.apache.poi.hssf.model.Workbook
        </member>
        <member name="M:NPOI.HSSF.Record.FormatRecord.SetFormatStringLength(System.Byte)">
             Set the format string Length
            
             @param len  the Length of the format string
             @see #SetFormatString(String)
        </member>
        <member name="M:NPOI.HSSF.Record.FormatRecord.SetUnicodeFlag(System.Boolean)">
             Set whether the string Is Unicode
            
             @param Unicode flag for whether string Is Unicode
        </member>
        <member name="M:NPOI.HSSF.Record.FormatRecord.SetFormatString(System.String)">
             Set the format string
            
             @param fs  the format string
             @see #SetFormatStringLength(byte)
        </member>
        <member name="M:NPOI.HSSF.Record.FormatRecord.GetIndexCode">
             Get the format index code (for built in formats)
            
             @return the format index code
             @see org.apache.poi.hssf.model.Workbook
        </member>
        <member name="M:NPOI.HSSF.Record.FormatRecord.GetUnicodeFlag">
             Get whether the string Is Unicode
            
             @return flag for whether string Is Unicode
        </member>
        <member name="M:NPOI.HSSF.Record.FormatRecord.GetFormatString">
             Get the format string
            
             @return the format string
        </member>
        <member name="T:NPOI.HSSF.Record.SpecialCachedValue">
            Manages the cached formula result values of other types besides numeric.
            Excel encodes the same 8 bytes that would be field_4_value with various NaN
            values that are decoded/encoded by this class. 
        </member>
        <member name="F:NPOI.HSSF.Record.SpecialCachedValue.BIT_MARKER">
            deliberately chosen by Excel in order to encode other values within Double NaNs 
        </member>
        <member name="M:NPOI.HSSF.Record.SpecialCachedValue.Create(System.Int64)">
            @return <c>null</c> if the double value encoded by <tt>valueLongBits</tt> 
            is a normal (non NaN) double value.
        </member>
        <member name="T:NPOI.HSSF.Record.FormulaRecord">
            Formula Record.
            REFERENCE:  PG 317/444 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
            @author Andrew C. Oliver (acoliver at apache dot org)
            @author Jason Height (jheight at chariot dot net dot au)
            @version 2.0-pre
        </member>
        <member name="F:NPOI.HSSF.Record.FormulaRecord.specialCachedValue">
            Since the NaN support seems sketchy (different constants) we'll store and spit it out directly
        </member>
        <member name="F:NPOI.HSSF.Record.FormulaRecord.value_data">
            Since the NaN support seems sketchy (different constants) we'll store and spit it out directly
        </member>
        <member name="M:NPOI.HSSF.Record.FormulaRecord.#ctor">
            Creates new FormulaRecord 
        </member>
        <member name="M:NPOI.HSSF.Record.FormulaRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
             Constructs a Formula record and Sets its fields appropriately.
             Note - id must be 0x06 (NOT 0x406 see MSKB #Q184647 for an 
             "explanation of this bug in the documentation) or an exception
              will be throw upon validation
            
             @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.FormulaRecord.HasCachedResultString">
            @return <c>true</c> if this {@link FormulaRecord} is followed by a
             {@link StringRecord} representing the cached text result of the formula
             evaluation.
        </member>
        <member name="P:NPOI.HSSF.Record.FormulaRecord.Value">
             Get the calculated value of the formula
            
             @return calculated value
        </member>
        <member name="P:NPOI.HSSF.Record.FormulaRecord.Options">
             Get the option flags
            
             @return bitmask
        </member>
        <member name="P:NPOI.HSSF.Record.FormulaRecord.ParsedExpression">
             Get the stack as a list
            
             @return list of tokens (casts stack to a list and returns it!)
             this method can return null Is we are Unable to Create Ptgs from 
                 existing excel file
             callers should Check for null!
        </member>
        <member name="T:NPOI.HSSF.Record.GridsetRecord">
             Title:        GridSet Record.
             Description:  flag denoting whether the user specified that gridlines are used when
                           printing.
             REFERENCE:  PG 320 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
            
             @author Andrew C. Oliver (acoliver at apache dot org)
             @author  Glen Stampoultzis (glens at apache.org)
             @author Jason Height (jheight at chariot dot net dot au)
            
             @version 2.0-pre
        </member>
        <member name="M:NPOI.HSSF.Record.GridsetRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Constructs a GridSet record and Sets its fields appropriately.
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.GridsetRecord.Gridset">
             Get whether the gridlines are shown during printing.
            
             @return gridSet - true if gridlines are NOT printed, false if they are.
        </member>
        <member name="T:NPOI.HSSF.Record.GutsRecord">
            Title:        Guts Record 
            Description:  Row/column gutter sizes 
            REFERENCE:  PG 320 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
            @author Andrew C. Oliver (acoliver at apache dot org)
            @author Jason Height (jheight at chariot dot net dot au)
            @version 2.0-pre
        </member>
        <member name="M:NPOI.HSSF.Record.GutsRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Constructs a Guts record and Sets its fields appropriately.
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.GutsRecord.LeftRowGutter">
             Get the size of the gutter that appears at the left of the rows
            
             @return gutter size in screen Units
        </member>
        <member name="P:NPOI.HSSF.Record.GutsRecord.TopColGutter">
             Get the size of the gutter that appears at the above the columns
            
             @return gutter size in screen Units
        </member>
        <member name="P:NPOI.HSSF.Record.GutsRecord.RowLevelMax">
             Get the maximum outline level for the row gutter.
            
             @return maximum outline level
        </member>
        <member name="P:NPOI.HSSF.Record.GutsRecord.ColLevelMax">
             Get the maximum outline level for the col gutter.
            
             @return maximum outline level
        </member>
        <member name="T:NPOI.HSSF.Record.HCenterRecord">
            Title:        HCenter record
            Description:  whether to center between horizontal margins
            REFERENCE:  PG 320 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
            @author Andrew C. Oliver (acoliver at apache dot org)
            @author Jason Height (jheight at chariot dot net dot au)
            @version 2.0-pre
        </member>
        <member name="M:NPOI.HSSF.Record.HCenterRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Constructs an HCenter record and Sets its fields appropriately.
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.HCenterRecord.HCenter">
            Get whether or not to horizonatally center this sheet.
            @return center - t/f
        </member>
        <member name="T:NPOI.HSSF.Record.HeaderRecord">
            Title:        Header Record
            Description:  Specifies a header for a sheet
            REFERENCE:  PG 321 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
            @author Andrew C. Oliver (acoliver at apache dot org)
            @author Shawn Laubach (slaubach at apache dot org) Modified 3/14/02
            @author Jason Height (jheight at chariot dot net dot au)
            @version 2.0-pre
        </member>
        <member name="M:NPOI.HSSF.Record.HeaderRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Constructs an Header record and Sets its fields appropriately.
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.HeaderRecord.IsMultibyte">
             see the Unicode flag
            
             @return bool flag
              true:footer string has at least one multibyte Char
        </member>
        <member name="P:NPOI.HSSF.Record.HeaderRecord.HeaderLength">
             Get the Length of the header string
            
             @return Length of the header string
             @see #Header
        </member>
        <member name="P:NPOI.HSSF.Record.HeaderRecord.Header">
             Get the header string
            
             @return header string to Display
             @see #HeaderLength
        </member>
        <member name="T:NPOI.HSSF.Record.HideObjRecord">
            Title:        Hide Object Record
            Description:  flag defines whether to hide placeholders and object
            REFERENCE:  PG 321 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
            @author Andrew C. Oliver (acoliver at apache dot org)
            @version 2.0-pre
        </member>
        <member name="M:NPOI.HSSF.Record.HideObjRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Constructs an HideObj record and Sets its fields appropriately.
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="M:NPOI.HSSF.Record.HideObjRecord.SetHideObj(System.Int16)">
             Set hide object options
            
             @param hide options
             @see #HIDE_ALL
             @see #SHOW_PLACEHOLDERS
             @see #SHOW_ALL
        </member>
        <member name="M:NPOI.HSSF.Record.HideObjRecord.GetHideObj">
             Get hide object options
            
             @return hide options
             @see #HIDE_ALL
             @see #SHOW_PLACEHOLDERS
             @see #SHOW_ALL
        </member>
        <member name="T:NPOI.HSSF.Record.HorizontalPageBreakRecord">
            HorizontalPageBreak record that stores page breaks at rows
            
            This class Is just used so that SID Compares work properly in the RecordFactory
            @see PageBreakRecord
            @author Danny Mui (dmui at apache dot org) 
        </member>
        <member name="M:NPOI.HSSF.Record.HorizontalPageBreakRecord.#ctor">
            
        </member>
        <member name="M:NPOI.HSSF.Record.HorizontalPageBreakRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            @param in the RecordInputstream to Read the record from
        </member>
        <!-- Badly formed XML comment ignored for member "T:NPOI.HSSF.Record.HyperlinkRecord" -->
        <member name="F:NPOI.HSSF.Record.HyperlinkRecord.HLINK_URL">
            Link flags
        </member>
        <member name="F:NPOI.HSSF.Record.HyperlinkRecord.URL_uninterpretedTail">
            Tail of a URL link
        </member>
        <member name="F:NPOI.HSSF.Record.HyperlinkRecord.FILE_uninterpretedTail">
            Tail of a file link
        </member>
        <member name="F:NPOI.HSSF.Record.HyperlinkRecord._range">
            cell range of this hyperlink 
        </member>
        <member name="F:NPOI.HSSF.Record.HyperlinkRecord._guid">
            16-byte GUID
        </member>
        <member name="F:NPOI.HSSF.Record.HyperlinkRecord._fileOpts">
            Some sort of options for file links.
        </member>
        <member name="F:NPOI.HSSF.Record.HyperlinkRecord._linkOpts">
            Link options. Can include any of HLINK_* flags.
        </member>
        <member name="F:NPOI.HSSF.Record.HyperlinkRecord._label">
            Test label
        </member>
        <member name="F:NPOI.HSSF.Record.HyperlinkRecord._moniker">
            Moniker. Makes sense only for URL and file links
        </member>
        <member name="F:NPOI.HSSF.Record.HyperlinkRecord._shortFilename">
            in 8:3 DOS format No Unicode string header,
            always 8-bit characters, zero-terminated 
        </member>
        <member name="F:NPOI.HSSF.Record.HyperlinkRecord._address">
            Link 
        </member>
        <member name="F:NPOI.HSSF.Record.HyperlinkRecord._textMark">
            Text describing a place in document.  In Excel UI, this is appended to the
            address, (after a '#' delimiter).<br/>
            This field is optional.  If present, the {@link #HLINK_PLACE} must be set.
        </member>
        <member name="F:NPOI.HSSF.Record.HyperlinkRecord._uninterpretedTail">
            Remaining bytes
        </member>
        <member name="M:NPOI.HSSF.Record.HyperlinkRecord.#ctor">
            Create a new hyperlink
        </member>
        <member name="M:NPOI.HSSF.Record.HyperlinkRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
             Read hyperlink from input stream
            
             @param in the stream to Read from
        </member>
        <member name="P:NPOI.HSSF.Record.HyperlinkRecord.FirstColumn">
             Return the column of the first cell that Contains the hyperlink
            
             @return the 0-based column of the first cell that Contains the hyperlink
        </member>
        <member name="P:NPOI.HSSF.Record.HyperlinkRecord.LastColumn">
             Set the column of the last cell that Contains the hyperlink
            
             @return the 0-based column of the last cell that Contains the hyperlink
        </member>
        <member name="P:NPOI.HSSF.Record.HyperlinkRecord.FirstRow">
             Return the row of the first cell that Contains the hyperlink
            
             @return the 0-based row of the first cell that Contains the hyperlink
        </member>
        <member name="P:NPOI.HSSF.Record.HyperlinkRecord.LastRow">
             Return the row of the last cell that Contains the hyperlink
            
             @return the 0-based row of the last cell that Contains the hyperlink
        </member>
        <member name="P:NPOI.HSSF.Record.HyperlinkRecord.Guid">
             Returns a 16-byte guid identifier. Seems to always equal {@link STD_MONIKER}
            
             @return 16-byte guid identifier
        </member>
        <member name="P:NPOI.HSSF.Record.HyperlinkRecord.Moniker">
             Returns a 16-byte moniker.
            
             @return 16-byte moniker
        </member>
        <member name="P:NPOI.HSSF.Record.HyperlinkRecord.Label">
             Return text label for this hyperlink
            
             @return  text to Display
        </member>
        <member name="P:NPOI.HSSF.Record.HyperlinkRecord.Address">
             Hypelink Address. Depending on the hyperlink type it can be URL, e-mail, patrh to a file, etc.
            
             @return  the Address of this hyperlink
        </member>
        <member name="P:NPOI.HSSF.Record.HyperlinkRecord.LinkOptions">
            Link options. Must be a combination of HLINK_* constants.
        </member>
        <member name="P:NPOI.HSSF.Record.HyperlinkRecord.LabelOptions">
            Label options
        </member>
        <member name="P:NPOI.HSSF.Record.HyperlinkRecord.FileOptions">
            Options for a file link
        </member>
        <member name="M:NPOI.HSSF.Record.HyperlinkRecord.CreateUrlLink">
            <summary>
            Initialize a new url link
            </summary>        
        </member>
        <member name="M:NPOI.HSSF.Record.HyperlinkRecord.CreateFileLink">
            <summary>
            Initialize a new file link
            </summary>
        </member>
        <member name="M:NPOI.HSSF.Record.HyperlinkRecord.CreateDocumentLink">
            <summary>
            Initialize a new document link
            </summary>
        </member>
        <member name="T:NPOI.HSSF.Record.IndexRecord">
            Title:        Index Record
            Description:  Occurs right after BOF, tells you where the DBCELL records are for a sheet
                          Important for locating cells
            NOT USED IN THIS RELEASE
            REFERENCE:  PG 323 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
            @author Andrew C. Oliver (acoliver at apache dot org)
            @author Jason Height (jheight at chariot dot net dot au)
            @version 2.0-pre
        </member>
        <member name="M:NPOI.HSSF.Record.IndexRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Constructs an Index record and Sets its fields appropriately.
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="M:NPOI.HSSF.Record.IndexRecord.GetRecordSizeForBlockCount(System.Int32)">
            Returns the size of an INdexRecord when it needs to index the specified number of blocks
            
        </member>
        <member name="T:NPOI.HSSF.Record.InterfaceEndRecord">
            Title: Interface End Record
            Description: Shows where the Interface Records end (MMS)
             (has no fields)
            REFERENCE:  PG 324 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
            @author Andrew C. Oliver (acoliver at apache dot org)
            @version 2.0-pre
        </member>
        <member name="M:NPOI.HSSF.Record.InterfaceEndRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Constructs an InterfaceEnd record and Sets its fields appropriately.
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="T:NPOI.HSSF.Record.IterationRecord">
            Title:        Iteration Record
            Description:  Tells whether to iterate over forumla calculations or not
                          (if a formula Is dependant upon another formula's result)
                          (odd feature for something that can only have 32 elements in
                           a formula!)
            REFERENCE:  PG 325 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
            @author Andrew C. Oliver (acoliver at apache dot org)
            @author Jason Height (jheight at chariot dot net dot au)
            @version 2.0-pre
        </member>
        <member name="M:NPOI.HSSF.Record.IterationRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Constructs an Iteration record and Sets its fields appropriately.
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.IterationRecord.Iteration">
             Get whether or not to iterate for calculations
            
             @return whether iterative calculations are turned off or on
        </member>
        <member name="T:NPOI.HSSF.Record.LabelRecord">
            Label Record - Read only support for strings stored directly in the cell..  Don't
            use this (except to Read), use LabelSST instead 
            REFERENCE:  PG 325 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
            @author Andrew C. Oliver (acoliver at apache dot org)
            @author Jason Height (jheight at chariot dot net dot au)
            @version 2.0-pre
            @see org.apache.poi.hssf.record.LabelSSTRecord
        </member>
        <member name="M:NPOI.HSSF.Record.LabelRecord.#ctor">
            Creates new LabelRecord 
        </member>
        <member name="M:NPOI.HSSF.Record.LabelRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
             Constructs an Label record and Sets its fields appropriately.
            
             @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.LabelRecord.StringLength">
            Get the number of Chars this string Contains
            @return number of Chars
        </member>
        <member name="P:NPOI.HSSF.Record.LabelRecord.IsUncompressedUnicode">
            Is this Uncompressed Unicode (16bit)?  Or just 8-bit compressed?
            @return IsUnicode - True for 16bit- false for 8bit
        </member>
        <member name="P:NPOI.HSSF.Record.LabelRecord.Value">
             Get the value
            
             @return the text string
             @see #GetStringLength
        </member>
        <member name="M:NPOI.HSSF.Record.LabelRecord.Serialize(System.Int32,System.Byte[])">
            THROWS A RUNTIME EXCEPTION..  USE LABELSSTRecords.  YOU HAVE NO REASON to use LABELRecord!!
        </member>
        <member name="T:NPOI.HSSF.Record.LabelSSTRecord">
            Title:        Label SST Record
            Description:  Refers to a string in the shared string table and Is a column
                          value.  
            REFERENCE:  PG 325 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
            @author Andrew C. Oliver (acoliver at apache dot org)
            @author Jason Height (jheight at chariot dot net dot au)
            @version 2.0-pre
        </member>
        <member name="M:NPOI.HSSF.Record.LabelSSTRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Constructs an LabelSST record and Sets its fields appropriately.
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.LabelSSTRecord.SSTIndex">
             Get the index to the string in the SSTRecord
            
             @return index of string in the SST Table
             @see org.apache.poi.hssf.record.SSTRecord
        </member>
        <member name="T:NPOI.HSSF.Record.LeftMarginRecord">
            Record for the left margin.
            NOTE: This source was automatically generated.
            @author Shawn Laubach (slaubach at apache dot org)
        </member>
        <member name="M:NPOI.HSSF.Record.LeftMarginRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
             Constructs a LeftMargin record and Sets its fields appropriately.
            
             @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.LeftMarginRecord.RecordSize">
            Size of record (exluding 4 byte header)
        </member>
        <member name="P:NPOI.HSSF.Record.LeftMarginRecord.Margin">
            Get the margin field for the LeftMargin record.
        </member>
        <member name="T:NPOI.HSSF.Record.LinkedDataFormulaField">
             Not implemented yet. May commit it anyway just so people can see
             where I'm heading.
            
             @author Glen Stampoultzis (glens at apache.org)
        </member>
        <member name="T:NPOI.HSSF.Record.Margin">
             The margin interface Is a parent used to define left, right, top and bottom margins.
             This allows much of the code to be generic when it comes to handling margins.
             NOTE: This source wass automatically generated.
            
             @author Shawn Laubach (slaubach at apache dot org)
        </member>
        <member name="P:NPOI.HSSF.Record.Margin.Margin">
            Get the margin field for the Margin.
        </member>
        <!-- Badly formed XML comment ignored for member "T:NPOI.HSSF.Record.MergeCellsRecord" -->
        <member name="F:NPOI.HSSF.Record.MergeCellsRecord._regions">
            sometimes the regions array is shared with other MergedCellsRecords 
        </member>
        <member name="M:NPOI.HSSF.Record.MergeCellsRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Constructs a MergedCellsRecord and Sets its fields appropriately
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.MergeCellsRecord.NumAreas">
            Get the number of merged areas.  If this drops down to 0 you should just go
            ahead and delete the record.
            @return number of areas
        </member>
        <member name="M:NPOI.HSSF.Record.MergeCellsRecord.GetAreaAt(System.Int32)">
            @return MergedRegion at the given index representing the area that is Merged (r1,c1 - r2,c2)
        </member>
        <member name="T:NPOI.HSSF.Record.MMSRecord">
            Title: MMS Record
            Description: defines how many Add menu and del menu options are stored
                               in the file. Should always be Set to 0 for HSSF workbooks
            REFERENCE:  PG 328 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
            @author Andrew C. Oliver (acoliver at apache dot org)
            @version 2.0-pre
        </member>
        <member name="M:NPOI.HSSF.Record.MMSRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Constructs a MMS record and Sets its fields appropriately.
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="M:NPOI.HSSF.Record.MMSRecord.SetAddMenuCount(System.Byte)">
            Set number of Add menu options (Set to 0)
            @param am  number of Add menu options
        </member>
        <member name="M:NPOI.HSSF.Record.MMSRecord.SetDelMenuCount(System.Byte)">
            Set number of del menu options (Set to 0)
            @param dm  number of del menu options
        </member>
        <member name="M:NPOI.HSSF.Record.MMSRecord.GetAddMenuCount">
            Get number of Add menu options (should be 0)
            @return number of Add menu options
        </member>
        <member name="M:NPOI.HSSF.Record.MMSRecord.GetDelMenuCount">
            Get number of Add del options (should be 0)
            @return number of Add menu options
        </member>
        <member name="T:NPOI.HSSF.Record.MulBlankRecord">
            Title:        Mulitple Blank cell record 
            Description:  Represents a  Set of columns in a row with no value but with styling.
                          In this release we have Read-only support for this record type.
                          The RecordFactory Converts this to a Set of BlankRecord objects.
            REFERENCE:  PG 329 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
            @author Andrew C. Oliver (acoliver at apache dot org)
            @author Glen Stampoultzis (glens at apache.org)
            @version 2.0-pre
            @see org.apache.poi.hssf.record.BlankRecord
        </member>
        <member name="M:NPOI.HSSF.Record.MulBlankRecord.#ctor">
            Creates new MulBlankRecord 
        </member>
        <member name="M:NPOI.HSSF.Record.MulBlankRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
             Constructs a MulBlank record and Sets its fields appropriately.
            
             @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.MulBlankRecord.Row">
             Get the row number of the cells this represents
            
             @return row number
        </member>
        <member name="P:NPOI.HSSF.Record.MulBlankRecord.FirstColumn">
            starting column (first cell this holds in the row)
            @return first column number
        </member>
        <member name="P:NPOI.HSSF.Record.MulBlankRecord.LastColumn">
            ending column (last cell this holds in the row)
            @return first column number
        </member>
        <member name="P:NPOI.HSSF.Record.MulBlankRecord.NumColumns">
            Get the number of columns this Contains (last-first +1)
            @return number of columns (last - first +1)
        </member>
        <member name="M:NPOI.HSSF.Record.MulBlankRecord.GetXFAt(System.Int32)">
            returns the xf index for column (coffset = column - field_2_first_col)
            @param coffset  the column (coffset = column - field_2_first_col)
            @return the XF index for the column
        </member>
        <member name="T:NPOI.HSSF.Record.MulRKRecord">
            Used to store multiple RK numbers on a row.  1 MulRk = Multiple Cell values.
            HSSF just Converts this into multiple NUMBER records.  Read-ONLY SUPPORT!
            REFERENCE:  PG 330 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
            @author Andrew C. Oliver (acoliver at apache dot org)
            @version 2.0-pre
        </member>
        <member name="M:NPOI.HSSF.Record.MulRKRecord.#ctor">
            Creates new MulRKRecord 
        </member>
        <member name="M:NPOI.HSSF.Record.MulRKRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
             Constructs a MulRK record and Sets its fields appropriately.
            
             @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.MulRKRecord.FirstColumn">
            starting column (first cell this holds in the row)
            @return first column number
        </member>
        <member name="P:NPOI.HSSF.Record.MulRKRecord.LastColumn">
            ending column (last cell this holds in the row)
            @return first column number
        </member>
        <member name="P:NPOI.HSSF.Record.MulRKRecord.NumColumns">
            Get the number of columns this Contains (last-first +1)
            @return number of columns (last - first +1)
        </member>
        <member name="M:NPOI.HSSF.Record.MulRKRecord.GetXFAt(System.Int32)">
            returns the xf index for column (coffset = column - field_2_first_col)
            @return the XF index for the column
        </member>
        <member name="M:NPOI.HSSF.Record.MulRKRecord.GetRKNumberAt(System.Int32)">
            returns the rk number for column (coffset = column - field_2_first_col)
            @return the value (decoded into a double)
        </member>
        <member name="T:NPOI.HSSF.Record.NameRecord">
            Title:        Name Record (aka Named Range) 
            Description:  Defines a named range within a workbook. 
            REFERENCE:  
            @author Libin Roman (Vista Portal LDT. Developer)
            @author  Sergei Kozello (sergeikozello at mail.ru)
            @author Glen Stampoultzis (glens at apache.org)
            @version 1.0-pre
        </member>
        <member name="F:NPOI.HSSF.Record.NameRecord.sid">
        </member>
        <member name="F:NPOI.HSSF.Record.NameRecord.BUILTIN_CONSOLIDATE_AREA">
            Included for completeness sake, not implemented
        </member>
        <member name="F:NPOI.HSSF.Record.NameRecord.BUILTIN_AUTO_OPEN">
            Included for completeness sake, not implemented
        </member>
        <member name="F:NPOI.HSSF.Record.NameRecord.BUILTIN_AUTO_CLOSE">
            Included for completeness sake, not implemented
        </member>
        <member name="F:NPOI.HSSF.Record.NameRecord.BUILTIN_DATABASE">
            Included for completeness sake, not implemented
        </member>
        <member name="F:NPOI.HSSF.Record.NameRecord.BUILTIN_CRITERIA">
            Included for completeness sake, not implemented
        </member>
        <member name="F:NPOI.HSSF.Record.NameRecord.BUILTIN_RECORDER">
            Included for completeness sake, not implemented
        </member>
        <member name="F:NPOI.HSSF.Record.NameRecord.BUILTIN_DATA_FORM">
            Included for completeness sake, not implemented
        </member>
        <member name="F:NPOI.HSSF.Record.NameRecord.BUILTIN_AUTO_ACTIVATE">
            Included for completeness sake, not implemented
        </member>
        <member name="F:NPOI.HSSF.Record.NameRecord.BUILTIN_AUTO_DEACTIVATE">
            Included for completeness sake, not implemented
        </member>
        <member name="F:NPOI.HSSF.Record.NameRecord.BUILTIN_SHEET_TITLE">
            Included for completeness sake, not implemented
        </member>
        <member name="F:NPOI.HSSF.Record.NameRecord.field_5_externSheetIndex_plus1">
            One-based extern index of sheet (resolved via LinkTable). Zero if this is a global name  
        </member>
        <member name="F:NPOI.HSSF.Record.NameRecord.field_6_sheetNumber">
            the one based sheet number.  
        </member>
        <member name="M:NPOI.HSSF.Record.NameRecord.#ctor">
            Creates new NameRecord 
        </member>
        <member name="M:NPOI.HSSF.Record.NameRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
             Constructs a Name record and Sets its fields appropriately.
            
             @param in the RecordInputstream to Read the record from
        </member>
        <member name="M:NPOI.HSSF.Record.NameRecord.#ctor(System.Byte,System.Int32)">
            Constructor to Create a built-in named region
            @param builtin Built-in byte representation for the name record, use the public constants
            @param index 
        </member>
        <member name="P:NPOI.HSSF.Record.NameRecord.FnGroup">
            @return function Group
            @see FnGroupCountRecord
        </member>
        <member name="P:NPOI.HSSF.Record.NameRecord.OptionFlag">
            Gets the option flag
            @return option flag
        </member>
        <member name="P:NPOI.HSSF.Record.NameRecord.KeyboardShortcut">
            returns the keyboard shortcut
            @return keyboard shortcut
        </member>
        <member name="P:NPOI.HSSF.Record.NameRecord.NameTextLength">
            ** 
        </member>
        <member name="P:NPOI.HSSF.Record.NameRecord.HasFormula">
            @return <c>true</c> if name has a formula (named range or defined value)
        </member>
        <member name="P:NPOI.HSSF.Record.NameRecord.IsHiddenName">
            @return true if name Is hidden
        </member>
        <member name="P:NPOI.HSSF.Record.NameRecord.IsFunctionName">
            @return true if name Is a function
        </member>
        <member name="P:NPOI.HSSF.Record.NameRecord.IsCommandName">
            @return true if name Is a command
        </member>
        <member name="P:NPOI.HSSF.Record.NameRecord.IsMacro">
            @return true if function macro or command macro
        </member>
        <member name="P:NPOI.HSSF.Record.NameRecord.IsComplexFunction">
            @return true if array formula or user defined
        </member>
        <member name="P:NPOI.HSSF.Record.NameRecord.IsBuiltInName">
            Convenience Function to determine if the name Is a built-in name
        </member>
        <member name="P:NPOI.HSSF.Record.NameRecord.NameText">
            Gets the name
            @return name
        </member>
        <member name="P:NPOI.HSSF.Record.NameRecord.BuiltInName">
            Gets the Built In Name
            @return the built in Name
        </member>
        <member name="P:NPOI.HSSF.Record.NameRecord.NameDefinition">
            Gets the definition, reference (Formula)
            @return definition -- can be null if we cant Parse ptgs
        </member>
        <member name="P:NPOI.HSSF.Record.NameRecord.CustomMenuText">
            Get the custom menu text
            @return custom menu text
        </member>
        <member name="P:NPOI.HSSF.Record.NameRecord.DescriptionText">
            Gets the description text
            @return description text
        </member>
        <member name="P:NPOI.HSSF.Record.NameRecord.HelpTopicText">
            Get the help topic text
            @return gelp topic text
        </member>
        <member name="P:NPOI.HSSF.Record.NameRecord.StatusBarText">
            Gets the status bar text
            @return status bar text
        </member>
        <member name="P:NPOI.HSSF.Record.NameRecord.SheetNumber">
            For named ranges, and built-in names
            @return the 1-based sheet number. 
        </member>
        <member name="M:NPOI.HSSF.Record.NameRecord.Serialize(NPOI.Util.IO.LittleEndianOutput)">
            called by the class that Is responsible for writing this sucker.
            Subclasses should implement this so that their data Is passed back in a
            @param offset to begin writing at
            @param data byte array containing instance data
            @return number of bytes written
        </member>
        <member name="P:NPOI.HSSF.Record.NameRecord.ExternSheetNumber">
            Gets the extern sheet number
            @return extern sheet index
        </member>
        <member name="P:NPOI.HSSF.Record.NameRecord.Sid">
            return the non static version of the id for this record.
        </member>
        <member name="M:NPOI.HSSF.Record.NameRecord.ToString">
            @see Object#ToString()
        </member>
        <member name="M:NPOI.HSSF.Record.NameRecord.TranslateBuiltInName(System.Byte)">
            Creates a human Readable name for built in types
            @return Unknown if the built-in name cannot be translated
        </member>
        <member name="T:NPOI.HSSF.Record.NoteRecord">
             NOTE: Comment Associated with a Cell (1Ch)
            
             @author Yegor Kozlov
        </member>
        <member name="F:NPOI.HSSF.Record.NoteRecord.NOTE_HIDDEN">
            Flag indicating that the comment Is hidden (default)
        </member>
        <member name="F:NPOI.HSSF.Record.NoteRecord.NOTE_VISIBLE">
            Flag indicating that the comment Is visible
        </member>
        <member name="M:NPOI.HSSF.Record.NoteRecord.#ctor">
            Construct a new <c>NoteRecord</c> and
            Fill its data with the default values
        </member>
        <member name="M:NPOI.HSSF.Record.NoteRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
             Constructs a <c>NoteRecord</c> and Fills its fields
             from the supplied <c>RecordInputStream</c>.
            
             @param in the stream to Read from
        </member>
        <member name="P:NPOI.HSSF.Record.NoteRecord.Sid">
            @return id of this record.
        </member>
        <member name="M:NPOI.HSSF.Record.NoteRecord.Serialize(System.Int32,System.Byte[])">
             Serialize the record data into the supplied array of bytes
            
             @param offset offset in the <c>data</c>
             @param data the data to Serialize into
            
             @return size of the record
        </member>
        <member name="P:NPOI.HSSF.Record.NoteRecord.RecordSize">
            Size of record
        </member>
        <member name="M:NPOI.HSSF.Record.NoteRecord.ToString">
            Convert this record to string.
            Used by BiffViewer and other utulities.
        </member>
        <member name="P:NPOI.HSSF.Record.NoteRecord.Row">
             Return the row that Contains the comment
            
             @return the row that Contains the comment
        </member>
        <member name="P:NPOI.HSSF.Record.NoteRecord.Column">
             Return the column that Contains the comment
            
             @return the column that Contains the comment
        </member>
        <member name="P:NPOI.HSSF.Record.NoteRecord.Flags">
             Options flags.
            
             @return the options flag
             @see #NOTE_VISIBLE
             @see #NOTE_HIDDEN
        </member>
        <member name="P:NPOI.HSSF.Record.NoteRecord.ShapeId">
            Object id for OBJ record that Contains the comment
        </member>
        <member name="P:NPOI.HSSF.Record.NoteRecord.Author">
             Name of the original comment author
            
             @return the name of the original author of the comment
        </member>
        <member name="T:NPOI.HSSF.Record.NumberRecord">
            Contains a numeric cell value. 
            REFERENCE:  PG 334 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
            @author Andrew C. Oliver (acoliver at apache dot org)
            @author Jason Height (jheight at chariot dot net dot au)
            @version 2.0-pre
        </member>
        <member name="M:NPOI.HSSF.Record.NumberRecord.#ctor">
            Creates new NumberRecord 
        </member>
        <member name="M:NPOI.HSSF.Record.NumberRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
             Constructs a Number record and Sets its fields appropriately.
            
             @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.NumberRecord.Value">
             Get the value for the cell
            
             @return double representing the value
        </member>
        <member name="T:NPOI.HSSF.Record.ObjectProtectRecord">
            Title: Object Protect Record
            Description: Protect embedded object with the lamest "security" ever invented.  
            This record tells  "I want to protect my objects" with lame security.  It 
            appears in conjunction with the PASSWORD and PROTECT records as well as its 
            scenario protect cousin.
            REFERENCE:  PG 368 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
            @author Andrew C. Oliver (acoliver at apache dot org)
        </member>
        <member name="M:NPOI.HSSF.Record.ObjectProtectRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Constructs a Protect record and Sets its fields appropriately.
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.ObjectProtectRecord.Protect">
            Get whether the sheet Is protected or not
            @return whether to protect the sheet or not
        </member>
        <member name="T:NPOI.HSSF.Record.ObjRecord">
             The obj record is used to hold various graphic objects and controls.
            
             @author Glen Stampoultzis (glens at apache.org)
        </member>
        <member name="F:NPOI.HSSF.Record.ObjRecord._uninterpretedData">
            used when POI has no idea what is going on 
        </member>
        <member name="F:NPOI.HSSF.Record.ObjRecord._isPaddedToQuadByteMultiple">
            Excel seems to tolerate padding to quad or double byte length
        </member>
        <member name="M:NPOI.HSSF.Record.ObjRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
             Constructs a OBJ record and Sets its fields appropriately.
            
             @param in the RecordInputstream to Read the record from
        </member>
        <member name="M:NPOI.HSSF.Record.ObjRecord.CanPaddingBeDiscarded(System.Byte[],System.Int32)">
            Some XLS files have ObjRecords with nearly 8Kb of excessive padding. These were probably
            written by a version of POI (around 3.1) which incorrectly interpreted the second short of
            the ftLbs subrecord (0x1FEE) as a length, and read that many bytes as padding (other bugs
            helped allow this to occur).
            
            Excel reads files with this excessive padding OK, truncating the over-sized ObjRecord back
            to the its proper size.  POI does the same.
        </member>
        <member name="P:NPOI.HSSF.Record.ObjRecord.RecordSize">
            Size of record (excluding 4 byte header)
        </member>
        <member name="T:NPOI.HSSF.Record.PageBreakRecord">
            Record that Contains the functionality page _breaks (horizontal and vertical)
            
            The other two classes just specifically Set the SIDS for record creation.
            
            REFERENCE:  Microsoft Excel SDK page 322 and 420
            
            @see HorizontalPageBreakRecord
            @see VerticalPageBreakRecord
            @author Danny Mui (dmui at apache dot org)
        </member>
        <member name="T:NPOI.HSSF.Record.PageBreakRecord.Break">
            Since both records store 2byte integers (short), no point in 
            differentiating it in the records.
            
            The subs (rows or columns, don't seem to be able to Set but excel Sets
            them automatically)
        </member>
        <member name="M:NPOI.HSSF.Record.PageBreakRecord.AddBreak(System.Int32,System.Int32,System.Int32)">
            Adds the page break at the specified parameters
            @param main Depending on sid, will determine row or column to put page break (zero-based)
            @param subFrom No user-interface to Set (defaults to minumum, 0)
            @param subTo No user-interface to Set
        </member>
        <member name="M:NPOI.HSSF.Record.PageBreakRecord.RemoveBreak(System.Int32)">
            Removes the break indicated by the parameter
            @param main (zero-based)
        </member>
        <member name="M:NPOI.HSSF.Record.PageBreakRecord.GetBreak(System.Int32)">
            Retrieves the region at the row/column indicated
            @param main FIXME: Document this!
            @return The Break or null if no break exists at the row/col specified.
        </member>
        <member name="T:NPOI.HSSF.Record.PaletteRecord">
            PaletteRecord - Supports custom palettes.
            @author Andrew C. Oliver (acoliver at apache dot org)
            @author Brian Sanders (bsanders at risklabs dot com) - custom palette editing
            @version 2.0-pre
        </member>
        <member name="F:NPOI.HSSF.Record.PaletteRecord.STANDARD_PALETTE_SIZE">
            The standard size of an XLS palette 
        </member>
        <member name="F:NPOI.HSSF.Record.PaletteRecord.FIRST_COLOR_INDEX">
            The byte index of the first color 
        </member>
        <member name="M:NPOI.HSSF.Record.PaletteRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Constructs a PaletteRecord record and Sets its fields appropriately.
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="M:NPOI.HSSF.Record.PaletteRecord.GetColor(System.Int16)">
             Returns the color value at a given index
            
             @return the RGB triplet for the color, or null if the specified index
             does not exist
        </member>
        <member name="M:NPOI.HSSF.Record.PaletteRecord.SetColor(System.Int16,System.Byte,System.Byte,System.Byte)">
             Sets the color value at a given index
            
             If the given index Is greater than the current last color index,
             then black Is Inserted at every index required to make the palette continuous.
            
             @param byteIndex the index to Set; if this index Is less than 0x8 or greater than
             0x40, then no modification Is made
        </member>
        <member name="M:NPOI.HSSF.Record.PaletteRecord.CreateDefaultPalette">
             Creates the default palette as PaletteRecord binary data
            
             @see org.apache.poi.hssf.model.Workbook#createPalette
        </member>
        <member name="T:NPOI.HSSF.Record.PColor">
            PColor - element in the list of colors - consider it a "struct"
        </member>
        <member name="T:NPOI.HSSF.Record.PaneRecord">
                 * Describes the frozen and Unfozen panes.
                 * NOTE: This source Is automatically generated please do not modify this file.  Either subclass or
                 *       Remove the record in src/records/definitions.
            
                 * @author Glen Stampoultzis (glens at apache.org)
        </member>
        <member name="F:NPOI.HSSF.Record.PaneRecord.ACTIVE_PANE_UPER_LEFT">
            @deprecated use ACTIVE_PANE_UPPER_LEFT 
        </member>
        <member name="M:NPOI.HSSF.Record.PaneRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
             Constructs a Pane record and Sets its fields appropriately.
            
             @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.PaneRecord.RecordSize">
            Size of record (exluding 4 byte header)
        </member>
        <member name="P:NPOI.HSSF.Record.PaneRecord.X">
            Get the x field for the Pane record.
        </member>
        <member name="P:NPOI.HSSF.Record.PaneRecord.Y">
            Get the y field for the Pane record.
        </member>
        <member name="P:NPOI.HSSF.Record.PaneRecord.TopRow">
            Get the top row field for the Pane record.
        </member>
        <member name="P:NPOI.HSSF.Record.PaneRecord.LeftColumn">
            Get the left column field for the Pane record.
        </member>
        <member name="P:NPOI.HSSF.Record.PaneRecord.ActivePane">
             Get the active pane field for the Pane record.
            
             @return  One of 
                    ACTIVE_PANE_LOWER_RIGHT
                    ACTIVE_PANE_UPPER_RIGHT
                    ACTIVE_PANE_LOWER_LEFT
                    ACTIVE_PANE_UPPER_LEFT
        </member>
        <member name="T:NPOI.HSSF.Record.PasswordRecord">
            Title:        Password Record
            Description:  stores the encrypted password for a sheet or workbook (HSSF doesn't support encryption)
            REFERENCE:  PG 371 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
            @author Andrew C. Oliver (acoliver at apache dot org)
            @version 2.0-pre
        </member>
        <member name="M:NPOI.HSSF.Record.PasswordRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Constructs a Password record and Sets its fields appropriately.
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.PasswordRecord.Password">
             Get the password
            
             @return short  representing the password
        </member>
        <member name="M:NPOI.HSSF.Record.PasswordRecord.Clone">
            Clone this record.
        </member>
        <member name="T:NPOI.HSSF.Record.PasswordRev4Record">
            Title:        Protection Revision 4 password Record
            Description:  Stores the (2 byte??!!) encrypted password for a shared
                          workbook
            REFERENCE:  PG 374 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
            @author Andrew C. Oliver (acoliver at apache dot org)
            @version 2.0-pre
        </member>
        <member name="M:NPOI.HSSF.Record.PasswordRev4Record.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Constructs a PasswordRev4 (PROT4REVPASS) record and Sets its fields appropriately.
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.PasswordRev4Record.Password">
             Get the password
            
             @return short  representing the password
        </member>
        <member name="T:NPOI.HSSF.Record.PivotTable.DataItemRecord">
            SXDI - Data Item (0x00C5)<br/>
            
            @author Patrick Cheng
        </member>
        <member name="T:NPOI.HSSF.Record.PivotTable.ExtendedPivotTableViewFieldsRecord">
            SXVDEX - Extended PivotTable View Fields (0x0100)<br/>
            
            @author Patrick Cheng
        </member>
        <member name="F:NPOI.HSSF.Record.PivotTable.ExtendedPivotTableViewFieldsRecord.STRING_NOT_PRESENT_LEN">
            the value of the <tt>cchSubName</tt> field when the subName is not present 
        </member>
        <member name="T:NPOI.HSSF.Record.PivotTable.PageItemRecord">
            SXPI - Page Item (0x00B6)<br/>
            
            @author Patrick Cheng
        </member>
        <member name="T:NPOI.HSSF.Record.PivotTable.StreamIDRecord">
            SXIDSTM - Stream ID (0x00D5)<br/>
            
            @author Patrick Cheng
        </member>
        <member name="T:NPOI.HSSF.Record.PivotTable.ViewDefinitionRecord">
            SXVIEW - View Definition (0x00B0)<br/>
            
            @author Patrick Cheng
        </member>
        <member name="T:NPOI.HSSF.Record.PivotTable.ViewFieldsRecord">
            SXVD - View Fields (0x00B1)<br/>
            
            @author Patrick Cheng
        </member>
        <member name="F:NPOI.HSSF.Record.PivotTable.ViewFieldsRecord.STRING_NOT_PRESENT_LEN">
            the value of the <tt>cchName</tt> field when the name is not present 
        </member>
        <member name="T:NPOI.HSSF.Record.PivotTable.ViewFieldsRecord.Axis">
            values for the {@link ViewFieldsRecord#sxaxis} field
        </member>
        <member name="T:NPOI.HSSF.Record.PivotTable.ViewSourceRecord">
            SXVS - View Source (0x00E3)<br/>
            
            @author Patrick Cheng
        </member>
        <member name="T:NPOI.HSSF.Record.PrecisionRecord">
            Title:        Precision Record
            Description:  defines whether to store with full precision or what's Displayed by the gui
                          (meaning have really screwed up and skewed figures or only think you do!)
            REFERENCE:  PG 372 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
            @author Andrew C. Oliver (acoliver at apache dot org)
            @version 2.0-pre
        </member>
        <member name="M:NPOI.HSSF.Record.PrecisionRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Constructs a Precision record and Sets its fields appropriately.
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.PrecisionRecord.FullPrecision">
             Get whether to use full precision or just skew all you figures all to hell.
            
             @return fullprecision - or not
        </member>
        <member name="T:NPOI.HSSF.Record.PrintGridlinesRecord">
            Title:        Print Gridlines Record
            Description:  whether to print the gridlines when you enjoy you spReadsheet on paper.
            REFERENCE:  PG 373 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
            @author Andrew C. Oliver (acoliver at apache dot org)
            @author Jason Height (jheight at chariot dot net dot au)
            @version 2.0-pre
        </member>
        <member name="M:NPOI.HSSF.Record.PrintGridlinesRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Constructs a PrintGridlines record and Sets its fields appropriately.
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.PrintGridlinesRecord.PrintGridlines">
             Get whether or not to print the gridlines (and make your spReadsheet ugly)
            
             @return make spReadsheet ugly - Y/N
        </member>
        <member name="T:NPOI.HSSF.Record.PrintHeadersRecord">
            Title:        Print Headers Record
            Description:  Whether or not to print the row/column headers when you
                          enjoy your spReadsheet in the physical form.
            REFERENCE:  PG 373 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
            @author Andrew C. Oliver (acoliver at apache dot org)
            @author Jason Height (jheight at chariot dot net dot au)
            @version 2.0-pre
        </member>
        <member name="M:NPOI.HSSF.Record.PrintHeadersRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Constructs a PrintHeaders record and Sets its fields appropriately.
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.PrintHeadersRecord.PrintHeaders">
            <summary>
            Get whether to print the headers - y/n
            </summary>
            <value><c>true</c> if [print headers]; otherwise, <c>false</c>.</value>
        </member>
        <member name="T:NPOI.HSSF.Record.PrintSetupRecord">
            Title:        Print Setup Record
            Description:  Stores print Setup options -- bogus for HSSF (and marked as such)
            REFERENCE:  PG 385 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
            @author Andrew C. Oliver (acoliver at apache dot org)
            @author Jason Height (jheight at chariot dot net dot au)
            @version 2.0-pre
        </member>
        <member name="M:NPOI.HSSF.Record.PrintSetupRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Constructs a PrintSetup (SetUP) record and Sets its fields appropriately.
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="T:NPOI.HSSF.Record.ProtectionRev4Record">
            Title:        Protection Revision 4 Record
            Description:  describes whether this is a protected shared/tracked workbook
             ( HSSF does not support encryption because we don't feel like going to jail ) 
            REFERENCE:  PG 373 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
            @author Andrew C. Oliver (acoliver at apache dot org)
            @version 2.0-pre
        </member>
        <member name="M:NPOI.HSSF.Record.ProtectionRev4Record.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Constructs a ProtectionRev4 record and Sets its fields appropriately.
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.ProtectionRev4Record.Protect">
            Get whether the this is protected shared/tracked workbook or not
            @return whether to protect the workbook or not
        </member>
        <member name="T:NPOI.HSSF.Record.ProtectRecord">
            Title: Protect Record
            Description:  defines whether a sheet or workbook is protected (HSSF DOES NOT SUPPORT ENCRYPTION)
            (kindly ask the US government to stop having arcane stupid encryption laws and we'll support it) 
            (after all terrorists will all use US-legal encrypton right??)
            HSSF now supports the simple "protected" sheets (where they are not encrypted and open office et al
            ignore the password record entirely).
            REFERENCE:  PG 373 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
            @author Andrew C. Oliver (acoliver at apache dot org)
        </member>
        <member name="M:NPOI.HSSF.Record.ProtectRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Constructs a Protect record and Sets its fields appropriately.
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.ProtectRecord.Protect">
            Get whether the sheet is protected or not
            @return whether to protect the sheet or not
        </member>
        <member name="T:NPOI.HSSF.Record.RecalcIdRecord">
            Title: Recalc Id Record
            Description:  This record Contains an ID that marks when a worksheet was last
                          recalculated. It's an optimization Excel uses to determine if it
                          needs to  recalculate the spReadsheet when it's opened. So far, only
                          the two values <c>0xC1 0x01 0x00 0x00 0x80 0x38 0x01 0x00</c>
                          (do not recalculate) and <c>0xC1 0x01 0x00 0x00 0x60 0x69 0x01
                          0x00</c> have been seen. If the field <c>isNeeded</c> Is
                          Set to false (default), then this record Is swallowed during the
                          serialization Process
            REFERENCE:  http://chicago.sourceforge.net/devel/docs/excel/biff8.html
            @author Luc Girardin (luc dot girardin at macrofocus dot com)
            @version 2.0-pre
            @see org.apache.poi.hssf.model.Workbook
        </member>
        <member name="M:NPOI.HSSF.Record.RecalcIdRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Constructs a RECALCID record and Sets its fields appropriately.
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="M:NPOI.HSSF.Record.RecalcIdRecord.SetRecalcIdArray(System.Int16[])">
            Set the recalc array.
            @param array of recalc id's
        </member>
        <member name="M:NPOI.HSSF.Record.RecalcIdRecord.GetRecalcIdArray">
            Get the recalc array.
            @return array of recalc id's
        </member>
        <member name="T:NPOI.HSSF.Record.RecordFactory">
             Title:  Record Factory
             Description:  Takes a stream and outputs an array of Record objects.
            
             @deprecated use {@link org.apache.poi.hssf.eventmodel.EventRecordFactory} instead
             @see org.apache.poi.hssf.eventmodel.EventRecordFactory
             @author Andrew C. Oliver (acoliver at apache dot org)
             @author Marc Johnson (mjohnson at apache dot org)
             @author Glen Stampoultzis (glens at apache.org)
             @author Csaba Nagy (ncsaba at yahoo dot com)
        </member>
        <member name="M:NPOI.HSSF.Record.RecordFactory.SetCapacity(System.Int32)">
            Changes the default capacity (10000) to handle larger files
        </member>
        <member name="M:NPOI.HSSF.Record.RecordFactory.CreateRecords(System.IO.Stream)">
             Create an array of records from an input stream
            
             @param in the InputStream from which the records will be
                       obtained
            
             @return an array of Records Created from the InputStream
            
             @exception RecordFormatException on error Processing the
                        InputStream
        </member>
        <member name="M:NPOI.HSSF.Record.RecordFactory.ConvertBlankRecords(NPOI.HSSF.Record.MulBlankRecord)">
            Converts a {@link MulBlankRecord} into an equivalent array of {@link BlankRecord}s
        </member>
        <member name="M:NPOI.HSSF.Record.RecordFactory.ConvertToNumberRecord(NPOI.HSSF.Record.RKRecord)">
            <summary>
            RK record is a slightly smaller alternative to NumberRecord
            POI likes NumberRecord better
            </summary>
            <param name="rk">The rk.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.Record.RecordFactory.ConvertRKRecords(NPOI.HSSF.Record.MulRKRecord)">
            <summary>
            Converts a MulRKRecord into an equivalent array of NumberRecords
            </summary>
            <param name="mrk">The MRK.</param>
            <returns></returns>
        </member>
        <member name="T:NPOI.HSSF.Record.RecordFactoryInputStream">
            A stream based way to get at complete records, with
            as low a memory footprint as possible.
            This handles Reading from a RecordInputStream, turning
            the data into full records, processing continue records
            etc.
            Most users should use {@link HSSFEventFactory} /
            {@link HSSFListener} and have new records pushed to
            them, but this does allow for a "pull" style of coding.
        </member>
        <member name="T:NPOI.HSSF.Record.RecordFactoryInputStream.StreamEncryptionInfo">
            Keeps track of the sizes of the Initial records up to and including {@link FilePassRecord}
            Needed for protected files because each byte is encrypted with respect to its absolute
            position from the start of the stream.
        </member>
        <member name="P:NPOI.HSSF.Record.RecordFactoryInputStream.StreamEncryptionInfo.LastRecord">
            @return last record scanned while looking for encryption info.
            This will typically be the first or second record Read. Possibly <code>null</code>
            if stream was empty
        </member>
        <member name="P:NPOI.HSSF.Record.RecordFactoryInputStream.StreamEncryptionInfo.HasBOFRecord">
            <code>false</code> in some test cases
        </member>
        <member name="F:NPOI.HSSF.Record.RecordFactoryInputStream._unreadRecordBuffer">
            Temporarily stores a group of {@link Record}s, for future return by {@link #nextRecord()}.
            This is used at the start of the workbook stream, and also when the most recently read
            underlying record is a {@link MulRKRecord}
        </member>
        <member name="F:NPOI.HSSF.Record.RecordFactoryInputStream._unreadRecordIndex">
            used to help iterating over the unread records
        </member>
        <member name="F:NPOI.HSSF.Record.RecordFactoryInputStream._lastRecord">
            The most recent record that we gave to the user
        </member>
        <member name="F:NPOI.HSSF.Record.RecordFactoryInputStream._lastDrawingRecord">
            The most recent DrawingRecord seen
        </member>
        <member name="M:NPOI.HSSF.Record.RecordFactoryInputStream.#ctor(System.IO.Stream,System.Boolean)">
            @param shouldIncludeContinueRecords caller can pass <code>false</code> if loose
            {@link ContinueRecord}s should be skipped (this is sometimes useful in event based
            processing).
        </member>
        <member name="M:NPOI.HSSF.Record.RecordFactoryInputStream.NextRecord">
            Returns the next (complete) record from the
            stream, or null if there are no more.
        </member>
        <member name="M:NPOI.HSSF.Record.RecordFactoryInputStream.GetNextUnreadRecord">
            @return the next {@link Record} from the multiple record group as expanded from
            a recently read {@link MulRKRecord}. <code>null</code> if not present.
        </member>
        <member name="M:NPOI.HSSF.Record.RecordFactoryInputStream.ReadNextRecord">
            @return the next available record, or <code>null</code> if
            this pass didn't return a record that's
            suitable for returning (eg was a continue record).
        </member>
        <member name="T:NPOI.HSSF.Record.RefModeRecord">
            Title:        RefMode Record
            Description:  Describes which reference mode to use
            REFERENCE:  PG 376 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
            @author Andrew C. Oliver (acoliver at apache dot org)
            @author Jason Height (jheight at chariot dot net dot au)
            @version 2.0-pre
        </member>
        <member name="M:NPOI.HSSF.Record.RefModeRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Constructs a RefMode record and Sets its fields appropriately.
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.RefModeRecord.Mode">
            Get the reference mode to use (HSSF uses/assumes A1)
            @return mode to use
            @see #USE_A1_MODE
            @see #USE_R1C1_MODE
        </member>
        <member name="T:NPOI.HSSF.Record.RefreshAllRecord">
            Title:        Refresh All Record 
            Description:  Flag whether to refresh all external data when loading a sheet.
                          (which hssf doesn't support anyhow so who really cares?)
            REFERENCE:  PG 376 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
            @author Andrew C. Oliver (acoliver at apache dot org)
            @version 2.0-pre
        </member>
        <member name="M:NPOI.HSSF.Record.RefreshAllRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Constructs a RefreshAll record and Sets its fields appropriately.
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.RefreshAllRecord.RefreshAll">
            Get whether to refresh all external data when loading a sheet
            @return refreshall or not
        </member>
        <member name="T:NPOI.HSSF.Record.RightMarginRecord">
            Record for the right margin. * NOTE: This source was automatically generated. * @author Shawn Laubach (slaubach at apache dot org)
        </member>
        <member name="M:NPOI.HSSF.Record.RightMarginRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Constructs a RightMargin record and Sets its fields appropriately.     *     * @param id    id must be 0x27 or an exception     *              will be throw upon validation     * @param size  size the size of the data area of the record     * @param data  data of the record (should not contain sid/len)
        </member>
        <member name="P:NPOI.HSSF.Record.RightMarginRecord.RecordSize">
            Size of record (exluding 4 byte header)
        </member>
        <member name="P:NPOI.HSSF.Record.RightMarginRecord.Margin">
            Get the margin field for the RightMargin record.
        </member>
        <member name="T:NPOI.HSSF.Record.RKRecord">
             Title:        RK Record
             Description:  An internal 32 bit number with the two most significant bits
                           storing the type.  This is part of a bizarre scheme to save disk
                           space and memory (gee look at all the other whole records that
                           are in the file just "cause"..,far better to waste Processor
                           cycles on this then leave on of those "valuable" records out).
             We support this in Read-ONLY mode.  HSSF Converts these to NUMBER records
            
            
            
             REFERENCE:  PG 376 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
             @author Andrew C. Oliver (acoliver at apache dot org)
             @author Jason Height (jheight at chariot dot net dot au)
             @version 2.0-pre
             @see org.apache.poi.hssf.record.NumberRecord
        </member>
        <member name="M:NPOI.HSSF.Record.RKRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Constructs a RK record and Sets its fields appropriately.
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.RKRecord.RKType">
             Get the type of the number
            
             @return one of these values:
                     <OL START="0">
                         <LI>RK_IEEE_NUMBER</LI>
                         <LI>RK_IEEE_NUMBER_TIMES_100</LI>
                         <LI>RK_INTEGER</LI>
                         <LI>RK_INTEGER_TIMES_100</LI>
                     </OL>
        </member>
        <member name="P:NPOI.HSSF.Record.RKRecord.RKNumber">
             Extract the value of the number
             
             The mechanism for determining the value is dependent on the two
             low order bits of the raw number. If bit 1 is Set, the number
             is an integer and can be cast directly as a double, otherwise,
             it's apparently the exponent and mantissa of a double (and the
             remaining low-order bits of the double's mantissa are 0's).
             
             If bit 0 is Set, the result of the conversion to a double Is
             divided by 100; otherwise, the value is left alone.
             
             [Insert picture of Screwy Squirrel in full Napoleonic regalia]
            
             @return the value as a proper double (hey, it <B>could</B>
                     happen)
        </member>
        <member name="T:NPOI.HSSF.Record.RowRecord">
            Title:        Row Record
            Description:  stores the row information for the sheet. 
            REFERENCE:  PG 379 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
            @author Andrew C. Oliver (acoliver at apache dot org)
            @author Jason Height (jheight at chariot dot net dot au)
            @version 2.0-pre
        </member>
        <member name="F:NPOI.HSSF.Record.RowRecord.MAX_ROW_NUMBER">
            The maximum row number that excel can handle (zero based) ie 65536 rows Is
            max number of rows.
        </member>
        <member name="F:NPOI.HSSF.Record.RowRecord.field_7_option_flags">
            16 bit options flags 
        </member>
        <member name="M:NPOI.HSSF.Record.RowRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Constructs a Row record and Sets its fields appropriately.
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.RowRecord.RowNumber">
            Get the logical row number for this row (0 based index)
            @return row - the row number
        </member>
        <member name="P:NPOI.HSSF.Record.RowRecord.FirstCol">
            Get the logical col number for the first cell this row (0 based index)
            @return col - the col number
        </member>
        <member name="P:NPOI.HSSF.Record.RowRecord.LastCol">
            Get the logical col number for the last cell this row plus one (0 based index)
            @return col - the last col number + 1
        </member>
        <member name="P:NPOI.HSSF.Record.RowRecord.Height">
            Get the height of the row
            @return height of the row
        </member>
        <member name="P:NPOI.HSSF.Record.RowRecord.Optimize">
            Get whether to optimize or not (Set to 0)
            @return optimize (Set to 0)
        </member>
        <member name="P:NPOI.HSSF.Record.RowRecord.OptionFlags">
            Gets the option bitmask.  (use the individual bit Setters that refer to this
            method)
            @return options - the bitmask
        </member>
        <member name="P:NPOI.HSSF.Record.RowRecord.OutlineLevel">
            Get the outline level of this row
            @return ol - the outline level
            @see #GetOptionFlags()
        </member>
        <member name="P:NPOI.HSSF.Record.RowRecord.Colapsed">
            Get whether or not to colapse this row
            @return c - colapse or not
            @see #GetOptionFlags()
        </member>
        <member name="P:NPOI.HSSF.Record.RowRecord.ZeroHeight">
            Get whether or not to Display this row with 0 height
            @return - z height is zero or not.
            @see #GetOptionFlags()
        </member>
        <member name="P:NPOI.HSSF.Record.RowRecord.BadFontHeight">
            Get whether the font and row height are not compatible
            @return - f -true if they aren't compatible (damn not logic)
            @see #GetOptionFlags()
        </member>
        <member name="P:NPOI.HSSF.Record.RowRecord.Formatted">
            Get whether the row has been formatted (even if its got all blank cells)
            @return formatted or not
            @see #GetOptionFlags()
        </member>
        <member name="P:NPOI.HSSF.Record.RowRecord.XFIndex">
            if the row is formatted then this is the index to the extended format record
            @see org.apache.poi.hssf.record.ExtendedFormatRecord
            @return index to the XF record or bogus value (undefined) if Isn't formatted
        </member>
        <member name="T:NPOI.HSSF.Record.SaveRecalcRecord">
            Title:        Save Recalc Record 
            Description:  defines whether to recalculate before saving (Set to true)
            REFERENCE:  PG 381 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
            @author Andrew C. Oliver (acoliver at apache dot org)
            @author Jason Height (jheight at chariot dot net dot au)
            @version 2.0-pre
        </member>
        <member name="M:NPOI.HSSF.Record.SaveRecalcRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Constructs an SaveRecalc record and Sets its fields appropriately.
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.SaveRecalcRecord.Recalc">
            Get whether to recalculate formulas/etc before saving or not
            @return recalc - whether to recalculate or not
        </member>
        <member name="T:NPOI.HSSF.Record.ScenarioProtectRecord">
            Title: Scenario Protect Record
            Description:  I have no idea what a Scenario is or why on would want to 
            protect it with the lamest "security" ever invented.  However this record tells
            excel "I want to protect my scenarios" (0xAF) with lame security.  It appears 
            in conjunction with the PASSWORD and PROTECT records as well as its object 
            protect cousin.
            REFERENCE:  PG 383 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
            @author Andrew C. Oliver (acoliver at apache dot org)
        </member>
        <member name="M:NPOI.HSSF.Record.ScenarioProtectRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Constructs a Protect record and Sets its fields appropriately.
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.ScenarioProtectRecord.Protect">
            Get whether the sheet is protected or not
            @return whether to protect the sheet or not
        </member>
        <member name="T:NPOI.HSSF.Record.SCLRecord">
                 * Specifies the window's zoom magnification.  If this record Isn't present then the windows zoom is 100%. see p384 Excel Dev Kit
                 * NOTE: This source is automatically generated please do not modify this file.  Either subclass or
                 *       Remove the record in src/records/definitions.
            
                 * @author Andrew C. Oliver (acoliver at apache.org)
        </member>
        <member name="M:NPOI.HSSF.Record.SCLRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
             Constructs a SCL record and Sets its fields appropriately.
            
             @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.SCLRecord.DataSize">
            Size of record (exluding 4 byte header)
        </member>
        <member name="P:NPOI.HSSF.Record.SCLRecord.Numerator">
            Get the numerator field for the SCL record.
        </member>
        <member name="P:NPOI.HSSF.Record.SCLRecord.Denominator">
            Get the denominator field for the SCL record.
        </member>
        <member name="T:NPOI.HSSF.Record.SelectionRecord">
             Title:        Selection Record
             Description:  shows the user's selection on the sheet
                           for Write Set num refs to 0
            
             TODO :  Fully implement reference subrecords.
             REFERENCE:  PG 291 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
             @author Andrew C. Oliver (acoliver at apache dot org)
             @author Jason Height (jheight at chariot dot net dot au)
             @author Glen Stampoultzis (glens at apache.org)
        </member>
        <member name="M:NPOI.HSSF.Record.SelectionRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            <summary>
            Constructs a Selection record and Sets its fields appropriately.
            </summary>
            <param name="in1">the RecordInputstream to Read the record from</param>
        </member>
        <member name="P:NPOI.HSSF.Record.SelectionRecord.Pane">
            <summary>
            Gets or sets the pane this is for.
            </summary>
            <value>The pane.</value>
        </member>
        <member name="P:NPOI.HSSF.Record.SelectionRecord.ActiveCellRow">
            <summary>
            Gets or sets the active cell row.
            </summary>
            <value>row number of active cell</value>
        </member>
        <member name="P:NPOI.HSSF.Record.SelectionRecord.ActiveCellCol">
            <summary>
            Gets or sets the active cell's col
            </summary>
            <value>number of active cell</value>
        </member>
        <member name="P:NPOI.HSSF.Record.SelectionRecord.ActiveCellRef">
            <summary>
            Gets or sets the active cell's reference number
            </summary>
            <value>ref number of active cell</value>
        </member>
        <member name="T:NPOI.HSSF.Record.SharedFormulaRecord">
            Title:        SharedFormulaRecord
            Description:  Primarily used as an excel optimization so that multiple similar formulas
            				  are not written out too many times.  We should recognize this record and
                          Serialize as Is since this Is used when Reading templates.
            
            Note: the documentation says that the SID Is BC where biffviewer reports 4BC.  The hex dump shows
            that the two byte sid representation to be 'BC 04' that Is consistent with the other high byte
            record types.
            @author Danny Mui at apache dot org
        </member>
        <member name="M:NPOI.HSSF.Record.SharedFormulaRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="M:NPOI.HSSF.Record.SharedFormulaRecord.ToString">
            print a sort of string representation ([SHARED FORMULA RECORD] id = x [/SHARED FORMULA RECORD])
        </member>
        <member name="M:NPOI.HSSF.Record.SharedFormulaRecord.ConvertSharedFormulas(NPOI.HSSF.Record.Formula.Ptg[],System.Int32,System.Int32)">
             Creates a non shared formula from the shared formula counterpart<br/>
            
             Perhaps this functionality could be implemented in terms of the raw
             byte array inside {@link Formula}.
        </member>
        <member name="M:NPOI.HSSF.Record.SharedFormulaRecord.GetFormulaTokens(NPOI.HSSF.Record.FormulaRecord)">
            @return the equivalent {@link Ptg} array that the formula would have, were it not shared.
        </member>
        <member name="T:NPOI.HSSF.Record.SharedValueRecordBase">
            Common base class for {@link SharedFormulaRecord}, {@link ArrayRecord} and
            {@link TableRecord} which are have similarities.
            
            @author Josh Micich
        </member>
        <member name="M:NPOI.HSSF.Record.SharedValueRecordBase.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            reads only the range (1 {@link CellRangeAddress8Bit}) from the stream
        </member>
        <member name="M:NPOI.HSSF.Record.SharedValueRecordBase.IsInRange(System.Int32,System.Int32)">
            @return <c>true</c> if (rowIx, colIx) is within the range ({@link #Range})
            of this shared value object.
        </member>
        <member name="M:NPOI.HSSF.Record.SharedValueRecordBase.IsFirstCell(System.Int32,System.Int32)">
            @return <c>true</c> if (rowIx, colIx) describes the first cell in this shared value 
            object's range ({@link #Range})
        </member>
        <member name="T:NPOI.HSSF.Record.SSTDeserializer">
             Handles the task of deserializing a SST string.  The two main entry points are
            
             @author Glen Stampoultzis (glens at apache.org)
             @author Jason Height (jheight at apache.org)
        </member>
        <member name="M:NPOI.HSSF.Record.SSTDeserializer.ManufactureStrings(System.Int32,NPOI.HSSF.Record.RecordInputStream)">
            This Is the starting point where strings are constructed.  Note that
            strings may span across multiple continuations. Read the SST record
            carefully before beginning to hack.
        </member>
        <member name="T:NPOI.HSSF.Record.SSTRecord">
             Title:        Static String Table Record
             
             Description:  This holds all the strings for LabelSSTRecords.
             
             REFERENCE:    PG 389 Microsoft Excel 97 Developer's Kit (ISBN:
                           1-57231-498-2)
             
             @author Andrew C. Oliver (acoliver at apache dot org)
             @author Marc Johnson (mjohnson at apache dot org)
             @author Glen Stampoultzis (glens at apache.org)
            
             @see org.apache.poi.hssf.record.LabelSSTRecord
             @see org.apache.poi.hssf.record.ContinueRecord
        </member>
        <member name="F:NPOI.HSSF.Record.SSTRecord.MAX_RECORD_SIZE">
            how big can an SST record be? As big as any record can be: 8228 bytes 
        </member>
        <member name="F:NPOI.HSSF.Record.SSTRecord.STD_RECORD_OVERHEAD">
            standard record overhead: two shorts (record id plus data space size)
        </member>
        <member name="F:NPOI.HSSF.Record.SSTRecord.SST_RECORD_OVERHEAD">
            SST overhead: the standard record overhead, plus the number of strings and the number of Unique strings -- two ints 
        </member>
        <member name="F:NPOI.HSSF.Record.SSTRecord.MAX_DATA_SPACE">
            how much data can we stuff into an SST record? That would be _max minus the standard SST record overhead 
        </member>
        <member name="F:NPOI.HSSF.Record.SSTRecord.STRING_MINIMAL_OVERHEAD">
            overhead for each string includes the string's Char count (a short) and the flag describing its Charistics (a byte) 
        </member>
        <member name="F:NPOI.HSSF.Record.SSTRecord.field_1_num_strings">
            Union of strings in the SST and EXTSST 
        </member>
        <member name="F:NPOI.HSSF.Record.SSTRecord.field_2_num_unique_strings">
            according to docs ONLY SST 
        </member>
        <member name="F:NPOI.HSSF.Record.SSTRecord.bucketAbsoluteOffsets">
            Offsets from the beginning of the SST record (even across continuations) 
        </member>
        <member name="F:NPOI.HSSF.Record.SSTRecord.bucketRelativeOffsets">
            Offsets relative the start of the current SST or continue record 
        </member>
        <member name="M:NPOI.HSSF.Record.SSTRecord.#ctor">
            default constructor
        </member>
        <member name="M:NPOI.HSSF.Record.SSTRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
             Constructs an SST record and Sets its fields appropriately.
            
             @param in the RecordInputstream to Read the record from
        </member>
        <member name="M:NPOI.HSSF.Record.SSTRecord.AddString(NPOI.HSSF.Record.UnicodeString)">
             Add a string.
            
             @param string string to be Added
            
             @return the index of that string in the table
        </member>
        <member name="P:NPOI.HSSF.Record.SSTRecord.NumStrings">
            @return number of strings
        </member>
        <member name="P:NPOI.HSSF.Record.SSTRecord.NumUniqueStrings">
            @return number of Unique strings
        </member>
        <member name="M:NPOI.HSSF.Record.SSTRecord.GetString(System.Int32)">
             Get a particular string by its index
            
             @param id index into the array of strings
            
             @return the desired string
        </member>
        <member name="M:NPOI.HSSF.Record.SSTRecord.ToString">
             Return a debugging string representation
            
             @return string representation
        </member>
        <member name="P:NPOI.HSSF.Record.SSTRecord.Sid">
            @return sid
        </member>
        <member name="M:NPOI.HSSF.Record.SSTRecord.GetHashCode">
            @return hashcode
        </member>
        <member name="M:NPOI.HSSF.Record.SSTRecord.GetStrings">
            @return an iterator of the strings we hold. All instances are
                    UnicodeStrings
        </member>
        <member name="P:NPOI.HSSF.Record.SSTRecord.CountStrings">
            @return count of the strings we hold.
        </member>
        <member name="M:NPOI.HSSF.Record.SSTRecord.Serialize(NPOI.HSSF.Record.Cont.ContinuableRecordOutput)">
             called by the class that Is responsible for writing this sucker.
             Subclasses should implement this so that their data Is passed back in a
             byte array.
            
             @return size
        </member>
        <member name="M:NPOI.HSSF.Record.SSTRecord.CreateExtSSTRecord(System.Int32)">
             Creates an extended string record based on the current contents of
             the current SST record.  The offset within the stream to the SST record
             Is required because the extended string record points directly to the
             strings in the SST record.
             
             NOTE: THIS FUNCTION MUST ONLY BE CALLED AFTER THE SST RECORD HAS BEEN
                   SERIALIZED.
            
             @param sstOffset     The offset in the stream to the start of the
                                  SST record.
             @return  The new SST record.
        </member>
        <member name="M:NPOI.HSSF.Record.SSTRecord.CalcExtSSTRecordSize">
             Calculates the size in bytes of the EXTSST record as it would be if the
             record was Serialized.
            
             @return  The size of the ExtSST record in bytes.
        </member>
        <member name="T:NPOI.HSSF.Record.SSTSerializer">
             This class handles serialization of SST records.  It utilizes the record processor
             class write individual records. This has been refactored from the SSTRecord class.
            
             @author Glen Stampoultzis (glens at apache.org)
        </member>
        <member name="F:NPOI.HSSF.Record.SSTSerializer.bucketAbsoluteOffsets">
            OffSets from the beginning of the SST record (even across continuations) 
        </member>
        <member name="F:NPOI.HSSF.Record.SSTSerializer.bucketRelativeOffsets">
            OffSets relative the start of the current SST or continue record 
        </member>
        <member name="T:NPOI.HSSF.Record.StringRecord">
             Supports the STRING record structure.
            
             @author Glen Stampoultzis (glens at apache.org)
        </member>
        <member name="M:NPOI.HSSF.Record.StringRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
             Constructs a String record and Sets its fields appropriately.
            
             @param in the RecordInputstream to Read the record from
        </member>
        <member name="M:NPOI.HSSF.Record.StringRecord.Serialize(NPOI.HSSF.Record.Cont.ContinuableRecordOutput)">
             called by the class that Is responsible for writing this sucker.
             Subclasses should implement this so that their data Is passed back in a
             byte array.
            
             @param offset to begin writing at
             @param data byte array containing instance data
             @return number of bytes written
        </member>
        <member name="P:NPOI.HSSF.Record.StringRecord.Sid">
            return the non static version of the id for this record.
        </member>
        <member name="P:NPOI.HSSF.Record.StringRecord.String">
            @return The string represented by this record.
        </member>
        <member name="T:NPOI.HSSF.Record.StyleRecord">
            Title:        Style Record
            Description:  Describes a builtin to the gui or user defined style
            REFERENCE:  PG 390 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
            @author Andrew C. Oliver (acoliver at apache dot org)
            @author aviks : string fixes for UserDefined Style
            @version 2.0-pre
        </member>
        <member name="M:NPOI.HSSF.Record.StyleRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Constructs a Style record and Sets its fields appropriately.
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.StyleRecord.Index">
            Get the entire index field (including the type) (see bit Getters that reference this method)
             @return bitmask
        </member>
        <member name="P:NPOI.HSSF.Record.StyleRecord.Type">
            Get the type of the style (builtin or user-defined)
            @see #STYLE_USER_DEFINED
            @see #STYLE_BUILT_IN
            @return type of style (userdefined/builtin)
            @see #Index
        </member>
        <member name="P:NPOI.HSSF.Record.StyleRecord.XFIndex">
            Get the actual index of the style extended format record
            @see #Index
            @return index of the xf record
        </member>
        <member name="P:NPOI.HSSF.Record.StyleRecord.NameLength">
            if this Is a user defined record Get the Length of the style name
            @return Length of the style's name
            @see #Name
        </member>
        <member name="P:NPOI.HSSF.Record.StyleRecord.Name">
            Get the style's name
            @return name of the style
            @see #NameLength
        </member>
        <member name="P:NPOI.HSSF.Record.StyleRecord.Builtin">
             if this Is a builtin style Get the number of the built in style
             @return  builtin style number (0-7)
            
        </member>
        <member name="P:NPOI.HSSF.Record.StyleRecord.OutlineStyleLevel">
            Get the row or column level of the style (if builtin 1||2)
        </member>
        <member name="T:NPOI.HSSF.Record.CommonObjectType">
                 * The common object data record is used to store all common preferences for an excel object.
                 * NOTE: This source is automatically generated please do not modify this file.  Either subclass or
                 *       Remove the record in src/records/definitions.
            
                 * @author Glen Stampoultzis (glens at apache.org)
        </member>
        <member name="M:NPOI.HSSF.Record.CommonObjectDataSubRecord.#ctor(NPOI.Util.IO.LittleEndianInput,System.Int32)">
             Constructs a CommonObjectData record and Sets its fields appropriately.
            
             @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.CommonObjectDataSubRecord.DataSize">
            Size of record (exluding 4 byte header)
        </member>
        <member name="P:NPOI.HSSF.Record.CommonObjectDataSubRecord.ObjectType">
            Get the object type field for the CommonObjectData record.
        </member>
        <member name="P:NPOI.HSSF.Record.CommonObjectDataSubRecord.ObjectId">
            Get the object id field for the CommonObjectData record.
        </member>
        <member name="P:NPOI.HSSF.Record.CommonObjectDataSubRecord.Option">
            Get the option field for the CommonObjectData record.
        </member>
        <member name="P:NPOI.HSSF.Record.CommonObjectDataSubRecord.Reserved1">
            Get the reserved1 field for the CommonObjectData record.
        </member>
        <member name="P:NPOI.HSSF.Record.CommonObjectDataSubRecord.Reserved2">
            Get the reserved2 field for the CommonObjectData record.
        </member>
        <member name="P:NPOI.HSSF.Record.CommonObjectDataSubRecord.Reserved3">
            Get the reserved3 field for the CommonObjectData record.
        </member>
        <member name="P:NPOI.HSSF.Record.CommonObjectDataSubRecord.IsLocked">
            true if object is locked when sheet has been protected
            @return  the locked field value.
        </member>
        <member name="P:NPOI.HSSF.Record.CommonObjectDataSubRecord.IsPrintable">
            object appears when printed
            @return  the printable field value.
        </member>
        <member name="P:NPOI.HSSF.Record.CommonObjectDataSubRecord.IsAutoFill">
            whether object uses an automatic Fill style
            @return  the autoFill field value.
        </member>
        <member name="P:NPOI.HSSF.Record.CommonObjectDataSubRecord.IsAutoline">
            whether object uses an automatic line style
            @return  the autoline field value.
        </member>
        <member name="T:NPOI.HSSF.Record.EmbeddedObjectRefSubRecord">
             A sub-record within the OBJ record which stores a reference to an object
             stored in a Separate entry within the OLE2 compound file.
            
             @author Daniel Noll
        </member>
        <member name="F:NPOI.HSSF.Record.EmbeddedObjectRefSubRecord.field_2_refPtg">
            either an area or a cell ref 
        </member>
        <member name="F:NPOI.HSSF.Record.EmbeddedObjectRefSubRecord.field_4_unknownByte">
            Formulas often have a single non-zero trailing byte.
            This is in a similar position to he pre-streamId padding
            It is unknown if the value is important (it seems to mirror a value a few bytes earlier) 
             
        </member>
        <member name="M:NPOI.HSSF.Record.EmbeddedObjectRefSubRecord.#ctor(NPOI.Util.IO.LittleEndianInput,System.Int32)">
             Constructs an EmbeddedObjectRef record and Sets its fields appropriately.
            
             @param in the record input stream.
        </member>
        <member name="P:NPOI.HSSF.Record.EmbeddedObjectRefSubRecord.StreamId">
             Gets the stream ID containing the actual data.  The data itself
             can be found under a top-level directory entry in the OLE2 filesystem
             under the name "MBD<var>xxxxxxxx</var>" where <var>xxxxxxxx</var> is
             this ID converted into hex (in big endian order, funnily enough.)
            
             @return the data stream ID. Possibly <c>null</c>
        </member>
        <member name="T:NPOI.HSSF.Record.EndSubRecord">
                 * The end data record is used to denote the end of the subrecords.
                 * NOTE: This source is automatically generated please do not modify this file.  Either subclass or
                 *       Remove the record in src/records/definitions.
            
                 * @author Glen Stampoultzis (glens at apache.org)
        </member>
        <member name="M:NPOI.HSSF.Record.EndSubRecord.#ctor(NPOI.Util.IO.LittleEndianInput,System.Int32)">
             Constructs a End record and Sets its fields appropriately.
            
             @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.EndSubRecord.DataSize">
            Size of record (exluding 4 byte header)
        </member>
        <member name="T:NPOI.HSSF.Record.GroupMarkerSubRecord">
                 * The Group marker record is used as a position holder for Groups.
            
                 * @author Glen Stampoultzis (glens at apache.org)
        </member>
        <member name="M:NPOI.HSSF.Record.GroupMarkerSubRecord.#ctor(NPOI.Util.IO.LittleEndianInput,System.Int32)">
             Constructs a Group marker record and Sets its fields appropriately.
            
             @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.GroupMarkerSubRecord.DataSize">
            Size of record (exluding 4 byte header)
        </member>
        <member name="F:NPOI.HSSF.Record.LbsDataSubRecord._cbFContinued">
             From [MS-XLS].pdf 2.5.147 FtLbsData:
            
             An unsigned integer that indirectly specifies whether
             some of the data in this structure appear in a subsequent Continue record.
             If _cbFContinued is 0x00, all of the fields in this structure except sid and _cbFContinued
              MUST NOT exist. If this entire structure is Contained within the same record,
             then _cbFContinued MUST be greater than or equal to the size, in bytes,
             of this structure, not including the four bytes for the ft and _cbFContinued fields
        </member>
        <member name="F:NPOI.HSSF.Record.LbsDataSubRecord._unknownPreFormulaInt">
            a formula that specifies the range of cell values that are the items in this list.
        </member>
        <member name="F:NPOI.HSSF.Record.LbsDataSubRecord._cLines">
            An unsigned integer that specifies the number of items in the list.
        </member>
        <member name="F:NPOI.HSSF.Record.LbsDataSubRecord._iSel">
            An unsigned integer that specifies the one-based index of the first selected item in this list.
            A value of 0x00 specifies there is no currently selected item.
        </member>
        <member name="F:NPOI.HSSF.Record.LbsDataSubRecord._flags">
            flags that tell what data follows
        </member>
        <member name="F:NPOI.HSSF.Record.LbsDataSubRecord._idEdit">
            An ObjId that specifies the edit box associated with this list.
            A value of 0x00 specifies that there is no edit box associated with this list.
        </member>
        <member name="F:NPOI.HSSF.Record.LbsDataSubRecord._dropData">
            An optional LbsDropData that specifies properties for this dropdown control.
            This field MUST exist if and only if the Containing Obj?s cmo.ot is equal to 0x14.
        </member>
        <member name="F:NPOI.HSSF.Record.LbsDataSubRecord._rgLines">
            An optional array of strings where each string specifies an item in the list.
            The number of elements in this array, if it exists, MUST be {@link #_cLines}
        </member>
        <member name="F:NPOI.HSSF.Record.LbsDataSubRecord._bsels">
            An optional array of bools that specifies
            which items in the list are part of a multiple selection
        </member>
        <member name="M:NPOI.HSSF.Record.LbsDataSubRecord.#ctor(NPOI.Util.IO.LittleEndianInput,System.Int32,System.Int32)">
            @param in the stream to read data from
            @param cbFContinued the seconf short in the record header
            @param cmoOt the Containing Obj's {@link CommonObjectDataSubRecord#field_1_objectType}
        </member>
        <member name="P:NPOI.HSSF.Record.LbsDataSubRecord.Formula">
            
             @return the formula that specifies the range of cell values that are the items in this list.
        </member>
        <member name="P:NPOI.HSSF.Record.LbsDataSubRecord.NumberOfItems">
            @return the number of items in the list
        </member>
        <member name="T:NPOI.HSSF.Record.LbsDropData">
            This structure specifies properties of the dropdown list control
        </member>
        <member name="F:NPOI.HSSF.Record.LbsDropData._wStyle">
            An unsigned integer that specifies the style of this dropdown. 
        </member>
        <member name="F:NPOI.HSSF.Record.LbsDropData._cLine">
            An unsigned integer that specifies the number of lines to be displayed in the dropdown.
        </member>
        <member name="F:NPOI.HSSF.Record.LbsDropData._dxMin">
            An unsigned integer that specifies the smallest width in pixels allowed for the dropdown window
        </member>
        <member name="F:NPOI.HSSF.Record.LbsDropData._str">
            a string that specifies the current string value in the dropdown
        </member>
        <member name="F:NPOI.HSSF.Record.LbsDropData._unused">
            Optional, undefined and MUST be ignored.
            This field MUST exist if and only if the size of str in bytes is an odd number
        </member>
        <member name="T:NPOI.HSSF.Record.NoteStructureSubRecord">
             Represents a NoteStructure (0xD) sub record.
            
             
             The docs say nothing about it. The Length of this record is always 26 bytes.
             
            
             @author Yegor Kozlov
        </member>
        <member name="M:NPOI.HSSF.Record.NoteStructureSubRecord.#ctor">
            Construct a new <c>NoteStructureSubRecord</c> and
            Fill its data with the default values
        </member>
        <member name="M:NPOI.HSSF.Record.NoteStructureSubRecord.#ctor(NPOI.Util.IO.LittleEndianInput,System.Int32)">
             Constructs a NoteStructureSubRecord and Sets its fields appropriately.
            
        </member>
        <member name="M:NPOI.HSSF.Record.NoteStructureSubRecord.ToString">
            Convert this record to string.
            Used by BiffViewer and other utulities.
        </member>
        <member name="M:NPOI.HSSF.Record.NoteStructureSubRecord.Serialize(NPOI.Util.IO.LittleEndianOutput)">
             Serialize the record data into the supplied array of bytes
            
             @param offset offset in the <c>data</c>
             @param data the data to Serialize into
            
             @return size of the record
        </member>
        <member name="P:NPOI.HSSF.Record.NoteStructureSubRecord.DataSize">
            Size of record
        </member>
        <member name="P:NPOI.HSSF.Record.NoteStructureSubRecord.Sid">
            @return id of this record.
        </member>
        <member name="T:NPOI.HSSF.Record.ScrollableObjectSubRecord">
            <summary>
            FtSbs structure
            </summary>
        </member>
        <member name="T:NPOI.HSSF.Record.SubRecord">
            Subrecords are part of the OBJ class.
        </member>
        <member name="P:NPOI.HSSF.Record.SubRecord.IsTerminating">
             Wether this record terminates the sub-record stream.
             There are two cases when this method must be overridden and return <code>true</code>
              - EndSubRecord (sid = 0x00)
              - LbsDataSubRecord (sid = 0x12)
            
             @return whether this record is the last in the sub-record stream
        </member>
        <member name="T:NPOI.HSSF.Record.SupBookRecord">
             Title:        Sup Book (EXTERNALBOOK) 
             Description:  A External Workbook Description (Suplemental Book)
                           Its only a dummy record for making new ExternSheet Record 
             REFERENCE:  5.38
             @author Libin Roman (Vista Portal LDT. Developer)
             @author Andrew C. Oliver (acoliver@apache.org)
            
        </member>
        <member name="M:NPOI.HSSF.Record.SupBookRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
             Constructs a Extern Sheet record and Sets its fields appropriately.
            
             @param id     id must be 0x16 or an exception will be throw upon validation
             @param size  the size of the data area of the record
             @param data  data of the record (should not contain sid/len)
        </member>
        <member name="T:NPOI.HSSF.Record.TabIdRecord">
            Title: Sheet Tab Index Array Record
            Description:  Contains an array of sheet id's.  Sheets always keep their ID
                          regardless of what their name Is.
            REFERENCE:  PG 412 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
            @author Andrew C. Oliver (acoliver at apache dot org)
            @version 2.0-pre
        </member>
        <member name="M:NPOI.HSSF.Record.TabIdRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Constructs a TabID record and Sets its fields appropriately.
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="M:NPOI.HSSF.Record.TabIdRecord.SetTabIdArray(System.Int16[])">
            Set the tab array.  (0,1,2).
            @param array of tab id's {0,1,2}
        </member>
        <member name="M:NPOI.HSSF.Record.TabIdRecord.GetTabIdArray">
            Get the tab array.  (0,1,2).
            @return array of tab id's {0,1,2}
        </member>
        <member name="T:NPOI.HSSF.Record.TableRecord">
             DATATABLE (0x0236)<p/>
            
             TableRecord - The record specifies a data table.
             This record Is preceded by a single Formula record that
              defines the first cell in the data table, which should
              only contain a single Ptg, {@link TblPtg}.
            
             See p536 of the June 08 binary docs
        </member>
        <member name="T:NPOI.HSSF.Record.TableStylesRecord">
            TABLESTYLES (0x088E)<br/>
            
            @author Patrick Cheng
        </member>
        <member name="F:NPOI.HSSF.Record.TextObjectRecord._linkRefPtg">
            expect tRef, tRef3D, tArea, tArea3D or tName 
        </member>
        <member name="F:NPOI.HSSF.Record.TextObjectRecord._unknownPostFormulaByte">
            Not clear if needed .  Excel seems to be OK if this byte is not present. 
            Value is often the same as the earlier firstColumn byte. 
        </member>
        <member name="P:NPOI.HSSF.Record.TextObjectRecord.DataSize">
            Only for the current record. does not include any subsequent Continue
            records
        </member>
        <member name="P:NPOI.HSSF.Record.TextObjectRecord.TextOrientation">
             Get the text orientation field for the TextObjectBase record.
            
             @return  One of 
                    TEXT_ORIENTATION_NONE
                    TEXT_ORIENTATION_TOP_TO_BOTTOM
                    TEXT_ORIENTATION_ROT_RIGHT
                    TEXT_ORIENTATION_ROT_LEFT
        </member>
        <member name="P:NPOI.HSSF.Record.TextObjectRecord.HorizontalTextAlignment">
            @return the Horizontal text alignment field value.
        </member>
        <member name="P:NPOI.HSSF.Record.TextObjectRecord.VerticalTextAlignment">
            @return the Vertical text alignment field value.
        </member>
        <member name="P:NPOI.HSSF.Record.TextObjectRecord.IsTextLocked">
            Text has been locked
            @return  the text locked field value.
        </member>
        <member name="T:NPOI.HSSF.Record.TopMarginRecord">
             Record for the top margin.
             NOTE: This source was automatically generated.
            
             @author Shawn Laubach (slaubach at apache dot org)
        </member>
        <member name="M:NPOI.HSSF.Record.TopMarginRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
             Constructs a TopMargin record and Sets its fields appropriately.
            
             @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.TopMarginRecord.RecordSize">
            Size of record (exluding 4 byte header)
        </member>
        <member name="P:NPOI.HSSF.Record.TopMarginRecord.Margin">
            Get the margin field for the TopMargin record.
        </member>
        <member name="T:NPOI.HSSF.Record.UncalcedRecord">
            Title: Uncalced Record
            
            If this record occurs in the Worksheet Substream, it indicates that the formulas have not 
            been recalculated before the document was saved.
            
            @author Olivier Leprince
        </member>
        <member name="M:NPOI.HSSF.Record.UncalcedRecord.#ctor">
            Default constructor
        </member>
        <member name="M:NPOI.HSSF.Record.UncalcedRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Read constructor
        </member>
        <member name="T:NPOI.HSSF.Record.UnknownRecord">
            Title:        Unknown Record (for debugging)
            Description:  Unknown record just tells you the sid so you can figure out
                          what records you are missing.  Also helps us Read/modify sheets we
                          don't know all the records to.  (HSSF leaves these alone!) 
            Company:      SuperLink Software, Inc.
            @author Andrew C. Oliver (acoliver at apache dot org)
            @author Jason Height (jheight at chariot dot net dot au)
            @author Glen Stampoultzis (glens at apache.org)
        </member>
        <member name="M:NPOI.HSSF.Record.UnknownRecord.#ctor(System.Int32,System.Byte[])">
            @param id    id of the record -not Validated, just stored for serialization
            @param data  the data
        </member>
        <member name="M:NPOI.HSSF.Record.UnknownRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            construct an Unknown record.  No fields are interperated and the record will
            be Serialized in its original form more or less
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="M:NPOI.HSSF.Record.UnknownRecord.Serialize(NPOI.Util.IO.LittleEndianOutput)">
            spit the record out AS IS. no interpretation or identification
        </member>
        <member name="M:NPOI.HSSF.Record.UnknownRecord.ToString">
            print a sort of string representation ([UNKNOWN RECORD] id = x [/UNKNOWN RECORD])
        </member>
        <member name="M:NPOI.HSSF.Record.UnknownRecord.GetBiffName(System.Int32)">
             These BIFF record types are known but still uninterpreted by POI
            
             @return the documented name of this BIFF record type, <code>null</code> if unknown to POI
        </member>
        <member name="M:NPOI.HSSF.Record.UnknownRecord.IsObservedButUnknown(System.Int32)">
            @return <code>true</code> if the unknown record id has been observed in POI unit tests
        </member>
        <member name="M:NPOI.HSSF.Record.UnknownRecord.Clone">
            Unlike the other Record.Clone methods this Is a shallow Clone
        </member>
        <member name="T:NPOI.HSSF.Record.UseSelFSRecord">
            Title:        Use Natural Language Formulas Flag
            Description:  Tells the GUI if this was written by something that can use
                          "natural language" formulas. HSSF can't.
            REFERENCE:  PG 420 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
            @author Andrew C. Oliver (acoliver at apache dot org)
            @version 2.0-pre
        </member>
        <member name="M:NPOI.HSSF.Record.UseSelFSRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Constructs a UseSelFS record and Sets its fields appropriately.
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="M:NPOI.HSSF.Record.UseSelFSRecord.SetFlag(System.Int16)">
             turn the flag on or off
            
             @param flag  whether to use natural language formulas or not
             @see #TRUE
             @see #FALSE
        </member>
        <member name="M:NPOI.HSSF.Record.UseSelFSRecord.GetFlag">
             returns whether we use natural language formulas or not
            
             @return whether to use natural language formulas or not
             @see #TRUE
             @see #FALSE
        </member>
        <member name="T:NPOI.HSSF.Record.VCenterRecord">
            Title:        VCenter record
            Description:  tells whether to center the sheet between vertical margins
            REFERENCE:  PG 420 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
            @author Andrew C. Oliver (acoliver at apache dot org)
            @author Jason Height (jheight at chariot dot net dot au)
            @version 2.0-pre
        </member>
        <member name="M:NPOI.HSSF.Record.VCenterRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Constructs a VCENTER record and Sets its fields appropriately.
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.VCenterRecord.VCenter">
            Get whether to center vertically or not
            @return vcenter or not
        </member>
        <member name="T:NPOI.HSSF.Record.VerticalPageBreakRecord">
            VerticalPageBreak record that stores page breaks at columns
            
            This class Is just used so that SID Compares work properly in the RecordFactory
            @see PageBreakRecord
            @author Danny Mui (dmui at apache dot org) 
        </member>
        <member name="M:NPOI.HSSF.Record.VerticalPageBreakRecord.#ctor">
            
        </member>
        <member name="M:NPOI.HSSF.Record.VerticalPageBreakRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="T:NPOI.HSSF.Record.WindowOneRecord">
            Title:        Window1 Record
            Description:  Stores the attributes of the workbook window.  This Is basically
                          so the gui knows how big to make the window holding the spReadsheet
                          document.
            REFERENCE:  PG 421 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
            @author Andrew C. Oliver (acoliver at apache dot org)
            @version 2.0-pre
        </member>
        <member name="M:NPOI.HSSF.Record.WindowOneRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Constructs a WindowOne record and Sets its fields appropriately.
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.WindowOneRecord.HorizontalHold">
            Get the horizontal position of the window (in 1/20ths of a point)
            @return h - horizontal location
        </member>
        <member name="P:NPOI.HSSF.Record.WindowOneRecord.VerticalHold">
            Get the vertical position of the window (in 1/20ths of a point)
            @return v - vertical location
        </member>
        <member name="P:NPOI.HSSF.Record.WindowOneRecord.Width">
            Get the width of the window
            @return width
        </member>
        <member name="P:NPOI.HSSF.Record.WindowOneRecord.Height">
            Get the height of the window
            @return height
        </member>
        <member name="P:NPOI.HSSF.Record.WindowOneRecord.Options">
             Get the options bitmask (see bit Setters)
            
             @return o - the bitmask
        </member>
        <member name="P:NPOI.HSSF.Record.WindowOneRecord.Hidden">
            Get whether the window Is hidden or not
            @return Ishidden or not
        </member>
        <member name="P:NPOI.HSSF.Record.WindowOneRecord.Iconic">
            Get whether the window has been iconized or not
            @return iconize  or not
        </member>
        <member name="P:NPOI.HSSF.Record.WindowOneRecord.DisplayHorizontalScrollbar">
            Get whether to Display the horizontal scrollbar or not
            @return Display or not
        </member>
        <member name="P:NPOI.HSSF.Record.WindowOneRecord.DisplayVerticalScrollbar">
            Get whether to Display the vertical scrollbar or not
            @return Display or not
        </member>
        <member name="P:NPOI.HSSF.Record.WindowOneRecord.DisplayTabs">
            Get whether to Display the tabs or not
            @return Display or not
        </member>
        <member name="P:NPOI.HSSF.Record.WindowOneRecord.ActiveSheetIndex">
            @return the index of the currently Displayed sheet 
        </member>
        <member name="P:NPOI.HSSF.Record.WindowOneRecord.SelectedTab">
            deprecated May 2008
            @deprecated - Misleading name - use GetActiveSheetIndex() 
        </member>
        <member name="P:NPOI.HSSF.Record.WindowOneRecord.FirstVisibleTab">
            @return the first visible sheet in the worksheet tab-bar. 
            I.E. the scroll position of the tab-bar.
        </member>
        <member name="P:NPOI.HSSF.Record.WindowOneRecord.DisplayedTab">
            deprecated May 2008
            @deprecated - Misleading name - use GetFirstVisibleTab() 
        </member>
        <member name="P:NPOI.HSSF.Record.WindowOneRecord.NumSelectedTabs">
            Get the number of selected tabs
            @return number of tabs
        </member>
        <member name="P:NPOI.HSSF.Record.WindowOneRecord.TabWidthRatio">
            ratio of the width of the tabs to the horizontal scrollbar
            @return ratio
        </member>
        <member name="T:NPOI.HSSF.Record.WindowProtectRecord">
            Title: Window Protect Record
            Description:  flags whether workbook windows are protected
            REFERENCE:  PG 424 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
            @author Andrew C. Oliver (acoliver at apache dot org)
            @version 2.0-pre
        </member>
        <member name="M:NPOI.HSSF.Record.WindowProtectRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Constructs a WindowProtect record and Sets its fields appropriately.
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.WindowProtectRecord.Protect">
             Is this window protected or not
            
             @return protected or not
        </member>
        <member name="T:NPOI.HSSF.Record.WindowTwoRecord">
            Title:        Window Two Record
            Description:  sheet window Settings
            REFERENCE:  PG 422 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
            @author Andrew C. Oliver (acoliver at apache dot org)
            @author Jason Height (jheight at chariot dot net dot au)
            @version 2.0-pre
        </member>
        <member name="M:NPOI.HSSF.Record.WindowTwoRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Constructs a WindowTwo record and Sets its fields appropriately.
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.WindowTwoRecord.Options">
            Get the options bitmask or just use the bit Setters.
            @return options
        </member>
        <member name="P:NPOI.HSSF.Record.WindowTwoRecord.DisplayFormulas">
            Get whether the window should Display formulas
            @return formulas or not
        </member>
        <member name="P:NPOI.HSSF.Record.WindowTwoRecord.DisplayGridlines">
            Get whether the window should Display gridlines
            @return gridlines or not
        </member>
        <member name="P:NPOI.HSSF.Record.WindowTwoRecord.DisplayRowColHeadings">
            Get whether the window should Display row and column headings
            @return headings or not
        </member>
        <member name="P:NPOI.HSSF.Record.WindowTwoRecord.FreezePanes">
            Get whether the window should freeze panes
            @return freeze panes or not
        </member>
        <member name="P:NPOI.HSSF.Record.WindowTwoRecord.DisplayZeros">
            Get whether the window should Display zero values
            @return zeros or not
        </member>
        <member name="P:NPOI.HSSF.Record.WindowTwoRecord.DefaultHeader">
            Get whether the window should Display a default header
            @return header or not
        </member>
        <member name="P:NPOI.HSSF.Record.WindowTwoRecord.Arabic">
            Is this arabic?
            @return arabic or not
        </member>
        <member name="P:NPOI.HSSF.Record.WindowTwoRecord.DisplayGuts">
            Get whether the outline symbols are displaed
            @return symbols or not
        </member>
        <member name="P:NPOI.HSSF.Record.WindowTwoRecord.FreezePanesNoSplit">
            freeze Unsplit panes or not
            @return freeze or not
        </member>
        <member name="P:NPOI.HSSF.Record.WindowTwoRecord.IsSelected">
            sheet tab Is selected
            @return selected or not
        </member>
        <member name="P:NPOI.HSSF.Record.WindowTwoRecord.IsActive">
            Is the sheet currently Displayed in the window
            @return Displayed or not
        </member>
        <member name="P:NPOI.HSSF.Record.WindowTwoRecord.Paged">
            deprecated May 2008
            @deprecated use IsActive()
        </member>
        <member name="P:NPOI.HSSF.Record.WindowTwoRecord.SavedInPageBreakPreview">
            was the sheet saved in page break view
            @return pagebreaksaved or not
        </member>
        <member name="P:NPOI.HSSF.Record.WindowTwoRecord.TopRow">
            Get the top row visible in the window
            @return toprow
        </member>
        <member name="P:NPOI.HSSF.Record.WindowTwoRecord.LeftCol">
            Get the leftmost column Displayed in the window
            @return leftmost
        </member>
        <member name="P:NPOI.HSSF.Record.WindowTwoRecord.HeaderColor">
            Get the palette index for the header color
            @return color
        </member>
        <member name="P:NPOI.HSSF.Record.WindowTwoRecord.PageBreakZoom">
            zoom magification in page break view
            @return zoom
        </member>
        <member name="P:NPOI.HSSF.Record.WindowTwoRecord.NormalZoom">
            Get the zoom magnification in normal view
            @return zoom
        </member>
        <member name="P:NPOI.HSSF.Record.WindowTwoRecord.Reserved">
            Get the reserved bits - why would you do this?
            @return reserved stuff -probably garbage
        </member>
        <member name="T:NPOI.HSSF.Record.WriteAccessRecord">
            Title:        Write Access Record
            Description:  Stores the username of that who owns the spReadsheet generator
                          (on Unix the user's login, on Windoze its the name you typed when
                           you installed the thing)
            REFERENCE:  PG 424 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
            @author Andrew C. Oliver (acoliver at apache dot org)
            @version 2.0-pre
        </member>
        <member name="F:NPOI.HSSF.Record.WriteAccessRecord.PADDING">
            this record is always padded to a constant length 
        </member>
        <member name="M:NPOI.HSSF.Record.WriteAccessRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Constructs a WriteAccess record and Sets its fields appropriately.
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.WriteAccessRecord.Username">
            Get the username for the user that Created the report.  HSSF uses the logged in user.  On
            natively Created M$ Excel sheet this would be the name you typed in when you installed it
            in most cases.
            @return username of the user who  Is logged in (probably "tomcat" or "apache")
        </member>
        <member name="T:NPOI.HSSF.Record.WriteProtectRecord">
            Title:        Write Protect Record
            Description:  Indicated that the sheet/workbook Is Write protected. 
            REFERENCE:  PG 425 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
            @version 3.0-pre
        </member>
        <member name="M:NPOI.HSSF.Record.WriteProtectRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Constructs a WriteAccess record and Sets its fields appropriately.
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="T:NPOI.HSSF.Record.WSBoolRecord">
            Title:        WSBool Record.
            Description:  stores workbook Settings  (aka its a big "everything we didn't
                          put somewhere else")
            REFERENCE:  PG 425 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
            @author Andrew C. Oliver (acoliver at apache dot org)
            @author Glen Stampoultzis (gstamp@iprimus.com.au)
            @author Jason Height (jheight at chariot dot net dot au)
            @version 2.0-pre
        </member>
        <member name="M:NPOI.HSSF.Record.WSBoolRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Constructs a WSBool record and Sets its fields appropriately.
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.WSBoolRecord.WSBool1">
            Get first byte (see bit Getters)
        </member>
        <member name="P:NPOI.HSSF.Record.WSBoolRecord.Autobreaks">
            <summary>
            Whether to show automatic page breaks or not
            </summary>
        </member>
        <member name="P:NPOI.HSSF.Record.WSBoolRecord.Dialog">
            <summary>
            Whether sheet is a dialog sheet or not
            </summary>
        </member>
        <member name="P:NPOI.HSSF.Record.WSBoolRecord.RowSumsBelow">
            <summary>
            Get if row summaries appear below detail in the outline
            </summary>
        </member>
        <member name="P:NPOI.HSSF.Record.WSBoolRecord.RowSumsRight">
            <summary>
            Get if col summaries appear right of the detail in the outline
            </summary>
        </member>
        <member name="P:NPOI.HSSF.Record.WSBoolRecord.WSBool2">
            <summary>
            Get the second byte (see bit Getters)
            </summary>
        </member>
        <member name="P:NPOI.HSSF.Record.WSBoolRecord.FitToPage">
            <summary>
            fit to page option is on
            </summary>
        </member>
        <member name="P:NPOI.HSSF.Record.WSBoolRecord.DisplayGuts">
            <summary>
            Whether to display the guts or not
            </summary>
        </member>
        <member name="P:NPOI.HSSF.Record.WSBoolRecord.AlternateExpression">
            <summary>
            whether alternate expression evaluation is on
            </summary>
        </member>
        <member name="P:NPOI.HSSF.Record.WSBoolRecord.AlternateFormula">
            <summary>
            whether alternative formula entry is on
            </summary>
        </member>
        <member name="M:NPOI.HSSF.Record.BiffHeaderInput.ReadRecordSID">
            Read an unsigned short from the stream without decrypting
        </member>
        <member name="M:NPOI.HSSF.Record.BiffHeaderInput.ReadDataSize">
            Read an unsigned short from the stream without decrypting
        </member>
        <member name="T:NPOI.HSSF.Record.BOFRecord">
            Title: Beginning Of File
            Description: Somewhat of a misnomer, its used for the beginning of a Set of
                         records that have a particular pupose or subject.
                         Used in sheets and workbooks.
            REFERENCE:  PG 289 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
            @author Andrew C. Oliver
            @author Jason Height (jheight at chariot dot net dot au)
            @version 2.0-pre
        </member>
        <member name="F:NPOI.HSSF.Record.BOFRecord.sid">
            for BIFF8 files the BOF is 0x809.  For earlier versions it was 0x09 or 0x(biffversion)09
        </member>
        <member name="F:NPOI.HSSF.Record.BOFRecord.VERSION">
            suggested default (0x06 - BIFF8)
        </member>
        <member name="F:NPOI.HSSF.Record.BOFRecord.BUILD">
            suggested default 0x10d3
        </member>
        <member name="F:NPOI.HSSF.Record.BOFRecord.BUILD_YEAR">
            suggested default  0x07CC (1996)
        </member>
        <member name="F:NPOI.HSSF.Record.BOFRecord.HISTORY_MASK">
            suggested default for a normal sheet (0x41)
        </member>
        <member name="M:NPOI.HSSF.Record.BOFRecord.#ctor">
            Constructs an empty BOFRecord with no fields Set.
        </member>
        <member name="M:NPOI.HSSF.Record.BOFRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Constructs a BOFRecord and Sets its fields appropriately
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.BOFRecord.Version">
            Version number - for BIFF8 should be 0x06
            @see #VERSION
            @param version version to be Set
        </member>
        <member name="P:NPOI.HSSF.Record.BOFRecord.HistoryBitMask">
            Set the history bit mask (not very useful)
            @see #HISTORY_MASK
            @param bitmask bitmask to Set for the history
        </member>
        <member name="P:NPOI.HSSF.Record.BOFRecord.RequiredVersion">
             Set the minimum version required to Read this file
            
             @see #VERSION
             @param version version to Set
        </member>
        <member name="P:NPOI.HSSF.Record.BOFRecord.Type">
            type of object this marks
            @see #TYPE_WORKBOOK
            @see #TYPE_VB_MODULE
            @see #TYPE_WORKSHEET
            @see #TYPE_CHART
            @see #TYPE_EXCEL_4_MACRO
            @see #TYPE_WORKSPACE_FILE
            @return short type of object
        </member>
        <member name="P:NPOI.HSSF.Record.BOFRecord.Build">
            Get the build that wrote this file
            @see #BUILD
            @return short build number of the generator of this file
        </member>
        <member name="P:NPOI.HSSF.Record.BOFRecord.BuildYear">
            Year of the build that wrote this file
            @see #BUILD_YEAR
            @return short build year of the generator of this file
        </member>
        <member name="T:NPOI.HSSF.Record.CellValueRecordInterface">
             The cell value record interface Is implemented by all classes of type Record that
             contain cell values.  It allows the containing sheet to move through them and Compare
             them.
            
             @author Andrew C. Oliver (acoliver at apache dot org)
             @author Jason Height (jheight at chariot dot net dot au)
            
             @see org.apache.poi.hssf.model.Sheet
             @see org.apache.poi.hssf.record.Record
             @see org.apache.poi.hssf.record.RecordFactory
        </member>
        <member name="P:NPOI.HSSF.Record.CellValueRecordInterface.Row">
             Get the row this cell occurs on
            
             @return the row
        </member>
        <member name="P:NPOI.HSSF.Record.CellValueRecordInterface.Column">
             Get the column this cell defines within the row
            
             @return the column
        </member>
        <member name="T:NPOI.HSSF.Record.Constant.ConstantValueParser">
            To support Constant Values (2.5.7) as required by the CRN record.
            This class is also used for two dimensional arrays which are encoded by 
            EXTERNALNAME (5.39) records and Array tokens.<p/>
            
            @author Josh Micich
        </member>
        <member name="M:NPOI.HSSF.Record.Constant.ConstantValueParser.GetEncodedSize(System.Object)">
            @return encoded size without the 'type' code byte
        </member>
        <member name="T:NPOI.HSSF.Record.Constant.ErrorConstant">
             <summary>
             Represents a constant error code value as encoded in a constant values array.
             This class is a type-safe wrapper for a 16-bit int value performing a similar job to
             <tt>ErrorEval</tt>
             </summary>
            <remarks> @author Josh Micich</remarks>
        </member>
        <member name="M:NPOI.HSSF.Record.Constant.ErrorConstant.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HSSF.Record.Constant.ErrorConstant"/> class.
            </summary>
            <param name="errorCode">The error code.</param>
        </member>
        <member name="P:NPOI.HSSF.Record.Constant.ErrorConstant.ErrorCode">
            <summary>
            Gets the error code.
            </summary>
            <value>The error code.</value>
        </member>
        <member name="P:NPOI.HSSF.Record.Constant.ErrorConstant.Text">
            <summary>
            Gets the text.
            </summary>
            <value>The text.</value>
        </member>
        <member name="M:NPOI.HSSF.Record.Constant.ErrorConstant.ValueOf(System.Int32)">
            <summary>
            Values the of.
            </summary>
            <param name="errorCode">The error code.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.Record.Constant.ErrorConstant.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="T:NPOI.HSSF.Record.ContinueRecord">
            Title:        Continue Record - Helper class used primarily for SST Records 
            Description:  handles overflow for prior record in the input
                          stream; content Is tailored to that prior record
            @author Marc Johnson (mjohnson at apache dot org)
            @author Andrew C. Oliver (acoliver at apache dot org)
            @author Csaba Nagy (ncsaba at yahoo dot com)
            @version 2.0-pre
        </member>
        <member name="M:NPOI.HSSF.Record.ContinueRecord.#ctor">
            default constructor
        </member>
        <member name="M:NPOI.HSSF.Record.ContinueRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
             Main constructor -- kinda dummy because we don't validate or fill fields
            
             @param in the RecordInputstream to Read the record from
        </member>
        <member name="M:NPOI.HSSF.Record.ContinueRecord.Serialize">
            USE ONLY within "ProcessContinue"
        </member>
        <member name="M:NPOI.HSSF.Record.ContinueRecord.Write(System.Byte[],System.Int32,System.Nullable{System.Byte},System.Byte[])">
            Writes the full encoding of a Continue record without making an instance
        </member>
        <member name="M:NPOI.HSSF.Record.ContinueRecord.Write(System.Byte[],System.Int32,System.Nullable{System.Byte},System.Byte[],System.Int32,System.Int32)">
            @param initialDataByte (optional - often used for unicode flag). 
            If supplied, this will be written before srcData
            @return the total number of bytes written
        </member>
        <member name="P:NPOI.HSSF.Record.ContinueRecord.Data">
            Get the data for continuation
            @return byte array containing all of the continued data
        </member>
        <member name="M:NPOI.HSSF.Record.ContinueRecord.ToString">
             Debugging toString
            
             @return string representation
        </member>
        <member name="M:NPOI.HSSF.Record.ContinueRecord.Clone">
            Clone this record.
        </member>
        <member name="T:NPOI.HSSF.Record.Cont.ContinuableRecord">
            Common superclass of all records that can produce {@link ContinueRecord}s while being Serialized.
            
            @author Josh Micich
        </member>
        <member name="M:NPOI.HSSF.Record.Cont.ContinuableRecord.Serialize(NPOI.HSSF.Record.Cont.ContinuableRecordOutput)">
            Serializes this record's content to the supplied data output.<br/>
            The standard BIFF header (ushort sid, ushort size) has been handled by the superclass, so 
            only BIFF data should be written by this method.  Simple data types can be written with the
            standard {@link LittleEndianOutput} methods.  Methods from {@link ContinuableRecordOutput} 
            can be used to Serialize strings (with {@link ContinueRecord}s being written as required).
            If necessary, implementors can explicitly start {@link ContinueRecord}s (regardless of the
            amount of remaining space).
            
            @param out a data output stream
        </member>
        <member name="P:NPOI.HSSF.Record.Cont.ContinuableRecord.RecordSize">
            @return the total Length of the encoded record(s) 
            (Note - if any {@link ContinueRecord} is required, this result includes the
            size of those too)
        </member>
        <member name="T:NPOI.HSSF.Record.Cont.ContinuableRecordOutput">
            An augmented {@link LittleEndianOutput} used for serialization of {@link ContinuableRecord}s.
            This class keeps track of how much remaining space is available in the current BIFF record and
            can start new {@link ContinueRecord}s as required. 
            
            @author Josh Micich
        </member>
        <member name="P:NPOI.HSSF.Record.Cont.ContinuableRecordOutput.TotalSize">
            @return total number of bytes written so far (including all BIFF headers) 
        </member>
        <member name="M:NPOI.HSSF.Record.Cont.ContinuableRecordOutput.Terminate">
            Terminates the last record (also updates its 'ushort size' field)
        </member>
        <member name="P:NPOI.HSSF.Record.Cont.ContinuableRecordOutput.AvailableSpace">
            @return number of remaining bytes of space in current record
        </member>
        <member name="M:NPOI.HSSF.Record.Cont.ContinuableRecordOutput.WriteContinue">
            Terminates the current record and starts a new {@link ContinueRecord} (regardless
            of how much space is still available in the current record).
        </member>
        <member name="M:NPOI.HSSF.Record.Cont.ContinuableRecordOutput.WriteStringData(System.String)">
            Writes the 'optionFlags' byte and encoded character data of a unicode string.  This includes:
            <ul>
            <li>byte optionFlags</li>
            <li>encoded character data (in "ISO-8859-1" or "UTF-16LE" encoding)</li>
            </ul>
            
            Notes:
            <ul>
            <li>The value of the 'is16bitEncoded' flag is determined by the actual character data 
            of <tt>text</tt></li>
            <li>The string options flag is never separated (by a {@link ContinueRecord}) from the
            first chunk of character data it refers to.</li>
            <li>The 'ushort Length' field is assumed to have been explicitly written earlier.  Hence, 
            there may be an intervening {@link ContinueRecord}</li>
            </ul>
        </member>
        <member name="M:NPOI.HSSF.Record.Cont.ContinuableRecordOutput.WriteString(System.String,System.Int32,System.Int32)">
            Writes a unicode string complete with header and character data.  This includes:
            <ul>
            <li>ushort Length</li>
            <li>byte optionFlags</li>
            <li>ushort numberOfRichTextRuns (optional)</li>
            <li>ushort extendedDataSize (optional)</li>
            <li>encoded character data (in "ISO-8859-1" or "UTF-16LE" encoding)</li>
            </ul>
            
            The following bits of the 'optionFlags' byte will be set as appropriate:
            <table border='1'>
            <tr><th>Mask</th><th>Description</th></tr>
            <tr><td>0x01</td><td>is16bitEncoded</td></tr>
            <tr><td>0x04</td><td>hasExtendedData</td></tr>
            <tr><td>0x08</td><td>isRichText</td></tr>
            </table>
            Notes:
            <ul> 
            <li>The value of the 'is16bitEncoded' flag is determined by the actual character data 
            of <tt>text</tt></li>
            <li>The string header fields are never separated (by a {@link ContinueRecord}) from the
            first chunk of character data (i.e. the first character is always encoded in the same
            record as the string header).</li>
            </ul>
        </member>
        <member name="F:NPOI.HSSF.Record.Cont.ContinuableRecordOutput.NOPOutput">
            **
        </member>
        <member name="T:NPOI.HSSF.Record.Cont.UnknownLengthRecordOutput">
            Allows the writing of BIFF records when the 'ushort size' header field is not known in advance.
            When the client is finished writing data, it calls {@link #terminate()}, at which point this 
            class updates the 'ushort size' with its value. 
            
            @author Josh Micich
        </member>
        <member name="F:NPOI.HSSF.Record.Cont.UnknownLengthRecordOutput._dataSizeOutput">
            for writing the 'ushort size'  field once its value is known 
        </member>
        <member name="P:NPOI.HSSF.Record.Cont.UnknownLengthRecordOutput.TotalSize">
            includes 4 byte header
        </member>
        <member name="M:NPOI.HSSF.Record.Cont.UnknownLengthRecordOutput.Terminate">
            Finishes writing the current record and updates 'ushort size' field.<br/>
            After this method is called, only {@link #getTotalSize()} may be called.
        </member>
        <member name="T:NPOI.HSSF.Record.Crypto.Biff8DecryptingStream">
            
             @author Josh Micich
        </member>
        <member name="M:NPOI.HSSF.Record.Crypto.Biff8DecryptingStream.ReadRecordSID">
            Reads an unsigned short value without decrypting
        </member>
        <member name="M:NPOI.HSSF.Record.Crypto.Biff8DecryptingStream.ReadDataSize">
            Reads an unsigned short value without decrypting
        </member>
        <member name="M:NPOI.HSSF.Record.Crypto.Biff8EncryptionKey.Create(System.Byte[])">
            Create using the default password and a specified docId
            @param docId 16 bytes
        </member>
        <member name="M:NPOI.HSSF.Record.Crypto.Biff8EncryptionKey.Validate(System.Byte[],System.Byte[])">
            @return <code>true</code> if the keyDigest is compatible with the specified saltData and saltHash
        </member>
        <member name="M:NPOI.HSSF.Record.Crypto.Biff8EncryptionKey.CreateRC4(System.Int32)">
            The {@link RC4} instance needs to be Changed every 1024 bytes.
            @param keyBlockNo used to seed the newly Created {@link RC4}
        </member>
        <member name="F:NPOI.HSSF.Record.Crypto.Biff8EncryptionKey._userPasswordTLS">
            Stores the BIFF8 encryption/decryption password for the current thread.  This has been done
            using a {@link ThreadLocal} in order to avoid further overloading the various public APIs
            (e.g. {@link HSSFWorkbook}) that need this functionality.
        </member>
        <member name="P:NPOI.HSSF.Record.Crypto.Biff8EncryptionKey.CurrentUserPassword">
            @return the BIFF8 encryption/decryption password for the current thread.
            <code>null</code> if it is currently unSet.
        </member>
        <member name="T:NPOI.HSSF.Record.Crypto.Biff8RC4">
             Used for both encrypting and decrypting BIFF8 streams. The internal
             {@link RC4} instance is renewed (re-keyed) every 1024 bytes.
            
             @author Josh Micich
        </member>
        <member name="F:NPOI.HSSF.Record.Crypto.Biff8RC4._streamPos">
            This field is used to keep track of when to change the {@link RC4}
            instance. The change occurs every 1024 bytes. Every byte passed over is
            counted.
        </member>
        <member name="M:NPOI.HSSF.Record.Crypto.Biff8RC4.IsNeverEncryptedRecord(System.Int32)">
             TODO: Additionally, the lbPlyPos (position_of_BOF) field of the BoundSheet8 record MUST NOT be encrypted.
            
             @return <code>true</code> if record type specified by <tt>sid</tt> is never encrypted
        </member>
        <member name="M:NPOI.HSSF.Record.Crypto.Biff8RC4.SkipTwoBytes">
            Used when BIFF header fields (sid, size) are being Read. The internal
            {@link RC4} instance must step even when unencrypted bytes are read
        </member>
        <member name="T:NPOI.HSSF.Record.Crypto.RC4">
             Simple implementation of the alleged RC4 algorithm.
            
             Inspired by <A HREF="http://en.wikipedia.org/wiki/RC4">wikipedia's RC4 article</A>
            
             @author Josh Micich
        </member>
        <member name="T:NPOI.HSSF.Record.EOFRecord">
            End Of File record.
            
            Description:  Marks the end of records belonging to a particular object in the
                          HSSF File
            REFERENCE:  PG 307 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
            @author Andrew C. Oliver (acoliver at apache dot org)
            @author Jason Height (jheight at chariot dot net dot au)
            @version 2.0-pre
        </member>
        <member name="M:NPOI.HSSF.Record.EOFRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Constructs a EOFRecord record and Sets its fields appropriately.
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="T:NPOI.HSSF.Record.FilePassRecord">
            Title:        File Pass Record
            Description:  Indicates that the record after this record are encrypted. HSSF does not support encrypted excel workbooks
            and the presence of this record will cause Processing to be aborted.
            REFERENCE:  PG 420 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
            @author Jason Height (jheight at chariot dot net dot au)
            @version 3.0-pre
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.AbstractFunctionPtg">
            This class provides the base functionality for Excel sheet functions
            There are two kinds of function Ptgs - tFunc and tFuncVar
            Therefore, this class will have ONLY two subclasses
            @author  Avik Sengupta
            @author Andrew C. Oliver (acoliver at apache dot org)
        </member>
        <member name="F:NPOI.HSSF.Record.Formula.AbstractFunctionPtg.FUNCTION_NAME_IF">
            The name of the IF function (i.e. "IF").  Extracted as a constant for clarity.
        </member>
        <member name="F:NPOI.HSSF.Record.Formula.AbstractFunctionPtg.FUNCTION_INDEX_EXTERNAL">
            All external functions have function index 255 
        </member>
        <member name="P:NPOI.HSSF.Record.Formula.AbstractFunctionPtg.IsExternalFunction">
            external functions Get some special Processing
            @return <c>true</c> if this is an external function
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.AbstractFunctionPtg.IsInternalFunctionName(System.String)">
            Used to detect whether a function name found in a formula is one of the standard excel functions
            
            The name matching is case insensitive.
            @return <c>true</c> if the name specifies a standard worksheet function,
             <c>false</c> if the name should be assumed to be an external function.
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.AbstractFunctionPtg.IsBuiltInFunctionName(System.String)">
            Used to detect whether a function name found in a formula is one of the standard excel functions
            
            The name matching is case insensitive.
            @return <c>true</c> if the name specifies a standard worksheet function,
             <c>false</c> if the name should be assumed to be an external function.
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.AbstractFunctionPtg.LookupIndex(System.String)">
            Resolves internal function names into function indexes.
            
            The name matching is case insensitive.
            @return the standard worksheet function index if found, otherwise <tt>FUNCTION_INDEX_EXTERNAL</tt>
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.AddPtg">
            Addition operator PTG the "+" binomial operator.  If you need more 
            explanation than that then well...We really can't help you here.
            @author  Andrew C. Oliver (acoliver@apache.org)
            @author Jason Height (jheight at chariot dot net dot au)
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.AddPtg.ToFormulaString(System.String[])">
            implementation of method from OperationsPtg
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Area2DPtgBase">
            Common superclass of 2-D area refs 
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Area3DPtg">
            Title:        Area 3D Ptg - 3D reference (Sheet + Area)
            Description:  Defined a area in Extern Sheet. 
            REFERENCE:  
            @author Libin Roman (Vista Portal LDT. Developer)
            @author avik
            @author Jason Height (jheight at chariot dot net dot au)
            @version 1.0-pre
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Area3DPtg.ToFormulaString(NPOI.SS.Formula.FormulaRenderingWorkbook)">
            @return text representation of this area reference that can be used in text
             formulas. The sheet name will get properly delimited if required.
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.AreaErrPtg">
             AreaErr - handles deleted cell area references.
            
             @author Daniel Noll (daniel at nuix dot com dot au)
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.AreaI">
            Common interface for AreaPtg and Area3DPtg, and their
             child classes.
        </member>
        <member name="P:NPOI.HSSF.Record.Formula.AreaI.FirstRow">
            @return the first row in the area
        </member>
        <member name="P:NPOI.HSSF.Record.Formula.AreaI.LastRow">
            @return last row in the range (x2 in x1,y1-x2,y2)
        </member>
        <member name="P:NPOI.HSSF.Record.Formula.AreaI.FirstColumn">
            @return the first column number in the area.
        </member>
        <member name="P:NPOI.HSSF.Record.Formula.AreaI.LastColumn">
            @return lastcolumn in the area
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.AreaNPtg">
            Specifies a rectangular area of cells A1:A4 for instance.
            @author Jason Height (jheight at chariot dot net dot au)
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.AreaPtg">
            Specifies a rectangular area of cells A1:A4 for instance.
            @author Jason Height (jheight at chariot dot net dot au)
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.AreaPtgBase">
            Specifies a rectangular area of cells A1:A4 for instance.
            @author  andy
            @author Jason Height (jheight at chariot dot net dot au)
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.AreaPtgBase.NotImplemented">
            TODO - (May-2008) fix subclasses of AreaPtg 'AreaN~' which are used in shared formulas.
            see similar comment in ReferencePtg
        </member>
        <member name="F:NPOI.HSSF.Record.Formula.AreaPtgBase.field_1_first_row">
            zero based, Unsigned 16 bit 
        </member>
        <member name="F:NPOI.HSSF.Record.Formula.AreaPtgBase.field_2_last_row">
            zero based, Unsigned 16 bit 
        </member>
        <member name="F:NPOI.HSSF.Record.Formula.AreaPtgBase.field_3_first_column">
            zero based, Unsigned 8 bit 
        </member>
        <member name="F:NPOI.HSSF.Record.Formula.AreaPtgBase.field_4_last_column">
            zero based, Unsigned 8 bit 
        </member>
        <member name="P:NPOI.HSSF.Record.Formula.AreaPtgBase.FirstRow">
            @return the first row in the area
        </member>
        <member name="P:NPOI.HSSF.Record.Formula.AreaPtgBase.LastRow">
            @return last row in the range (x2 in x1,y1-x2,y2)
        </member>
        <member name="P:NPOI.HSSF.Record.Formula.AreaPtgBase.FirstColumn">
            @return the first column number in the area.
        </member>
        <member name="P:NPOI.HSSF.Record.Formula.AreaPtgBase.IsFirstRowRelative">
            @return whether or not the first row is a relative reference or not.
        </member>
        <member name="P:NPOI.HSSF.Record.Formula.AreaPtgBase.IsFirstColRelative">
            @return Isrelative first column to relative or not
        </member>
        <member name="P:NPOI.HSSF.Record.Formula.AreaPtgBase.LastColumn">
            @return lastcolumn in the area
        </member>
        <member name="P:NPOI.HSSF.Record.Formula.AreaPtgBase.LastColumnRaw">
            @return last column and bitmask (the raw field)
        </member>
        <member name="P:NPOI.HSSF.Record.Formula.AreaPtgBase.IsLastRowRelative">
            @return last row relative or not
        </member>
        <member name="P:NPOI.HSSF.Record.Formula.AreaPtgBase.IsLastColRelative">
            @return lastcol relative or not
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.AreaPtgBase.SetLastColumnRaw(System.Int16)">
            Set the last column irrespective of the bitmasks
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.ArrayPtg">
            ArrayPtg - handles arrays
            
            The ArrayPtg is a little weird, the size of the Ptg when parsing initially only
            includes the Ptg sid and the reserved bytes. The next Ptg in the expression then follows.
            It is only after the "size" of all the Ptgs is met, that the ArrayPtg data is actually
            held after this. So Ptg.CreateParsedExpression keeps track of the number of 
            ArrayPtg elements and need to Parse the data upto the FORMULA record size.
             
            @author Jason Height (jheight at chariot dot net dot au)
        </member>
        <member name="F:NPOI.HSSF.Record.Formula.ArrayPtg.PLAIN_TOKEN_SIZE">
            The size of the plain tArray token written within the standard formula tokens
            (not including the data which comes after all formula tokens)
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.ArrayPtg.#ctor(System.Object[][])">
            @param values2d array values arranged in rows
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.ArrayPtg.ReadTokenValues(NPOI.Util.IO.LittleEndianInput)">
            Read in the actual token (array) values. This occurs 
            AFTER the last Ptg in the expression.
            See page 304-305 of Excel97-2007BinaryFileFormat(xls)Specification.pdf
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.ArrayPtg.GetValueIndex(System.Int32,System.Int32)">
            Note - (2D) array elements are stored column by column 
            @return the index into the internal 1D array for the specified column and row
        </member>
        <member name="P:NPOI.HSSF.Record.Formula.ArrayPtg.Size">
            This size includes the size of the array Ptg plus the Array Ptg Token value size
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Atp.ParityFunction">
            Implementation of Excel 'Analysis ToolPak' function ISEVEN() ISODD()<br/>
            
            @author Josh Micich
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Atp.YearFrac">
            Implementation of Excel 'Analysis ToolPak' function YEARFRAC()<br/>
            
            Returns the fraction of the year spanned by two dates.<p/>
            
            <b>Syntax</b><br/>
            <b>YEARFRAC</b>(<b>startDate</b>, <b>endDate</b>, basis)<p/>
            
            The <b>basis</b> optionally specifies the behaviour of YEARFRAC as follows:
            
            <table border="0" cellpadding="1" cellspacing="0" summary="basis parameter description">
              <tr><th>Value</th><th>Days per Month</th><th>Days per Year</th></tr>
              <tr align='center'><td>0 (default)</td><td>30</td><td>360</td></tr>
              <tr align='center'><td>1</td><td>actual</td><td>actual</td></tr>
              <tr align='center'><td>2</td><td>actual</td><td>360</td></tr>
              <tr align='center'><td>3</td><td>actual</td><td>365</td></tr>
              <tr align='center'><td>4</td><td>30</td><td>360</td></tr>
            </table>
            
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Atp.YearFrac.MakeDate(System.Int32,System.Int32,System.Int32)">
            @param month 1-based
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Atp.YearFracCalculator">
            <summary>
            Internal calculation methods for Excel 'Analysis ToolPak' function YEARFRAC()
            Algorithm inspired by www.dwheeler.com/yearfrac
            @author Josh Micich
            </summary>
            <remarks>
            Date Count convention 
            http://en.wikipedia.org/wiki/Day_count_convention
            </remarks>
            <remarks>
            Office Online Help on YEARFRAC
            http://office.microsoft.com/en-us/excel/HP052093441033.aspx
            </remarks>
        </member>
        <member name="F:NPOI.HSSF.Record.Formula.Atp.YearFracCalculator.MS_PER_HOUR">
            use UTC time-zone to avoid daylight savings issues 
        </member>
        <member name="F:NPOI.HSSF.Record.Formula.Atp.YearFracCalculator.LONG_MONTH_LEN">
            the length of normal long months i.e. 31 
        </member>
        <member name="F:NPOI.HSSF.Record.Formula.Atp.YearFracCalculator.SHORT_MONTH_LEN">
            the length of normal short months i.e. 30 
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Atp.YearFracCalculator.Calculate(System.Double,System.Double,System.Int32)">
            <summary>
            Calculates YEARFRAC()
            </summary>
            <param name="pStartDateVal">The start date.</param>
            <param name="pEndDateVal">The end date.</param>
            <param name="basis">The basis value.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Atp.YearFracCalculator.Basis0(System.Int32,System.Int32)">
            <summary>
            Basis 0, 30/360 date convention 
            </summary>
            <param name="startDateVal">The start date value assumed to be less than or equal to endDateVal.</param>
            <param name="endDateVal">The end date value assumed to be greater than or equal to startDateVal.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Atp.YearFracCalculator.Basis1(System.Int32,System.Int32)">
            <summary>
            Basis 1, Actual/Actual date convention 
            </summary>
            <param name="startDateVal">The start date value assumed to be less than or equal to endDateVal.</param>
            <param name="endDateVal">The end date value assumed to be greater than or equal to startDateVal.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Atp.YearFracCalculator.Basis2(System.Int32,System.Int32)">
            <summary>
            Basis 2, Actual/360 date convention 
            </summary>
            <param name="startDateVal">The start date value assumed to be less than or equal to endDateVal.</param>
            <param name="endDateVal">The end date value assumed to be greater than or equal to startDateVal.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Atp.YearFracCalculator.Basis3(System.Double,System.Double)">
            <summary>
            Basis 3, Actual/365 date convention 
            </summary>
            <param name="startDateVal">The start date value assumed to be less than or equal to endDateVal.</param>
            <param name="endDateVal">The end date value assumed to be greater than or equal to startDateVal.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Atp.YearFracCalculator.Basis4(System.Int32,System.Int32)">
            <summary>
            Basis 4, European 30/360 date convention 
            </summary>
            <param name="startDateVal">The start date value assumed to be less than or equal to endDateVal.</param>
            <param name="endDateVal">The end date value assumed to be greater than or equal to startDateVal.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Atp.YearFracCalculator.CalculateAdjusted(NPOI.HSSF.Record.Formula.Atp.YearFracCalculator.SimpleDate,NPOI.HSSF.Record.Formula.Atp.YearFracCalculator.SimpleDate,System.Int32,System.Int32)">
            <summary>
            Calculates the adjusted.
            </summary>
            <param name="startDate">The start date.</param>
            <param name="endDate">The end date.</param>
            <param name="date1day">The date1day.</param>
            <param name="date2day">The date2day.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Atp.YearFracCalculator.IsLastDayOfMonth(NPOI.HSSF.Record.Formula.Atp.YearFracCalculator.SimpleDate)">
            <summary>
            Determines whether [is last day of month] [the specified date].
            </summary>
            <param name="date">The date.</param>
            <returns>
            	<c>true</c> if [is last day of month] [the specified date]; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Atp.YearFracCalculator.GetLastDayOfMonth(NPOI.HSSF.Record.Formula.Atp.YearFracCalculator.SimpleDate)">
            <summary>
            Gets the last day of month.
            </summary>
            <param name="date">The date.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Atp.YearFracCalculator.ShouldCountFeb29(NPOI.HSSF.Record.Formula.Atp.YearFracCalculator.SimpleDate,NPOI.HSSF.Record.Formula.Atp.YearFracCalculator.SimpleDate)">
            <summary>
            Assumes dates are no more than 1 year apart.
            </summary>
            <param name="start">The start.</param>
            <param name="end">The end.</param>
            <returns><c>true</c>
             if dates both within a leap year, or span a period including Feb 29</returns>
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Atp.YearFracCalculator.DateDiff(System.Int64,System.Int64)">
            <summary>
            return the whole number of days between the two time-stamps.  Both time-stamps are
            assumed to represent 12:00 midnight on the respective day.
            </summary>
            <param name="startDateTicks">The start date ticks.</param>
            <param name="endDateTicks">The end date ticks.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Atp.YearFracCalculator.AverageYearLength(System.Int32,System.Int32)">
            <summary>
            Averages the length of the year.
            </summary>
            <param name="startYear">The start year.</param>
            <param name="endYear">The end year.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Atp.YearFracCalculator.IsLeapYear(System.Int32)">
            <summary>
            determine Leap Year
            </summary>
            <param name="i">the year</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Atp.YearFracCalculator.IsGreaterThanOneYear(NPOI.HSSF.Record.Formula.Atp.YearFracCalculator.SimpleDate,NPOI.HSSF.Record.Formula.Atp.YearFracCalculator.SimpleDate)">
            <summary>
            Determines whether [is greater than one year] [the specified start].
            </summary>
            <param name="start">The start date.</param>
            <param name="end">The end date.</param>
            <returns>
            	<c>true</c> if [is greater than one year] [the specified start]; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Atp.YearFracCalculator.CreateDate(System.Int32)">
            <summary>
            Creates the date.
            </summary>
            <param name="dayCount">The day count.</param>
            <returns></returns>
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Atp.YearFracCalculator.SimpleDate">
            <summary>
            Simple Date Wrapper
            </summary>
        </member>
        <member name="F:NPOI.HSSF.Record.Formula.Atp.YearFracCalculator.SimpleDate.month">
            1-based month 
        </member>
        <member name="F:NPOI.HSSF.Record.Formula.Atp.YearFracCalculator.SimpleDate.day">
            day of month 
        </member>
        <member name="F:NPOI.HSSF.Record.Formula.Atp.YearFracCalculator.SimpleDate.ticks">
            milliseconds since 1970 
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.AttrPtg">
            "Special Attributes"
            This seems to be a Misc Stuff and Junk record.  One function it serves Is
            in SUM functions (i.e. SUM(A1:A3) causes an area PTG then an ATTR with the SUM option Set)
            @author  andy
            @author Jason Height (jheight at chariot dot net dot au)
        </member>
        <member name="F:NPOI.HSSF.Record.Formula.AttrPtg._jumpTable">
            only used for tAttrChoose: table of offsets to starts of args 
        </member>
        <member name="F:NPOI.HSSF.Record.Formula.AttrPtg._chooseFuncOffset">
            only used for tAttrChoose: offset to the tFuncVar for CHOOSE() 
        </member>
        <member name="F:NPOI.HSSF.Record.Formula.AttrPtg.SpaceType.SPACE_BEFORE">
            00H = Spaces before the next token (not allowed before tParen token) 
        </member>
        <member name="F:NPOI.HSSF.Record.Formula.AttrPtg.SpaceType.CR_BEFORE">
            01H = Carriage returns before the next token (not allowed before tParen token) 
        </member>
        <member name="F:NPOI.HSSF.Record.Formula.AttrPtg.SpaceType.SPACE_BEFORE_OPEN_PAREN">
            02H = Spaces before opening parenthesis (only allowed before tParen token) 
        </member>
        <member name="F:NPOI.HSSF.Record.Formula.AttrPtg.SpaceType.CR_BEFORE_OPEN_PAREN">
            03H = Carriage returns before opening parenthesis (only allowed before tParen token) 
        </member>
        <member name="F:NPOI.HSSF.Record.Formula.AttrPtg.SpaceType.SPACE_BEFORE_CLOSE_PAREN">
            04H = Spaces before closing parenthesis (only allowed before tParen, tFunc, and tFuncVar tokens) 
        </member>
        <member name="F:NPOI.HSSF.Record.Formula.AttrPtg.SpaceType.CR_BEFORE_CLOSE_PAREN">
            05H = Carriage returns before closing parenthesis (only allowed before tParen, tFunc, and tFuncVar tokens) 
        </member>
        <member name="F:NPOI.HSSF.Record.Formula.AttrPtg.SpaceType.SPACE_AFTER_EQUALITY">
            06H = Spaces following the equality sign (only in macro sheets) 
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.AttrPtg.CreateSpace(System.Int32,System.Int32)">
            <summary>
            Creates the space.
            </summary>
            <param name="type">a constant from SpaceType</param>
            <param name="count">The count.</param>
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.AttrPtg.CreateIf(System.Int32)">
            <summary>
            Creates if.
            </summary>
            <param name="dist">distance (in bytes) to start of either
            tFuncVar(IF) token (when false parameter is not present).</param>
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.AttrPtg.CreateSkip(System.Int32)">
            <summary>
            Creates the skip.
            </summary>
            <param name="dist">distance (in bytes) to position behind tFuncVar(IF) token (minus 1).</param>
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.BoolPtg">
            bool (bool)
            Stores a (java) bool value in a formula.
            @author Paul Krause (pkrause at soundbite dot com)
            @author Andrew C. Oliver (acoliver at apache dot org)
            @author Jason Height (jheight at chariot dot net dot au)
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.ConcatPtg">
            
             @author  andy
             @author Jason Height (jheight at chariot dot net dot au)
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.ControlPtg">
            Common baseclass for 
            tExp
            tTbl
            tParen
            tNlr
            tAttr
            tSheet
            tEndSheet
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.DeletedArea3DPtg">
            Title:        Deleted Area 3D Ptg - 3D referecnce (Sheet + Area)
            Description:  Defined a area in Extern Sheet. 
            REFERENCE:  
            @author Patrick Luby
            @version 1.0-pre
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.DeletedRef3DPtg">
            Title:        Deleted Reference 3D Ptg 
            Description:  Defined a cell in extern sheet. 
            REFERENCE:  
            @author Patrick Luby
            @version 1.0-pre
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.DeletedRef3DPtg.#ctor(NPOI.Util.IO.LittleEndianInput)">
            Creates new DeletedRef3DPtg 
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.DividePtg">
            This PTG implements the standard binomial divide "/"
            @author  Andrew C. Oliver acoliver at apache dot org
            @author Jason Height (jheight at chariot dot net dot au)
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.EqualPtg">
            
             @author  andy
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.ErrPtg">
            @author Daniel Noll (daniel at nuix dot com dot au)
        </member>
        <member name="F:NPOI.HSSF.Record.Formula.ErrPtg.NULL_INTERSECTION">
            <b>#NULL!</b>  - Intersection of two cell ranges is empty 
        </member>
        <member name="F:NPOI.HSSF.Record.Formula.ErrPtg.DIV_ZERO">
            <b>#DIV/0!</b> - Division by zero 
        </member>
        <member name="F:NPOI.HSSF.Record.Formula.ErrPtg.VALUE_INVALID">
            <b>#VALUE!</b> - Wrong type of operand 
        </member>
        <member name="F:NPOI.HSSF.Record.Formula.ErrPtg.REF_INVALID">
            <b>#REF!</b> - Illegal or deleted cell reference 
        </member>
        <member name="F:NPOI.HSSF.Record.Formula.ErrPtg.NAME_INVALID">
            <b>#NAME?</b> - Wrong function or range name 
        </member>
        <member name="F:NPOI.HSSF.Record.Formula.ErrPtg.NUM_ERROR">
            <b>#NUM!</b> - Value range overflow 
        </member>
        <member name="F:NPOI.HSSF.Record.Formula.ErrPtg.N_A">
            <b>#N/A</b> - Argument or function not available 
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.ErrPtg.#ctor(System.Int32)">
            Creates new ErrPtg 
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Eval.AreaEval">
            @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
             
        </member>
        <member name="P:NPOI.HSSF.Record.Formula.Eval.AreaEval.FirstRow">
            returns the 0-based index of the first row in
            this area.
        </member>
        <member name="P:NPOI.HSSF.Record.Formula.Eval.AreaEval.LastRow">
            returns the 0-based index of the last row in
            this area.
        </member>
        <member name="P:NPOI.HSSF.Record.Formula.Eval.AreaEval.FirstColumn">
            returns the 0-based index of the first col in
            this area.
        </member>
        <member name="P:NPOI.HSSF.Record.Formula.Eval.AreaEval.LastColumn">
            returns the 0-based index of the last col in
            this area.
        </member>
        <member name="P:NPOI.HSSF.Record.Formula.Eval.AreaEval.IsRow">
            returns true if the Area's start and end row indexes
            are same. This result of this method should agree
            with FirstRow() == LastRow().
        </member>
        <member name="P:NPOI.HSSF.Record.Formula.Eval.AreaEval.IsColumn">
            returns true if the Area's start and end col indexes
            are same. This result of this method should agree
            with FirstColumn() == LastColumn().
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Eval.AreaEval.GetValueAt(System.Int32,System.Int32)">
            returns the ValueEval from the values array at the specified 
            row and col index. The specified indexes should be absolute indexes
            in the sheet and not relative indexes within the area. Also,
            if Contains(row, col) Evaluates to true, a null value will
            bre returned.
            @param row
            @param col
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Eval.AreaEval.Contains(System.Int32,System.Int32)">
            returns true if the cell at row and col specified 
            as absolute indexes in the sheet is contained in 
            this area.
            @param row
            @param col
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Eval.AreaEval.ContainsColumn(System.Int32)">
            returns true if the specified col is in range
            @param col
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Eval.AreaEval.ContainsRow(System.Int32)">
            returns true if the specified row is in range
            @param row
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Eval.AreaEval.GetRelativeValue(System.Int32,System.Int32)">
            @return the ValueEval from within this area at the specified relativeRowIndex and 
            relativeColumnIndex. Never <c>null</c> (possibly {@link BlankEval}). The
            specified indexes should relative to the top left corner of this area.  
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Eval.AreaEval.Offset(System.Int32,System.Int32,System.Int32,System.Int32)">
            Creates an {@link AreaEval} offset by a relative amount from from the upper left cell
            of this area
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Eval.AreaEvalBase">
            @author Josh Micich
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Eval.BlankEval">
            @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt; This class is a
                    marker class. It is a special value for empty cells.
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Eval.BoolEval">
            @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
             
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Eval.BoolEval.ValueOf(System.Boolean)">
            Convenience method for the following:<br/>
            <c>(b ? BoolEval.TRUE : BoolEval.FALSE)</c>
            @return a <tt>BoolEval</tt> instance representing <tt>b</tt>.
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Eval.ConcatEval">
            @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
             
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Eval.ErrorEval">
             @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
            
        </member>
        <member name="F:NPOI.HSSF.Record.Formula.Eval.ErrorEval.NULL_INTERSECTION">
            <b>#NULL!</b>  - Intersection of two cell ranges is empty 
        </member>
        <member name="F:NPOI.HSSF.Record.Formula.Eval.ErrorEval.DIV_ZERO">
            <b>#DIV/0!</b> - Division by zero 
        </member>
        <member name="F:NPOI.HSSF.Record.Formula.Eval.ErrorEval.VALUE_INVALID">
            <b>#VALUE!</b> - Wrong type of operand 
        </member>
        <member name="F:NPOI.HSSF.Record.Formula.Eval.ErrorEval.REF_INVALID">
            <b>#REF!</b> - Illegal or deleted cell reference 
        </member>
        <member name="F:NPOI.HSSF.Record.Formula.Eval.ErrorEval.NAME_INVALID">
            <b>#NAME?</b> - Wrong function or range name 
        </member>
        <member name="F:NPOI.HSSF.Record.Formula.Eval.ErrorEval.NUM_ERROR">
            <b>#NUM!</b> - Value range overflow 
        </member>
        <member name="F:NPOI.HSSF.Record.Formula.Eval.ErrorEval.NA">
            <b>#N/A</b> - Argument or function not available 
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Eval.ErrorEval.ValueOf(System.Int32)">
            Translates an Excel internal error code into the corresponding POI ErrorEval instance
            @param errorCode
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Eval.ErrorEval.GetText(System.Int32)">
            Converts error codes to text.  Handles non-standard error codes OK.  
            For debug/test purposes (and for formatting error messages).
            @return the String representation of the specified Excel error code.
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Eval.ErrorEval.#ctor(System.Int32)">
            @param errorCode an 8-bit value
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Eval.Eval">
            @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
             
        </member>
        <!-- Badly formed XML comment ignored for member "T:NPOI.HSSF.Record.Formula.Eval.EvaluationException" -->
        <member name="M:NPOI.HSSF.Record.Formula.Eval.EvaluationException.InvalidValue">
            <b>#VALUE!</b> - Wrong type of operand 
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Eval.EvaluationException.InvalidRef">
            <b>#REF!</b> - Illegal or deleted cell reference 
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Eval.EvaluationException.NumberError">
            <b>#NUM!</b> - Value range overflow 
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Eval.FunctionEval">
            @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
             
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Eval.FunctionEval.FunctionID">
            Some function IDs that require special treatment
        </member>
        <member name="F:NPOI.HSSF.Record.Formula.Eval.FunctionEval.FunctionID.IF">
            1 
        </member>
        <member name="F:NPOI.HSSF.Record.Formula.Eval.FunctionEval.FunctionID.OFFSET">
            78 
        </member>
        <member name="F:NPOI.HSSF.Record.Formula.Eval.FunctionEval.FunctionID.CHOOSE">
            100 
        </member>
        <member name="F:NPOI.HSSF.Record.Formula.Eval.FunctionEval.FunctionID.INDIRECT">
            148 
        </member>
        <member name="F:NPOI.HSSF.Record.Formula.Eval.FunctionEval.FunctionID.EXTERNAL_FUNC">
            255 
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Eval.NameEval">
            @author Josh Micich
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Eval.NameEval.#ctor(System.String)">
            Creates a NameEval representing a function name
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Eval.NameXEval">
            @author Josh Micich
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Eval.NumberEval">
            @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
             
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Eval.NumericValueEval">
            @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
             
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Eval.OperandResolver">
            Provides functionality for evaluating arguments to functions and operators.
            
            @author Josh Micich
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Eval.OperandResolver.GetSingleValue(NPOI.HSSF.Record.Formula.Eval.ValueEval,System.Int32,System.Int32)">
            Retrieves a single value from a variety of different argument types according to standard
            Excel rules.  Does not perform any type conversion.
            @param arg the Evaluated argument as passed to the function or operator.
            @param srcCellRow used when arg is a single column AreaRef
            @param srcCellCol used when arg is a single row AreaRef
            @return a <tt>NumberEval</tt>, <tt>StringEval</tt>, <tt>BoolEval</tt> or <tt>BlankEval</tt>.
            Never <c>null</c> or <tt>ErrorEval</tt>.
            @throws EvaluationException(#VALUE!) if srcCellRow or srcCellCol do not properly index into
             an AreaEval.  If the actual value retrieved is an ErrorEval, a corresponding 
             EvaluationException is thrown.
        </member>
        <!-- Badly formed XML comment ignored for member "M:NPOI.HSSF.Record.Formula.Eval.OperandResolver.ChooseSingleElementFromArea(NPOI.HSSF.Record.Formula.Eval.AreaEval,System.Int32,System.Int32)" -->
        <member name="M:NPOI.HSSF.Record.Formula.Eval.OperandResolver.ChooseSingleElementFromAreaInternal(NPOI.HSSF.Record.Formula.Eval.AreaEval,System.Int32,System.Int32)">
            @return possibly  <tt>ErrorEval</tt>, and <c>null</c> 
        </member>
        <!-- Badly formed XML comment ignored for member "M:NPOI.HSSF.Record.Formula.Eval.OperandResolver.CoerceValueToInt(NPOI.HSSF.Record.Formula.Eval.ValueEval)" -->
        <member name="M:NPOI.HSSF.Record.Formula.Eval.OperandResolver.CoerceValueToDouble(NPOI.HSSF.Record.Formula.Eval.ValueEval)">
            Applies some conversion rules if the supplied value is not already a number.
            Note - <tt>BlankEval</tt> is not supported and must be handled by the caller. 
            @param ev must be a <tt>NumberEval</tt>, <tt>StringEval</tt> or <tt>BoolEval</tt>
            @return actual, Parsed or interpreted double value (respectively).
            @throws EvaluationException(#VALUE!) only if a StringEval is supplied and cannot be Parsed
            as a double (See <tt>Parsedouble()</tt> for allowable formats).
            @throws Exception if the supplied parameter is not <tt>NumberEval</tt>,
             <tt>StringEval</tt> or <tt>BoolEval</tt>
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Eval.OperandResolver.ParseDouble(System.String)">
            Converts a string to a double using standard rules that Excel would use.<br/>
            Tolerates currency prefixes, commas, leading and trailing spaces.<p/>
              
             Some examples:<br/> 
             " 123 " -&gt; 123.0<br/>
             ".123" -&gt; 0.123<br/>
             These not supported yet:<br/>
             " $ 1,000.00 " -&gt; 1000.0<br/>
             "$1.25E4" -&gt; 12500.0<br/>
             "5**2" -&gt; 500<br/>
             "250%" -&gt; 2.5<br/>
             
            @param text
            @return <c>null</c> if the specified text cannot be Parsed as a number
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Eval.OperandResolver.CoerceValueToString(NPOI.HSSF.Record.Formula.Eval.ValueEval)">
            @param ve must be a <tt>NumberEval</tt>, <tt>StringEval</tt>, <tt>BoolEval</tt>, or <tt>BlankEval</tt>
            @return the Converted string value. never <c>null</c>
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Eval.OperandResolver.CoerceValueToBoolean(NPOI.HSSF.Record.Formula.Eval.ValueEval,System.Boolean)">
            @return <c>null</c> to represent blank values
            @throws EvaluationException if ve is an ErrorEval, or if a string value cannot be converted
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Eval.PercentEval">
            Implementation of Excel formula token '%'. <p/>
            @author Josh Micich
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Eval.RangeEval">
            
            @author Josh Micich 
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Eval.RefEval">
            @author Amol S Deshmukh &lt; amolweb at ya hoo dot com &gt;
            
            RefEval is the base interface for Ref2D and Ref3DEval. Basically a RefEval
            impl should contain reference to the original ReferencePtg or Ref3DPtg as
            well as the "value" resulting from the evaluation of the cell
            reference. Thus if the HSSFCell has type CELL_TYPE_NUMERIC, the contained
            value object should be of type NumberEval; if cell type is CELL_TYPE_STRING,
            contained value object should be of type StringEval
        </member>
        <member name="P:NPOI.HSSF.Record.Formula.Eval.RefEval.InnerValueEval">
            The (possibly Evaluated) ValueEval contained
            in this RefEval. eg. if cell A1 Contains "test"
            then in a formula referring to cell A1 
            the RefEval representing
            A1 will return as the InnerValueEval the
            object of concrete type StringEval
        </member>
        <member name="P:NPOI.HSSF.Record.Formula.Eval.RefEval.Column">
            returns the zero based column index.
        </member>
        <member name="P:NPOI.HSSF.Record.Formula.Eval.RefEval.Row">
            returns the zero based row index.
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Eval.RefEval.Offset(System.Int32,System.Int32,System.Int32,System.Int32)">
            Creates an {@link AreaEval} offset by a relative amount from this RefEval
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Eval.EqualEval">
            @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
             
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Eval.GreaterEqualEval">
            @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
             
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Eval.GreaterThanEval">
            @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
             
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Eval.LessEqualEval">
            @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
             
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Eval.LessThanEval">
            @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
             
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Eval.NotEqualEval">
            @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
             
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Eval.RelationalOperationEval">
             @author Amol S. Deshmukh &lt; amolweb at ya hoo Dot com &gt;
            
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Eval.StringEval">
            @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
             
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Eval.StringValueEval">
            @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
             
        </member>
        <member name="P:NPOI.HSSF.Record.Formula.Eval.StringValueEval.StringValue">
            @return never <code>null</code>, possibly empty string.
        </member>
        <!-- Badly formed XML comment ignored for member "T:NPOI.HSSF.Record.Formula.Eval.AddEval" -->
        <member name="T:NPOI.HSSF.Record.Formula.Eval.DivideEval">
            @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
             
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Eval.MultiplyEval">
            @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
             
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Eval.PowerEval">
            @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
             
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Eval.SubtractEval">
            @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
             
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Eval.UnaryMinusEval">
            @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
             
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Eval.UnaryPlusEval">
            @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
             
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Eval.ValueEval">
            @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
             
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Eval.ValueEvalToNumericXlator">
             @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
            
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Eval.ValueEvalToNumericXlator.AttemptXlateToNumeric(NPOI.HSSF.Record.Formula.Eval.ValueEval)">
            returned value can be either A NumericValueEval, BlankEval or ErrorEval.
            The params can be either NumberEval, BoolEval, StringEval, or
            RefEval
            @param eval
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Eval.ValueEvalToNumericXlator.XlateBlankEval(System.Int32)">
            no args are required since BlankEval has only one 
            instance. If flag is Set, a zero
            valued numbereval is returned, else BlankEval.INSTANCE
            is returned.
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Eval.ValueEvalToNumericXlator.XlateRefEval(NPOI.HSSF.Record.Formula.Eval.RefEval)">
            uses the relevant flags to decode the supplied RefVal
            @param eval
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Eval.ValueEvalToNumericXlator.XlateStringEval(NPOI.HSSF.Record.Formula.Eval.StringEval)">
            uses the relevant flags to decode the StringEval
            @param eval
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Eval.ValueEvalToNumericXlator.XlateRefStringEval(NPOI.HSSF.Record.Formula.Eval.StringEval)">
            uses the relevant flags to decode the StringEval
            @param eval
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.ExpPtg">
            
             @author  andy
             @author Jason Height (jheight at chariot dot net dot au)
             @author dmui (save existing implementation)
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.FormulaShifter">
            @author Josh Micich
        </member>
        <member name="F:NPOI.HSSF.Record.Formula.FormulaShifter._externSheetIndex">
            Extern sheet index of sheet where moving is occurring
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.FormulaShifter.AdjustFormula(NPOI.HSSF.Record.Formula.Ptg[],System.Int32)">
            @param ptgs - if necessary, will get modified by this method
            @param currentExternSheetIx - the extern sheet index of the sheet that contains the formula being adjusted
            @return <c>true</c> if a change was made to the formula tokens
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.FormulaShifter.AdjustPtgDueToRowMove(NPOI.HSSF.Record.Formula.Ptg,System.Int32)">
            @return <c>true</c> if this Ptg needed to be changed
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.FuncPtg">
            @author aviks
            @author Jason Height (jheight at chariot dot net dot au)
            @author Danny Mui (dmui at apache dot org) (Leftover handling)
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.FuncPtg.#ctor(NPOI.Util.IO.LittleEndianInput)">
            Creates new function pointer from a byte array
            usually called while Reading an excel file.
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.AggregateFunction">
             @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
            
        </member>
        <!-- Badly formed XML comment ignored for member "T:NPOI.HSSF.Record.Formula.Functions.BooleanFunction" -->
        <member name="T:NPOI.HSSF.Record.Formula.Functions.False">
            @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
             
        </member>
        <!-- Badly formed XML comment ignored for member "T:NPOI.HSSF.Record.Formula.Functions.Not" -->
        <member name="T:NPOI.HSSF.Record.Formula.Functions.True">
            @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
             
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.CalendarFieldFunction">
            Implementation of Excel functions DAY, MONTH and YEAR
            
            
            @author Guenter Kickinger g.kickinger@gmx.net
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Ceiling">
             @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
            
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Choose">
            @author Josh Micich
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Columns">
            Implementation for Excel COLUMNS function.
            
            @author Josh Micich
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Combin">
             @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
            
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Count">
             Counts the number of cells that contain numeric data within
              the list of arguments. 
            
             Excel Syntax
             COUNT(value1,value2,...)
             Value1, value2, ...   are 1 to 30 arguments representing the values or ranges to be Counted.
             
             TODO: Check this properly Matches excel on edge cases
              like formula cells, error cells etc
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Counta">
             Counts the number of cells that contain data within the list of arguments. 
            
             Excel Syntax
             COUNTA(value1,value2,...)
             Value1, value2, ...   are 1 to 30 arguments representing the values or ranges to be Counted.
             
             @author Josh Micich
        </member>
        <!-- Badly formed XML comment ignored for member "T:NPOI.HSSF.Record.Formula.Functions.Countif" -->
        <member name="P:NPOI.HSSF.Record.Formula.Functions.Countif.CmpOp.Length">
            @return number of characters used to represent this operator
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Functions.Countif.StringMatcher.GetWildCardPattern(System.String)">
            <summary>
            Translates Excel countif wildcard strings into .NET regex strings
            </summary>
            <param name="value">Excel wildcard expression</param>
            <returns>return null if the specified value contains no special wildcard characters.</returns>
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Functions.Countif.CountMatchingCellsInArea(NPOI.HSSF.Record.Formula.Eval.ValueEval,NPOI.HSSF.Record.Formula.Functions.I_MatchPredicate)">
            @return the number of Evaluated cells in the range that match the specified criteria
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Functions.Countif.CreateGeneralMatchPredicate(NPOI.HSSF.Record.Formula.Eval.StringEval)">
            When the second argument Is a string, many things are possible
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Functions.Countif.ParseBoolean(System.String)">
            bool literals ('TRUE', 'FALSE') treated similarly but NOT same as numbers. 
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.I_MatchPredicate">
            Common interface for the matching criteria.
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.CountUtils">
             Common logic for COUNT, COUNTA and COUNTIF
            
             @author Josh Micich 
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Functions.CountUtils.CountMatchingCellsInArea(NPOI.HSSF.Record.Formula.Eval.AreaEval,NPOI.HSSF.Record.Formula.Functions.I_MatchPredicate)">
            @return the number of evaluated cells in the range that match the specified criteria
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Functions.CountUtils.CountMatchingCell(NPOI.HSSF.Record.Formula.Eval.RefEval,NPOI.HSSF.Record.Formula.Functions.I_MatchPredicate)">
            @return 1 if the evaluated cell matches the specified criteria
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.DateFunc">
            @author Pavel Krupets (pkrupets at palmtreebusiness dot com)
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Degrees">
            @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
             
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Dollar">
             @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
            
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Even">
            @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
             
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Exp">
             @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
            
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Fact">
             @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
            
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.FinanceFunction">
            @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
            Super class for all Evals for financial function evaluation.
            
        </member>
        <!-- Badly formed XML comment ignored for member "T:NPOI.HSSF.Record.Formula.Functions.FinanceLib" -->
        <member name="M:NPOI.HSSF.Record.Formula.Functions.FinanceLib.fv(System.Double,System.Double,System.Double,System.Double,System.Boolean)">
            Future value of an amount given the number of payments, rate, amount
            of individual payment, present value and bool value indicating whether
            payments are due at the beginning of period 
            (false => payments are due at end of period) 
            @param r rate
            @param n num of periods
            @param y pmt per period
            @param p future value
            @param t type (true=pmt at end of period, false=pmt at begining of period)
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Functions.FinanceLib.pv(System.Double,System.Double,System.Double,System.Double,System.Boolean)">
            Present value of an amount given the number of future payments, rate, amount
            of individual payment, future value and bool value indicating whether
            payments are due at the beginning of period 
            (false => payments are due at end of period) 
            @param r
            @param n
            @param y
            @param f
            @param t
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Functions.FinanceLib.npv(System.Double,System.Double[])">
            calculates the Net Present Value of a principal amount
            given the disCount rate and a sequence of cash flows 
            (supplied as an array). If the amounts are income the value should 
            be positive, else if they are payments and not income, the 
            value should be negative.
            @param r
            @param cfs cashflow amounts
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Functions.FinanceLib.pmt(System.Double,System.Double,System.Double,System.Double,System.Boolean)">
            
            @param r
            @param n
            @param p
            @param f
            @param t
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Functions.FinanceLib.nper(System.Double,System.Double,System.Double,System.Double,System.Boolean)">
            
            @param r
            @param y
            @param p
            @param f
            @param t
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Fixed0ArgFunction">
             Convenience base class for functions that only take zero arguments.
            
             @author Josh Micich
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Fixed1ArgFunction">
             Convenience base class for functions that must take exactly one argument.
            
             @author Josh Micich
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Fixed2ArgFunction">
             Convenience base class for functions that must take exactly two arguments.
            
             @author Josh Micich
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Fixed3ArgFunction">
             Convenience base class for functions that must take exactly three arguments.
            
             @author Josh Micich
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Fixed4ArgFunction">
             Convenience base class for functions that must take exactly four arguments.
            
             @author Josh Micich
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Floor">
             @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
            
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.FreeRefFunction">
            For most Excel functions, involving references ((cell, area), (2d, 3d)), the references are 
            passed in as arguments, and the exact location remains fixed.  However, a select few Excel
            functions have the ability to access cells that were not part of any reference passed as an
            argument.<br/>
            Two important functions with this feature are <b>INDIRECT</b> and <b>OFFSet</b><p/>
             
            In POI, the <tt>HSSFFormulaEvaluator</tt> Evaluates every cell in each reference argument before
            calling the function.  This means that functions using fixed references do not need access to
            the rest of the workbook to execute.  Hence the <tt>Evaluate()</tt> method on the common
            interface <tt>Function</tt> does not take a workbook parameter.  
            
            This interface recognises the requirement of some functions to freely Create and Evaluate 
            references beyond those passed in as arguments.
            
            @author Josh Micich
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Functions.FreeRefFunction.Evaluate(NPOI.HSSF.Record.Formula.Eval.ValueEval[],NPOI.SS.Formula.OperationEvaluationContext)">
            @param args the pre-Evaluated arguments for this function. args is never <code>null</code>,
                        nor are any of its elements.
            @param ec primarily used to identify the source cell Containing the formula being Evaluated.
                        may also be used to dynamically create reference evals.
            @return never <code>null</code>. Possibly an instance of <tt>ErrorEval</tt> in the case of
            a specified Excel error (Exceptions are never thrown to represent Excel errors).
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Function">
            <summary>
            Function serves as a marker interface.
            </summary>
            @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Functions.Function.Evaluate(NPOI.HSSF.Record.Formula.Eval.ValueEval[],System.Int32,System.Int32)">
            <summary>
            Evaluates the specified args.
            </summary>
            <param name="args">the evaluated function arguments.  Empty values are represented with BlankEval or MissingArgEval</param>
            <param name="srcRowIndex">row index of the cell containing the formula under evaluation</param>
            <param name="srcColumnIndex">column index of the cell containing the formula under evaluation</param>
            <returns></returns>
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Function0Arg">
             Implemented by all functions that can be called with zero arguments
            
             @author Josh Micich
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Functions.Function0Arg.Evaluate(System.Int32,System.Int32)">
            see {@link Function#Evaluate(ValueEval[], int, int)}
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Function1Arg">
             Implemented by all functions that can be called with one argument
            
             @author Josh Micich
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Functions.Function1Arg.Evaluate(System.Int32,System.Int32,NPOI.HSSF.Record.Formula.Eval.ValueEval)">
            see {@link Function#Evaluate(ValueEval[], int, int)}
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Function2Arg">
             Implemented by all functions that can be called with two arguments
            
             @author Josh Micich
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Functions.Function2Arg.Evaluate(System.Int32,System.Int32,NPOI.HSSF.Record.Formula.Eval.ValueEval,NPOI.HSSF.Record.Formula.Eval.ValueEval)">
            see {@link Function#Evaluate(ValueEval[], int, int)}
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Function3Arg">
             Implemented by all functions that can be called with three arguments
            
             @author Josh Micich
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Functions.Function3Arg.Evaluate(System.Int32,System.Int32,NPOI.HSSF.Record.Formula.Eval.ValueEval,NPOI.HSSF.Record.Formula.Eval.ValueEval,NPOI.HSSF.Record.Formula.Eval.ValueEval)">
            see {@link Function#Evaluate(ValueEval[], int, int)}
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Function4Arg">
             Implemented by all functions that can be called with four arguments
            
             @author Josh Micich
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Functions.Function4Arg.Evaluate(System.Int32,System.Int32,NPOI.HSSF.Record.Formula.Eval.ValueEval,NPOI.HSSF.Record.Formula.Eval.ValueEval,NPOI.HSSF.Record.Formula.Eval.ValueEval,NPOI.HSSF.Record.Formula.Eval.ValueEval)">
            see {@link Function#Evaluate(ValueEval[], int, int)}
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Hlookup">
            Implementation of the HLOOKUP() function.<p/>
            
            HLOOKUP Finds a column in a lookup table by the first row value and returns the value from another row.<br/>
            
            <b>Syntax</b>:<br/>
            <b>HLOOKUP</b>(<b>lookup_value</b>, <b>table_array</b>, <b>row_index_num</b>, range_lookup)<p/>
            
            <b>lookup_value</b>  The value to be found in the first column of the table array.<br/>
            <b>table_array</b> An area reference for the lookup data. <br/>
            <b>row_index_num</b> a 1 based index specifying which row value of the lookup data will be returned.<br/>
            <b>range_lookup</b> If TRUE (default), HLOOKUP Finds the largest value less than or equal to 
            the lookup_value.  If FALSE, only exact Matches will be considered<br/>   
            
            @author Josh Micich
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Functions.Hlookup.CreateResultColumnVector(NPOI.HSSF.Record.Formula.Eval.AreaEval,System.Int32)">
            Returns one column from an <tt>AreaEval</tt>
            
            @(#VALUE!) if colIndex Is negative, (#REF!) if colIndex Is too high
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.If">
            @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
            
        </member>
        <!-- Badly formed XML comment ignored for member "T:NPOI.HSSF.Record.Formula.Functions.Index" -->
        <member name="M:NPOI.HSSF.Record.Formula.Functions.Index.GetValueFromArea(NPOI.HSSF.Record.Formula.Eval.AreaEval,System.Int32,System.Int32,System.Boolean,System.Int32,System.Int32)">
            @param colArgWasPassed <code>false</code> if the INDEX argument lIst had just 2 items
                       (exactly 1 comma).  If anything Is passed for the <tt>column_num</tt> argument
                       (including {@link BlankEval} or {@link MIssingArgEval}) this parameter will be
                       <code>true</code>.  ThIs parameter is needed because error codes are slightly
                       different when only 2 args are passed.
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Functions.Index.ResolveIndexArg(NPOI.HSSF.Record.Formula.Eval.ValueEval,System.Int32,System.Int32)">
            @param arg a 1-based index.
            @return the Resolved 1-based index. Zero if the arg was missing or blank
            @throws EvaluationException if the arg Is an error value evaluates to a negative numeric value
        </member>
        <!-- Badly formed XML comment ignored for member "T:NPOI.HSSF.Record.Formula.Functions.Indirect" -->
        <member name="M:NPOI.HSSF.Record.Formula.Functions.Indirect.ParseWorkbookAndSheetName(System.String)">
            @return array of length 2: {workbookName, sheetName,}.  Second element will always be
            present.  First element may be null if sheetName is unqualified.
            Returns <code>null</code> if text cannot be parsed.
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Functions.Indirect.UnescapeString(System.String)">
            @return <code>null</code> if there is a syntax error in any escape sequence
            (the typical syntax error is a single quote character not followed by another).
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Int">
             @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
            
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Isblank">
             @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
            
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Iserror">
             @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
            
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Islogical">
             @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
            
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Isna">
             @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
            
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Isnontext">
             @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
            
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Isnumber">
             @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
            
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Isref">
             @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
            
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Istext">
             @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
            
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.LogicalFunction">
             @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
            
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Functions.LogicalFunction.Evaluate(NPOI.HSSF.Record.Formula.Eval.ValueEval)">
            @param arg any {@link ValueEval}, potentially {@link BlankEval} or {@link ErrorEval}.
        </member>
        <!-- Badly formed XML comment ignored for member "T:NPOI.HSSF.Record.Formula.Functions.Lookup" -->
        <member name="T:NPOI.HSSF.Record.Formula.Functions.LookupUtils">
            Common functionality used by VLOOKUP, HLOOKUP, LOOKUP and MATCH
            
            @author Josh Micich
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Functions.LookupUtils.CreateVector(NPOI.HSSF.Record.Formula.Eval.AreaEval)">
            @return <c>null</c> if the supplied area is neither a single row nor a single colum
        </member>
        <!-- Badly formed XML comment ignored for member "M:NPOI.HSSF.Record.Formula.Functions.LookupUtils.ResolveRowOrColIndexArg(NPOI.HSSF.Record.Formula.Eval.ValueEval,System.Int32,System.Int32)" -->
        <member name="M:NPOI.HSSF.Record.Formula.Functions.LookupUtils.ResolveTableArrayArg(NPOI.HSSF.Record.Formula.Eval.ValueEval)">
            The second argument (table_array) should be an area ref, but can actually be a cell ref, in
            which case it Is interpreted as a 1x1 area ref.  Other scalar values cause #VALUE! error.
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Functions.LookupUtils.ResolveRangeLookupArg(NPOI.HSSF.Record.Formula.Eval.ValueEval,System.Int32,System.Int32)">
            Resolves the last (optional) parameter (<b>range_lookup</b>) to the VLOOKUP and HLOOKUP functions. 
            @param rangeLookupArg
            @param srcCellRow
            @param srcCellCol
            @return
            @throws EvaluationException
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Functions.LookupUtils.LookupIndexOfExactValue(NPOI.HSSF.Record.Formula.Functions.LookupValueComparer,NPOI.HSSF.Record.Formula.Functions.ValueVector)">
            Finds first (lowest index) exact occurrence of specified value.
            @param lookupValue the value to be found in column or row vector
            @param vector the values to be searched. For VLOOKUP this Is the first column of the 
            	tableArray. For HLOOKUP this Is the first row of the tableArray. 
            @return zero based index into the vector, -1 if value cannot be found
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Functions.LookupUtils.PerformBinarySearch(NPOI.HSSF.Record.Formula.Functions.ValueVector,NPOI.HSSF.Record.Formula.Functions.LookupValueComparer)">
            Excel has funny behaviour when the some elements in the search vector are the wrong type.
            
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Functions.LookupUtils.HandleMidValueTypeMismatch(NPOI.HSSF.Record.Formula.Functions.LookupValueComparer,NPOI.HSSF.Record.Formula.Functions.ValueVector,NPOI.HSSF.Record.Formula.Functions.BinarySearchIndexes,System.Int32)">
            Excel seems to handle mismatched types initially by just stepping 'mid' ix forward to the 
            first compatible value.
            @param midIx 'mid' index (value which has the wrong type)
            @return usually -1, signifying that the BinarySearchIndex has been narrowed to the new mid 
            index.  Zero or greater signifies that an exact match for the lookup value was found
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Functions.LookupUtils.FindLastIndexInRunOfEqualValues(NPOI.HSSF.Record.Formula.Functions.LookupValueComparer,NPOI.HSSF.Record.Formula.Functions.ValueVector,System.Int32,System.Int32)">
            Once the binary search has found a single match, (V/H)LOOKUP steps one by one over subsequent
            values to choose the last matching item.
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.CompareResult">
            Enumeration to support <b>4</b> valued comparison results.<p/>
            Excel lookup functions have complex behaviour in the case where the lookup array has mixed 
            types, and/or Is Unordered.  Contrary to suggestions in some Excel documentation, there
            does not appear to be a Universal ordering across types.  The binary search algorithm used
            Changes behaviour when the Evaluated 'mid' value has a different type to the lookup value.<p/>
            
            A simple int might have done the same job, but there Is risk in confusion with the well 
            known <tt>Comparable.CompareTo()</tt> and <tt>Comparator.Compare()</tt> which both use
            a ubiquitous 3 value result encoding.
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.BinarySearchIndexes">
            Encapsulates some standard binary search functionality so the Unusual Excel behaviour can
            be clearly distinguished. 
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Functions.BinarySearchIndexes.GetMidIx">
            @return -1 if the search range Is empty
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.ValueVector">
            Represents a single row or column within an <tt>AreaEval</tt>.
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Functions.LookupValueComparer.CompareTo(NPOI.HSSF.Record.Formula.Eval.ValueEval)">
            @return one of 4 instances or <tt>CompareResult</tt>: <tt>LESS_THAN</tt>, <tt>EQUAL</tt>, 
            <tt>GREATER_THAN</tt> or <tt>TYPE_MISMATCH</tt>
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Functions.LookupValueComparerBase.GetValueAsString">
            used only for debug purposes 
        </member>
        <!-- Badly formed XML comment ignored for member "T:NPOI.HSSF.Record.Formula.Functions.Match" -->
        <member name="M:NPOI.HSSF.Record.Formula.Functions.Match.FindIndexOfValue(NPOI.HSSF.Record.Formula.Eval.ValueEval,NPOI.HSSF.Record.Formula.Functions.ValueVector,System.Boolean,System.Boolean)">
            @return zero based index
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.MathX">
            @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
            This class Is an extension to the standard math library
            provided by java.lang.Math class. It follows the Math class
            in that it has a private constructor and all static methods.
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Functions.MathX.round(System.Double,System.Int32)">
            Returns a value rounded to p digits after decimal.
            If p Is negative, then the number Is rounded to
            places to the left of the decimal point. eg. 
            10.23 rounded to -1 will give: 10. If p Is zero,
            the returned value Is rounded to the nearest integral
            value.
            If n Is negative, the resulting value Is obtained
            as the round value of absolute value of n multiplied
            by the sign value of n (@see MathX.sign(double d)). 
            Thus, -0.6666666 rounded to p=0 will give -1 not 0.
            If n Is NaN, returned value Is NaN.
            @param n
            @param p
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Functions.MathX.roundUp(System.Double,System.Int32)">
            Returns a value rounded-up to p digits after decimal.
            If p Is negative, then the number Is rounded to
            places to the left of the decimal point. eg. 
            10.23 rounded to -1 will give: 20. If p Is zero,
            the returned value Is rounded to the nearest integral
            value.
            If n Is negative, the resulting value Is obtained
            as the round-up value of absolute value of n multiplied
            by the sign value of n (@see MathX.sign(double d)). 
            Thus, -0.2 rounded-up to p=0 will give -1 not 0.
            If n Is NaN, returned value Is NaN.
            @param n
            @param p
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Functions.MathX.roundDown(System.Double,System.Int32)">
            Returns a value rounded to p digits after decimal.
            If p Is negative, then the number Is rounded to
            places to the left of the decimal point. eg. 
            10.23 rounded to -1 will give: 10. If p Is zero,
            the returned value Is rounded to the nearest integral
            value.
            If n Is negative, the resulting value Is obtained
            as the round-up value of absolute value of n multiplied
            by the sign value of n (@see MathX.sign(double d)). 
            Thus, -0.8 rounded-down to p=0 will give 0 not -1.
            If n Is NaN, returned value Is NaN.
            @param n
            @param p
        </member>
        <!-- Badly formed XML comment ignored for member "M:NPOI.HSSF.Record.Formula.Functions.MathX.sign(System.Double)" -->
        <member name="M:NPOI.HSSF.Record.Formula.Functions.MathX.average(System.Double[])">
            average of all values
            @param values
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Functions.MathX.sum(System.Double[])">
            sum of all values
            @param values
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Functions.MathX.sumsq(System.Double[])">
            sum of squares of all values
            @param values
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Functions.MathX.product(System.Double[])">
            product of all values
            @param values
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Functions.MathX.min(System.Double[])">
            min of all values. If supplied array Is zero Length,
            double.POSITIVE_INFINITY Is returned.
            @param values
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Functions.MathX.max(System.Double[])">
            min of all values. If supplied array Is zero Length,
            double.NEGATIVE_INFINITY Is returned.
            @param values
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Functions.MathX.floor(System.Double,System.Double)">
            Note: this function Is different from java.lang.Math.floor(..).
            
            When n and s are "valid" arguments, the returned value Is: Math.floor(n/s) * s;
            <br/>
            n and s are invalid if any of following conditions are true:
            <ul>
            <li>s Is zero</li>
            <li>n Is negative and s Is positive</li>
            <li>n Is positive and s Is negative</li>
            </ul>
            In all such cases, double.NaN Is returned.
            @param n
            @param s
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Functions.MathX.ceiling(System.Double,System.Double)">
            Note: this function Is different from java.lang.Math.ceil(..).
            
            When n and s are "valid" arguments, the returned value Is: Math.ceiling(n/s) * s;
            <br/>
            n and s are invalid if any of following conditions are true:
            <ul>
            <li>s Is zero</li>
            <li>n Is negative and s Is positive</li>
            <li>n Is positive and s Is negative</li>
            </ul>
            In all such cases, double.NaN Is returned.
            @param n
            @param s
        </member>
        <!-- Badly formed XML comment ignored for member "M:NPOI.HSSF.Record.Formula.Functions.MathX.factorial(System.Int32)" -->
        <member name="M:NPOI.HSSF.Record.Formula.Functions.MathX.mod(System.Double,System.Double)">
            returns the remainder resulting from operation:
            n / d. 
            <br/> The result has the sign of the divisor.
            <br/> Examples:
            <ul>
            <li>mod(3.4, 2) = 1.4</li>
            <li>mod(-3.4, 2) = 0.6</li>
            <li>mod(-3.4, -2) = -1.4</li>
            <li>mod(3.4, -2) = -0.6</li>
            </ul>
            If d == 0, result Is NaN
            @param n
            @param d
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Functions.MathX.acosh(System.Double)">
            inverse hyperbolic cosine
            @param d
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Functions.MathX.asinh(System.Double)">
            inverse hyperbolic sine
            @param d
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Functions.MathX.atanh(System.Double)">
            inverse hyperbolic tangent
            @param d
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Functions.MathX.cosh(System.Double)">
            hyperbolic cosine
            @param d
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Functions.MathX.sinh(System.Double)">
            hyperbolic sine
            @param d
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Functions.MathX.tanh(System.Double)">
            hyperbolic tangent
            @param d
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Functions.MathX.sumproduct(System.Double[][])">
            returns the sum of product of corresponding double value in each
            subarray. It Is the responsibility of the caller to Ensure that
            all the subarrays are of equal Length. If the subarrays are
            not of equal Length, the return value can be Unpredictable.
            @param arrays
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Functions.MathX.sumx2my2(System.Double[],System.Double[])">
            returns the sum of difference of squares of corresponding double 
            value in each subarray: ie. sigma (xarr[i]^2-yarr[i]^2) 
            <br/>
            It Is the responsibility of the caller 
            to Ensure that the two subarrays are of equal Length. If the 
            subarrays are not of equal Length, the return value can be 
            Unpredictable.
            @param xarr
            @param yarr
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Functions.MathX.sumx2py2(System.Double[],System.Double[])">
            returns the sum of sum of squares of corresponding double 
            value in each subarray: ie. sigma (xarr[i]^2 + yarr[i]^2) 
            <br/>
            It Is the responsibility of the caller 
            to Ensure that the two subarrays are of equal Length. If the 
            subarrays are not of equal Length, the return value can be 
            Unpredictable.
            @param xarr
            @param yarr
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Functions.MathX.sumxmy2(System.Double[],System.Double[])">
            returns the sum of squares of difference of corresponding double 
            value in each subarray: ie. sigma ( (xarr[i]-yarr[i])^2 ) 
            <br/>
            It Is the responsibility of the caller 
            to Ensure that the two subarrays are of equal Length. If the 
            subarrays are not of equal Length, the return value can be 
            Unpredictable.
            @param xarr
            @param yarr
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Functions.MathX.nChooseK(System.Int32,System.Int32)">
            returns the total number of combinations possible when
            k items are chosen out of total of n items. If the number
            Is too large, loss of precision may occur (since returned
            value Is double). If the returned value Is larger than
            double.MAX_VALUE, double.POSITIVE_INFINITY Is returned.
            If either of the parameters Is negative, double.NaN Is returned.
            @param n
            @param k
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.MinaMaxa">
            @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
            
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Mod">
             @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
            
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Mode">
             @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
            
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.MultiOperandNumericFunction">
            @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
            This Is the base class for all excel function evaluator
            classes that take variable number of operands, and
            where the order of operands does not matter
        </member>
        <member name="P:NPOI.HSSF.Record.Formula.Functions.MultiOperandNumericFunction.MaxNumOperands">
            Maximum number of operands accepted by this function.
            Subclasses may override to Change default value.
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Functions.MultiOperandNumericFunction.CollectValues(NPOI.HSSF.Record.Formula.Eval.ValueEval,NPOI.HSSF.Record.Formula.Functions.MultiOperandNumericFunction.DoubleList)">
            Collects values from a single argument
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Functions.MultiOperandNumericFunction.GetNumberArray(NPOI.HSSF.Record.Formula.Eval.ValueEval[])">
             Returns a double array that contains values for the numeric cells
             from among the list of operands. Blanks and Blank equivalent cells
             are ignored. Error operands or cells containing operands of type
             that are considered invalid and would result in #VALUE! error in
             excel cause this function to return <c>null</c>.
            
             @return never <c>null</c>
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Functions.MultiOperandNumericFunction.AreSubArraysConsistent(System.Double[][])">
            Ensures that a two dimensional array has all sub-arrays present and the same Length
            @return <c>false</c> if any sub-array Is missing, or Is of different Length
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Na">
            Implementation of Excel function NA()
            
            @author Josh Micich
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.NotImplementedFunction">
            
            @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
            This Is the default implementation of a Function class. 
            The default behaviour Is to return a non-standard ErrorEval
            "ErrorEval.FUNCTION_NOT_IMPLEMENTED". This error should alert 
            the user that the formula contained a function that Is not
            yet implemented.
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Abs">
            @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
             
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Acos">
             @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
            
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Acosh">
             @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
             Support for hyperbolic trig functions was Added as a part of
             Java distribution only in JDK1.5. This class uses custom
             naive implementation based on formulas at:
             http://www.math2.org/math/trig/hyperbolics.htm
             These formulas seem to agree with excel's implementation.
            
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Asin">
             @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
            
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Asinh">
             @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
             Support for hyperbolic trig functions was Added as a part of
             Java distribution only in JDK1.5. This class uses custom
             naive implementation based on formulas at:
             http://www.math2.org/math/trig/hyperbolics.htm
             These formulas seem to agree with excel's implementation.
            
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Atan">
             @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
            
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Atan2">
             @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
            
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Atanh">
             @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
             Support for hyperbolic trig functions was Added as a part of
             Java distribution only in JDK1.5. This class uses custom
             naive implementation based on formulas at:
             http://www.math2.org/math/trig/hyperbolics.htm
             These formulas seem to agree with excel's implementation.
            
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Cos">
             @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
            
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Cosh">
             @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
            
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Ln">
             @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
            
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Log">
            @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
            Log: LOG(number,[base])
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Log10">
             @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
            
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.NumericFunction">
             @author Amol S. Deshmukh &lt; amolweb at yahoo dot com &gt;
            
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Pi">
            @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
             
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Rand">
            @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
             
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Sin">
             @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
            
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Sinh">
             @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
            
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Sqrt">
             @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
            
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Tan">
             @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
            
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Tanh">
             @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
            
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Odd">
            @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
             
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Offset">
            Implementation for Excel function OFFSet()<p/>
            
            OFFSet returns an area reference that Is a specified number of rows and columns from a 
            reference cell or area.<p/>
            
            <b>Syntax</b>:<br/>
            <b>OFFSet</b>(<b>reference</b>, <b>rows</b>, <b>cols</b>, height, width)<p/>
            <b>reference</b> Is the base reference.<br/>
            <b>rows</b> Is the number of rows up or down from the base reference.<br/>
            <b>cols</b> Is the number of columns left or right from the base reference.<br/>
            <b>height</b> (default same height as base reference) Is the row Count for the returned area reference.<br/>
            <b>width</b> (default same width as base reference) Is the column Count for the returned area reference.<br/>
            
            @author Josh Micich
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Offset.EvalEx">
            Exceptions are used within this class to help simplify flow control when error conditions
            are enCountered 
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Offset.LinearOffsetRange">
            A one dimensional base + offset.  Represents either a row range or a column range.
            Two instances of this class toGether specify an area range.
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Functions.Offset.LinearOffsetRange.NormaliseAndTranslate(System.Int32)">
            Moves the range by the specified translation amount.<p/>
            
            This method also 'normalises' the range: Excel specifies that the width and height 
            parameters (Length field here) cannot be negative.  However, OFFSet() does produce
            sensible results in these cases.  That behavior Is replicated here. <p/>
            
            @param translationAmount may be zero negative or positive
            
            @return the equivalent <tt>LinearOffsetRange</tt> with a positive Length, moved by the
            specified translationAmount.
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Offset.BaseRef">
            Encapsulates either an area or cell reference which may be 2d or 3d.
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Functions.Offset.EvaluateIntArg(NPOI.HSSF.Record.Formula.Eval.ValueEval,System.Int32,System.Int32)">
            OFFSet's numeric arguments (2..5) have similar Processing rules
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Functions.Offset.ConvertDoubleToInt(System.Double)">
            Fractional values are silently truncated by Excel.
            Truncation Is toward negative infinity.
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Pmt">
            Implementation for the PMT() Excel function.<p/>
            
            <b>Syntax:</b><br/>
            <b>PMT</b>(<b>rate</b>, <b>nper</b>, <b>pv</b>, fv, type)<p/>
            
            Returns the constant repayment amount required for a loan assuming a constant interest rate.<p/>
            
            <b>rate</b> the loan interest rate.<br/>
            <b>nper</b> the number of loan repayments.<br/>
            <b>pv</b> the present value of the future payments (or principle).<br/>
            <b>fv</b> the future value (default zero) surplus cash at the end of the loan lifetime.<br/>
            <b>type</b> whether payments are due at the beginning(1) or end(0 - default) of each payment period.<br/>
            
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Power">
            @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
             
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Radians">
            @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
             
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Rows">
            Implementation for Excel ROWS function.
            
            @author Josh Micich
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.StatsLib">
             @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
            
             Library for common statistics functions
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Functions.StatsLib.avedev(System.Double[])">
            returns the mean of deviations from mean.
            @param v
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Functions.StatsLib.mode(System.Double[])">
            if v Is zero Length or Contains no duplicates, return value
            Is double.NaN. Else returns the value that occurs most times
            and if there Is a tie, returns the first such value. 
            @param v
        </member>
        <!-- Badly formed XML comment ignored for member "M:NPOI.HSSF.Record.Formula.Functions.StatsLib.kthLargest(System.Double[],System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:NPOI.HSSF.Record.Formula.Functions.StatsLib.kthSmallest(System.Double[],System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "T:NPOI.HSSF.Record.Formula.Functions.Sumproduct" -->
        <member name="M:NPOI.HSSF.Record.Formula.Functions.Sumproduct.GetProductTerm(NPOI.HSSF.Record.Formula.Eval.ValueEval,System.Boolean)">
            Determines a <c>double</c> value for the specified <c>ValueEval</c>. 
            @param IsScalarProduct <c>false</c> for SUMPRODUCTs over area refs.
            @throws EvalEx if <c>ve</c> represents an error value.
            <p/>
            Note - string values and empty cells are interpreted differently depending on 
            <c>isScalarProduct</c>.  For scalar products, if any term Is blank or a string, the
            error (#VALUE!) Is raised.  For area (sum)products, if any term Is blank or a string, the
            result Is zero.
        </member>
        <!-- Badly formed XML comment ignored for member "T:NPOI.HSSF.Record.Formula.Functions.Sumx2my2" -->
        <!-- Badly formed XML comment ignored for member "T:NPOI.HSSF.Record.Formula.Functions.Sumx2py2" -->
        <!-- Badly formed XML comment ignored for member "T:NPOI.HSSF.Record.Formula.Functions.Sumxmy2" -->
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Concatenate">
             @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
            
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Exact">
             @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
            
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.LeftRight">
             @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
            
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Len">
             @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
            
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Lower">
             @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
            
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Mid">
            <summary>
            An implementation of the MID function
            MID returns a specific number of
            Chars from a text string, starting at the specified position.
            @author Manda Wilson &lt; wilson at c bio dot msk cc dot org;
            </summary>
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Replace">
            An implementation of the Replace function:
            Replaces part of a text string based on the number of Chars 
            you specify, with another text string.
            @author Manda Wilson &lt; wilson at c bio dot msk cc dot org &gt;
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Functions.Replace.EvaluateFunc(NPOI.HSSF.Record.Formula.Eval.ValueEval[],System.Int32,System.Int32)">
            Replaces part of a text string based on the number of Chars 
            you specify, with another text string.
            
            @see org.apache.poi.hssf.record.formula.eval.Eval
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Substitute">
            An implementation of the SUBSTITUTE function:
            Substitutes text in a text string with new text, some number of times.
            @author Manda Wilson &lt; wilson at c bio dot msk cc dot org &gt;
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Functions.Substitute.EvaluateFunc(NPOI.HSSF.Record.Formula.Eval.ValueEval[],System.Int32,System.Int32)">
            Substitutes text in a text string with new text, some number of times.
             
             @see org.apache.poi.hssf.record.formula.eval.Eval
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.TextFunction">
             @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
            
        </member>
        <member name="F:NPOI.HSSF.Record.Formula.Functions.TextFunction.TRIM">
            An implementation of the TRIM function:
            Removes leading and trailing spaces from value if evaluated operand
             value is string.
            @author Manda Wilson &lt; wilson at c bio dot msk cc dot org &gt;
        </member>
        <!-- Badly formed XML comment ignored for member "F:NPOI.HSSF.Record.Formula.Functions.TextFunction.MID" -->
        <member name="F:NPOI.HSSF.Record.Formula.Functions.TextFunction.FIND">
             Implementation of the FIND() function.<p/>
            
             <b>Syntax</b>:<br/>
             <b>FIND</b>(<b>Find_text</b>, <b>within_text</b>, start_num)<p/>
            
             FIND returns the character position of the first (case sensitive) occurrence of
             <tt>Find_text</tt> inside <tt>within_text</tt>.  The third parameter,
             <tt>start_num</tt>, is optional (default=1) and specifies where to start searching
             from.  Character positions are 1-based.<p/>
            
             @author Torstein Tauno Svendsen (torstei@officenet.no)
        </member>
        <member name="F:NPOI.HSSF.Record.Formula.Functions.TextFunction.SEARCH">
             Implementation of the FIND() function.<p/>
            
             <b>Syntax</b>:<br/>
             <b>SEARCH</b>(<b>Find_text</b>, <b>within_text</b>, start_num)<p/>
            
             SEARCH is a case-insensitive version of FIND()
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Trim">
            An implementation of the TRIM function:
            Removes leading and trailing spaces from value if Evaluated operand
             value Is string.
            @author Manda Wilson &lt; wilson at c bio dot msk cc dot org &gt;
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Upper">
             @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
            
        </member>
        <member name="F:NPOI.HSSF.Record.Formula.Functions.Value.MIN_DISTANCE_BETWEEN_THOUSANDS_SEPARATOR">
            "1,0000" is valid, "1,00" is not 
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Functions.Value.ConvertTextToNumber(System.String)">
             TODO see if the same functionality is needed in {@link OperandResolver#parseDouble(String)}
            
             @return <code>null</code> if there is any problem Converting the text
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Var1or2ArgFunction">
             Convenience base class for any function which must take two or three
             arguments
            
             @author Josh Micich
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Var2or3ArgFunction">
             Convenience base class for any function which must take two or three
             arguments
            
             @author Josh Micich
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Var3or4ArgFunction">
             Convenience base class for any function which must take three or four
             arguments
            
             @author Josh Micich
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.Vlookup">
            Implementation of the VLOOKUP() function.<p/>
            
            VLOOKUP Finds a row in a lookup table by the first column value and returns the value from another column.<br/>
            
            <b>Syntax</b>:<br/>
            <b>VLOOKUP</b>(<b>lookup_value</b>, <b>table_array</b>, <b>col_index_num</b>, range_lookup)<p/>
            
            <b>lookup_value</b>  The value to be found in the first column of the table array.<br/>
            <b>table_array</b> An area reference for the lookup data. <br/>
            <b>col_index_num</b> a 1 based index specifying which column value of the lookup data will be returned.<br/>
            <b>range_lookup</b> If TRUE (default), VLOOKUP Finds the largest value less than or equal to 
            the lookup_value.  If FALSE, only exact Matches will be considered<br/>   
            
            @author Josh Micich
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Functions.Vlookup.CreateResultColumnVector(NPOI.HSSF.Record.Formula.Eval.AreaEval,System.Int32)">
            Returns one column from an <tt>AreaEval</tt>
            
            @(#VALUE!) if colIndex Is negative, (#REF!) if colIndex Is too high
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Functions.XYNumericFunction">
             @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
            
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Functions.XYNumericFunction.CreateAccumulator">
            Constructs a new instance of the Accumulator used to calculated this function
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Function.FunctionDataBuilder">
            Temporarily collects <tt>FunctionMetadata</tt> instances for creation of a
            <tt>FunctionMetadataRegistry</tt>.
            
            @author Josh Micich
        </member>
        <member name="F:NPOI.HSSF.Record.Formula.Function.FunctionDataBuilder._mutatingFunctionIndexes">
            stores indexes of all functions with footnotes (i.e. whose definitions might Change) 
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Function.FunctionMetadata">
            Holds information about Excel built-in functions.
            
            @author Josh Micich
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Function.FunctionMetadataReader">
            Converts the text meta-data file into a <tt>FunctionMetadataRegistry</tt>
            
            @author Josh Micich
        </member>
        <member name="F:NPOI.HSSF.Record.Formula.Function.FunctionMetadataReader.ELLIPSIS">
            plain ASCII text metadata file uses three dots for ellipsis 
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Function.FunctionMetadataReader.ValidateFunctionName(System.String)">
            Makes sure that footnote digits from the original OOO document have not been accidentally 
            left behind
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Function.FunctionMetadataRegistry">
            Allows clients to Get <tt>FunctionMetadata</tt> instances for any built-in function of Excel.
            
            @author Josh Micich
        </member>
        <member name="F:NPOI.HSSF.Record.Formula.Function.FunctionMetadataRegistry.FUNCTION_NAME_IF">
            The name of the IF function (i.e. "IF").  Extracted as a constant for clarity.
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Function.FunctionMetadataRegistry.LookupIndexByName(System.String)">
            Resolves a built-in function index. 
            @param name uppercase function name
            @return a negative value if the function name is not found.
            This typically occurs for external functions.
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.FuncVarPtg">
            
             @author Jason Height (jheight at chariot dot net dot au)
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.FuncVarPtg.#ctor(NPOI.Util.IO.LittleEndianInput)">
            Creates new function pointer from a byte array
            usually called while Reading an excel file.
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.FuncVarPtg.#ctor(System.String,System.Byte)">
            Create a function ptg from a string tokenised by the Parser
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.GreaterEqualPtg">
             PTG class to implement greater or equal to
            
             @author  fred at stsci dot edu
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.GreaterThanPtg">
            Greater than operator PTG ">"
            @author  Cameron Riley (criley at ekmail.com)
        </member>
        <member name="P:NPOI.HSSF.Record.Formula.GreaterThanPtg.NumberOfOperands">
            Get the number of operands for the Less than operator
            @return int the number of operands
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.GreaterThanPtg.ToFormulaString(System.String[])">
            Implementation of method from OperationsPtg
            @param operands a String array of operands
            @return String the Formula as a String
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.IntersectionPtg">
            @author Daniel Noll (daniel at nuix dot com dot au)
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.IntersectionPtg.ToFormulaString">
            Implementation of method from Ptg 
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.IntersectionPtg.ToFormulaString(System.String[])">
            implementation of method from OperationsPtg
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.IntPtg">
            Integer (unsigned short integer)
            Stores an Unsigned short value (java int) in a formula
            @author  Andrew C. Oliver (acoliver at apache dot org)
            @author Jason Height (jheight at chariot dot net dot au)
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.IntPtg.IsInRange(System.Int32)">
            Excel represents integers 0..65535 with the tInt token. 
            @return <c>true</c> if the specified value is within the range of values 
            <tt>IntPtg</tt> can represent. 
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.LessEqualPtg">
             Ptg class to implement less than or equal
            
             @author fred at stsci dot edu
        </member>
        <!-- Badly formed XML comment ignored for member "T:NPOI.HSSF.Record.Formula.LessThanPtg" -->
        <member name="F:NPOI.HSSF.Record.Formula.LessThanPtg.sid">
            the sid for the less than operator as hex 
        </member>
        <member name="F:NPOI.HSSF.Record.Formula.LessThanPtg.LESSTHAN">
            identifier for LESS THAN char 
        </member>
        <member name="P:NPOI.HSSF.Record.Formula.LessThanPtg.NumberOfOperands">
            Get the number of operands for the Less than operator
            @return int the number of operands
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.LessThanPtg.ToFormulaString(System.String[])">
            Implementation of method from OperationsPtg
            @param operands a String array of operands
            @return String the Formula as a String
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.MemAreaPtg">
            @author Daniel Noll (daniel at nuix dot com dot au)
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.MemAreaPtg.#ctor(System.Int32)">
            Creates new MemAreaPtg 
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.MemErrPtg">
            
             @author  andy
             @author Jason Height (jheight at chariot dot net dot au)
             @author Daniel Noll (daniel at nuix dot com dot au)
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.MemErrPtg.#ctor(NPOI.Util.IO.LittleEndianInput)">
            Creates new MemErrPtg 
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.MemFuncPtg">
            @author Glen Stampoultzis (glens at apache.org)
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.MemFuncPtg.#ctor(NPOI.Util.IO.LittleEndianInput)">
            Creates new function pointer from a byte array
            usually called while Reading an excel file.
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.MissingArgPtg">
             Missing Function Arguments
            
             Avik Sengupta &lt;avik at apache.org&gt;
             @author Jason Height (jheight at chariot dot net dot au)
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.MultiplyPtg">
            Implements the standard mathmatical multiplication - *
            @author  Andrew C. Oliver (acoliver at apache dot org)
            @author Jason Height (jheight at chariot dot net dot au)
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.NamePtg">
            
             @author  andy
             @author Jason Height (jheight at chariot dot net dot au)
        </member>
        <member name="F:NPOI.HSSF.Record.Formula.NamePtg.field_1_label_index">
            one-based index to defined name record 
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.NamePtg.#ctor(System.Int32)">
            @param nameIndex zero-based index to name within workbook
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.NamePtg.#ctor(NPOI.Util.IO.LittleEndianInput)">
            Creates new NamePtg 
        </member>
        <member name="P:NPOI.HSSF.Record.Formula.NamePtg.Index">
            @return zero based index to a defined name record in the LinkTable
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.NameXPtg">
            
             @author  aviks
        </member>
        <member name="F:NPOI.HSSF.Record.Formula.NameXPtg._sheetRefIndex">
            index to REF entry in externsheet record 
        </member>
        <member name="F:NPOI.HSSF.Record.Formula.NameXPtg._nameNumber">
            index to defined name or externname table(1 based) 
        </member>
        <member name="F:NPOI.HSSF.Record.Formula.NameXPtg._reserved">
            reserved must be 0 
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.NameXPtg.#ctor(System.Int32,System.Int32)">
            @param sheetRefIndex index to REF entry in externsheet record
            @param nameIndex index to defined name or externname table
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.NotEqualPtg">
             Ptg class to implement not equal
            
             @author fred at stsci dot edu
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.NumberPtg">
            Number
            Stores a floating point value in a formula
            value stored in a 8 byte field using IEEE notation
            @author  Avik Sengupta
            @author Jason Height (jheight at chariot dot net dot au)
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.NumberPtg.#ctor(NPOI.Util.IO.LittleEndianInput)">
            Create a NumberPtg from a byte array Read from disk 
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.NumberPtg.#ctor(System.String)">
            Create a NumberPtg from a string representation of  the number
            Number format is not checked, it is expected to be validated in the parser
             that calls this method. 
            @param value : String representation of a floating point number
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.OperandPtg">
            @author Josh Micich
        </member>
        <member name="P:NPOI.HSSF.Record.Formula.OperandPtg.IsBaseToken">
            All Operand <tt>Ptg</tt>s are classifed ('relative', 'value', 'array')  
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.OperationPtg">
            defines a Ptg that is an operation instead of an operand
            @author  andy
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.OperationPtg.ToFormulaString(System.String[])">
            returns a string representation of the operations
            the Length of the input array should equal the number returned by 
            @see #GetNumberOfOperands
            
        </member>
        <member name="P:NPOI.HSSF.Record.Formula.OperationPtg.NumberOfOperands">
            The number of operands expected by the operations
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.ParenthesisPtg">
             While formula tokens are stored in RPN order and thus do not need parenthesis for 
             precedence reasons, Parenthesis tokens ARE written to Ensure that user entered
             parenthesis are Displayed as-is on Reading back
            
             Avik Sengupta &lt;lists@aviksengupta.com&gt;
             Andrew C. Oliver (acoliver at apache dot org)
             @author Jason Height (jheight at chariot dot net dot au)
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.PercentPtg">
             Percent PTG.
            
             @author Daniel Noll (daniel at nuix.com.au)
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.PowerPtg">
            
             @author  andy
             @author Jason Height (jheight at chariot dot net dot au)
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Ptg">
             <tt>Ptg</tt> represents a syntactic token in a formula.  'PTG' is an acronym for 
             '<b>p</b>arse <b>t</b>hin<b>g</b>'.  Originally, the name referred to the single 
             byte identifier at the start of the token, but in POI, <tt>Ptg</tt> encapsulates
             the whole formula token (initial byte + value data).
             
             
             <tt>Ptg</tt>s are logically arranged in a tree representing the structure of the
             Parsed formula.  However, in BIFF files <tt>Ptg</tt>s are written/Read in 
             <em>Reverse-Polish Notation</em> order. The RPN ordering also simplifies formula
             evaluation logic, so POI mostly accesses <tt>Ptg</tt>s in the same way.
            
             @author  andy
             @author avik
             @author Jason Height (jheight at chariot dot net dot au)
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Ptg.ReadTokens(System.Int32,NPOI.Util.IO.LittleEndianInput)">
            Reads <tt>size</tt> bytes of the input stream, to Create an array of <tt>Ptg</tt>s.
            Extra data (beyond <tt>size</tt>) may be Read if and <tt>ArrayPtg</tt>s are present.
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Ptg.WriteBytes(System.Byte[],System.Int32)">
            Write this Ptg to a byte array
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Ptg.GetEncodedSizeWithoutArrayData(NPOI.HSSF.Record.Formula.Ptg[])">
            Used to calculate value that should be encoded at the start of the encoded Ptg token array;
            @return the size of the encoded Ptg tokens not including any trailing array data.
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Ptg.Copy">
            @return a distinct copy of this <tt>Ptg</tt> if the class is mutable, or the same instance
            if the class is immutable.
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Ptg.SerializePtgs(NPOI.HSSF.Record.Formula.Ptg[],System.Byte[],System.Int32)">
             Writes the ptgs to the data buffer, starting at the specified offset.  
            
             <br/>
             The 2 byte encode Length field is <b>not</b> written by this method.
             @return number of bytes written
        </member>
        <member name="P:NPOI.HSSF.Record.Formula.Ptg.Size">
            @return the encoded Length of this Ptg, including the initial Ptg type identifier byte. 
        </member>
        <member name="P:NPOI.HSSF.Record.Formula.Ptg.IsBaseToken">
            @return <c>false</c> if this token is classified as 'reference', 'value', or 'array'
        </member>
        <member name="P:NPOI.HSSF.Record.Formula.Ptg.RVAType">
            Debug / diagnostic method to get this token's 'operand class' type.
            @return 'R' for 'reference', 'V' for 'value', 'A' for 'array' and '.' for base tokens
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Ptg.Write(NPOI.Util.IO.LittleEndianOutput)">
            Write this Ptg to a byte array
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Ptg.ToFormulaString">
            return a string representation of this token alone
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Ptg.ToString">
            Overridden toString method to Ensure object hash is not printed.
             This helps Get rid of gratuitous diffs when comparing two dumps
             Subclasses may output more relevant information by overriding this method
            
        </member>
        <member name="P:NPOI.HSSF.Record.Formula.Ptg.PtgClass">
            @return the 'operand class' (REF/VALUE/ARRAY) for this Ptg
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.RangePtg">
            @author Daniel Noll (daniel at nuix dot com dot au)
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.RangePtg.ToFormulaString(System.String[])">
            implementation of method from OperationsPtg
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Ref2DPtgBase">
            @author Josh Micich
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Ref2DPtgBase.#ctor(System.String)">
            Takes in a String representation of a cell reference and fills out the
            numeric fields.
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Ref3DPtg">
            Title:        Reference 3D Ptg 
            Description:  Defined a cell in extern sheet. 
            REFERENCE:  
            @author Libin Roman (Vista Portal LDT. Developer)
            @author Jason Height (jheight at chariot dot net dot au)
            @version 1.0-pre
        </member>
        <member name="F:NPOI.HSSF.Record.Formula.Ref3DPtg.rowRelative">
            Field 2 
            - lower 8 bits is the zero based Unsigned byte column index 
            - bit 16 - IsRowRelative
            - bit 15 - IsColumnRelative 
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Ref3DPtg.#ctor">
            Creates new AreaPtg 
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Ref3DPtg.ToFormulaString(NPOI.SS.Formula.FormulaRenderingWorkbook)">
            @return text representation of this cell reference that can be used in text 
            formulas. The sheet name will Get properly delimited if required.
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.RefErrorPtg">
            RefError - handles deleted cell reference
            @author Jason Height (jheight at chariot dot net dot au)
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.RefNPtg">
            RefNPtg
            @author Jason Height (jheight at apache dot com)
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.RefNPtg.#ctor(NPOI.Util.IO.LittleEndianInput)">
            Creates new ValueReferencePtg 
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.RefPtg">
            ReferencePtg - handles references (such as A1, A2, IA4)
            @author  Andrew C. Oliver (acoliver@apache.org)
            @author Jason Height (jheight at chariot dot net dot au)
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.RefPtg.#ctor(System.String)">
            Takes in a String representation of a cell reference and Fills out the
            numeric fields.
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.RefPtgBase">
            ReferencePtgBase - handles references (such as A1, A2, IA4)
            @author  Andrew C. Oliver (acoliver@apache.org)
            @author Jason Height (jheight at chariot dot net dot au)
        </member>
        <member name="F:NPOI.HSSF.Record.Formula.RefPtgBase.field_1_row">
            The row index - zero based Unsigned 16 bit value 
        </member>
        <member name="F:NPOI.HSSF.Record.Formula.RefPtgBase.field_2_col">
            Field 2
            - lower 8 bits is the zero based Unsigned byte column index
            - bit 16 - IsRowRelative
            - bit 15 - IsColumnRelative
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.RefPtgBase.#ctor(System.String)">
            Takes in a String representation of a cell reference and Fills out the
            numeric fields.
        </member>
        <member name="P:NPOI.HSSF.Record.Formula.RefPtgBase.Row">
            Returns the row number as a short, which will be
             wrapped (negative) for values between 32769 and 65535
        </member>
        <member name="P:NPOI.HSSF.Record.Formula.RefPtgBase.RowAsInt">
            Returns the row number as an int, between 0 and 65535
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.ScalarConstantPtg">
            @author Josh Micich
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.SheetNameFormatter">
            Formats sheet names for use in formula expressions.
            
            @author Josh Micich
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.SheetNameFormatter.Format(System.String)">
            Used to format sheet names as they would appear in cell formula expressions.
            @return the sheet name UnChanged if there is no need for delimiting.  Otherwise the sheet
            name is enclosed in single quotes (').  Any single quotes which were already present in the 
            sheet name will be converted to double single quotes ('').  
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.SheetNameFormatter.AppendFormat(System.Text.StringBuilder,System.String)">
            Convenience method for when a StringBuilder is already available
            
            @param out - sheet name will be Appended here possibly with delimiting quotes 
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.SheetNameFormatter.IsSpecialChar(System.Char)">
            @return <c>true</c> if the presence of the specified Char in a sheet name would 
            require the sheet name to be delimited in formulas.  This includes every non-alphanumeric 
            Char besides Underscore '_'.
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.SheetNameFormatter.CellReferenceIsWithinRange(System.String,System.String)">
            Used to decide whether sheet names like 'AB123' need delimiting due to the fact that they 
            look like cell references.
            <p/>
            This code is currently being used for translating formulas represented with <code>Ptg</code>
            tokens into human readable text form.  In formula expressions, a sheet name always has a 
            trailing '!' so there is little chance for ambiguity.  It doesn't matter too much what this 
            method returns but it is worth noting the likely consumers of these formula text strings:
            <ol>
            <li>POI's own formula parser</li>
            <li>Visual reading by human</li>
            <li>VBA automation entry into Excel cell contents e.g.  ActiveCell.Formula = "=c64!A1"</li>
            <li>Manual entry into Excel cell contents</li>
            <li>Some third party formula parser</li>
            </ol>
            
            At the time of writing, POI's formula parser tolerates cell-like sheet names in formulas
            with or without delimiters.  The same goes for Excel(2007), both manual and automated entry.  
            <p/>
            For better or worse this implementation attempts to replicate Excel's formula renderer.
            Excel uses range checking on the apparent 'row' and 'column' components.  Note however that
            the maximum sheet size varies across versions.
            @see org.apache.poi.hssf.util.CellReference
        </member>
        <!-- Badly formed XML comment ignored for member "M:NPOI.HSSF.Record.Formula.SheetNameFormatter.NameLooksLikePlainCellReference(System.String)" -->
        <member name="T:NPOI.HSSF.Record.Formula.StringPtg">
            String Stores a String value in a formula value stored in the format
            &lt;Length 2 bytes&gt;char[]
            
            @author Werner Froidevaux
            @author Jason Height (jheight at chariot dot net dot au)
            @author Bernard Chesnoy
        </member>
        <member name="F:NPOI.HSSF.Record.Formula.StringPtg.FORMULA_DELIMITER">
            the Char (")used in formulas to delimit string literals 
        </member>
        <member name="F:NPOI.HSSF.Record.Formula.StringPtg.field_1_Length">
            NOTE: OO doc says 16bit Length, but BiffViewer says 8 Book says something
            totally different, so don't look there!
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.StringPtg.#ctor(NPOI.Util.IO.LittleEndianInput)">
            Create a StringPtg from a stream 
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.StringPtg.#ctor(System.String)">
            Create a StringPtg from a string representation of the number Number
            format Is not Checked, it Is expected to be Validated in the Parser that
            calls this method.
            
            @param value :
                       String representation of a floating point number
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.SubtractPtg">
            
             @author  andy
             @author Jason Height (jheight at chariot dot net dot au)
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.TblPtg">
             This ptg indicates a data table.
             It only occurs in a FORMULA record, never in an
              ARRAY or NAME record.  When ptgTbl occurs in a
              formula, it is the only token in the formula.
            
             This indicates that the cell containing the
              formula is an interior cell in a data table;
              the table description is found in a TABLE
              record. Rows and columns which contain input
              values to be substituted in the table do
              not contain ptgTbl.
             See page 811 of the june 08 binary docs.
        </member>
        <member name="F:NPOI.HSSF.Record.Formula.TblPtg.field_1_first_row">
            The row number of the upper left corner 
        </member>
        <member name="F:NPOI.HSSF.Record.Formula.TblPtg.field_2_first_col">
            The column number of the upper left corner 
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Udf.AggregatingUDFFinder">
             Collects Add-in libraries and VB macro functions toGether into one UDF Finder
            
             @author PUdalau
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Udf.AggregatingUDFFinder.FindFunction(System.String)">
             Returns executor by specified name. Returns <code>null</code> if
             function isn't Contained by any registered tool pack.
            
             @param name Name of function.
             @return Function executor. <code>null</code> if not found
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Udf.DefaultUDFFinder">
             Default UDF Finder - for Adding your own user defined functions.
            
             @author PUdalau
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.Udf.UDFFinder">
             Common interface for "Add-in" libraries and user defined function libraries.
            
             @author PUdalau
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.Udf.UDFFinder.FindFunction(System.String)">
             Returns executor by specified name. Returns <code>null</code> if the function name is unknown.
            
             @param name Name of function.
             @return Function executor.
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.UnaryMinusPtg">
            Unary Plus operator
            does not have any effect on the operand
            @author Avik Sengupta
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.UnaryMinusPtg.ToFormulaString(System.String[])">
            implementation of method from OperationsPtg
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.UnaryPlusPtg">
            Unary Plus operator
            does not have any effect on the operand
            @author Avik Sengupta
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.UnaryPlusPtg.ToFormulaString(System.String[])">
            implementation of method from OperationsPtg
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.UnionPtg">
            @author Glen Stampoultzis (glens at apache.org)
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.UnionPtg.ToFormulaString(System.String[])">
            implementation of method from OperationsPtg
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.UnknownPtg">
            
             @author  andy
             @author Jason Height (jheight at chariot dot net dot au)
        </member>
        <member name="M:NPOI.HSSF.Record.Formula.UnknownPtg.#ctor">
            Creates new UnknownPtg 
        </member>
        <member name="T:NPOI.HSSF.Record.Formula.ValueOperatorPtg">
            Common baseclass of all value operators.
            Subclasses include all Unary and binary operators except for the reference operators (IntersectionPtg, RangePtg, UnionPtg) 
            
            @author Josh Micich
        </member>
        <member name="P:NPOI.HSSF.Record.Formula.ValueOperatorPtg.IsBaseToken">
            All Operator <tt>Ptg</tt>s are base tokens (i.e. are not RVA classified)  
        </member>
        <member name="T:NPOI.HSSF.Record.InterfaceHdrRecord">
            Title: Interface Header Record
            Description: Defines the beginning of Interface records (MMS)
            REFERENCE:  PG 324 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)
            @author Andrew C. Oliver (acoliver at apache dot org)
            @version 2.0-pre
        </member>
        <member name="F:NPOI.HSSF.Record.InterfaceHdrRecord.CODEPAGE">
            suggested (and probably correct) default
        </member>
        <member name="M:NPOI.HSSF.Record.InterfaceHdrRecord.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            Constructs an Codepage record and Sets its fields appropriately.
            @param in the RecordInputstream to Read the record from
        </member>
        <member name="T:NPOI.HSSF.Record.Record">
            Title: Record
            Description: All HSSF Records inherit from this class.  It
                         populates the fields common to all records (id, size and data).
                         Subclasses should be sure to validate the id,
            Company:
            @author Andrew C. Oliver
            @author Marc Johnson (mjohnson at apache dot org)
            @author Jason Height (jheight at chariot dot net dot au)
            @version 2.0-pre
        </member>
        <member name="M:NPOI.HSSF.Record.Record.#ctor">
            instantiates a blank record strictly for ID matching
        </member>
        <member name="M:NPOI.HSSF.Record.Record.Serialize">
             called by the class that is responsible for writing this sucker.
             Subclasses should implement this so that their data is passed back in a
             byte array.
            
             @return byte array containing instance data
        </member>
        <member name="P:NPOI.HSSF.Record.Record.RecordSize">
            gives the current Serialized size of the record. Should include the sid and recLength (4 bytes).
        </member>
        <member name="P:NPOI.HSSF.Record.Record.Sid">
            return the non static version of the id for this record.
        </member>
        <member name="T:NPOI.HSSF.Record.RecordBase">
            Common base class of {@link Record} and {@link RecordAggregate}
            
            @author Josh Micich
        </member>
        <member name="M:NPOI.HSSF.Record.RecordBase.Serialize(System.Int32,System.Byte[])">
            called by the class that is responsible for writing this sucker.
            Subclasses should implement this so that their data is passed back in a
            byte array.
            
            @param offset to begin writing at
            @param data byte array containing instance data
            @return number of bytes written
        </member>
        <member name="P:NPOI.HSSF.Record.RecordBase.RecordSize">
            gives the current serialized size of the record. Should include the sid
            and reclength (4 bytes).
        </member>
        <member name="T:NPOI.HSSF.Record.RecordFormatException">
            <summary>
            Used by records to indicate invalid format/data.
            </summary>
        </member>
        <member name="T:NPOI.HSSF.Record.RecordInputStream">
             Title:  Record Input Stream
             Description:  Wraps a stream and provides helper methods for the construction of records.
            
             @author Jason Height (jheight @ apache dot org)
        </member>
        <member name="F:NPOI.HSSF.Record.RecordInputStream.MAX_RECORD_DATA_SIZE">
            Maximum size of a single record (minus the 4 byte header) without a continue
        </member>
        <member name="F:NPOI.HSSF.Record.RecordInputStream._bhi">
            Header {@link LittleEndianInput} facet of the wrapped {@link InputStream} 
        </member>
        <member name="F:NPOI.HSSF.Record.RecordInputStream._dataInput">
            Data {@link LittleEndianInput} facet of the wrapped {@link InputStream} 
        </member>
        <member name="F:NPOI.HSSF.Record.RecordInputStream.data">
            the record identifier of the BIFF record currently being read 
        </member>
        <member name="M:NPOI.HSSF.Record.RecordInputStream.Read">
            This method will Read a byte from the current record
        </member>
        <member name="M:NPOI.HSSF.Record.RecordInputStream.ReadNextSid">
            
            @return the sid of the next record or {@link #INVALID_SID_VALUE} if at end of stream
        </member>
        <member name="M:NPOI.HSSF.Record.RecordInputStream.NextRecord">
            Moves to the next record in the stream.
            
            <i>Note: The auto continue flag is Reset to true</i>
        </member>
        <member name="M:NPOI.HSSF.Record.RecordInputStream.ReadByte">
            Reads an 8 bit, signed value
        </member>
        <member name="M:NPOI.HSSF.Record.RecordInputStream.ReadShort">
            Reads a 16 bit, signed value
        </member>
        <member name="M:NPOI.HSSF.Record.RecordInputStream.ReadUByte">
            Reads an 8 bit, Unsigned value
        </member>
        <member name="M:NPOI.HSSF.Record.RecordInputStream.ReadUShort">
            Reads a 16 bit,un- signed value.
            @return
        </member>
        <member name="M:NPOI.HSSF.Record.RecordInputStream.ReadUnicodeLEString(System.Int32)">
             given a byte array of 16-bit Unicode Chars, compress to 8-bit and     
             return a string     
                
            { 0x16, 0x00 } -0x16     
                 
            @param Length the Length of the string
            @return                                     the Converted string
            @exception  ArgumentException        if len is too large (i.e.,
                 there is not enough data in string to Create a String of that     
                 Length)     
        </member>
        <member name="M:NPOI.HSSF.Record.RecordInputStream.ReadRemainder">
            Returns the remaining bytes for the current record.
            
            @return The remaining bytes of the current record.
        </member>
        <member name="M:NPOI.HSSF.Record.RecordInputStream.ReadAllContinuedRemainder">
            Reads all byte data for the current record, including any
             that overlaps into any following continue records.
            
             @deprecated Best to write a input stream that wraps this one where there Is
             special sub record that may overlap continue records.
        </member>
        <member name="P:NPOI.HSSF.Record.RecordInputStream.Remaining">
            The remaining number of bytes in the <i>current</i> record.
            
            @return The number of bytes remaining in the current record
        </member>
        <member name="P:NPOI.HSSF.Record.RecordInputStream.IsContinueNext">
            Returns true iif a Continue record is next in the excel stream _currentDataOffset
            
            @return True when a ContinueRecord is next.
        </member>
        <member name="T:NPOI.HSSF.Record.StandardRecord">
            Subclasses of this class (the majority of BIFF records) are non-continuable.  This allows for
            some simplification of serialization logic
            
            @author Josh Micich
        </member>
        <member name="M:NPOI.HSSF.Record.StandardRecord.Serialize(NPOI.Util.IO.LittleEndianOutput)">
            Write the data content of this BIFF record.  The 'ushort sid' and 'ushort size' header fields
            have already been written by the superclass.<br/>
            
            The subclass must write the exact number of bytes as reported by {@link Record#getDataSize()}
        </member>
        <member name="T:NPOI.HSSF.Record.UnicodeString">
            Title: Unicode String<p/>
            Description:  Unicode String - just standard fields that are in several records.
                          It is considered more desirable then repeating it in all of them.<p/>
            REFERENCE:  PG 264 Microsoft Excel 97 Developer's Kit (ISBN: 1-57231-498-2)<p/>
            @author  Andrew C. Oliver
            @author Marc Johnson (mjohnson at apache dot org)
            @author Glen Stampoultzis (glens at apache.org)
        </member>
        <member name="M:NPOI.HSSF.Record.UnicodeString.Equals(System.Object)">
             Our handling of equals is inconsistent with CompareTo.  The trouble is because we don't truely understand
             rich text fields yet it's difficult to make a sound comparison.
            
             @param o     The object to Compare.
             @return      true if the object is actually equal.
        </member>
        <member name="M:NPOI.HSSF.Record.UnicodeString.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            construct a unicode string record and fill its fields, ID is ignored
            @param in the RecordInPutstream to read the record from
        </member>
        <member name="P:NPOI.HSSF.Record.UnicodeString.CharCount">
             get the number of characters in the string,
              as an un-wrapped int
            
             @return number of characters
        </member>
        <member name="P:NPOI.HSSF.Record.UnicodeString.OptionFlags">
             get the option flags which among other things return if this is a 16-bit or
             8 bit string
            
             @return optionflags bitmask
            
        </member>
        <member name="P:NPOI.HSSF.Record.UnicodeString.String">
            @return the actual string this Contains as a java String object
        </member>
        <member name="M:NPOI.HSSF.Record.UnicodeString.AddFormatRun(NPOI.HSSF.Record.FormatRun)">
            Adds a font run to the formatted string.
            
              If a font run exists at the current charcter location, then it is
              Replaced with the font run to be Added.
        </member>
        <member name="M:NPOI.HSSF.Record.UnicodeString.SwapFontUse(System.Int16,System.Int16)">
            Swaps all use in the string of one font index
             for use of a different font index.
            Normally only called when fonts have been
             Removed / re-ordered
        </member>
        <member name="M:NPOI.HSSF.Record.UnicodeString.ToString">
            unlike the real records we return the same as "GetString()" rather than debug info
            @see #GetDebugInfo()
            @return String value of the record
        </member>
        <member name="M:NPOI.HSSF.Record.UnicodeString.GetDebugInfo">
             return a character representation of the fields of this record
            
            
             @return String of output for biffviewer etc.
            
        </member>
        <member name="T:NPOI.HSSF.UserModel.Contrib.HSSFCellUtil">
            <summary>
            Various utility functions that make working with a cells and rows easier.  The various
            methods that deal with style's allow you to Create your HSSFCellStyles as you need them.
            When you apply a style change to a cell, the code will attempt to see if a style already
            exists that meets your needs.  If not, then it will Create a new style.  This is to prevent
            creating too many styles.  there is an upper limit in Excel on the number of styles that
            can be supported.
            @author     Eric Pugh epugh@upstate.com
            </summary>
        </member>
        <member name="M:NPOI.HSSF.UserModel.Contrib.HSSFCellUtil.GetRow(System.Int32,NPOI.HSSF.UserModel.HSSFSheet)">
            <summary>
            Get a row from the spreadsheet, and Create it if it doesn't exist.
            </summary>
            <param name="rowCounter">The 0 based row number</param>
            <param name="sheet">The sheet that the row is part of.</param>
            <returns>The row indicated by the rowCounter</returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.Contrib.HSSFCellUtil.GetCell(NPOI.SS.UserModel.Row,System.Int32)">
            <summary>
            Get a specific cell from a row. If the cell doesn't exist,
            </summary>
            <param name="row">The row that the cell is part of</param>
            <param name="column">The column index that the cell is in.</param>
            <returns>The cell indicated by the column.</returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.Contrib.HSSFCellUtil.CreateCell(NPOI.SS.UserModel.Row,System.Int32,System.String,NPOI.HSSF.UserModel.HSSFCellStyle)">
            <summary>
            Creates a cell, gives it a value, and applies a style if provided
            </summary>
            <param name="row">the row to Create the cell in</param>
            <param name="column">the column index to Create the cell in</param>
            <param name="value">The value of the cell</param>
            <param name="style">If the style is not null, then Set</param>
            <returns>A new HSSFCell</returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.Contrib.HSSFCellUtil.CreateCell(NPOI.SS.UserModel.Row,System.Int32,System.String)">
            <summary>
            Create a cell, and give it a value.
            </summary>
            <param name="row">the row to Create the cell in</param>
            <param name="column">the column index to Create the cell in</param>
            <param name="value">The value of the cell</param>
            <returns>A new HSSFCell.</returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.Contrib.HSSFCellUtil.SetAlignment(NPOI.SS.UserModel.Cell,NPOI.HSSF.UserModel.HSSFWorkbook,System.Int16)">
            <summary>
            Take a cell, and align it.
            </summary>
            <param name="cell">the cell to Set the alignment for</param>
            <param name="workbook">The workbook that is being worked with.</param>
            <param name="align">the column alignment to use.</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.Contrib.HSSFCellUtil.SetFont(NPOI.SS.UserModel.Cell,NPOI.HSSF.UserModel.HSSFWorkbook,NPOI.HSSF.UserModel.HSSFFont)">
            <summary>
            Take a cell, and apply a font to it
            </summary>
            <param name="cell">the cell to Set the alignment for</param>
            <param name="workbook">The workbook that is being worked with.</param>
            <param name="font">The HSSFFont that you want to Set...</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.Contrib.HSSFCellUtil.SetCellStyleProperty(NPOI.SS.UserModel.Cell,NPOI.HSSF.UserModel.HSSFWorkbook,System.String,System.Object)">
              This method attempt to find an already existing HSSFCellStyle that matches
              what you want the style to be. If it does not find the style, then it
              Creates a new one. If it does Create a new one, then it applies the
              propertyName and propertyValue to the style. This is necessary because
              Excel has an upper limit on the number of Styles that it supports.
            
            @param  workbook               The workbook that is being worked with.
            @param  propertyName           The name of the property that is to be
                  changed.
            @param  propertyValue          The value of the property that is to be
                  changed.
            @param  cell                   The cell that needs it's style changes
            @exception  NestableException  Thrown if an error happens.
        </member>
        <member name="M:NPOI.HSSF.UserModel.Contrib.HSSFCellUtil.GetFormatProperties(NPOI.SS.UserModel.CellStyle)">
            <summary>
            Returns a map containing the format properties of the given cell style.
            </summary>
            <param name="style">cell style</param>
            <returns>map of format properties (String -&gt; Object)</returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.Contrib.HSSFCellUtil.SetFormatProperties(NPOI.SS.UserModel.CellStyle,NPOI.HSSF.UserModel.HSSFWorkbook,System.Collections.Hashtable)">
            <summary>
            Sets the format properties of the given style based on the given map.
            </summary>
            <param name="style">The cell style</param>
            <param name="workbook">The parent workbook.</param>
            <param name="properties">The map of format properties (String -&gt; Object).</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.Contrib.HSSFCellUtil.GetShort(System.Collections.Hashtable,System.String)">
            <summary>
            Utility method that returns the named short value form the given map.
            Returns zero if the property does not exist, or is not a {@link Short}.
            </summary>
            <param name="properties">The map of named properties (String -&gt; Object)</param>
            <param name="name">The property name.</param>
            <returns>property value, or zero</returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.Contrib.HSSFCellUtil.GetBoolean(System.Collections.Hashtable,System.String)">
            <summary>
            Utility method that returns the named boolean value form the given map.
            Returns false if the property does not exist, or is not a {@link Boolean}.
            </summary>
            <param name="properties">map of properties (String -&gt; Object)</param>
            <param name="name">The property name.</param>
            <returns>property value, or false</returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.Contrib.HSSFCellUtil.PutShort(System.Collections.Hashtable,System.String,System.Int16)">
            <summary>
            Utility method that Puts the named short value to the given map.
            </summary>
            <param name="properties">The map of properties (String -&gt; Object).</param>
            <param name="name">The property name.</param>
            <param name="value">The property value.</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.Contrib.HSSFCellUtil.PutBoolean(System.Collections.Hashtable,System.String,System.Boolean)">
            <summary>
            Utility method that Puts the named boolean value to the given map.
            </summary>
            <param name="properties">map of properties (String -&gt; Object)</param>
            <param name="name">property name</param>
            <param name="value">property value</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.Contrib.HSSFCellUtil.TranslateUnicodeValues(NPOI.SS.UserModel.Cell)">
            <summary>
            Looks for text in the cell that should be unicode, like alpha; and provides the
            unicode version of it.
            </summary>
            <param name="cell">The cell to check for unicode values</param>
            <returns>transalted to unicode</returns>
        </member>
        <member name="T:NPOI.HSSF.UserModel.Contrib.HSSFRegionUtil">
            <summary>
            Various utility functions that make working with a region of cells easier.
            @author Eric Pugh epugh@upstate.com
            </summary>
        </member>
        <member name="T:NPOI.HSSF.UserModel.Contrib.HSSFRegionUtil.CellPropertySetter">
            <summary>
            For setting the same property on many cells to the same value
            </summary>
        </member>
        <member name="M:NPOI.HSSF.UserModel.Contrib.HSSFRegionUtil.SetBorderLeft(NPOI.SS.UserModel.CellBorderType,NPOI.SS.Util.CellRangeAddress,NPOI.HSSF.UserModel.HSSFSheet,NPOI.HSSF.UserModel.HSSFWorkbook)">
            <summary>
            Sets the left border for a region of cells by manipulating the cell style
            of the individual cells on the left
            </summary>
            <param name="border">The new border</param>
            <param name="region">The region that should have the border</param>
            <param name="sheet">The sheet that the region is on.</param>
            <param name="workbook">The workbook that the region is on.</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.Contrib.HSSFRegionUtil.SetLeftBorderColor(System.Int32,NPOI.SS.Util.CellRangeAddress,NPOI.HSSF.UserModel.HSSFSheet,NPOI.HSSF.UserModel.HSSFWorkbook)">
            <summary>
            Sets the leftBorderColor attribute of the HSSFRegionUtil object
            </summary>
            <param name="color">The color of the border</param>
            <param name="region">The region that should have the border</param>
            <param name="sheet">The sheet that the region is on.</param>
            <param name="workbook">The workbook that the region is on.</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.Contrib.HSSFRegionUtil.SetBorderRight(NPOI.SS.UserModel.CellBorderType,NPOI.SS.Util.CellRangeAddress,NPOI.HSSF.UserModel.HSSFSheet,NPOI.HSSF.UserModel.HSSFWorkbook)">
            <summary>
            Sets the borderRight attribute of the HSSFRegionUtil object
            </summary>
            <param name="border">The new border</param>
            <param name="region">The region that should have the border</param>
            <param name="sheet">The sheet that the region is on.</param>
            <param name="workbook">The workbook that the region is on.</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.Contrib.HSSFRegionUtil.SetRightBorderColor(System.Int32,NPOI.SS.Util.CellRangeAddress,NPOI.HSSF.UserModel.HSSFSheet,NPOI.HSSF.UserModel.HSSFWorkbook)">
            <summary>
            Sets the rightBorderColor attribute of the HSSFRegionUtil object
            </summary>
            <param name="color">The color of the border</param>
            <param name="region">The region that should have the border</param>
            <param name="sheet">The workbook that the region is on.</param>
            <param name="workbook">The sheet that the region is on.</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.Contrib.HSSFRegionUtil.SetBorderBottom(NPOI.SS.UserModel.CellBorderType,NPOI.SS.Util.CellRangeAddress,NPOI.HSSF.UserModel.HSSFSheet,NPOI.HSSF.UserModel.HSSFWorkbook)">
            <summary>
            Sets the borderBottom attribute of the HSSFRegionUtil object
            </summary>
            <param name="border">The new border</param>
            <param name="region">The region that should have the border</param>
            <param name="sheet">The sheet that the region is on.</param>
            <param name="workbook">The workbook that the region is on.</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.Contrib.HSSFRegionUtil.SetBottomBorderColor(System.Int32,NPOI.SS.Util.CellRangeAddress,NPOI.HSSF.UserModel.HSSFSheet,NPOI.HSSF.UserModel.HSSFWorkbook)">
            <summary>
            Sets the bottomBorderColor attribute of the HSSFRegionUtil object
            </summary>
            <param name="color">The color of the border</param>
            <param name="region">The region that should have the border</param>
            <param name="sheet">The sheet that the region is on.</param>
            <param name="workbook">The workbook that the region is on.</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.Contrib.HSSFRegionUtil.SetBorderTop(NPOI.SS.UserModel.CellBorderType,NPOI.SS.Util.CellRangeAddress,NPOI.HSSF.UserModel.HSSFSheet,NPOI.HSSF.UserModel.HSSFWorkbook)">
            <summary>
            Sets the borderBottom attribute of the HSSFRegionUtil object
            </summary>
            <param name="border">The new border</param>
            <param name="region">The region that should have the border</param>
            <param name="sheet">The sheet that the region is on.</param>
            <param name="workbook">The workbook that the region is on.</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.Contrib.HSSFRegionUtil.SetTopBorderColor(System.Int32,NPOI.SS.Util.CellRangeAddress,NPOI.HSSF.UserModel.HSSFSheet,NPOI.HSSF.UserModel.HSSFWorkbook)">
            <summary>
            Sets the topBorderColor attribute of the HSSFRegionUtil object
            </summary>
            <param name="color">The color of the border</param>
            <param name="region">The region that should have the border</param>
            <param name="sheet">The sheet that the region is on.</param>
            <param name="workbook">The workbook that the region is on.</param>
        </member>
        <member name="T:NPOI.HSSF.UserModel.DVConstraint">
            
            @author Josh Micich
        </member>
        <member name="T:NPOI.HSSF.UserModel.DVConstraint.ValidationType">
            ValidationType enum
        </member>
        <member name="F:NPOI.HSSF.UserModel.DVConstraint.ValidationType.ANY">
            'Any value' type - value not restricted 
        </member>
        <member name="F:NPOI.HSSF.UserModel.DVConstraint.ValidationType.INTEGER">
            Integer ('Whole number') type 
        </member>
        <member name="F:NPOI.HSSF.UserModel.DVConstraint.ValidationType.DECIMAL">
            Decimal type 
        </member>
        <member name="F:NPOI.HSSF.UserModel.DVConstraint.ValidationType.LIST">
            List type ( combo box type ) 
        </member>
        <member name="F:NPOI.HSSF.UserModel.DVConstraint.ValidationType.DATE">
            Date type 
        </member>
        <member name="F:NPOI.HSSF.UserModel.DVConstraint.ValidationType.TIME">
            Time type 
        </member>
        <member name="F:NPOI.HSSF.UserModel.DVConstraint.ValidationType.TEXT_LENGTH">
            String length type 
        </member>
        <member name="F:NPOI.HSSF.UserModel.DVConstraint.ValidationType.FORMULA">
            Formula ( 'Custom' ) type 
        </member>
        <member name="T:NPOI.HSSF.UserModel.DVConstraint.OperatorType">
            Condition operator enum
        </member>
        <member name="F:NPOI.HSSF.UserModel.DVConstraint.OperatorType.IGNORED">
            default value to supply when the operator type is not used 
        </member>
        <member name="M:NPOI.HSSF.UserModel.DVConstraint.#ctor(System.String,System.String[])">
            Creates a list constraint
        </member>
        <member name="M:NPOI.HSSF.UserModel.DVConstraint.CreateNumericConstraint(System.Int32,System.Int32,System.String,System.String)">
            Creates a number based data validation constraint. The text values entered for expr1 and expr2
            can be either standard Excel formulas or formatted number values. If the expression starts 
            with '=' it is parsed as a formula, otherwise it is parsed as a formatted number. 
            
            @param validationType one of {@link ValidationType#ANY}, {@link ValidationType#DECIMAL},
            {@link ValidationType#INTEGER}, {@link ValidationType#TEXT_LENGTH}
            @param comparisonOperator any constant from {@link OperatorType} enum
            @param expr1 date formula (when first char is '=') or formatted number value
            @param expr2 date formula (when first char is '=') or formatted number value
        </member>
        <member name="M:NPOI.HSSF.UserModel.DVConstraint.CreateTimeConstraint(System.Int32,System.String,System.String)">
            Creates a time based data validation constraint. The text values entered for expr1 and expr2
            can be either standard Excel formulas or formatted time values. If the expression starts 
            with '=' it is parsed as a formula, otherwise it is parsed as a formatted time.  To parse 
            formatted times, two formats are supported:  "HH:MM" or "HH:MM:SS".  This is contrary to 
            Excel which uses the default time format from the OS.
            
            @param comparisonOperator constant from {@link OperatorType} enum
            @param expr1 date formula (when first char is '=') or formatted time value
            @param expr2 date formula (when first char is '=') or formatted time value
        </member>
        <member name="M:NPOI.HSSF.UserModel.DVConstraint.CreateDateConstraint(System.Int32,System.String,System.String,System.String)">
            Creates a date based data validation constraint. The text values entered for expr1 and expr2
            can be either standard Excel formulas or formatted date values. If the expression starts 
            with '=' it is parsed as a formula, otherwise it is parsed as a formatted date (Excel uses 
            the same convention).  To parse formatted dates, a date format needs to be specified.  This
            is contrary to Excel which uses the default short date format from the OS.
            
            @param comparisonOperator constant from {@link OperatorType} enum
            @param expr1 date formula (when first char is '=') or formatted date value
            @param expr2 date formula (when first char is '=') or formatted date value
            @param dateFormat ignored if both expr1 and expr2 are formulas.  Default value is "YYYY/MM/DD"
            otherwise any other valid argument for <tt>SimpleDateFormat</tt> can be used
            @see <a href='http://java.sun.com/j2se/1.5.0/docs/api/java/text/DateFormat.html'>SimpleDateFormat</a>
        </member>
        <member name="M:NPOI.HSSF.UserModel.DVConstraint.getFormulaFromTextExpression(System.String)">
            Distinguishes formula expressions from simple value expressions.  This logic is only 
            required by a few factory methods in this class that Create data validation constraints
            from more or less the same parameters that would have been entered in the Excel UI.  The
            data validation dialog box uses the convention that formulas begin with '='.  Other methods
            in this class follow the POI convention (formulas and values are distinct), so the '=' 
            convention is not used there.
             
            @param textExpr a formula or value expression
            @return all text after '=' if textExpr begins with '='. Otherwise <c>null</c> if textExpr does not begin with '='
        </member>
        <member name="M:NPOI.HSSF.UserModel.DVConstraint.ConvertNumber(System.String)">
            @return <c>null</c> if numberStr is <c>null</c>
        </member>
        <member name="M:NPOI.HSSF.UserModel.DVConstraint.ConvertTime(System.String)">
            @return <c>null</c> if timeStr is <c>null</c>
        </member>
        <member name="M:NPOI.HSSF.UserModel.DVConstraint.ConvertDate(System.String,System.String)">
            @param dateFormat pass <c>null</c> for default YYYYMMDD
            @return <c>null</c> if timeStr is <c>null</c>
        </member>
        <member name="M:NPOI.HSSF.UserModel.DVConstraint.CreateFormulas(NPOI.HSSF.UserModel.HSSFWorkbook)">
            @return both parsed formulas (for expression 1 and 2). 
        </member>
        <member name="M:NPOI.HSSF.UserModel.DVConstraint.ConvertDoubleFormula(System.String,System.Double,NPOI.HSSF.UserModel.HSSFWorkbook)">
            @return The parsed token array representing the formula or value specified. 
            Empty array if both formula and value are <c>null</c>
        </member>
        <member name="M:NPOI.HSSF.UserModel.DVConstraint.GetValidationType">
            @return data validation type of this constraint
            @see ValidationType
        </member>
        <member name="P:NPOI.HSSF.UserModel.DVConstraint.IsListValidationType">
            Convenience method
            @return <c>true</c> if this constraint is a 'list' validation
        </member>
        <member name="P:NPOI.HSSF.UserModel.DVConstraint.IsExplicitList">
            Convenience method
            @return <c>true</c> if this constraint is a 'list' validation with explicit values
        </member>
        <member name="P:NPOI.HSSF.UserModel.DVConstraint.Operator">
            @return the operator used for this constraint
            @see OperatorType
        </member>
        <member name="P:NPOI.HSSF.UserModel.DVConstraint.Formula1">
            @return the formula for expression 1. May be <c>null</c>
        </member>
        <member name="P:NPOI.HSSF.UserModel.DVConstraint.Formula2">
            @return the formula for expression 2. May be <c>null</c>
        </member>
        <member name="P:NPOI.HSSF.UserModel.DVConstraint.Value1">
            @return the numeric value for expression 1. May be <c>null</c>
        </member>
        <member name="P:NPOI.HSSF.UserModel.DVConstraint.Value2">
            @return the numeric value for expression 2. May be <c>null</c>
        </member>
        <member name="T:NPOI.HSSF.UserModel.EscherGraphics">
             Translates Graphics calls into escher calls.  The translation Is lossy so
             many features are not supported and some just aren't implemented yet.  If
             in doubt test the specific calls you wish to make. Graphics calls are
             always performed into an EscherGroup so one will need to be Created.
             
             <b>Important:</b>
             <blockquote>
             One important concept worth considering Is that of font size.  One of the
             difficulties in Converting Graphics calls into escher Drawing calls Is that
             Excel does not have the concept of absolute pixel positions.  It measures
             it's cell widths in 'Chars' and the cell heights in points.
             Unfortunately it's not defined exactly what a type of Char it's
             measuring.  Presumably this Is due to the fact that the Excel will be
             using different fonts on different platforms or even within the same
             platform.
             
             Because of this constraint we've had to calculate the
             verticalPointsPerPixel.  This the amount the font should be scaled by when
             you Issue commands such as DrawString().  A good way to calculate this
             Is to use the follow formula:
             
             <pre>
                  multipler = GroupHeightInPoints / heightOfGroup
             </pre>
             
             The height of the Group Is calculated fairly simply by calculating the
             difference between the y coordinates of the bounding box of the shape.  The
             height of the Group can be calculated by using a convenience called
             <c>HSSFClientAnchor.GetAnchorHeightInPoints()</c>.
             </blockquote>
            
             @author Glen Stampoultzis (glens at apache.org)
        </member>
        <member name="M:NPOI.HSSF.UserModel.EscherGraphics.#ctor(NPOI.HSSF.UserModel.HSSFShapeGroup,NPOI.HSSF.UserModel.HSSFWorkbook,System.Drawing.Color,System.Single)">
             Construct an escher graphics object.
            
             @param escherGroup           The escher Group to Write the graphics calls into.
             @param workbook              The workbook we are using.
             @param forecolor             The foreground color to use as default.
             @param verticalPointsPerPixel    The font multiplier.  (See class description for information on how this works.).
        </member>
        <member name="M:NPOI.HSSF.UserModel.EscherGraphics.#ctor(NPOI.HSSF.UserModel.HSSFShapeGroup,NPOI.HSSF.UserModel.HSSFWorkbook,System.Drawing.Color,System.Drawing.Font,System.Single)">
             Constructs an escher graphics object.
            
             @param escherGroup           The escher Group to Write the graphics calls into.
             @param workbook              The workbook we are using.
             @param foreground            The foreground color to use as default.
             @param verticalPointsPerPixel    The font multiplier.  (See class description for information on how this works.).
             @param font                  The font to use.
        </member>
        <!-- Badly formed XML comment ignored for member "M:NPOI.HSSF.UserModel.EscherGraphics.FillPolygon(System.Int32[],System.Int32[],System.Int32)" -->
        <member name="T:NPOI.HSSF.UserModel.EvaluationCycleDetector">
            Instances of this class keep track of multiple dependent cell evaluations due
            to recursive calls to <tt>HSSFFormulaEvaluator.internalEvaluate()</tt>.
            The main purpose of this class Is to detect an attempt to evaluate a cell
            that Is alReady being evaluated. In other words, it detects circular
            references in spReadsheet formulas.
            
            @author Josh Micich
        </member>
        <member name="T:NPOI.HSSF.UserModel.EvaluationCycleDetector.CellEvaluationFrame">
            Stores the parameters that identify the evaluation of one cell.<br/>
        </member>
        <member name="M:NPOI.HSSF.UserModel.EvaluationCycleDetector.CellEvaluationFrame.FormatAsString">
            @return human Readable string for debug purposes
        </member>
        <!-- Badly formed XML comment ignored for member "M:NPOI.HSSF.UserModel.EvaluationCycleDetector.StartEvaluate(NPOI.HSSF.UserModel.HSSFWorkbook,NPOI.HSSF.UserModel.HSSFSheet,System.Int32,System.Int32)" -->
        <member name="M:NPOI.HSSF.UserModel.EvaluationCycleDetector.EndEvaluate(NPOI.HSSF.UserModel.HSSFWorkbook,NPOI.HSSF.UserModel.HSSFSheet,System.Int32,System.Int32)">
            Notifies this evaluation tracker that the evaluation of the specified
            cell Is complete. <p/>
            
            Every successful call to <tt>startEvaluate</tt> must be followed by a
            call to <tt>endEvaluate</tt> (recommended in a finally block) to enable
            proper tracking of which cells are being evaluated at any point in time.<p/>
            
            Assuming a well behaved client, parameters to this method would not be
            required. However, they have been included to assert correct behaviour,
            and form more meaningful error messages.
        </member>
        <member name="T:NPOI.HSSF.UserModel.EvaluationCycleDetectorManager">
            This class makes an <tt>EvaluationCycleDetector</tt> instance available to
            each thRead via a <tt>ThReadLocal</tt> in order to avoid Adding a parameter
            to a few protected methods within <tt>HSSFFormulaEvaluator</tt>.
            
            @author Josh Micich
        </member>
        <member name="M:NPOI.HSSF.UserModel.EvaluationCycleDetectorManager.GetTracker">
            @return
        </member>
        <member name="T:NPOI.HSSF.UserModel.FontDetails">
            <summary>
            Stores width and height details about a font.
            @author Glen Stampoultzis (glens at apache.org)
            </summary>
        </member>
        <member name="M:NPOI.HSSF.UserModel.FontDetails.#ctor(System.String,System.Int32)">
            <summary>
            Construct the font details with the given name and height.
            </summary>
            <param name="fontName">The font name.</param>
            <param name="height">The height of the font.</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.FontDetails.GetFontName">
            <summary>
            Gets the name of the font.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.FontDetails.GetHeight">
            <summary>
            Gets the height.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.FontDetails.AddChar(System.Char,System.Int32)">
            <summary>
            Adds the char.
            </summary>
            <param name="c">The c.</param>
            <param name="width">The width.</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.FontDetails.GetCharWidth(System.Char)">
            <summary>
            Retrieves the width of the specified Char.  If the metrics for
            a particular Char are not available it defaults to returning the
            width for the 'W' Char.
            </summary>
            <param name="c">The character.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.FontDetails.AddChars(System.Char[],System.Int32[])">
            <summary>
            Adds the chars.
            </summary>
            <param name="Chars">The chars.</param>
            <param name="widths">The widths.</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.FontDetails.BuildFontHeightProperty(System.String)">
            <summary>
            Builds the font height property.
            </summary>
            <param name="fontName">Name of the font.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.FontDetails.BuildFontWidthsProperty(System.String)">
            <summary>
            Builds the font widths property.
            </summary>
            <param name="fontName">Name of the font.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.FontDetails.BuildFontCharsProperty(System.String)">
            <summary>
            Builds the font chars property.
            </summary>
            <param name="fontName">Name of the font.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.FontDetails.Create(System.String,NPOI.Util.Collections.Properties)">
            <summary>
            Create an instance of 
            <c>FontDetails</c>
             by loading them from the
            provided property object.
            </summary>
            <param name="fontName">the font name.</param>
            <param name="fontMetricsProps">the property object holding the details of this
            particular font.</param>
            <returns>a new FontDetails instance.</returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.FontDetails.GetStringWidth(System.String)">
            <summary>
            Gets the width of all Chars in a string.
            </summary>
            <param name="str">The string to measure.</param>
            <returns>The width of the string for a 10 point font.</returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.FontDetails.Split(System.String,System.String,System.Int32)">
            <summary>
            Split the given string into an array of strings using the given
            delimiter.
            </summary>
            <param name="text">The text.</param>
            <param name="separator">The separator.</param>
            <param name="max">The max.</param>
            <returns></returns>
        </member>
        <member name="T:NPOI.HSSF.UserModel.HeaderFooter">
            <summary>
            Common class for HSSFHeader and HSSFFooter
            </summary>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HeaderFooter.Left">
            <summary>
            Get the left side of the header or footer.
            </summary>
            <value>The string representing the left side.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HeaderFooter.Center">
            <summary>
            Get the center of the header or footer.
            </summary>
            <value>The string representing the center.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HeaderFooter.Right">
            <summary>
            Get the right side of the header or footer.
            </summary>
            <value>The string representing the right side..</value>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HeaderFooter.FontSize(System.Int16)">
            <summary>
            Returns the string that represents the change in font size.
            </summary>
            <param name="size">the new font size.</param>
            <returns>The special string to represent a new font size</returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HeaderFooter.Font(System.String,System.String)">
            <summary>
            Returns the string that represents the change in font.
            </summary>
            <param name="font">the new font.</param>
            <param name="style">the fonts style, one of regular, italic, bold, italic bold or bold italic.</param>
            <returns>The special string to represent a new font size</returns>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HeaderFooter.Page">
            <summary>
            Returns the string representing the current page number
            </summary>
            <value>The special string for page number.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HeaderFooter.NumPages">
            <summary>
            Returns the string representing the number of pages.
            </summary>
            <value>The special string for the number of pages.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HeaderFooter.Date">
            <summary>
            Returns the string representing the current date
            </summary>
            <value>The special string for the date</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HeaderFooter.Time">
            <summary>
            Gets the time.
            </summary>
            <value>The time.</value>
            Returns the string representing the current time
            @return The special string for the time
        </member>
        <member name="P:NPOI.HSSF.UserModel.HeaderFooter.File">
            <summary>
            Returns the string representing the current file name
            </summary>
            <value>The special string for the file name.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HeaderFooter.Tab">
            <summary>
            Returns the string representing the current tab (sheet) name
            </summary>
            <value>The special string for tab name.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HeaderFooter.StartBold">
            <summary>
            Returns the string representing the start bold
            </summary>
            <returns>The special string for start bold</returns>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HeaderFooter.EndBold">
            <summary>
            Returns the string representing the end bold
            </summary>
            <value>The special string for end bold.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HeaderFooter.StartUnderline">
            <summary>
            Returns the string representing the start underline
            </summary>
            <value>The special string for start underline.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HeaderFooter.EndUnderline">
            <summary>
            Returns the string representing the end underline
            </summary>
            <value>The special string for end underline.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HeaderFooter.StartDoubleUnderline">
            <summary>
            Returns the string representing the start double underline
            </summary>
            <value>The special string for start double underline.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HeaderFooter.EndDoubleUnderline">
            <summary>
            Returns the string representing the end double underline
            </summary>
            <value>The special string for end double underline.</value>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HeaderFooter.StripFields(System.String)">
            <summary>
            Removes any fields (eg macros, page markers etc)
            from the string.
            Normally used to make some text suitable for showing
            to humans, and the resultant text should not normally
            be saved back into the document!
            </summary>
            <param name="text">The text.</param>
            <returns></returns>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HeaderFooter.AreFieldsStripped">
            <summary>
            Are fields currently being Stripped from
            the text that this {@link HeaderStories} returns?
            Default is false, but can be changed
            </summary>
            <value><c>true</c> if [are fields stripped]; otherwise, <c>false</c>.</value>
        </member>
        <member name="T:NPOI.HSSF.UserModel.HeaderFooter.Field">
            <summary>
            Represents a special field in a header or footer,
            eg the page number
            </summary>
        </member>
        <member name="F:NPOI.HSSF.UserModel.HeaderFooter.Field.sequence">
            The character sequence that marks this field 
        </member>
        <member name="T:NPOI.HSSF.UserModel.HeaderFooter.PairField">
            <summary>
            A special field that normally comes in a pair, eg
            turn on underline / turn off underline
            </summary>
        </member>
        <member name="T:NPOI.HSSF.UserModel.HSSFAnchor">
            <summary>
            An anchor Is what specifics the position of a shape within a client object
            or within another containing shape.
            @author Glen Stampoultzis (glens at apache.org)
            </summary>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFAnchor.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HSSF.UserModel.HSSFAnchor"/> class.
            </summary>
            <param name="dx1">The DX1.</param>
            <param name="dy1">The dy1.</param>
            <param name="dx2">The DX2.</param>
            <param name="dy2">The dy2.</param>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFAnchor.Dx1">
            <summary>
            Gets or sets the DX1.
            </summary>
            <value>The DX1.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFAnchor.Dy1">
            <summary>
            Gets or sets the dy1.
            </summary>
            <value>The dy1.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFAnchor.Dy2">
            <summary>
            Gets or sets the dy2.
            </summary>
            <value>The dy2.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFAnchor.Dx2">
            <summary>
            Gets or sets the DX2.
            </summary>
            <value>The DX2.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFAnchor.IsHorizontallyFlipped">
            <summary>
            Gets a value indicating whether this instance is horizontally flipped.
            </summary>
            <value>
            	<c>true</c> if this instance is horizontally flipped; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFAnchor.IsVerticallyFlipped">
            <summary>
            Gets a value indicating whether this instance is vertically flipped.
            </summary>
            <value>
            	<c>true</c> if this instance is vertically flipped; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="T:NPOI.HSSF.UserModel.HSSFBorderFormatting">
             High level representation for Border Formatting component
             of Conditional Formatting Settings
             
             @author Dmitriy Kumshayev
            
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFBorderFormatting.BORDER_NONE">
            No border 
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFBorderFormatting.BORDER_THIN">
            Thin border 
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFBorderFormatting.BORDER_MEDIUM">
            Medium border 
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFBorderFormatting.BORDER_DASHED">
            dash border 
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFBorderFormatting.BORDER_HAIR">
            dot border 
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFBorderFormatting.BORDER_THICK">
            Thick border 
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFBorderFormatting.BORDER_DOUBLE">
            double-line border 
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFBorderFormatting.BORDER_DOTTED">
            hair-line border 
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFBorderFormatting.BORDER_MEDIUM_DASHED">
            Medium dashed border 
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFBorderFormatting.BORDER_DASH_DOT">
            dash-dot border 
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFBorderFormatting.BORDER_MEDIUM_DASH_DOT">
            medium dash-dot border 
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFBorderFormatting.BORDER_DASH_DOT_DOT">
            dash-dot-dot border 
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFBorderFormatting.BORDER_MEDIUM_DASH_DOT_DOT">
            medium dash-dot-dot border 
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFBorderFormatting.BORDER_SLANTED_DASH_DOT">
            slanted dash-dot border 
        </member>
        <member name="T:NPOI.HSSF.UserModel.HSSFCell">
            <summary>
            High level representation of a cell in a row of a spReadsheet.
            Cells can be numeric, formula-based or string-based (text).  The cell type
            specifies this.  String cells cannot conatin numbers and numeric cells cannot
            contain strings (at least according to our model).  Client apps should do the
            conversions themselves.  Formula cells have the formula string, as well as
            the formula result, which can be numeric or string.
            Cells should have their number (0 based) before being Added to a row.  Only
            cells that have values should be Added.
            </summary>
            <remarks>
            @author  Andrew C. Oliver (acoliver at apache dot org)
            @author  Dan Sherman (dsherman at Isisph.com)
            @author  Brian Sanders (kestrel at burdell dot org) Active Cell support
            @author  Yegor Kozlov cell comments support
            </remarks>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFCell.#ctor(NPOI.HSSF.UserModel.HSSFWorkbook,NPOI.HSSF.UserModel.HSSFSheet,System.Int32,System.Int16)">
            <summary>
            Creates new Cell - Should only be called by HSSFRow.  This Creates a cell
            from scratch.
            When the cell is initially Created it is Set to NPOI.SS.UserModel.CellType.BLANK. Cell types
            can be Changed/overwritten by calling SetCellValue with the appropriate
            type as a parameter although conversions from one type to another may be
            prohibited.
            </summary>
            <param name="book">Workbook record of the workbook containing this cell</param>
            <param name="sheet">Sheet record of the sheet containing this cell</param>
            <param name="row">the row of this cell</param>
            <param name="col">the column for this cell</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFCell.#ctor(NPOI.HSSF.UserModel.HSSFWorkbook,NPOI.HSSF.UserModel.HSSFSheet,System.Int32,System.Int16,NPOI.SS.UserModel.CellType)">
            <summary>
            Creates new Cell - Should only be called by HSSFRow.  This Creates a cell
            from scratch.
            </summary>
            <param name="book">Workbook record of the workbook containing this cell</param>
            <param name="sheet">Sheet record of the sheet containing this cell</param>
            <param name="row">the row of this cell</param>
            <param name="col">the column for this cell</param>
            <param name="type">NPOI.SS.UserModel.CellType.NUMERIC, NPOI.SS.UserModel.CellType.STRING, NPOI.SS.UserModel.CellType.FORMULA, NPOI.SS.UserModel.CellType.BLANK,
            NPOI.SS.UserModel.CellType.BOOLEAN, NPOI.SS.UserModel.CellType.ERROR</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFCell.#ctor(NPOI.HSSF.UserModel.HSSFWorkbook,NPOI.HSSF.UserModel.HSSFSheet,NPOI.HSSF.Record.CellValueRecordInterface)">
            <summary>
            Creates an Cell from a CellValueRecordInterface.  HSSFSheet uses this when
            Reading in cells from an existing sheet.
            </summary>
            <param name="book">Workbook record of the workbook containing this cell</param>
            <param name="sheet">Sheet record of the sheet containing this cell</param>
            <param name="row">The row.</param>
            <param name="cval">the Cell Value Record we wish to represent</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFCell.#ctor">
            private constructor to prevent blank construction
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFCell.CellErrorValue">
             set a error value for the cell
            
             @param errorCode the error value to set this cell to.  For formulas we'll set the
                    precalculated value , for errors we'll set
                    its value. For other types we will change the cell to an error
                    cell and set its value.
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFCell.DetermineType(NPOI.HSSF.Record.CellValueRecordInterface)">
            used internally -- given a cell value record, figure out its type
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFCell.BoundWorkbook">
            Returns the Workbook that this Cell is bound to
            @return
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFCell.Row">
             Returns the HSSFRow this cell belongs to
            
             @return the HSSFRow that owns this cell
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFCell.SetCellType(NPOI.SS.UserModel.CellType)">
            <summary>
            Set the cells type (numeric, formula or string)
            </summary>
            <param name="cellType">Type of the cell.</param>
            @see #NPOI.SS.UserModel.CellType.NUMERIC
            @see #NPOI.SS.UserModel.CellType.STRING
            @see #NPOI.SS.UserModel.CellType.FORMULA
            @see #NPOI.SS.UserModel.CellType.BLANK
            @see #NPOI.SS.UserModel.CellType.BOOLEAN
            @see #NPOI.SS.UserModel.CellType.ERROR
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFCell.SetCellType(NPOI.SS.UserModel.CellType,System.Boolean,System.Int32,System.Int32,System.Int16)">
            <summary>
            Sets the cell type. The SetValue flag indicates whether to bother about
            trying to preserve the current value in the new record if one is Created.
            The SetCellValue method will call this method with false in SetValue
            since it will overWrite the cell value later
            </summary>
            <param name="cellType">Type of the cell.</param>
            <param name="setValue">if set to <c>true</c> [set value].</param>
            <param name="row">The row.</param>
            <param name="col">The col.</param>
            <param name="styleIndex">Index of the style.</param>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFCell.CellType">
            <summary>
            Get the cells type (numeric, formula or string)
            </summary>
            <value>The type of the cell.</value>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFCell.SetCellValue(System.Double)">
            <summary>
            Set a numeric value for the cell
            </summary>
            <param name="value">the numeric value to Set this cell to.  For formulas we'll Set the
            precalculated value, for numerics we'll Set its value. For other types we
            will Change the cell to a numeric cell and Set its value.</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFCell.SetCellValue(System.DateTime)">
            <summary>
            Set a date value for the cell. Excel treats dates as numeric so you will need to format the cell as
            a date.
            </summary>
            <param name="value">the date value to Set this cell to.  For formulas we'll Set the
            precalculated value, for numerics we'll Set its value. For other types we
            will Change the cell to a numeric cell and Set its value.</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFCell.SetCellValue(System.String)">
            <summary>
            Set a string value for the cell. Please note that if you are using
            full 16 bit Unicode you should call SetEncoding() first.
            </summary>
            <param name="value">value to Set the cell to.  For formulas we'll Set the formula
            string, for String cells we'll Set its value.  For other types we will
            Change the cell to a string cell and Set its value.
            If value is null then we will Change the cell to a Blank cell.</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFCell.SetCellErrorValue(System.Byte)">
             set a error value for the cell
            
             @param errorCode the error value to set this cell to.  For formulas we'll set the
                    precalculated value , for errors we'll set
                    its value. For other types we will change the cell to an error
                    cell and set its value.
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFCell.SetCellValue(NPOI.SS.UserModel.RichTextString)">
            <summary>
            Set a string value for the cell. Please note that if you are using
            full 16 bit Unicode you should call SetEncoding() first.
            </summary>
            <param name="value">value to Set the cell to.  For formulas we'll Set the formula
            string, for String cells we'll Set its value.  For other types we will
            Change the cell to a string cell and Set its value.
            If value is null then we will Change the cell to a Blank cell.</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFCell.NotifyFormulaChanging">
            Should be called any time that a formula could potentially be deleted.
            Does nothing if this cell currently does not hold a formula
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFCell.CellFormula">
            <summary>
            Gets or sets the cell formula.
            </summary>
            <value>The cell formula.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFCell.NumericCellValue">
            <summary>
            Get the value of the cell as a number.  For strings we throw an exception.
            For blank cells we return a 0.
            </summary>
            <value>The numeric cell value.</value>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFCell.GetCellTypeName(NPOI.SS.UserModel.CellType)">
            <summary>
            Used to help format error messages
            </summary>
            <param name="cellTypeCode">The cell type code.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFCell.TypeMismatch(NPOI.SS.UserModel.CellType,NPOI.SS.UserModel.CellType,System.Boolean)">
            <summary>
            Types the mismatch.
            </summary>
            <param name="expectedTypeCode">The expected type code.</param>
            <param name="actualTypeCode">The actual type code.</param>
            <param name="isFormulaCell">if set to <c>true</c> [is formula cell].</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFCell.CheckFormulaCachedValueType(NPOI.SS.UserModel.CellType,NPOI.HSSF.Record.FormulaRecord)">
            <summary>
            Checks the type of the formula cached value.
            </summary>
            <param name="expectedTypeCode">The expected type code.</param>
            <param name="fr">The fr.</param>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFCell.DateCellValue">
            <summary>
            Get the value of the cell as a date.  For strings we throw an exception.
            For blank cells we return a null.
            </summary>
            <value>The date cell value.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFCell.StringCellValue">
            <summary>
            Get the value of the cell as a string - for numeric cells we throw an exception.
            For blank cells we return an empty string.
            For formulaCells that are not string Formulas, we return empty String
            </summary>
            <value>The string cell value.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFCell.RichStringCellValue">
            <summary>
            Get the value of the cell as a string - for numeric cells we throw an exception.
            For blank cells we return an empty string.
            For formulaCells that are not string Formulas, we return empty String
            </summary>
            <value>The rich string cell value.</value>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFCell.SetCellValue(System.Boolean)">
            <summary>
            Set a bool value for the cell
            </summary>
            <param name="value">the bool value to Set this cell to.  For formulas we'll Set the
            precalculated value, for bools we'll Set its value. For other types we
            will Change the cell to a bool cell and Set its value.</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFCell.ConvertCellValueToBoolean">
            <summary>
            Chooses a new bool value for the cell when its type is changing.
            Usually the caller is calling SetCellType() with the intention of calling
            SetCellValue(bool) straight afterwards.  This method only exists to give
            the cell a somewhat reasonable value Until the SetCellValue() call (if at all).
            TODO - perhaps a method like SetCellTypeAndValue(int, Object) should be introduced to avoid this
            </summary>
            <returns></returns>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFCell.BooleanCellValue">
            <summary>
            Get the value of the cell as a bool.  For strings, numbers, and errors, we throw an exception.
            For blank cells we return a false.
            </summary>
            <value><c>true</c> if [boolean cell value]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFCell.ErrorCellValue">
            <summary>
            Get the value of the cell as an error code.  For strings, numbers, and bools, we throw an exception.
            For blank cells we return a 0.
            </summary>
            <value>The error cell value.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFCell.CellStyle">
            <summary>
            Get the style for the cell.  This is a reference to a cell style contained in the workbook
            object.
            </summary>
            <value>The cell style.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFCell.Encoding">
            <summary>
            used for internationalization, currently -1 for UnChanged, 0 for compressed Unicode or 1 for 16-bit
            </summary>
            <value>-1, 1 or 0 for UnChanged, compressed or Uncompressed (used only with String type)</value>
            @see #ENCODING_UNCHANGED
            @see #ENCODING_COMPRESSED_UNICODE
            @see #ENCODING_UTF_16
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFCell.CellValueRecord">
            <summary>
            Should only be used by HSSFSheet and friends.  Returns the low level CellValueRecordInterface record
            </summary>
            <value>the cell via the low level api.</value>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFCell.CheckBounds(System.Int32)">
            <summary>
            Checks the bounds.
            </summary>
            <param name="cellNum">The cell num.</param>
            <exception cref="T:System.Exception">if the bounds are exceeded.</exception>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFCell.SetAsActiveCell">
            <summary>
            Sets this cell as the active cell for the worksheet
            </summary>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFCell.ToString">
            <summary>
            Returns a string representation of the cell
            This method returns a simple representation,
            anthing more complex should be in user code, with
            knowledge of the semantics of the sheet being Processed.
            Formula cells return the formula string,
            rather than the formula result.
            Dates are Displayed in dd-MMM-yyyy format
            Errors are Displayed as #ERR&lt;errIdx&gt;
            </summary>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFCell.CellComment">
            <summary>
            Returns comment associated with this cell
            </summary>
            <value>The cell comment associated with this cell.</value>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFCell.RemoveCellComment">
            <summary>
            Removes the comment for this cell, if
            there is one.
            </summary>
            <remarks>WARNING - some versions of excel will loose
            all comments after performing this action!</remarks>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFCell.FindCellComment(NPOI.HSSF.Model.Sheet,System.Int32,System.Int32)">
            <summary>
            Cell comment Finder.
            Returns cell comment for the specified sheet, row and column.
            </summary>
            <param name="sheet">The sheet.</param>
            <param name="row">The row.</param>
            <param name="column">The column.</param>
            <returns>cell comment or 
            <c>null</c>
             if not found</returns>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFCell.ColumnIndex">
            <summary>
            Gets the index of the column.
            </summary>
            <value>The index of the column.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFCell.RowIndex">
            <summary>
            Gets the (zero based) index of the row containing this cell
            </summary>
            <value>The index of the row.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFCell.Hyperlink">
            <summary>
            Returns hyperlink associated with this cell
            </summary>
            <value>The hyperlink associated with this cell or null if not found</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFCell.CachedFormulaResultType">
            <summary>
            Only valid for formula cells
            </summary>
            <value>one of (NPOI.SS.UserModel.CellType.NUMERIC,NPOI.SS.UserModel.CellType.STRING, NPOI.SS.UserModel.CellType.BOOLEAN, NPOI.SS.UserModel.CellType.ERROR) depending
            on the cached value of the formula</value>
        </member>
        <member name="T:NPOI.HSSF.UserModel.HSSFCellStyle">
            <summary>
            High level representation of the style of a cell in a sheet of a workbook.
            @author  Andrew C. Oliver (acoliver at apache dot org)
            @author Jason Height (jheight at chariot dot net dot au)
            </summary>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFCellStyle.#ctor(System.Int16,NPOI.HSSF.Record.ExtendedFormatRecord,NPOI.HSSF.UserModel.HSSFWorkbook)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HSSF.UserModel.HSSFCellStyle"/> class.
            </summary>
            <param name="index">The index.</param>
            <param name="rec">The record.</param>
            <param name="workbook">The workbook.</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFCellStyle.#ctor(System.Int16,NPOI.HSSF.Record.ExtendedFormatRecord,NPOI.HSSF.Model.Workbook)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HSSF.UserModel.HSSFCellStyle"/> class.
            </summary>
            <param name="index">The index.</param>
            <param name="rec">The record.</param>
            <param name="workbook">The workbook.</param>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFCellStyle.Index">
            <summary>
            Get the index within the HSSFWorkbook (sequence within the collection of ExtnededFormat objects)
            </summary>
            <value>Unique index number of the Underlying record this style represents (probably you don't care
            Unless you're comparing which one is which)</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFCellStyle.ParentStyle">
            <summary>
            Gets the parent style.
            </summary>
            <value>the parent style for this cell style.
            In most cases this will be null, but in a few
            cases there'll be a fully defined parent.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFCellStyle.DataFormat">
            <summary>
            Get the index of the format
            </summary>
            <value>The data format.</value>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFCellStyle.GetDataFormatString">
            <summary>
            Get the contents of the format string, by looking up
            the DataFormat against the bound workbook
            </summary>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFCellStyle.GetDataFormatString(NPOI.HSSF.Model.Workbook)">
            <summary>
            Get the contents of the format string, by looking up
            the DataFormat against the supplied workbook
            </summary>
            <param name="workbook">The workbook.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFCellStyle.SetFont(NPOI.SS.UserModel.Font)">
            <summary>
            Set the font for this style
            </summary>
            <param name="font">a font object Created or retreived from the HSSFWorkbook object</param>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFCellStyle.FontIndex">
            <summary>
            Gets the index of the font for this style.
            </summary>
            <value>The index of the font.</value>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFCellStyle.GetFont(NPOI.SS.UserModel.Workbook)">
            <summary>
            Gets the font for this style
            </summary>
            <param name="parentWorkbook">The parent workbook that this style belongs to.</param>
            <returns></returns>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFCellStyle.IsHidden">
            <summary>
            Get whether the cell's using this style are to be hidden
            </summary>
            <value>whether the cell using this style should be hidden</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFCellStyle.IsLocked">
            <summary>
            Get whether the cell's using this style are to be locked
            </summary>
            <value>whether the cell using this style should be locked</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFCellStyle.Alignment">
            <summary>
            Get the type of horizontal alignment for the cell
            </summary>
            <value> the type of alignment</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFCellStyle.WrapText">
            <summary>
            Gets or sets a value indicating whether the text should be wrapped
            </summary>
            <value><c>true</c> if [wrap text]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFCellStyle.VerticalAlignment">
            <summary>
            Gets or sets the vertical alignment for the cell.
            </summary>
            <value>the type of alignment</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFCellStyle.Rotation">
            <summary>
            Gets or sets the degree of rotation for the text in the cell
            </summary>
            <value>The rotation degrees (between -90 and 90 degrees).</value>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFCellStyle.VerifyBelongsToWorkbook(NPOI.HSSF.UserModel.HSSFWorkbook)">
            <summary>
            Verifies that this style belongs to the supplied Workbook.
            Will throw an exception if it belongs to a different one.
            This is normally called when trying to assign a style to a
            cell, to ensure the cell and the style are from the same
            workbook (if they're not, it won't work)
            </summary>
            <param name="wb">The workbook.</param>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFCellStyle.Indention">
            <summary>
            Gets or sets the number of spaces to indent the text in the cell
            </summary>
            <value>number of spaces</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFCellStyle.BorderLeft">
            <summary>
            Gets or sets the type of border to use for the left border of the cell
            </summary>
            <value>The border type.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFCellStyle.BorderRight">
            <summary>
            Gets or sets the type of border to use for the right border of the cell
            </summary>
            <value>The border type.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFCellStyle.BorderTop">
            <summary>
            Gets or sets the type of border to use for the top border of the cell
            </summary>
            <value>The border type.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFCellStyle.BorderBottom">
            <summary>
            Gets or sets the type of border to use for the bottom border of the cell
            </summary>
            <value>The border type.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFCellStyle.LeftBorderColor">
            <summary>
            Gets or sets the color to use for the left border
            </summary>
            <value>The index of the color definition</value>
            @see org.apache.poi.hssf.usermodel.HSSFPalette#GetColor(short)
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFCellStyle.RightBorderColor">
            <summary>
            Gets or sets the color to use for the left border.
            </summary>
            <value>The index of the color definition</value>
            @see org.apache.poi.hssf.usermodel.HSSFPalette#GetColor(short)
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFCellStyle.TopBorderColor">
            <summary>
            Gets or sets the color to use for the top border
            </summary>
            <value>The index of the color definition.</value>
            @see org.apache.poi.hssf.usermodel.HSSFPalette#GetColor(short)
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFCellStyle.BottomBorderColor">
            <summary>
            Gets or sets the color to use for the left border
            </summary>
            <value>The index of the color definition.</value>
            @see org.apache.poi.hssf.usermodel.HSSFPalette#GetColor(short)
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFCellStyle.ShrinkToFit">
            <summary>
            Gets or sets whether the cell is shrink-to-fit
            </summary>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFCellStyle.FillPattern">
            <summary>
            Gets or sets the fill pattern. - Set to 1 to Fill with foreground color
            </summary>
            <value>The fill pattern.</value>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFCellStyle.CheckDefaultBackgroundFills">
            <summary>
            Checks if the background and foreground Fills are Set correctly when one
            or the other is Set to the default color.
            Works like the logic table below:
            BACKGROUND   FOREGROUND
            NONE         AUTOMATIC
            0x41         0x40
            NONE         RED/ANYTHING
            0x40         0xSOMETHING
            </summary>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFCellStyle.CloneStyleFrom(NPOI.SS.UserModel.CellStyle)">
             Clones all the style information from another
              HSSFCellStyle, onto this one. This
              HSSFCellStyle will then have all the same
              properties as the source, but the two may
              be edited independently.
             Any stylings on this HSSFCellStyle will be lost!
            
             The source HSSFCellStyle could be from another
              HSSFWorkbook if you like. This allows you to
              copy styles from one HSSFWorkbook to another.
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFCellStyle.CloneStyleFrom(NPOI.HSSF.UserModel.HSSFCellStyle)">
            <summary>
            Clones all the style information from another
            HSSFCellStyle, onto this one. This
            HSSFCellStyle will then have all the same
            properties as the source, but the two may
            be edited independently.
            Any stylings on this HSSFCellStyle will be lost!
            The source HSSFCellStyle could be from another
            HSSFWorkbook if you like. This allows you to
            copy styles from one HSSFWorkbook to another.
            </summary>
            <param name="source">The source.</param>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFCellStyle.UserStyleName">
            <summary>
            Gets the name of the user defined style.
            Returns null for built in styles, and
            styles where no name has been defined
            </summary>
            <value>The name of the user style.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFCellStyle.FillBackgroundColor">
            <summary>
            Gets or sets the color of the fill background.
            </summary>
            <value>The color of the fill background.</value>
            Set the background Fill color.
            <example>
            cs.SetFillPattern(HSSFCellStyle.FINE_DOTS );
            cs.SetFillBackgroundColor(new HSSFColor.RED().Index);
            optionally a Foreground and background Fill can be applied:
            Note: Ensure Foreground color is Set prior to background
            cs.SetFillPattern(HSSFCellStyle.FINE_DOTS );
            cs.SetFillForegroundColor(new HSSFColor.BLUE().Index);
            cs.SetFillBackgroundColor(new HSSFColor.RED().Index);
            or, for the special case of SOLID_Fill:
            cs.SetFillPattern(HSSFCellStyle.SOLID_FOREGROUND );
            cs.SetFillForegroundColor(new HSSFColor.RED().Index);
            It is necessary to Set the Fill style in order
            for the color to be shown in the cell.
            </example>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFCellStyle.FillForegroundColor">
            <summary>
            Gets or sets the foreground Fill color
            </summary>
            <value>Fill color.</value>
            @see org.apache.poi.hssf.usermodel.HSSFPalette#GetColor(short)
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFCellStyle.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFCellStyle.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with the current <see cref="T:System.Object"/>.</param>
            <returns>
            true if the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>; otherwise, false.
            </returns>
            <exception cref="T:System.NullReferenceException">
            The <paramref name="obj"/> parameter is null.
            </exception>
        </member>
        <member name="T:NPOI.HSSF.UserModel.HSSFClientAnchor">
            <summary>
            A client anchor Is attached to an excel worksheet.  It anchors against a
            top-left and buttom-right cell.
            @author Glen Stampoultzis (glens at apache.org)
            </summary>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFClientAnchor.#ctor">
            <summary>
            Creates a new client anchor and defaults all the anchor positions to 0.
            </summary>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFClientAnchor.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new client anchor and Sets the top-left and bottom-right
            coordinates of the anchor.
            </summary>
            <param name="dx1">the x coordinate within the first cell.</param>
            <param name="dy1">the y coordinate within the first cell.</param>
            <param name="dx2">the x coordinate within the second cell.</param>
            <param name="dy2">the y coordinate within the second cell.</param>
            <param name="col1">the column (0 based) of the first cell.</param>
            <param name="row1">the row (0 based) of the first cell.</param>
            <param name="col2">the column (0 based) of the second cell.</param>
            <param name="row2">the row (0 based) of the second cell.</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFClientAnchor.GetAnchorHeightInPoints(NPOI.SS.UserModel.Sheet)">
            <summary>
            Calculates the height of a client anchor in points.
            </summary>
            <param name="sheet">the sheet the anchor will be attached to</param>
            <returns>the shape height.</returns>     
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFClientAnchor.GetRowHeightInPoints(NPOI.SS.UserModel.Sheet,System.Int32)">
            <summary>
            Gets the row height in points.
            </summary>
            <param name="sheet">The sheet.</param>
            <param name="rowNum">The row num.</param>
            <returns></returns>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFClientAnchor.Col1">
            <summary>
            Gets or sets the col1.
            </summary>
            <value>The col1.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFClientAnchor.Col2">
            <summary>
            Gets or sets the col2.
            </summary>
            <value>The col2.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFClientAnchor.Row1">
            <summary>
            Gets or sets the row1.
            </summary>
            <value>The row1.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFClientAnchor.Row2">
            <summary>
            Gets or sets the row2.
            </summary>
            <value>The row2.</value>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFClientAnchor.SetAnchor(System.Int16,System.Int32,System.Int32,System.Int32,System.Int16,System.Int32,System.Int32,System.Int32)">
            <summary>
            Sets the top-left and bottom-right
            coordinates of the anchor
            </summary>
            <param name="col1">the column (0 based) of the first cell.</param>
            <param name="row1"> the row (0 based) of the first cell.</param>
            <param name="x1">the x coordinate within the first cell.</param>
            <param name="y1">the y coordinate within the first cell.</param>
            <param name="col2">the column (0 based) of the second cell.</param>
            <param name="row2">the row (0 based) of the second cell.</param>
            <param name="x2">the x coordinate within the second cell.</param>
            <param name="y2">the y coordinate within the second cell.</param>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFClientAnchor.IsHorizontallyFlipped">
            <summary>
            Gets a value indicating whether this instance is horizontally flipped.
            </summary>
            <value>
            	<c>true</c> if the anchor goes from right to left; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFClientAnchor.IsVerticallyFlipped">
            <summary>
            Gets a value indicating whether this instance is vertically flipped.
            </summary>
            <value>
            	<c>true</c> if the anchor goes from bottom to top.; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFClientAnchor.AnchorType">
            <summary>
            Gets the anchor type
            0 = Move and size with Cells, 2 = Move but don't size with cells, 3 = Don't move or size with cells.
            </summary>
            <value>The type of the anchor.</value>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFClientAnchor.CheckRange(System.Int32,System.Int32,System.Int32,System.String)">
            <summary>
            Checks the range.
            </summary>
            <param name="value">The value.</param>
            <param name="minRange">The min range.</param>
            <param name="maxRange">The max range.</param>
            <param name="varName">Name of the variable.</param>
        </member>
        <member name="T:NPOI.HSSF.UserModel.HSSFComment">
            <summary>
            Represents a cell comment - a sticky note associated with a cell.
            @author Yegor Kozlov
            </summary>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFComment.#ctor(NPOI.HSSF.UserModel.HSSFShape,NPOI.HSSF.UserModel.HSSFAnchor)">
            <summary>
            Construct a new comment with the given parent and anchor.
            </summary>
            <param name="parent"></param>
            <param name="anchor">defines position of this anchor in the sheet</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFComment.#ctor(NPOI.HSSF.Record.NoteRecord,NPOI.HSSF.Record.TextObjectRecord)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HSSF.UserModel.HSSFComment"/> class.
            </summary>
            <param name="note">The note.</param>
            <param name="txo">The txo.</param>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFComment.Visible">
            <summary>
            Gets or sets a value indicating whether this <see cref="T:NPOI.HSSF.UserModel.HSSFComment"/> is visible.
            </summary>
            <value><c>true</c> if visible; otherwise, <c>false</c>.</value>
            Sets whether this comment Is visible.
            @return 
            <c>true</c>
             if the comment Is visible, 
            <c>false</c>
             otherwise
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFComment.Row">
            <summary>
            Gets or sets the row of the cell that Contains the comment
            </summary>
            <value>the 0-based row of the cell that Contains the comment</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFComment.Column">
            <summary>
            Gets or sets the column of the cell that Contains the comment
            </summary>
            <value>the 0-based column of the cell that Contains the comment</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFComment.Author">
            <summary>
            Gets or sets the name of the original comment author
            </summary>
            <value>the name of the original author of the comment</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFComment.String">
            <summary>
            Gets or sets the rich text string used by this comment.
            </summary>   
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFComment.NoteRecord">
            <summary>
            Gets the note record.
            </summary>
            <value>the underlying Note record.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFComment.TextObjectRecord">
            <summary>
            Gets the text object record.
            </summary>
            <value>the underlying Text record</value>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NPOI.HSSF.UserModel.HSSFConditionalFormatting" -->
        <member name="M:NPOI.HSSF.UserModel.HSSFConditionalFormatting.#ctor(NPOI.HSSF.UserModel.HSSFWorkbook,NPOI.HSSF.Record.Aggregates.CFRecordsAggregate)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HSSF.UserModel.HSSFConditionalFormatting"/> class.
            </summary>
            <param name="workbook">The workbook.</param>
            <param name="cfAggregate">The cf aggregate.</param>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFConditionalFormatting.CFRecordsAggregate">
            <summary>
            Gets the CF records aggregate.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFConditionalFormatting.GetFormattingRegions">
            <summary>
            Gets the array of Regions
            </summary>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFConditionalFormatting.GetFormattingRanges">
            <summary>
            Gets array of CellRangeAddresses
            </summary>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFConditionalFormatting.SetRule(System.Int32,NPOI.HSSF.UserModel.HSSFConditionalFormattingRule)">
            <summary>
            Replaces an existing Conditional Formatting rule at position idx.
            Excel allows to Create up to 3 Conditional Formatting rules.
            This method can be useful to modify existing  Conditional Formatting rules.
            </summary>
            <param name="idx">position of the rule. Should be between 0 and 2.</param>
            <param name="cfRule">Conditional Formatting rule</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFConditionalFormatting.AddRule(NPOI.HSSF.UserModel.HSSFConditionalFormattingRule)">
            <summary>
            Add a Conditional Formatting rule.
            Excel allows to Create up to 3 Conditional Formatting rules.
            </summary>
            <param name="cfRule">Conditional Formatting rule</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFConditionalFormatting.GetRule(System.Int32)">
            <summary>
            Gets the Conditional Formatting rule at position idx
            </summary>
            <param name="idx">The index.</param>
            <returns></returns>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFConditionalFormatting.NumberOfRules">
            <summary>
            Gets the number of Conditional Formatting rules.
            </summary>
            <value>The number of rules.</value>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFConditionalFormatting.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="T:NPOI.HSSF.UserModel.HSSFConditionalFormattingRule">
            
            High level representation of Conditional Formatting Rule.
            It allows to specify formula based conditions for the Conditional Formatting
            and the formatting Settings such as font, border and pattern.
            
            @author Dmitriy Kumshayev
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFConditionalFormattingRule.GetFontFormatting">
            @return - font formatting object  if defined,  <c>null</c> otherwise
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFConditionalFormattingRule.CreateFontFormatting">
            Create a new font formatting structure if it does not exist, 
            otherwise just return existing object.
            @return - font formatting object, never returns <c>null</c>. 
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFConditionalFormattingRule.GetBorderFormatting">
            @return - border formatting object  if defined,  <c>null</c> otherwise
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFConditionalFormattingRule.CreateBorderFormatting">
            Create a new border formatting structure if it does not exist, 
            otherwise just return existing object.
            @return - border formatting object, never returns <c>null</c>. 
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFConditionalFormattingRule.GetPatternFormatting">
            @return - pattern formatting object  if defined, <c>null</c> otherwise
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFConditionalFormattingRule.CreatePatternFormatting">
            Create a new pattern formatting structure if it does not exist, 
            otherwise just return existing object.
            @return - pattern formatting object, never returns <c>null</c>. 
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFCreationHelper.CreateFormulaEvaluator">
             Creates a HSSFFormulaEvaluator, the object that Evaluates formula cells.
            
             @return a HSSFFormulaEvaluator instance
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFCreationHelper.CreateClientAnchor">
             Creates a HSSFClientAnchor. Use this object to position drawing object in a sheet
            
             @return a HSSFClientAnchor instance
             @see NPOI.SS.usermodel.Drawing
        </member>
        <member name="T:NPOI.HSSF.UserModel.HSSFDataFormat">
             <summary>
             Utility to identify builtin formats.  Now can handle user defined data formats also.  The following Is a list of the formats as
             returned by this class.
             </summary>
             <remark>
              @author  Andrew C. Oliver (acoliver at apache dot org)
              @author  Shawn M. Laubach (slaubach at apache dot org)
              </remark>
              <example>
                   0, "General"
                   1, "0"
                   2, "0.00"
                   3, "#,##0"
                   4, "#,##0.00"
                   5, "($#,##0_);($#,##0)"
                   6, "($#,##0_);[Red]($#,##0)"
                   7, "($#,##0.00);($#,##0.00)"
                   8, "($#,##0.00_);[Red]($#,##0.00)"
                   9, "0%"
                   0xa, "0.00%"
                   0xb, "0.00E+00"
                   0xc, "# ?/?"
                   0xd, "# ??/??"
                   0xe, "m/d/yy"
                   0xf, "d-mmm-yy"
                   0x10, "d-mmm"
                   0x11, "mmm-yy"
                   0x12, "h:mm AM/PM"
                   0x13, "h:mm:ss AM/PM"
                   0x14, "h:mm"
                   0x15, "h:mm:ss"
                   0x16, "m/d/yy h:mm"
            
                   // 0x17 - 0x24 reserved for international and Undocumented
                   0x25, "(#,##0_);(#,##0)"
                   0x26, "(#,##0_);[Red](#,##0)"
                   0x27, "(#,##0.00_);(#,##0.00)"
                   0x28, "(#,##0.00_);[Red](#,##0.00)"
                   0x29, "_(///#,##0_);_(///(#,##0);_(/// \"-\"_);_(@_)"
                   0x2a, "_($///#,##0_);_($///(#,##0);_($/// \"-\"_);_(@_)"
                   0x2b, "_(///#,##0.00_);_(///(#,##0.00);_(///\"-\"??_);_(@_)"
                   0x2c, "_($///#,##0.00_);_($///(#,##0.00);_($///\"-\"??_);_(@_)"
                   0x2d, "mm:ss"
                   0x2e, "[h]:mm:ss"
                   0x2f, "mm:ss.0"
                   0x30, "##0.0E+0"
                   0x31, "@" - This Is text format.
                   0x31  "text" - Alias for "@"
              </example>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFDataFormat.#ctor(NPOI.HSSF.Model.Workbook)">
            <summary>
            Construncts a new data formatter.  It takes a workbook to have
            access to the workbooks format records.
            </summary>
            <param name="workbook">the workbook the formats are tied to..</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFDataFormat.GetBuiltinFormat(System.String)">
            <summary>
            Get the format index that matches the given format string
            Automatically Converts "text" to excel's format string to represent text.
            </summary>
            <param name="format">The format string matching a built in format.</param>
            <returns>index of format or -1 if Undefined.</returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFDataFormat.GetFormat(System.String)">
            <summary>
            Get the format index that matches the given format
            string, creating a new format entry if required.
            Aliases text to the proper format as required.
            </summary>
            <param name="format">The format string matching a built in format.</param>
            <returns>index of format.</returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFDataFormat.GetFormat(System.Int16)">
            <summary>
            Get the format string that matches the given format index
            </summary>
            <param name="index">The index of a format.</param>
            <returns>string represented at index of format or null if there Is not a  format at that index</returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFDataFormat.GetBuiltinFormat(System.Int16)">
            <summary>
            Get the format string that matches the given format index
            </summary>
            <param name="index">The index of a built in format.</param>
            <returns>string represented at index of format or null if there Is not a builtin format at that index</returns>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFDataFormat.NumberOfBuiltinBuiltinFormats">
            <summary>
            Get the number of builtin and reserved builtinFormats
            </summary>
            <returns>number of builtin and reserved builtinFormats</returns>
        </member>
        <member name="T:NPOI.HSSF.UserModel.HSSFDataValidation">
            Title: HSSFDataValidation
            Description: Utilty class for creating data validation cells
            Copyright: Copyright (c) 2004
            Company: 
            @author Dragos Buleandra (dragos.buleandra@trade2b.ro)
            @version 2.0-pre
        </member>
        <member name="T:NPOI.HSSF.UserModel.HSSFDataValidation.ERRORSTYLE">
            Error style constants for error box
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFDataValidation.ERRORSTYLE.STOP">
            STOP style 
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFDataValidation.ERRORSTYLE.WARNING">
            WARNING style 
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFDataValidation.ERRORSTYLE.INFO">
            INFO style 
        </member>
        <member name="T:NPOI.HSSF.UserModel.HSSFDataValidation.DataType">
            <summary>
             Validation data type constants
            </summary>
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFDataValidation.DataType.LIST">
            <summary>
            List type ( combo box type )
            </summary>
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFDataValidation.DataType.TEXT_LENGTH">
            <summary>
            String Length type
            </summary>
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFDataValidation.DataType.FORMULA">
            <summary>
            Formula ( custom ) type
            </summary>
        </member>
        <member name="T:NPOI.HSSF.UserModel.HSSFDataValidation.OperatorType">
            <summary>
            Condition operator
            </summary>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFDataValidation.#ctor">
            Empty constructor
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFDataValidation.#ctor(NPOI.SS.Util.CellRangeAddressList,NPOI.HSSF.UserModel.DVConstraint)">
            Constructor which initializes the cell range on which this object will be
            applied
            @param constraint 
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFDataValidation.DataValidationType">
            Set the type of this object
            @param data_type The type
            @see DATA_TYPE_ANY, DATA_TYPE_INTEGER, DATA_TYPE_DECIMNAL, DATA_TYPE_LIST, DATA_TYPE_DATE,
                 DATA_TYPE_TIME, DATA_TYPE_TEXT_LENTGH, DATA_TYPE_FORMULA
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFDataValidation.ErrorStyle">
            Sets the error style for error box
            @param error_style Error style constant
            @see ERROR_STYLE_STOP, ERROR_STYLE_WARNING, ERROR_STYLE_INFO
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFDataValidation.ExplicitListFormula">
            If this object has an explicit formula . This is useful only for list data validation object
            @param explicit True if use an explicit formula
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFDataValidation.EmptyCellAllowed">
            Sets if this object allows empty as a valid value
            @param allowed True if this object should treats empty as valid value , false otherwise
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFDataValidation.SuppressDropDownArrow">
            Useful only list validation objects .
            This method always returns false if the object Isn't a list validation object
            @return True if a list should Display the values into a drop down list , false otherwise .
            @see SetDataValidationType( int data_type )
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFDataValidation.ShowPromptBox">
            @param show True if an prompt box should be Displayed , false otherwise
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFDataValidation.ShowErrorBox">
            @return True if an error box should be Displayed , false otherwise
        </member>
        <!-- Badly formed XML comment ignored for member "P:NPOI.HSSF.UserModel.HSSFDataValidation.Operator" -->
        <member name="M:NPOI.HSSF.UserModel.HSSFDataValidation.CreatePromptBox(System.String,System.String)">
            Sets the title and text for the prompt box . Prompt box is Displayed when the user
            selects a cell which belongs to this validation object . In order for a prompt box
            to be Displayed you should also use method SetShowPromptBox( bool show )
            @param title The prompt box's title
            @param text The prompt box's text
            @see SetShowPromptBox( bool show )
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFDataValidation.PromptBoxTitle">
            Returns the prompt box's title
            @return Prompt box's title or null
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFDataValidation.PromptBoxText">
            Returns the prompt box's text
            @return Prompt box's text or null
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFDataValidation.CreateErrorBox(System.String,System.String)">
            Sets the title and text for the error box . Error box is Displayed when the user
            enters an invalid value int o a cell which belongs to this validation object .
            In order for an error box to be Displayed you should also use method
            SetShowErrorBox( bool show )
            @param title The error box's title
            @param text The error box's text
            @see SetShowErrorBox( bool show )
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFDataValidation.ErrorBoxTitle">
            Returns the error box's title
            @return Error box's title or null
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFDataValidation.ErrorBoxText">
            Returns the error box's text
            @return Error box's text or null
        </member>
        <!-- Badly formed XML comment ignored for member "P:NPOI.HSSF.UserModel.HSSFDataValidation.FirstFormula" -->
        <!-- Badly formed XML comment ignored for member "P:NPOI.HSSF.UserModel.HSSFDataValidation.SecondFormula" -->
        <member name="T:NPOI.HSSF.UserModel.HSSFEvaluationCell">
            <summary>
            HSSF wrapper for a cell under evaluation
            @author Josh Micich
            </summary>
        </member>
        <member name="T:NPOI.HSSF.UserModel.HSSFEvaluationSheet">
            HSSF wrapper for a sheet under evaluation
            
            @author Josh Micich
        </member>
        <member name="T:NPOI.HSSF.UserModel.HSSFEvaluationWorkbook">
            Internal POI use only
            
            @author Josh Micich
        </member>
        <member name="T:NPOI.HSSF.UserModel.HSSFFont">
            <summary>
            Represents a Font used in a workbook.
            @version 1.0-pre
            @author  Andrew C. Oliver
            </summary>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFFont.#ctor(System.Int16,NPOI.HSSF.Record.FontRecord)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HSSF.UserModel.HSSFFont"/> class.
            </summary>
            <param name="index">The index.</param>
            <param name="rec">The record.</param>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFFont.FontName">
            <summary>
            Get the name for the font (i.e. Arial)
            </summary>
            <value>the name of the font to use</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFFont.Index">
            <summary>
            Get the index within the HSSFWorkbook (sequence within the collection of Font objects)
            </summary>
            <value>Unique index number of the Underlying record this Font represents (probably you don't care
            Unless you're comparing which one is which)</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFFont.FontHeight">
            <summary>
            Get or sets the font height in Unit's of 1/20th of a point.  Maybe you might want to
            use the GetFontHeightInPoints which matches to the familiar 10, 12, 14 etc..
            </summary>
            <value>height in 1/20ths of a point.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFFont.FontHeightInPoints">
            <summary>
            Gets or sets the font height in points.
            </summary>
            <value>height in the familiar Unit of measure - points.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFFont.IsItalic">
            <summary>
            Gets or sets whether to use italics or not
            </summary>
            <value><c>true</c> if this instance is italic; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFFont.IsStrikeout">
            <summary>
            Get whether to use a strikeout horizontal line through the text or not
            </summary>
            <value>
            strikeout or not
            </value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFFont.Color">
            <summary>
            Gets or sets the color for the font.
            </summary>
            <value>The color to use.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFFont.Boldweight">
            <summary>
            Gets or sets the boldness to use
            </summary>
            <value>The boldweight.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFFont.TypeOffset">
            <summary>
            Gets or sets normal,base or subscript.
            </summary>
            <value>offset type to use (none,base,sub)</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFFont.Underline">
            <summary>
            Gets or sets the type of text Underlining to use
            </summary>
            <value>The Underlining type.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFFont.Charset">
            <summary>
            Gets or sets the char set to use.
            </summary>
            <value>The char set.</value>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFFont.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFFont.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFFont.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with the current <see cref="T:System.Object"/>.</param>
            <returns>
            true if the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>; otherwise, false.
            </returns>
            <exception cref="T:System.NullReferenceException">
            The <paramref name="obj"/> parameter is null.
            </exception>
        </member>
        <member name="T:NPOI.HSSF.UserModel.HSSFFontFormatting">
             High level representation for Font Formatting component
             of Conditional Formatting Settings
             
             @author Dmitriy Kumshayev
            
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFFontFormatting.SS_NONE">
            Escapement type - None 
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFFontFormatting.SS_SUPER">
            Escapement type - Superscript 
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFFontFormatting.SS_SUB">
            Escapement type - Subscript 
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFFontFormatting.U_NONE">
            Underline type - None 
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFFontFormatting.U_SINGLE">
            Underline type - Single 
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFFontFormatting.U_DOUBLE">
            Underline type - Double 
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFFontFormatting.U_SINGLE_ACCOUNTING">
             Underline type - Single Accounting 
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFFontFormatting.U_DOUBLE_ACCOUNTING">
            Underline type - Double Accounting 
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFFontFormatting.EscapementType">
             Get the type of base or subscript for the font
            
             @return base or subscript option
             @see #SS_NONE
             @see #SS_SUPER
             @see #SS_SUB
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFFontFormatting.FontColorIndex">
            @return font color index
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFFontFormatting.FontHeight">
             Gets the height of the font in 1/20th point Units
            
             @return fontheight (in points/20); or -1 if not modified
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFFontFormatting.FontWeight">
             Get the font weight for this font (100-1000dec or 0x64-0x3e8).  Default Is
             0x190 for normal and 0x2bc for bold
            
             @return bw - a number between 100-1000 for the fonts "boldness"
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFFontFormatting.GetRawRecord">
            @return
            @see org.apache.poi.hssf.record.cf.FontFormatting#GetRawRecord()
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFFontFormatting.UnderlineType">
             Get the type of Underlining for the font
            
             @return font Underlining type
            
             @see #U_NONE
             @see #U_SINGLE
             @see #U_DOUBLE
             @see #U_SINGLE_ACCOUNTING
             @see #U_DOUBLE_ACCOUNTING
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFFontFormatting.IsBold">
             Get whether the font weight Is Set to bold or not
            
             @return bold - whether the font Is bold or not
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFFontFormatting.IsEscapementTypeModified">
            @return true if escapement type was modified from default   
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFFontFormatting.IsFontCancellationModified">
            @return true if font cancellation was modified from default   
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFFontFormatting.IsFontOutlineModified">
            @return true if font outline type was modified from default   
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFFontFormatting.IsFontShadowModified">
            @return true if font shadow type was modified from default   
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFFontFormatting.IsFontStyleModified">
            @return true if font style was modified from default   
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFFontFormatting.IsItalic">
            @return true if font style was Set to <i>italic</i> 
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFFontFormatting.IsOutlineOn">
            @return true if font outline Is on
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFFontFormatting.IsShadowOn">
            @return true if font shadow Is on
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFFontFormatting.IsStrikeout">
            @return true if font strikeout Is on
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFFontFormatting.IsUnderlineTypeModified">
            @return true if font Underline type was modified from default   
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFFontFormatting.IsFontWeightModified">
            @return true if font weight was modified from default   
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFFontFormatting.SetFontStyle(System.Boolean,System.Boolean)">
            Set font style options.
            
            @param italic - if true, Set posture style to italic, otherwise to normal 
            @param bold- if true, Set font weight to bold, otherwise to normal
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFFontFormatting.ResetFontStyle">
            Set font style options to default values (non-italic, non-bold)
        </member>
        <member name="T:NPOI.HSSF.UserModel.HSSFFooter">
            <summary>
            Class to Read and manipulate the footer.
            The footer works by having a left, center, and right side.  The total cannot
            be more that 255 bytes long.  One uses this class by Getting the HSSFFooter
            from HSSFSheet and then Getting or Setting the left, center, and right side.
            For special things (such as page numbers and date), one can use a the methods
            that return the Chars used to represent these.  One can also Change the
            fonts by using similar methods.
            @author Shawn Laubach (slaubach at apache dot org)
            </summary>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFFooter.#ctor(NPOI.HSSF.Record.FooterRecord)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HSSF.UserModel.HSSFFooter"/> class.
            </summary>
            <param name="footerRecord">Footer record to Create the footer with</param>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFFooter.Left">
            <summary>
            Get the left side of the footer.
            </summary>
            <value>The string representing the left side.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFFooter.Center">
            <summary>
            Get the center of the footer.
            </summary>
            <value>The string representing the center.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFFooter.Right">
            <summary>
            Get the right side of the footer.
            </summary>
            <value>The string representing the right side.</value> 
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFFooter.RawFooter">
            <summary>
            Gets the raw footer.
            </summary>
            <value>The raw footer.</value>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFFooter.CreateFooterString">
            <summary>
            Creates the complete footer string based on the left, center, and middle
            strings.
            </summary>
        </member>
        <member name="T:NPOI.HSSF.UserModel.HSSFFormulaEvaluator">
            @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
            
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFFormulaEvaluator.#ctor(NPOI.SS.UserModel.Workbook,NPOI.SS.Formula.IStabilityClassifier)">
            @param stabilityClassifier used to optimise caching performance. Pass <code>null</code>
            for the (conservative) assumption that any cell may have its definition changed after
            evaluation begins.
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFFormulaEvaluator.#ctor(NPOI.SS.UserModel.Workbook,NPOI.SS.Formula.IStabilityClassifier,NPOI.HSSF.Record.Formula.Udf.UDFFinder)">
            @param udfFinder pass <code>null</code> for default (AnalysisToolPak only)
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFFormulaEvaluator.SetupEnvironment(System.String[],NPOI.HSSF.UserModel.HSSFFormulaEvaluator[])">
            Coordinates several formula evaluators together so that formulas that involve external
            references can be evaluated.
            @param workbookNames the simple file names used to identify the workbooks in formulas
            with external links (for example "MyData.xls" as used in a formula "[MyData.xls]Sheet1!A1")
            @param evaluators all evaluators for the full set of workbooks required by the formulas. 
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFFormulaEvaluator.Evaluate(NPOI.SS.UserModel.Cell)">
            If cell Contains a formula, the formula is Evaluated and returned,
            else the CellValue simply copies the appropriate cell value from
            the cell and also its cell type. This method should be preferred over
            EvaluateInCell() when the call should not modify the contents of the
            original cell. 
            @param cell
            If cell contains a formula, the formula is evaluated and returned,
            else the CellValue simply copies the appropriate cell value from
            the cell and also its cell type. This method should be preferred over
            evaluateInCell() when the call should not modify the contents of the
            original cell.
            
            @param cell may be <c>null</c> signifying that the cell is not present (or blank)
            @return <c>null</c> if the supplied cell is <c>null</c> or blank
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFFormulaEvaluator.ClearAllCachedResultValues">
            Should be called whenever there are major changes (e.g. moving sheets) to input cells
            in the evaluated workbook.  If performance is not critical, a single call to this method
            may be used instead of many specific calls to the notify~ methods.
             
            Failure to call this method after changing cell values will cause incorrect behaviour
            of the evaluate~ methods of this class
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFFormulaEvaluator.NotifyUpdateCell(NPOI.SS.UserModel.Cell)">
            Should be called to tell the cell value cache that the specified (value or formula) cell 
            has changed.
            Failure to call this method after changing cell values will cause incorrect behaviour
            of the evaluate~ methods of this class
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFFormulaEvaluator.NotifyDeleteCell(NPOI.SS.UserModel.Cell)">
            Should be called to tell the cell value cache that the specified cell has just been
            deleted. 
            Failure to call this method after changing cell values will cause incorrect behaviour
            of the evaluate~ methods of this class
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFFormulaEvaluator.NotifySetFormula(NPOI.SS.UserModel.Cell)">
            Should be called to tell the cell value cache that the specified (value or formula) cell
            has changed.
            Failure to call this method after changing cell values will cause incorrect behaviour
            of the evaluate~ methods of this class
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFFormulaEvaluator.EvaluateFormulaCell(NPOI.SS.UserModel.Cell)">
            If cell Contains formula, it Evaluates the formula,
             and saves the result of the formula. The cell
             remains as a formula cell.
            Else if cell does not contain formula, this method leaves
             the cell UnChanged. 
            Note that the type of the formula result is returned,
             so you know what kind of value is also stored with
             the formula. 
            <pre>
            int EvaluatedCellType = evaluator.EvaluateFormulaCell(cell);
            </pre>
            Be aware that your cell will hold both the formula,
             and the result. If you want the cell Replaced with
             the result of the formula, use {@link #EvaluateInCell(HSSFCell)}
            @param cell The cell to Evaluate
            @return The type of the formula result (the cell's type remains as NPOI.SS.UserModel.CellType.FORMULA however)
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFFormulaEvaluator.EvaluateFormulaCellValue(NPOI.SS.UserModel.Cell)">
            Returns a CellValue wrapper around the supplied ValueEval instance.
            @param eval
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFFormulaEvaluator.EvaluateInCell(NPOI.SS.UserModel.Cell)">
            If cell Contains formula, it Evaluates the formula, and
             puts the formula result back into the cell, in place
             of the old formula.
            Else if cell does not contain formula, this method leaves
             the cell UnChanged. 
            Note that the same instance of Cell is returned to 
            allow chained calls like:
            <pre>
            int EvaluatedCellType = evaluator.EvaluateInCell(cell).CellType;
            </pre>
            Be aware that your cell value will be Changed to hold the
             result of the formula. If you simply want the formula
             value computed for you, use {@link #EvaluateFormulaCell(HSSFCell)}
            @param cell
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFFormulaEvaluator.EvaluateAllFormulaCells(NPOI.HSSF.UserModel.HSSFWorkbook)">
            Loops over all cells in all sheets of the supplied
             workbook.
            For cells that contain formulas, their formulas are
             Evaluated, and the results are saved. These cells
             remain as formula cells.
            For cells that do not contain formulas, no Changes
             are made.
            This is a helpful wrapper around looping over all 
             cells, and calling EvaluateFormulaCell on each one.
        </member>
        <member name="T:NPOI.HSSF.UserModel.HSSFFormulaEvaluator.CellValue">
            Mimics the 'data view' of a cell. This allows formula evaluator 
            to return a CellValue instead of precasting the value to String
            or Number or bool type.
            @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFFormulaEvaluator.CellValue.BooleanValue">
            @return Returns the boolValue.
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFFormulaEvaluator.CellValue.NumberValue">
            @return Returns the numberValue.
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFFormulaEvaluator.CellValue.StringValue">
            @return Returns the stringValue. This method is deprecated, use
            GetRichTextStringValue instead
            @deprecated
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFFormulaEvaluator.CellValue.CellType">
            @return Returns the cellType.
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFFormulaEvaluator.CellValue.ErrorValue">
            @return Returns the errorValue.
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFFormulaEvaluator.CellValue.RichTextStringValue">
            @return Returns the richTextStringValue.
        </member>
        <member name="T:NPOI.HSSF.UserModel.HSSFHeader">
            <summary>
            Class to Read and manipulate the header.
            The header works by having a left, center, and right side.  The total cannot
            be more that 255 bytes long.  One uses this class by Getting the HSSFHeader
            from HSSFSheet and then Getting or Setting the left, center, and right side.
            For special things (such as page numbers and date), one can use a the methods
            that return the Chars used to represent these.  One can also Change the
            fonts by using similar methods.
            @author Shawn Laubach (slaubach at apache dot org)
            </summary>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFHeader.#ctor(NPOI.HSSF.Record.HeaderRecord)">
            <summary>
            Creates a new header interface from a header record
            </summary>
            <param name="headerRecord">The Header record to Create the header with</param>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFHeader.Left">
            <summary>
            Get the left side of the header.
            </summary>
            <value>The string representing the left side.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFHeader.Center">
            <summary>
            Get the center of the header.
            </summary>
            <value>The string representing the center.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFHeader.Right">
            <summary>
            Get the right side of the header.
            </summary>
            <value>The string representing the right side.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFHeader.RawHeader">
            <summary>
            Gets the raw header.
            </summary>
            <value>The raw header.</value>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFHeader.CreateHeaderString">
            <summary>
            Creates the complete header string based on the left, center, and middle
            strings.
            </summary>
        </member>
        <member name="T:NPOI.HSSF.UserModel.HSSFHyperlink">
            <summary>
            Represents an Excel hyperlink.
            </summary>
            <remarks>@author Yegor Kozlov (yegor at apache dot org)</remarks>
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFHyperlink.record">
            Low-level record object that stores the actual hyperlink data
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFHyperlink.link_type">
            If we Create a new hypelrink remember its type
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFHyperlink.#ctor(NPOI.SS.UserModel.HyperlinkType)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HSSF.UserModel.HSSFHyperlink"/> class.
            </summary>
            <param name="type">The type of hyperlink to Create.</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFHyperlink.#ctor(NPOI.HSSF.Record.HyperlinkRecord)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HSSF.UserModel.HSSFHyperlink"/> class.
            </summary>
            <param name="record">The record.</param>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFHyperlink.FirstRow">
            <summary>
            Gets or sets the row of the first cell that Contains the hyperlink
            </summary>
            <value>the 0-based row of the cell that Contains the hyperlink.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFHyperlink.LastRow">
            <summary>
            Gets or sets the row of the last cell that Contains the hyperlink
            </summary>
            <value>the 0-based row of the last cell that Contains the hyperlink</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFHyperlink.FirstColumn">
            <summary>
            Gets or sets the column of the first cell that Contains the hyperlink
            </summary>
            <value>the 0-based column of the first cell that Contains the hyperlink</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFHyperlink.LastColumn">
            <summary>
            Gets or sets the column of the last cell that Contains the hyperlink
            </summary>
            <value>the 0-based column of the last cell that Contains the hyperlink</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFHyperlink.Address">
            <summary>
            Gets or sets Hypelink Address. Depending on the hyperlink type it can be URL, e-mail, patrh to a file, etc.
            </summary>
            <value>the Address of this hyperlink</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFHyperlink.TextMark">
            <summary>
            Gets or sets the text mark.
            </summary>
            <value>The text mark.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFHyperlink.ShortFilename">
            <summary>
            Gets or sets the short filename.
            </summary>
            <value>The short filename.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFHyperlink.Label">
            <summary>
            Gets or sets the text label for this hyperlink
            </summary>
            <value>text to Display</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFHyperlink.Type">
            <summary>
            Gets the type of this hyperlink
            </summary>
            <value>the type of this hyperlink</value>
        </member>
        <member name="T:NPOI.HSSF.UserModel.HSSFName">
            <summary>
            High Level Represantion of Named Range
            </summary>
            <remarks>@author Libin Roman (Vista Portal LDT. Developer)</remarks>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFName.#ctor(NPOI.HSSF.UserModel.HSSFWorkbook,NPOI.HSSF.Record.NameRecord)">
            <summary>
            Creates new HSSFName   - called by HSSFWorkbook to Create a sheet from
            scratch.
            </summary>
            <param name="book">lowlevel Workbook object associated with the sheet.</param>
            <param name="name">the Name Record</param>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFName.SheetName">
            <summary>
            Gets or sets the sheets name which this named range is referenced to
            </summary>
            <value>sheet name, which this named range refered to</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFName.NameName">
            <summary>
            Gets or sets the name of the named range
            </summary>
            <value>named range name</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFName.SheetIndex">
             Returns the sheet index this name applies to.
            
             @return the sheet index this name applies to, -1 if this name applies to the entire workbook
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFName.IsDeleted">
            <summary>
            Tests if this name points to a cell that no longer exists
            </summary>
            <value>
            	<c>true</c> if the name refers to a deleted cell; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFName.IsFunctionName">
            <summary>
            Gets a value indicating whether this instance is function name.
            </summary>
            <value>
            	<c>true</c> if this instance is function name; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFName.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="T:NPOI.HSSF.UserModel.HSSFObjectData">
             Represents binary object (i.e. OLE) data stored in the file.  Eg. A GIF, JPEG etc...
            
             @author Daniel Noll
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFObjectData.record">
            Underlying object record ultimately containing a reference to the object.
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFObjectData.poifs">
            Reference to the filesystem, required for retrieving the object data.
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFObjectData.#ctor(NPOI.HSSF.Record.ObjRecord,NPOI.POIFS.FileSystem.POIFSFileSystem)">
             Constructs object data by wrapping a lower level object record.
            
             @param record the low-level object record.
             @param poifs the filesystem, required for retrieving the object data.
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFObjectData.OLE2ClassName">
            Returns the OLE2 Class Name of the object
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFObjectData.GetDirectory">
             Gets the object data. Only call for ones that have
              data though. See {@link #hasDirectoryEntry()}
            
             @return the object data as an OLE2 directory.
             @ if there was an error Reading the data.
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFObjectData.GetObjectData">
            Returns the data portion, for an ObjectData
             that doesn't have an associated POIFS Directory
             Entry
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFObjectData.HasDirectoryEntry">
            Does this ObjectData have an associated POIFS 
             Directory Entry?
            (Not all do, those that don't have a data portion)
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFObjectData.FindObjectRecord">
            Finds the EmbeddedObjectRefSubRecord, or throws an 
             Exception if there wasn't one
        </member>
        <member name="T:NPOI.HSSF.UserModel.HSSFOptimiser">
            <summary>
            Excel can Get cranky if you give it files containing too
            many (especially duplicate) objects, and this class can
            help to avoid those.
            In general, it's much better to make sure you don't
            duplicate the objects in your code, as this is likely
            to be much faster than creating lots and lots of
            excel objects+records, only to optimise them down to
            many fewer at a later stage.
            However, sometimes this is too hard / tricky to do, which
            is where the use of this class comes in.
            </summary>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFOptimiser.OptimiseFonts(NPOI.HSSF.UserModel.HSSFWorkbook)">
            <summary>
            Goes through the Workbook, optimising the fonts by
            removing duplicate ones.
            For now, only works on fonts used in HSSFCellStyle
            and HSSFRichTextString. Any other font uses
            (eg charts, pictures) may well end up broken!
            This can be a slow operation, especially if you have
            lots of cells, cell styles or rich text strings
            </summary>
            <param name="workbook">The workbook in which to optimise the fonts</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFOptimiser.OptimiseCellStyles(NPOI.HSSF.UserModel.HSSFWorkbook)">
            <summary>
            Goes through the Wokrbook, optimising the cell styles
            by removing duplicate ones.
            For best results, optimise the fonts via a call to
            OptimiseFonts(HSSFWorkbook) first
            </summary>
            <param name="workbook">The workbook in which to optimise the cell styles</param>
        </member>
        <member name="T:NPOI.HSSF.UserModel.HSSFPalette">
            <summary>
            Represents a workbook color palette.
            Internally, the XLS format refers to colors using an offset into the palette
            record.  Thus, the first color in the palette has the index 0x8, the second
            has the index 0x9, etc. through 0x40
            @author Brian Sanders (bsanders at risklabs dot com)
            </summary>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFPalette.GetColor(System.Int16)">
            <summary>
            Retrieves the color at a given index
            </summary>
            <param name="index">the palette index, between 0x8 to 0x40 inclusive.</param>
            <returns>the color, or null if the index Is not populated</returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFPalette.FindColor(System.Byte,System.Byte,System.Byte)">
            <summary>
            Finds the first occurance of a given color
            </summary>
            <param name="red">the RGB red component, between 0 and 255 inclusive</param>
            <param name="green">the RGB green component, between 0 and 255 inclusive</param>
            <param name="blue">the RGB blue component, between 0 and 255 inclusive</param>
            <returns>the color, or null if the color does not exist in this palette</returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFPalette.FindSimilarColor(System.Byte,System.Byte,System.Byte)">
            <summary>
            Finds the closest matching color in the custom palette.  The
            method for Finding the distance between the colors Is fairly
            primative.
            </summary>
            <param name="red">The red component of the color to match.</param>
            <param name="green">The green component of the color to match.</param>
            <param name="blue">The blue component of the color to match.</param>
            <returns>The closest color or null if there are no custom
            colors currently defined.</returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFPalette.SetColorAtIndex(System.Int16,System.Byte,System.Byte,System.Byte)">
            <summary>
            Sets the color at the given offset
            </summary>
            <param name="index">the palette index, between 0x8 to 0x40 inclusive</param>
            <param name="red">the RGB red component, between 0 and 255 inclusive</param>
            <param name="green">the RGB green component, between 0 and 255 inclusive</param>
            <param name="blue">the RGB blue component, between 0 and 255 inclusive</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFPalette.AddColor(System.Byte,System.Byte,System.Byte)">
            <summary>
            Adds a new color into an empty color slot.
            </summary>
            <param name="red">The red component</param>
            <param name="green">The green component</param>
            <param name="blue">The blue component</param>
            <returns>The new custom color.</returns>
        </member>
        <member name="T:NPOI.HSSF.UserModel.HSSFPalette.CustomColor">
            <summary>
            user custom color
            </summary>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFPalette.CustomColor.#ctor(System.Int16,System.Byte[])">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HSSF.UserModel.HSSFPalette.CustomColor"/> class.
            </summary>
            <param name="byteOffset">The byte offset.</param>
            <param name="colors">The colors.</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFPalette.CustomColor.#ctor(System.Int16,System.Byte,System.Byte,System.Byte)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HSSF.UserModel.HSSFPalette.CustomColor"/> class.
            </summary>
            <param name="byteOffset">The byte offset.</param>
            <param name="red">The red.</param>
            <param name="green">The green.</param>
            <param name="blue">The blue.</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFPalette.CustomColor.GetIndex">
            <summary>
            Gets index to the standard palette
            </summary>
            <value></value>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFPalette.CustomColor.GetTriplet">
            <summary>
            Gets triplet representation like that in Excel
            </summary>
            <value></value>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFPalette.CustomColor.GetHexString">
            <summary>
            Gets a hex string exactly like a gnumeric triplet
            </summary>
            <value></value>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFPalette.CustomColor.GetGnumericPart(System.Byte)">
            <summary>
            Gets the gnumeric part.
            </summary>
            <param name="color">The color.</param>
            <returns></returns>
        </member>
        <member name="T:NPOI.HSSF.UserModel.HSSFPatriarch">
            <summary>
            The patriarch is the toplevel container for shapes in a sheet.  It does
            little other than act as a container for other shapes and Groups.
            @author Glen Stampoultzis (glens at apache.org)
            </summary>
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFPatriarch.boundAggregate">
            The EscherAggregate we have been bound to.
            (This will handle writing us out into records,
             and building up our shapes from the records)
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFPatriarch.#ctor(NPOI.HSSF.UserModel.HSSFSheet,NPOI.HSSF.Record.EscherAggregate)">
            <summary>
            Creates the patriarch.
            </summary>
            <param name="sheet">the sheet this patriarch is stored in.</param>
            <param name="boundAggregate">The bound aggregate.</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFPatriarch.CreateGroup(NPOI.HSSF.UserModel.HSSFClientAnchor)">
            <summary>
            Creates a new Group record stored Under this patriarch.
            </summary>
            <param name="anchor">the client anchor describes how this Group is attached
            to the sheet.</param>
            <returns>the newly created Group.</returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFPatriarch.CreateSimpleShape(NPOI.HSSF.UserModel.HSSFClientAnchor)">
            <summary>
            Creates a simple shape.  This includes such shapes as lines, rectangles,
            and ovals.
            </summary>
            <param name="anchor">the client anchor describes how this Group is attached
            to the sheet.</param>
            <returns>the newly created shape.</returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFPatriarch.CreatePicture(NPOI.SS.UserModel.ClientAnchor,System.Int32)">
            <summary>
            Creates a picture.
            </summary>
            <param name="anchor">the client anchor describes how this Group is attached
            to the sheet.</param>
            <param name="pictureIndex">Index of the picture.</param>
            <returns>the newly created shape.</returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFPatriarch.CreatePolygon(NPOI.SS.UserModel.ClientAnchor)">
            <summary>
            Creates a polygon
            </summary>
            <param name="anchor">the client anchor describes how this Group is attached
            to the sheet.</param>
            <returns>the newly Created shape.</returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFPatriarch.CreateTextbox(NPOI.SS.UserModel.ClientAnchor)">
            <summary>
            Constructs a textbox Under the patriarch.
            </summary>
            <param name="anchor">the client anchor describes how this Group is attached
            to the sheet.</param>
            <returns>the newly Created textbox.</returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFPatriarch.CreateCellComment(NPOI.SS.UserModel.ClientAnchor)">
            <summary>
            Constructs a cell comment.
            </summary>
            <param name="anchor">the client anchor describes how this comment is attached
            to the sheet.</param>
            <returns>the newly created comment.</returns>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFPatriarch.Children">
            <summary>
            Returns a list of all shapes contained by the patriarch.
            </summary>
            <value>The children.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFPatriarch.CountOfAllChildren">
            <summary>
            Total count of all children and their children's children.
            </summary>
            <value>The count of all children.</value>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFPatriarch.SetCoordinates(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Sets the coordinate space of this Group.  All children are contrained
            to these coordinates.
            </summary>
            <param name="x1">The x1.</param>
            <param name="y1">The y1.</param>
            <param name="x2">The x2.</param>
            <param name="y2">The y2.</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFPatriarch.ContainsChart">
            <summary>
            Does this HSSFPatriarch contain a chart?
            (Technically a reference to a chart, since they
            Get stored in a different block of records)
            FIXME - detect chart in all cases (only seems
            to work on some charts so far)
            </summary>
            <returns>
            	<c>true</c> if this instance contains chart; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFPatriarch.X1">
            <summary>
            The top left x coordinate of this Group.
            </summary>
            <value>The x1.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFPatriarch.Y1">
            <summary>
            The top left y coordinate of this Group.
            </summary>
            <value>The y1.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFPatriarch.X2">
            <summary>
            The bottom right x coordinate of this Group.
            </summary>
            <value>The x2.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFPatriarch.Y2">
            <summary>
            The bottom right y coordinate of this Group.
            </summary>
            <value>The y2.</value>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFPatriarch._GetBoundAggregate">
            <summary>
            Returns the aggregate escher record we're bound to
            </summary>
            <returns></returns>
        </member>
        <member name="T:NPOI.HSSF.UserModel.HSSFPatternFormatting">
            <summary>
            High level representation for Conditional Formatting Settings
            @author Dmitriy Kumshayev
            </summary>
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFPatternFormatting.NO_Fill">
             No background 
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFPatternFormatting.SOLID_FOREGROUND">
             Solidly Filled 
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFPatternFormatting.FINE_DOTS">
             Small fine dots 
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFPatternFormatting.ALT_BARS">
             Wide dots 
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFPatternFormatting.SPARSE_DOTS">
             SParse dots 
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFPatternFormatting.THICK_HORZ_BANDS">
             Thick horizontal bands 
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFPatternFormatting.THICK_VERT_BANDS">
             Thick vertical bands 
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFPatternFormatting.THICK_BACKWARD_DIAG">
             Thick backward facing diagonals 
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFPatternFormatting.THICK_FORWARD_DIAG">
             Thick forward facing diagonals 
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFPatternFormatting.BIG_SPOTS">
             Large spots 
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFPatternFormatting.BRICKS">
             Brick-like layout 
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFPatternFormatting.THIN_HORZ_BANDS">
             Thin horizontal bands 
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFPatternFormatting.THIN_VERT_BANDS">
             Thin vertical bands 
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFPatternFormatting.THIN_BACKWARD_DIAG">
             Thin backward diagonal 
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFPatternFormatting.THIN_FORWARD_DIAG">
             Thin forward diagonal 
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFPatternFormatting.SQUARES">
             Squares 
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFPatternFormatting.DIAMONDS">
             Diamonds 
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFPatternFormatting.LESS_DOTS">
             Less Dots 
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFPatternFormatting.LEAST_DOTS">
             Least Dots 
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFPatternFormatting.#ctor(NPOI.HSSF.Record.CFRuleRecord)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HSSF.UserModel.HSSFPatternFormatting"/> class.
            </summary>
            <param name="cfRuleRecord">The cf rule record.</param>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFPatternFormatting.PatternFormattingBlock">
            <summary>
            Gets the pattern formatting block.
            </summary>
            <value>The pattern formatting block.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFPatternFormatting.FillBackgroundColor">
            <summary>
            Gets or sets the color of the fill background.
            </summary>
            <value>The color of the fill background.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFPatternFormatting.FillForegroundColor">
            <summary>
            Gets or sets the color of the fill foreground.
            </summary>
            <value>The color of the fill foreground.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFPatternFormatting.FillPattern">
            <summary>
            Gets or sets the fill pattern.
            </summary>
            <value>The fill pattern.</value>
        </member>
        <member name="T:NPOI.HSSF.UserModel.HSSFPicture">
            <summary>
            Represents a escher picture.  Eg. A GIF, JPEG etc...
            @author Glen Stampoultzis
            @author Yegor Kozlov (yegor at apache.org)
            </summary>
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFPicture.PX_DEFAULT">
            width of 1px in columns with default width in Units of 1/256 of a Char width
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFPicture.PX_MODIFIED">
            width of 1px in columns with overridden width in Units of 1/256 of a Char width
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFPicture.PX_ROW">
            Height of 1px of a row
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFPicture.Patriarch">
            <summary>
            Gets or sets the patriarch.
            </summary>
            <value>The patriarch.</value>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFPicture.#ctor(NPOI.HSSF.UserModel.HSSFShape,NPOI.HSSF.UserModel.HSSFAnchor)">
            <summary>
            Constructs a picture object.
            </summary>
            <param name="parent">The parent.</param>
            <param name="anchor">The anchor.</param>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFPicture.PictureIndex">
            <summary>
            Gets or sets the index of the picture.
            </summary>
            <value>The index of the picture.</value>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFPicture.Resize(System.Double)">
            <summary>
            Reset the image to the original size.
            </summary>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFPicture.Resize">
            <summary>
            Reset the image to the original size.
            </summary>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFPicture.GetPreferredSize(System.Double)">
            <summary>
            Calculate the preferred size for this picture.
            </summary>
            <param name="scale">the amount by which image dimensions are multiplied relative to the original size.</param>
            <returns>HSSFClientAnchor with the preferred size for this image</returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFPicture.GetPreferredSize">
            <summary>
            Calculate the preferred size for this picture.
            </summary>
            <returns>HSSFClientAnchor with the preferred size for this image</returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFPicture.GetColumnWidthInPixels(System.Int32)">
            <summary>
            Gets the column width in pixels.
            </summary>
            <param name="column">The column.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFPicture.GetRowHeightInPixels(System.Int32)">
            <summary>
            Gets the row height in pixels.
            </summary>
            <param name="i">The row</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFPicture.GetPixelWidth(System.Int32)">
            <summary>
            Gets the width of the pixel.
            </summary>
            <param name="column">The column.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFPicture.GetResolution(System.Drawing.Image)">
            <summary>
            The metadata of PNG and JPEG can contain the width of a pixel in millimeters.
            Return the the "effective" dpi calculated as 
            <c>25.4/HorizontalPixelSize</c>
            and 
            <c>25.4/VerticalPixelSize</c>
            .  Where 25.4 is the number of mm in inch.
            </summary>
            <param name="r">The image.</param>
            <returns>the resolution</returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFPicture.GetImageDimension">
            <summary>
            Return the dimension of this image
            </summary>
            <returns>image dimension</returns>
        </member>
        <member name="T:NPOI.HSSF.UserModel.HSSFPictureData">
            <summary>
            Represents binary data stored in the file.  Eg. A GIF, JPEG etc...
            @author Daniel Noll
            </summary>
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFPictureData.blip">
            Underlying escher blip record containing the bitmap data.
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFPictureData.#ctor(NPOI.DDF.EscherBlipRecord)">
            <summary>
            Constructs a picture object.
            </summary>
            <param name="blip">the underlying blip record containing the bitmap data.</param>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFPictureData.Data">
            <summary>
            Gets the picture data.
            </summary>
            <value>the picture data.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFPictureData.Format">
            <summary>
            gets format of the picture.
            </summary>
            <value>The format.</value>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFPictureData.SuggestFileExtension">
            <summary>
            Suggests a file extension for this image.
            </summary>
            <returns>the file extension.</returns>
        </member>
        <member name="T:NPOI.HSSF.UserModel.HSSFPolygon">
            <summary>
            @author Glen Stampoultzis  (glens at baselinksoftware.com)
            </summary>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFPolygon.SetPolygonDrawArea(System.Int32,System.Int32)">
            Defines the width and height of the points in the polygon
            @param width
            @param height
        </member>
        <member name="T:NPOI.HSSF.UserModel.HSSFPrintSetup">
            <summary>
            Used to modify the print Setup.
            @author Shawn Laubach (slaubach at apache dot org)
            </summary>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFPrintSetup.#ctor(NPOI.HSSF.Record.PrintSetupRecord)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HSSF.UserModel.HSSFPrintSetup"/> class.
            </summary>
            <param name="printSetupRecord">Takes the low level print Setup record.</param>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFPrintSetup.PaperSize">
            <summary>
            Gets or sets the size of the paper.
            </summary>
            <value>The size of the paper.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFPrintSetup.Scale">
            <summary>
            Gets or sets the scale.
            </summary>
            <value>The scale.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFPrintSetup.PageStart">
            <summary>
            Gets or sets the page start.
            </summary>
            <value>The page start.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFPrintSetup.FitWidth">
            <summary>
            Gets or sets the number of pages wide to fit sheet in.
            </summary>
            <value>the number of pages wide to fit sheet in</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFPrintSetup.FitHeight">
            <summary>
            Gets or sets number of pages high to fit the sheet in
            </summary>
            <value>number of pages high to fit the sheet in.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFPrintSetup.Options">
            <summary>
            Gets or sets the bit flags for the options.
            </summary>
            <value>the bit flags for the options.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFPrintSetup.LeftToRight">
            <summary>
            Gets or sets the left to right print order.
            </summary>
            <value>the left to right print order.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFPrintSetup.Landscape">
            <summary>
            Gets or sets the landscape mode.
            </summary>
            <value>the landscape mode.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFPrintSetup.ValidSettings">
            <summary>
            Gets or sets the valid Settings.
            </summary>
            <value>the valid Settings.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFPrintSetup.NoColor">
            <summary>
            Gets or sets the black and white Setting.
            </summary>
            <value>black and white Setting</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFPrintSetup.Draft">
            <summary>
            Gets or sets the draft mode.
            </summary>
            <value>the draft mode.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFPrintSetup.Notes">
            <summary>
            Gets or sets the print notes.
            </summary>
            <value>the print notes.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFPrintSetup.NoOrientation">
            <summary>
            Gets or sets a value indicating whether [no orientation].
            </summary>
            <value><c>true</c> if [no orientation]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFPrintSetup.UsePage">
            <summary>
            Gets or sets the use page numbers.  
            </summary>
            <value>use page numbers.  </value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFPrintSetup.HResolution">
            <summary>
            Gets or sets the horizontal resolution.
            </summary>
            <value>the horizontal resolution.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFPrintSetup.VResolution">
            <summary>
            Gets or sets the vertical resolution.
            </summary>
            <value>the vertical resolution.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFPrintSetup.HeaderMargin">
            <summary>
            Gets or sets the header margin.
            </summary>
            <value>The header margin.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFPrintSetup.FooterMargin">
            <summary>
            Gets or sets the footer margin.
            </summary>
            <value>The footer margin.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFPrintSetup.Copies">
            <summary>
            Gets or sets the number of copies.
            </summary>
            <value>the number of copies.</value>
        </member>
        <member name="T:NPOI.HSSF.UserModel.HSSFRichTextString">
            <summary>
            Rich text Unicode string.  These strings can have fonts applied to
            arbitary parts of the string.
            @author Glen Stampoultzis (glens at apache.org)
            @author Jason Height (jheight at apache.org)
            </summary> 
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFRichTextString.NO_FONT">
            Place holder for indicating that NO_FONT has been applied here 
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFRichTextString.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HSSF.UserModel.HSSFRichTextString"/> class.
            </summary>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFRichTextString.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HSSF.UserModel.HSSFRichTextString"/> class.
            </summary>
            <param name="str">The string.</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFRichTextString.#ctor(NPOI.HSSF.Model.Workbook,NPOI.HSSF.Record.LabelSSTRecord)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HSSF.UserModel.HSSFRichTextString"/> class.
            </summary>
            <param name="book">The workbook.</param>
            <param name="record">The record.</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFRichTextString.SetWorkbookReferences(NPOI.HSSF.Model.Workbook,NPOI.HSSF.Record.LabelSSTRecord)">
            <summary>
            This must be called to Setup the internal work book references whenever
            a RichTextString Is Added to a cell
            </summary>
            <param name="book">The workbook.</param>
            <param name="record">The record.</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFRichTextString.CloneStringIfRequired">
            <summary>
            Called whenever the Unicode string Is modified. When it Is modified
            we need to Create a new SST index, so that other LabelSSTRecords will not
            be affected by Changes tat we make to this string.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFRichTextString.AddToSSTIfRequired">
            <summary>
            Adds to SST if required.
            </summary>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFRichTextString.ApplyFont(System.Int32,System.Int32,System.Int16)">
            <summary>
            Applies a font to the specified Chars of a string.
            </summary>
            <param name="startIndex">The start index to apply the font to (inclusive).</param>
            <param name="endIndex">The end index to apply the font to (exclusive).</param>
            <param name="fontIndex">The font to use.</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFRichTextString.ApplyFont(System.Int32,System.Int32,NPOI.SS.UserModel.Font)">
            <summary>
            Applies a font to the specified Chars of a string.
            </summary>
            <param name="startIndex">The start index to apply the font to (inclusive).</param>
            <param name="endIndex"> The end index to apply to font to (exclusive).</param>
            <param name="font">The index of the font to use.</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFRichTextString.ApplyFont(NPOI.SS.UserModel.Font)">
            <summary>
            Sets the font of the entire string.
            </summary>
            <param name="font">The font to use.</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFRichTextString.ClearFormatting">
            <summary>
            Removes any formatting that may have been applied to the string.
            </summary>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFRichTextString.String">
            <summary>
            Returns the plain string representation.
            </summary>
            <value>The string.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFRichTextString.RawUnicodeString">
            <summary>
            Returns the raw, probably shared Unicode String.
            Used when tweaking the styles, eg updating font
            positions.
            Changes to this string may well effect
            other RichTextStrings too!
            </summary>
            <value>The raw unicode string.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFRichTextString.UnicodeString">
            <summary>
            Gets or sets the unicode string.
            </summary>
            <value>The unicode string.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFRichTextString.Length">
            <summary>
            Gets the number of Chars in the font..
            </summary>
            <value>The length.</value>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFRichTextString.GetFontAtIndex(System.Int32)">
            <summary>
            Returns the font in use at a particular index.
            </summary>
            <param name="index">The index.</param>
            <returns>The font that's currently being applied at that
            index or null if no font Is being applied or the
            index Is out of range.</returns>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFRichTextString.NumFormattingRuns">
            <summary>
            Gets the number of formatting runs used. There will always be at
            least one of font NO_FONT.
            </summary>
            <value>The num formatting runs.</value>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFRichTextString.GetIndexOfFormattingRun(System.Int32)">
            <summary>
            The index within the string to which the specified formatting run applies.
            </summary>
            <param name="index">the index of the formatting run</param>
            <returns>the index within the string.</returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFRichTextString.GetFontOfFormattingRun(System.Int32)">
            <summary>
            Gets the font used in a particular formatting run.
            </summary>
            <param name="index">the index of the formatting run.</param>
            <returns>the font number used.</returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFRichTextString.CompareTo(System.Object)">
            <summary>
            Compares one rich text string to another.
            </summary>
            <param name="o">The o.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFRichTextString.Equals(System.Object)">
            <summary>
            Equalses the specified o.
            </summary>
            <param name="o">The o.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFRichTextString.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFRichTextString.ApplyFont(System.Int16)">
            <summary>
            Applies the specified font to the entire string.
            </summary>
            <param name="fontIndex">Index of the font to apply.</param>
        </member>
        <member name="T:NPOI.HSSF.UserModel.HSSFRow">
            <summary>
            High level representation of a row of a spReadsheet.
            Only rows that have cells should be Added to a Sheet.
            @author  Andrew C. Oliver (acoliver at apache dot org)
            @author Glen Stampoultzis (glens at apache.org)
            </summary>
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFRow.row">
            reference to low level representation
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFRow.book">
            reference to containing low level Workbook
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFRow.sheet">
            reference to containing Sheet
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFRow.#ctor(NPOI.HSSF.UserModel.HSSFWorkbook,NPOI.HSSF.UserModel.HSSFSheet,System.Int32)">
             <summary>
             Creates new HSSFRow from scratch. Only HSSFSheet should do this.
             </summary>
             <param name="book">low-level Workbook object containing the sheet that Contains this row</param>
             <param name="sheet">low-level Sheet object that Contains this Row</param>
             <param name="rowNum">the row number of this row (0 based)</param>
            <see cref="M:NPOI.HSSF.UserModel.HSSFSheet.CreateRow(System.Int32)"/>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFRow.#ctor(NPOI.HSSF.UserModel.HSSFWorkbook,NPOI.HSSF.UserModel.HSSFSheet,NPOI.HSSF.Record.RowRecord)">
             <summary>
             Creates an HSSFRow from a low level RowRecord object.  Only HSSFSheet should do
             this.  HSSFSheet uses this when an existing file is Read in.
             </summary>
             <param name="book">low-level Workbook object containing the sheet that Contains this row</param>
             <param name="sheet"> low-level Sheet object that Contains this Row</param>
             <param name="record">the low level api object this row should represent</param>
            <see cref="M:NPOI.HSSF.UserModel.HSSFSheet.CreateRow(System.Int32)"/>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFRow.CreateCell(System.Int32)">
            <summary>
            Use this to Create new cells within the row and return it.
            The cell that is returned is a CELL_TYPE_BLANK. The type can be Changed
            either through calling <c>SetCellValue</c> or <c>SetCellType</c>.
            </summary>
            <param name="column">the column number this cell represents</param>
            <returns>a high level representation of the Created cell.</returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFRow.CreateCell(System.Int32,NPOI.SS.UserModel.CellType)">
            <summary>
            Use this to create new cells within the row and return it.
            The cell that is returned is a CELL_TYPE_BLANK. The type can be changed
            either through calling setCellValue or setCellType.
            </summary>
            <param name="columnIndex">the column number this cell represents</param>
            <param name="type">a high level representation of the created cell.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFRow.RemoveCell(NPOI.SS.UserModel.Cell)">
            <summary>
            Remove the Cell from this row.
            </summary>
            <param name="cell">The cell to Remove.</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFRow.RemoveCell(NPOI.SS.UserModel.Cell,System.Boolean)">
            <summary>
            Removes the cell.
            </summary>
            <param name="cell">The cell.</param>
            <param name="alsoRemoveRecords">if set to <c>true</c> [also remove records].</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFRow.CreateCellFromRecord(NPOI.HSSF.Record.CellValueRecordInterface)">
            <summary>
            Create a high level Cell object from an existing low level record.  Should
            only be called from HSSFSheet or HSSFRow itself.
            </summary>
            <param name="cell">The low level cell to Create the high level representation from</param>
            <returns> the low level record passed in</returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFRow.RemoveAllCells">
            <summary>
            Removes all the cells from the row, and their
            records too.
            </summary>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFRow.RowNum">
            <summary>
            Get row number this row represents
            </summary>
            <value>the row number (0 based)</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFRow.OutlineLevel">
            <summary>
            Returns the rows outline level. Increased as you
            put it into more Groups (outlines), reduced as
            you take it out of them.
            </summary>
            <value>The outline level.</value>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFRow.MoveCell(NPOI.SS.UserModel.Cell,System.Int32)">
            <summary>
            Moves the supplied cell to a new column, which
            must not already have a cell there!
            </summary>
            <param name="cell">The cell to move</param>
            <param name="newColumn">The new column number (0 based)</param>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFRow.Sheet">
             Returns the HSSFSheet this row belongs to
            
             @return the HSSFSheet that owns this row
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFRow.AddCell(NPOI.SS.UserModel.Cell)">
            <summary>
            used internally to Add a cell.
            </summary>
            <param name="cell">The cell.</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFRow.RetrieveCell(System.Int32)">
            <summary>
            Get the hssfcell representing a given column (logical cell)
            0-based. If you ask for a cell that is not defined, then
            you Get a null.
            This is the basic call, with no policies applied
            </summary>
            <param name="cellnum">0 based column number</param>
            <returns>Cell representing that column or null if Undefined.</returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFRow.GetCell(System.Int16)">
            <summary>
            Get the hssfcell representing a given column (logical cell)
            0-based.  If you ask for a cell that is not defined then
            you Get a null, Unless you have Set a different
            MissingCellPolicy on the base workbook.
            Short method signature provided to retain binary
            compatibility.
            </summary>
            <param name="cellnum">0 based column number</param>
            <returns>Cell representing that column or null if Undefined.</returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFRow.GetCell(System.Int32)">
            <summary>
            Get the hssfcell representing a given column (logical cell)
            0-based.  If you ask for a cell that is not defined then
            you Get a null, Unless you have Set a different
            on the base workbook.
            </summary>
            <param name="cellnum">0 based column number</param>
            <returns>Cell representing that column or null if Undefined.</returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFRow.GetCell(System.Int32,NPOI.SS.UserModel.MissingCellPolicy)">
            <summary>
            Get the hssfcell representing a given column (logical cell)
            0-based.  If you ask for a cell that is not defined, then
            your supplied policy says what to do
            </summary>
            <param name="cellnum">0 based column number</param>
            <param name="policy">Policy on blank / missing cells</param>
            <returns>that column or null if Undefined + policy allows.</returns>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFRow.FirstCellNum">
            <summary>
            Get the number of the first cell contained in this row.
            </summary>
            <value>the first logical cell in the row, or -1 if the row does not contain any cells.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFRow.LastCellNum">
             <summary>
             Gets the index of the last cell contained in this row PLUS ONE
             . The result also happens to be the 1-based column number of the last cell.  This value can be used as a
             standard upper bound when iterating over cells:
             </summary>
             <value>
             short representing the last logical cell in the row PLUS ONE, or -1 if the
             row does not contain any cells.
            </value>
             <example>
             short minColIx = row.GetFirstCellNum();
             short maxColIx = row.GetLastCellNum();
             for(short colIx=minColIx; colIx&lt;maxColIx; colIx++) {
             Cell cell = row.GetCell(colIx);
             if(cell == null) {
             continue;
             }
             //... do something with cell
             }
             </example>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFRow.PhysicalNumberOfCells">
            <summary>
            Gets the number of defined cells (NOT number of cells in the actual row!).
            That is to say if only columns 0,4,5 have values then there would be 3.
            </summary>
            <value>the number of defined cells in the row.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFRow.ZeroHeight">
            <summary>
            Gets or sets  whether or not to Display this row with 0 height
            </summary>
            <value>height is zero or not.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFRow.Height">
            <summary>
            Get or sets the row's height or ff (-1) for Undefined/default-height in twips (1/20th of a point)
            </summary>
            <value>rowheight or 0xff for Undefined (use sheet default)</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFRow.IsFormatted">
            <summary>
            is this row formatted? Most aren't, but some rows
            do have whole-row styles. For those that do, you
            can get the formatting from {@link #getRowStyle()}
            </summary>
            <value>
            	<c>true</c> if this instance is formatted; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFRow.RowStyle">
            <summary>
            Returns the whole-row cell styles. Most rows won't
            have one of these, so will return null. Call IsFormmated to check first
            </summary>
            <value>The row style.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFRow.HeightInPoints">
            <summary>
            Get the row's height or ff (-1) for Undefined/default-height in points (20*Height)
            </summary>
            <value>row height or 0xff for Undefined (use sheet default).</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFRow.RowRecord">
            <summary>
            Get the lowlevel RowRecord represented by this object - should only be called
            by other parts of the high level API
            </summary>
            <value>RowRecord this row represents</value>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFRow.FindLastCell(System.Int32)">
            <summary>
            used internally to refresh the "last cell" when the last cell is Removed.
            </summary>
            <param name="lastcell">The last cell index</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFRow.FindFirstCell(System.Int32)">
            <summary>
            used internally to refresh the "first cell" when the first cell is Removed.
            </summary>
            <param name="firstcell">The first cell index.</param>
            <returns></returns>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFRow.Cells">
            <summary>
            Get cells in the row
            </summary>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFRow.GetCellEnumerator">
            <summary>
            Gets the cell enumerator of the physically defined cells.
            </summary>
            <remarks>
            Note that the 4th element might well not be cell 4, as the iterator
            will not return Un-defined (null) cells.
            Call CellNum on the returned cells to know which cell they are.
            </remarks>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFRow.CompareTo(System.Object)">
            <summary>
            Compares the current instance with another object of the same type and returns an integer that indicates whether the current instance precedes, follows, or occurs in the same position in the sort order as the other object.
            </summary>
            <param name="obj">An object to compare with this instance.</param>
            <returns>
            A 32-bit signed integer that indicates the relative order of the objects being compared. The return value has these meanings:
            Value
            Meaning
            Less than zero
            This instance is less than <paramref name="obj"/>.
            Zero
            This instance is equal to <paramref name="obj"/>.
            Greater than zero
            This instance is greater than <paramref name="obj"/>.
            </returns>
            <exception cref="T:System.ArgumentException">
            	<paramref name="obj"/> is not the same type as this instance.
            </exception>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFRow.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with the current <see cref="T:System.Object"/>.</param>
            <returns>
            true if the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>; otherwise, false.
            </returns>
            <exception cref="T:System.NullReferenceException">
            The <paramref name="obj"/> parameter is null.
            </exception>
        </member>
        <member name="T:NPOI.HSSF.UserModel.HSSFShape">
            <summary>
            An abstract shape.
            @author Glen Stampoultzis (glens at apache.org)
            </summary>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFShape.#ctor(NPOI.SS.UserModel.Shape,NPOI.HSSF.UserModel.HSSFAnchor)">
            <summary>
            Create a new shape with the specified parent and anchor.
            </summary>
            <param name="parent">The parent.</param>
            <param name="anchor">The anchor.</param>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFShape.Parent">
            <summary>
            Gets the parent shape.
            </summary>
            <value>The parent.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFShape.Anchor">
            <summary>
            Gets or sets the anchor that is used by this shape.
            </summary>
            <value>The anchor.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFShape.LineStyleColor">
            <summary>
            The color applied to the lines of this shape.
            </summary>
            <value>The color of the line style.</value>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFShape.SetLineStyleColor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Sets the color applied to the lines of this shape
            </summary>
            <param name="red">The red.</param>
            <param name="green">The green.</param>
            <param name="blue">The blue.</param>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFShape.FillColor">
            <summary>
            Gets or sets the color used to fill this shape.
            </summary>
            <value>The color of the fill.</value>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFShape.SetFillColor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Sets the color used to fill this shape.
            </summary>
            <param name="red">The red.</param>
            <param name="green">The green.</param>
            <param name="blue">The blue.</param>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFShape.LineWidth">
            <summary>
            Gets or sets with width of the line in EMUs.  12700 = 1 pt.
            </summary>
            <value>The width of the line.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFShape.LineStyle">
            <summary>
            Gets or sets One of the constants in LINESTYLE_*
            </summary>
            <value>The line style.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFShape.IsNoFill">
            <summary>
            Gets or sets a value indicating whether this instance is no fill.
            </summary>
            <value>
            	<c>true</c> if this shape Is not filled with a color; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFShape.CountOfAllChildren">
            <summary>
            Count of all children and their childrens children.
            </summary>
            <value>The count of all children.</value>
        </member>
        <member name="T:NPOI.HSSF.UserModel.HSSFShapeContainer">
            <summary>
            An interface that indicates whether a class can contain children.
            @author Glen Stampoultzis (glens at apache.org)
            </summary>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFShapeContainer.Children">
            <summary>
            Gets Any children contained by this shape.
            </summary>
            <value>The children.</value>
        </member>
        <member name="T:NPOI.HSSF.UserModel.HSSFShapeGroup">
            <summary>
            A shape Group may contain other shapes.  It was no actual form on the
            sheet.
            @author Glen Stampoultzis (glens at apache.org)
            </summary>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFShapeGroup.CreateGroup(NPOI.HSSF.UserModel.HSSFChildAnchor)">
            <summary>
            Create another Group Under this Group.
            </summary>
            <param name="anchor">the position of the new Group.</param>
            <returns>the Group</returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFShapeGroup.CreateShape(NPOI.HSSF.UserModel.HSSFChildAnchor)">
            <summary>
            Create a new simple shape Under this Group.
            </summary>
            <param name="anchor">the position of the shape.</param>
            <returns>the shape</returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFShapeGroup.CreateTextbox(NPOI.HSSF.UserModel.HSSFChildAnchor)">
            <summary>
            Create a new textbox Under this Group.
            </summary>
            <param name="anchor">the position of the shape.</param>
            <returns>the textbox</returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFShapeGroup.CreatePolygon(NPOI.HSSF.UserModel.HSSFChildAnchor)">
            <summary>
            Creates a polygon
            </summary>
            <param name="anchor">the client anchor describes how this Group Is attached
            to the sheet.</param>
            <returns>the newly Created shape.</returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFShapeGroup.CreatePicture(NPOI.HSSF.UserModel.HSSFChildAnchor,System.Int32)">
            <summary>
            Creates a picture.
            </summary>
            <param name="anchor">the client anchor describes how this Group Is attached
            to the sheet.</param>
            <param name="pictureIndex">Index of the picture.</param>
            <returns>the newly Created shape.</returns>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFShapeGroup.Children">
            <summary>
            Return all children contained by this shape.
            </summary>
            <value></value>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFShapeGroup.SetCoordinates(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Sets the coordinate space of this Group.  All children are constrained
            to these coordinates.
            </summary>
            <param name="x1">The x1.</param>
            <param name="y1">The y1.</param>
            <param name="x2">The x2.</param>
            <param name="y2">The y2.</param>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFShapeGroup.X1">
            <summary>
            Gets The top left x coordinate of this Group.
            </summary>
            <value>The x1.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFShapeGroup.Y1">
            <summary>
            Gets The top left y coordinate of this Group.
            </summary>
            <value>The y1.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFShapeGroup.X2">
            <summary>
            Gets The bottom right x coordinate of this Group.
            </summary>
            <value>The x2.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFShapeGroup.Y2">
            <summary>
            Gets the bottom right y coordinate of this Group.
            </summary>
            <value>The y2.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFShapeGroup.CountOfAllChildren">
            <summary>
            Count of all children and their childrens children.
            </summary>
            <value></value>
        </member>
        <member name="T:NPOI.HSSF.UserModel.HSSFSheet">
            <summary>
            High level representation of a worksheet.
            </summary>
            <remarks>
            @author  Andrew C. Oliver (acoliver at apache dot org)
            @author  Glen Stampoultzis (glens at apache.org)
            @author  Libin Roman (romal at vistaportal.com)
            @author  Shawn Laubach (slaubach at apache dot org) (Just a little)
            @author  Jean-Pierre Paris (jean-pierre.paris at m4x dot org) (Just a little, too)
            @author  Yegor Kozlov (yegor at apache.org) (Autosizing columns)
            </remarks>
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFSheet.INITIAL_CAPACITY">
            Used for compile-time optimization.  This is the initial size for the collection of
            rows.  It is currently Set to 20.  If you generate larger sheets you may benefit
            by Setting this to a higher number and recompiling a custom edition of HSSFSheet.
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFSheet._sheet">
            reference to the low level Sheet object
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.#ctor(NPOI.HSSF.UserModel.HSSFWorkbook)">
            <summary>
            Creates new HSSFSheet   - called by HSSFWorkbook to Create a _sheet from
            scratch.  You should not be calling this from application code (its protected anyhow).
            </summary>
            <param name="_workbook">The HSSF Workbook object associated with the _sheet..</param>
            <see cref="M:NPOI.HSSF.UserModel.HSSFWorkbook.CreateSheet"/>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.#ctor(NPOI.HSSF.UserModel.HSSFWorkbook,NPOI.HSSF.Model.Sheet)">
            <summary>
            Creates an HSSFSheet representing the given Sheet object.  Should only be
            called by HSSFWorkbook when Reading in an exisiting file.
            </summary>
            <param name="_workbook">The HSSF Workbook object associated with the _sheet.</param>
            <param name="_sheet">lowlevel Sheet object this _sheet will represent</param>
            <see cref="M:NPOI.HSSF.UserModel.HSSFWorkbook.CreateSheet"/>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.CloneSheet(NPOI.HSSF.UserModel.HSSFWorkbook)">
            <summary>
            Clones the _sheet.
            </summary>
            <param name="_workbook">The _workbook.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.SetPropertiesFromSheet(NPOI.HSSF.Model.Sheet)">
            <summary>
            used internally to Set the properties given a Sheet object
            </summary>
            <param name="_sheet">The _sheet.</param>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFSheet.DisplayZeros">
            Gets the flag indicating whether the window should show 0 (zero) in cells containing zero value.
            When false, cells with zero value appear blank instead of showing the number zero.
            In Excel 2003 this option can be changed in the Options dialog on the View tab.
            @return whether all zero values on the worksheet are displayed
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.CreateRow(System.Int32)">
            <summary>
            Create a new row within the _sheet and return the high level representation
            </summary>
            <param name="rownum">The row number.</param>
            <returns></returns>
            @see org.apache.poi.hssf.usermodel.HSSFRow
            @see #RemoveRow(HSSFRow)
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.CreateRowFromRecord(NPOI.HSSF.Record.RowRecord)">
            <summary>
            Used internally to Create a high level Row object from a low level row object.
            USed when Reading an existing file
            </summary>
            <param name="row">low level record to represent as a high level Row and Add to _sheet.</param>
            <returns>HSSFRow high level representation</returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.RemoveRow(NPOI.SS.UserModel.Row)">
            <summary>
            Remove a row from this _sheet.  All cells contained in the row are Removed as well
            </summary>
            <param name="row">the row to Remove.</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.FindLastRow(System.Int32)">
            <summary>
            used internally to refresh the "last row" when the last row is Removed.
            </summary>
            <param name="lastrow">The last row.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.FindFirstRow(System.Int32)">
            <summary>
            used internally to refresh the "first row" when the first row is Removed.
            </summary>
            <param name="firstrow">The first row.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.AddRow(NPOI.HSSF.UserModel.HSSFRow,System.Boolean)">
             Add a row to the _sheet
            
             @param AddLow whether to Add the row to the low level model - false if its already there
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.GetColumnStyle(System.Int32)">
            <summary>
            Returns the HSSFCellStyle that applies to the given
            (0 based) column, or null if no style has been
            set for that column
            </summary>
            <param name="column">The column.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.GetRow(System.Int32)">
            <summary>
            Returns the logical row (not physical) 0-based.  If you ask for a row that is not
            defined you get a null.  This is to say row 4 represents the fifth row on a _sheet.
            </summary>
            <param name="rowIndex">Index of the row to get.</param>
            <returns>the row number or null if its not defined on the _sheet</returns>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFSheet.PhysicalNumberOfRows">
            <summary>
            Returns the number of phsyically defined rows (NOT the number of rows in the _sheet)
            </summary>
            <value>The physical number of rows.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFSheet.FirstRowNum">
            <summary>
            Gets the first row on the _sheet
            </summary>
            <value>the number of the first logical row on the _sheet</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFSheet.LastRowNum">
            <summary>
            Gets the last row on the _sheet
            </summary>
            <value>last row contained n this _sheet.</value>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.AddValidationData(NPOI.HSSF.UserModel.HSSFDataValidation)">
            <summary>
            Creates a data validation object
            </summary>
            <param name="dataValidation">The Data validation object settings</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.SetColumnHidden(System.Int32,System.Boolean)">
            <summary>
            Get the visibility state for a given column.F:\Gloria\研究\文件格式\NPOI\src\NPOI\HSSF\Util\HSSFDataValidation.cs
            </summary>
            <param name="column">the column to Get (0-based).</param>
            <param name="hidden">the visiblity state of the column.</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.IsColumnHidden(System.Int32)">
            <summary>
            Get the hidden state for a given column.
            </summary>
            <param name="column">the column to Set (0-based)</param>
            <returns>the visiblity state of the column;
            </returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.SetColumnWidth(System.Int32,System.Int32)">
            <summary>
            Set the width (in Units of 1/256th of a Char width)
            </summary>
            <param name="column">the column to Set (0-based)</param>
            <param name="width">the width in Units of 1/256th of a Char width</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.GetColumnWidth(System.Int32)">
            <summary>
            Get the width (in Units of 1/256th of a Char width )
            </summary>
            <param name="column">the column to Set (0-based)</param>
            <returns>the width in Units of 1/256th of a Char width</returns>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFSheet.DefaultColumnWidth">
            <summary>
            Gets or sets the default width of the column.
            </summary>
            <value>The default width of the column.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFSheet.DefaultRowHeight">
            <summary>
            Get the default row height for the _sheet (if the rows do not define their own height) in
            twips (1/20 of  a point)
            </summary>
            <value>The default height of the row.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFSheet.DefaultRowHeightInPoints">
            <summary>
            Get the default row height for the _sheet (if the rows do not define their own height) in
            points.
            </summary>
            <value>The default row height in points.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFSheet.IsGridsPrinted">
            <summary>
            Get whether gridlines are printed.
            </summary>
            <value>
            	<c>true</c> if printed; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.AddMergedRegion(NPOI.SS.Util.Region)">
            <summary>
            Adds a merged region of cells (hence those cells form one)
            </summary>
            <param name="region">The region (rowfrom/colfrom-rowto/colto) to merge.</param>
            <returns>index of this region</returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.AddMergedRegion(NPOI.SS.Util.CellRangeAddress)">
            <summary>
            adds a merged region of cells (hence those cells form one)
            </summary>
            <param name="region">region (rowfrom/colfrom-rowto/colto) to merge</param>
            <returns>index of this region</returns>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFSheet.ForceFormulaRecalculation">
            <summary>
            Whether a record must be Inserted or not at generation to indicate that
            formula must be recalculated when _workbook is opened.
            </summary>
            <value>
            	<c>true</c> if [force formula recalculation]; otherwise, <c>false</c>.
            </value>
            @return true if an Uncalced record must be Inserted or not at generation
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFSheet.VerticallyCenter">
            <summary>
            Determine whether printed output for this _sheet will be vertically centered.
            </summary>
            <value><c>true</c> if [vertically center]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFSheet.HorizontallyCenter">
            <summary>
            Determine whether printed output for this _sheet will be horizontally centered.
            </summary>
            <value><c>true</c> if [horizontally center]; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.RemoveMergedRegion(System.Int32)">
            <summary>
            Removes a merged region of cells (hence letting them free)
            </summary>
            <param name="index">index of the region to Unmerge</param>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFSheet.NumMergedRegions">
            <summary>
            returns the number of merged regions
            </summary>
            <value>The number of merged regions</value>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.GetMergedRegionAt(System.Int32)">
            Gets the region at a particular index
            @param index of the region to fetch
            @return the merged region (simple eh?)
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.GetRowEnumerator">
            <summary>
            Gets the row enumerator.
            </summary>
            <returns></returns>
            @return an iterator of the PHYSICAL rows.  Meaning the 3rd element may not
            be the third row if say for instance the second row is Undefined.
            Call RowNum on each row if you care which one it Is.
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFSheet.Sheet">
            <summary>
            used internally in the API to Get the low level Sheet record represented by this
            Object.
            </summary>
            <value>low level representation of this HSSFSheet.</value>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.SetActiveCell(System.Int32,System.Int32)">
            <summary>
            Sets the active cell.
            </summary>
            <param name="row">The row.</param>
            <param name="column">The column.</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.SetActiveCellRange(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Sets the active cell range.
            </summary>
            <param name="firstrow">The firstrow.</param>
            <param name="lastrow">The lastrow.</param>
            <param name="firstcolumn">The firstcolumn.</param>
            <param name="lastcolumn">The lastcolumn.</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.SetActiveCellRange(System.Collections.Generic.List{NPOI.SS.Util.CellRangeAddress8Bit},System.Int32,System.Int32,System.Int32)">
            <summary>
            Sets the active cell range.
            </summary>
            <param name="cellranges">The cellranges.</param>
            <param name="activeRange">The index of the active range.</param>
            <param name="activeRow">The active row in the active range</param>
            <param name="activeColumn">The active column in the active range</param>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFSheet.AlternativeExpression">
            <summary>
            Gets or sets whether alternate expression evaluation is on
            </summary>
            <value>
            	<c>true</c> if [alternative expression]; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFSheet.AlternativeFormula">
            <summary>
            whether alternative formula entry is on
            </summary>
            <value><c>true</c> alternative formulas or not; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFSheet.Autobreaks">
            <summary>
            show automatic page breaks or not
            </summary>
            <value>whether to show auto page breaks</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFSheet.Dialog">
            <summary>
            Gets or sets a value indicating whether _sheet is a dialog _sheet
            </summary>
            <value><c>true</c> if is dialog; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFSheet.DisplayGuts">
            <summary>
            Gets or sets a value indicating whether to Display the guts or not.
            </summary>
            <value><c>true</c> if guts or no guts (or glory); otherwise, <c>false</c>.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFSheet.FitToPage">
            <summary>
            Gets or sets a value indicating whether fit to page option is on
            </summary>
            <value><c>true</c> if [fit to page]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFSheet.RowSumsBelow">
            <summary>
            Get if row summaries appear below detail in the outline
            </summary>
            <value><c>true</c> if below or not; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFSheet.RowSumsRight">
            <summary>
            Get if col summaries appear right of the detail in the outline
            </summary>
            <value><c>true</c> right or not; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFSheet.IsPrintGridlines">
            <summary>
            Gets or sets whether gridlines are printed.
            </summary>
            <value>
            	<c>true</c> Gridlines are printed; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFSheet.PrintSetup">
            <summary>
            Gets the print setup object.
            </summary>
            <value>The user model for the print setup object.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFSheet.Header">
            <summary>
            Gets the user model for the document header.
            </summary>
            <value>The Document header.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFSheet.Footer">
            <summary>
            Gets the user model for the document footer.
            </summary>
            <value>The Document footer.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFSheet.IsArabic">
            <summary>
            Gets or sets whether the worksheet is displayed from right to left instead of from left to right.
            </summary>
            <value>true for right to left, false otherwise</value>
            <remarks>poi bug 47970</remarks>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFSheet.IsSelected">
            <summary>
            Note - this is not the same as whether the _sheet is focused (isActive)
            </summary>
            <value>
            	<c>true</c> if this _sheet is currently selected; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFSheet.IsActive">
            <summary>
            Gets or sets a value indicating if this _sheet is currently focused.
            </summary>
            <value><c>true</c> if this _sheet is currently focused; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFSheet.Protect">
            <summary>
            Answer whether protection is enabled or disabled
            </summary>
            <value><c>true</c> if protection enabled; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFSheet.Password">
            <summary>
            Gets the hashed password
            </summary>
            <value>The password.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFSheet.ObjectProtect">
            <summary>
            Answer whether object protection is enabled or disabled
            </summary>
            <value><c>true</c> if protection enabled; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFSheet.ScenarioProtect">
            <summary>
            Answer whether scenario protection is enabled or disabled
            </summary>
            <value><c>true</c> if protection enabled; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.ProtectSheet(System.String)">
            <summary>
            Sets the protection enabled as well as the password
            </summary>
            <param name="password">The password to set for protection.</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.SetZoom(System.Int32,System.Int32)">
            <summary>
            Sets the zoom magnication for the _sheet.  The zoom is expressed as a
            fraction.  For example to express a zoom of 75% use 3 for the numerator
            and 4 for the denominator.
            </summary>
            <param name="numerator">The numerator for the zoom magnification.</param>
            <param name="denominator">The denominator for the zoom magnification.</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.SetEnclosedBorderOfRegion(NPOI.SS.Util.CellRangeAddress,NPOI.SS.UserModel.CellBorderType,System.Int16)">
            <summary>
            Sets the enclosed border of region.
            </summary>
            <param name="region">The region.</param>
            <param name="borderType">Type of the border.</param>
            <param name="color">The color.</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.SetBorderRightOfRegion(NPOI.SS.Util.CellRangeAddress,NPOI.SS.UserModel.CellBorderType,System.Int16)">
            <summary>
            Sets the right border of region.
            </summary>
            <param name="region">The region.</param>
            <param name="borderType">Type of the border.</param>
            <param name="color">The color.</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.SetBorderLeftOfRegion(NPOI.SS.Util.CellRangeAddress,NPOI.SS.UserModel.CellBorderType,System.Int16)">
            <summary>
            Sets the left border of region.
            </summary>
            <param name="region">The region.</param>
            <param name="borderType">Type of the border.</param>
            <param name="color">The color.</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.SetBorderTopOfRegion(NPOI.SS.Util.CellRangeAddress,NPOI.SS.UserModel.CellBorderType,System.Int16)">
            <summary>
            Sets the top border of region.
            </summary>
            <param name="region">The region.</param>
            <param name="borderType">Type of the border.</param>
            <param name="color">The color.</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.SetBorderBottomOfRegion(NPOI.SS.Util.CellRangeAddress,NPOI.SS.UserModel.CellBorderType,System.Int16)">
            <summary>
            Sets the bottom border of region.
            </summary>
            <param name="region">The region.</param>
            <param name="borderType">Type of the border.</param>
            <param name="color">The color.</param>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFSheet.TopRow">
            <summary>
            The top row in the visible view when the _sheet is
            first viewed after opening it in a viewer
            </summary>
            <value>the rownum (0 based) of the top row</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFSheet.LeftCol">
            <summary>
            The left col in the visible view when the _sheet Is
            first viewed after opening it in a viewer
            </summary>
            <value>the rownum (0 based) of the top row</value>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.ShowInPane(System.Int16,System.Int16)">
            <summary>
            Sets desktop window pane display area, when the
            file is first opened in a viewer.
            </summary>
            <param name="toprow">the top row to show in desktop window pane</param>
            <param name="leftcol">the left column to show in desktop window pane</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.ShiftMerged(System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Shifts the merged regions left or right depending on mode
            TODO: MODE , this is only row specific
            </summary>
            <param name="startRow">The start row.</param>
            <param name="endRow">The end row.</param>
            <param name="n">The n.</param>
            <param name="IsRow">if set to <c>true</c> [is row].</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.ShiftRows(System.Int32,System.Int32,System.Int32)">
            <summary>
            Shifts rows between startRow and endRow n number of rows.
            If you use a negative number, it will Shift rows up.
            Code Ensures that rows don't wrap around.
            Calls ShiftRows(startRow, endRow, n, false, false);
            Additionally Shifts merged regions that are completely defined in these
            rows (ie. merged 2 cells on a row to be Shifted).
            </summary>
            <param name="startRow">the row to start Shifting</param>
            <param name="endRow">the row to end Shifting</param>
            <param name="n">the number of rows to Shift</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.ShiftRows(System.Int32,System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Shifts rows between startRow and endRow n number of rows.
            If you use a negative number, it will shift rows up.
            Code ensures that rows don't wrap around
            Additionally shifts merged regions that are completely defined in these
            rows (ie. merged 2 cells on a row to be shifted).
            TODO Might want to add bounds checking here
            </summary>
            <param name="startRow">the row to start shifting</param>
            <param name="endRow">the row to end shifting</param>
            <param name="n">the number of rows to shift</param>
            <param name="copyRowHeight">whether to copy the row height during the shift</param>
            <param name="resetOriginalRowHeight">whether to set the original row's height to the default</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.ShiftRows(System.Int32,System.Int32,System.Int32,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Shifts rows between startRow and endRow n number of rows.
            If you use a negative number, it will Shift rows up.
            Code Ensures that rows don't wrap around
            Additionally Shifts merged regions that are completely defined in these
            rows (ie. merged 2 cells on a row to be Shifted).
            TODO Might want to Add bounds Checking here
            </summary>
            <param name="startRow">the row to start Shifting</param>
            <param name="endRow">the row to end Shifting</param>
            <param name="n">the number of rows to Shift</param>
            <param name="copyRowHeight">whether to copy the row height during the Shift</param>
            <param name="resetOriginalRowHeight">whether to Set the original row's height to the default</param>
            <param name="moveComments">if set to <c>true</c> [move comments].</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.InsertChartRecords(System.Collections.IList)">
            <summary>
            Inserts the chart records.
            </summary>
            <param name="records">The records.</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.CreateFreezePane(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a split (freezepane). Any existing freezepane or split pane is overwritten.
            </summary>
            <param name="colSplit">Horizonatal position of split.</param>
            <param name="rowSplit">Vertical position of split.</param>
            <param name="leftmostColumn">Top row visible in bottom pane</param>
            <param name="topRow">Left column visible in right pane.</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.CreateFreezePane(System.Int32,System.Int32)">
            <summary>
            Creates a split (freezepane). Any existing freezepane or split pane is overwritten.
            </summary>
            <param name="colSplit">Horizonatal position of split.</param>
            <param name="rowSplit">Vertical position of split.</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.CreateSplitPane(System.Int32,System.Int32,System.Int32,System.Int32,NPOI.SS.UserModel.PanePosition)">
            <summary>
            Creates a split pane. Any existing freezepane or split pane is overwritten.
            </summary>
            <param name="xSplitPos">Horizonatal position of split (in 1/20th of a point).</param>
            <param name="ySplitPos">Vertical position of split (in 1/20th of a point).</param>
            <param name="leftmostColumn">Top row visible in bottom pane</param>
            <param name="topRow">Left column visible in right pane.</param>
            <param name="activePane">Active pane.  One of: PANE_LOWER_RIGHT,PANE_UPPER_RIGHT, PANE_LOWER_LEFT, PANE_UPPER_LEFT</param>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFSheet.PaneInformation">
            <summary>
            Returns the information regarding the currently configured pane (split or freeze).
            </summary>
            <value>null if no pane configured, or the pane information.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFSheet.DisplayGridlines">
            <summary>
            Gets or sets if gridlines are Displayed.
            </summary>
            <value>whether gridlines are Displayed</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFSheet.DisplayFormulas">
            <summary>
            Gets or sets a value indicating whether formulas are displayed.
            </summary>
            <value>whether formulas are Displayed</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFSheet.DisplayRowColHeadings">
            <summary>
            Gets or sets a value indicating whether RowColHeadings are displayed.
            </summary>
            <value>
            	whether RowColHeadings are displayed
            </value>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.GetMargin(NPOI.SS.UserModel.MarginType)">
            <summary>
            Gets the size of the margin in inches.
            </summary>
            <param name="margin">which margin to get.</param>
            <returns>the size of the margin</returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.SetMargin(NPOI.SS.UserModel.MarginType,System.Double)">
            <summary>
            Sets the size of the margin in inches.
            </summary>
            <param name="margin">which margin to get.</param>
            <param name="size">the size of the margin</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.SetRowBreak(System.Int32)">
            <summary>
            Sets a page break at the indicated row
            </summary>
            <param name="row">The row.</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.IsRowBroken(System.Int32)">
            <summary>
            Determines if there is a page break at the indicated row
            </summary>
            <param name="row">The row.</param>
            <returns>
            	<c>true</c> if [is row broken] [the specified row]; otherwise, <c>false</c>.
            </returns>        
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.RemoveRowBreak(System.Int32)">
            <summary>
            Removes the page break at the indicated row
            </summary>
            <param name="row">The row.</param>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFSheet.RowBreaks">
            <summary>
            Retrieves all the horizontal page breaks
            </summary>
            <value>all the horizontal page breaks, or null if there are no row page breaks</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFSheet.ColumnBreaks">
            <summary>
            Retrieves all the vertical page breaks
            </summary>
            <value>all the vertical page breaks, or null if there are no column page breaks</value>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.SetColumnBreak(System.Int32)">
            <summary>
            Sets a page break at the indicated column
            </summary>
            <param name="column">The column.</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.IsColumnBroken(System.Int32)">
            <summary>
            Determines if there is a page break at the indicated column
            </summary>
            <param name="column">The column.</param>
            <returns>
            	<c>true</c> if [is column broken] [the specified column]; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.RemoveColumnBreak(System.Int32)">
            <summary>
            Removes a page break at the indicated column
            </summary>
            <param name="column">The column.</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.ValidateRow(System.Int32)">
            <summary>
            Runs a bounds Check for row numbers
            </summary>
            <param name="row">The row.</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.ValidateColumn(System.Int32)">
            <summary>
            Runs a bounds Check for column numbers
            </summary>
            <param name="column">The column.</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.DumpDrawingRecords(System.Boolean)">
            <summary>
            Aggregates the drawing records and dumps the escher record hierarchy
            to the standard output.
            </summary>
            <param name="fat">if set to <c>true</c> [fat].</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.CreateDrawingPatriarch">
            <summary>
            Creates the top-level drawing patriarch.  This will have
            the effect of removing any existing drawings on this
            _sheet.
            This may then be used to Add graphics or charts
            </summary>
            <returns>The new patriarch.</returns>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFSheet.DrawingEscherAggregate">
            <summary>
            Returns the agregate escher records for this _sheet,
            it there is one.
            WARNING - calling this will trigger a parsing of the
            associated escher records. Any that aren't supported
            (such as charts and complex drawing types) will almost
            certainly be lost or corrupted when written out.
            </summary>
            <value>The drawing escher aggregate.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFSheet.DrawingPatriarch">
            <summary>
            Returns the top-level drawing patriach, if there Is
            one.
            This will hold any graphics or charts for the _sheet.
            WARNING - calling this will trigger a parsing of the
            associated escher records. Any that aren't supported
            (such as charts and complex drawing types) will almost
            certainly be lost or corrupted when written out. Only
            use this with simple drawings, otherwise call
            HSSFSheet#CreateDrawingPatriarch() and
            start from scratch!
            </summary>
            <value>The drawing patriarch.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFSheet.TabColorIndex">
            <summary>
            Gets or sets the tab color of the _sheet
            </summary>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFSheet.IsAutoTabColor">
            <summary>
            Gets or sets whether the tab color of _sheet is automatic
            </summary>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.SetColumnGroupCollapsed(System.Int32,System.Boolean)">
            <summary>
            Expands or collapses a column Group.
            </summary>
            <param name="columnNumber">One of the columns in the Group.</param>
            <param name="collapsed">true = collapse Group, false = expand Group.</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.GroupColumn(System.Int32,System.Int32)">
            <summary>
            Create an outline for the provided column range.
            </summary>
            <param name="fromColumn">beginning of the column range.</param>
            <param name="toColumn">end of the column range.</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.UngroupColumn(System.Int32,System.Int32)">
            <summary>
            Ungroups the column.
            </summary>
            <param name="fromColumn">From column.</param>
            <param name="toColumn">To column.</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.GroupRow(System.Int32,System.Int32)">
            <summary>
            Groups the row.
            </summary>
            <param name="fromRow">From row.</param>
            <param name="toRow">To row.</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.UngroupRow(System.Int32,System.Int32)">
            <summary>
            Ungroups the row.
            </summary>
            <param name="fromRow">From row.</param>
            <param name="toRow">To row.</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.SetRowGroupCollapsed(System.Int32,System.Boolean)">
            <summary>
            Sets the row group collapsed.
            </summary>
            <param name="row">The row.</param>
            <param name="collapse">if set to <c>true</c> [collapse].</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.SetDefaultColumnStyle(System.Int32,NPOI.SS.UserModel.CellStyle)">
            <summary>
            Sets the default column style for a given column.  POI will only apply this style to new cells Added to the _sheet.
            </summary>
            <param name="column">the column index</param>
            <param name="style">the style to set</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.AutoSizeColumn(System.Int32)">
            <summary>
            Adjusts the column width to fit the contents.
            This Process can be relatively slow on large sheets, so this should
            normally only be called once per column, at the end of your
            Processing.
            </summary>
            <param name="column">the column index.</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.AutoSizeColumn(System.Int32,System.Boolean)">
            <summary>
            Adjusts the column width to fit the contents.
            This Process can be relatively slow on large sheets, so this should
            normally only be called once per column, at the end of your
            Processing.
            You can specify whether the content of merged cells should be considered or ignored.
            Default is to ignore merged cells.
            </summary>
            <param name="column">the column index</param>
            <param name="useMergedCells">whether to use the contents of merged cells when calculating the width of the column</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.GetMergedRegion(System.Int32)">
            <summary>
            Gets the merged region at the specified index
            </summary>
            <param name="index">The index.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.HSSFFont2Font(NPOI.HSSF.UserModel.HSSFFont)">
            <summary>
            Convert HSSFFont to Font.
            </summary>
            <param name="font1">The font.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheet.GetCellComment(System.Int32,System.Int32)">
            <summary>
            Returns cell comment for the specified row and column
            </summary>
            <param name="row">The row.</param>
            <param name="column">The column.</param>
            <returns>cell comment or null if not found</returns>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFSheet.SheetConditionalFormatting">
            <summary>
            Gets the sheet conditional formatting.
            </summary>
            <value>The sheet conditional formatting.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFSheet.DVRecords">
            <summary>
            Get the DVRecords objects that are associated to this _sheet
            </summary>
            <value>a list of DVRecord instances</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFSheet.SheetName">
             Returns the name of this _sheet
            
             @return the name of this _sheet
        </member>
        <member name="T:NPOI.HSSF.UserModel.HSSFSheetConditionalFormatting">
            <summary>
            The Conditional Formatting facet of HSSFSheet
            @author Dmitriy Kumshayev
            </summary>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheetConditionalFormatting.CreateConditionalFormattingRule(NPOI.HSSF.Record.ComparisonOperator,System.String,System.String)">
            <summary>
            A factory method allowing to Create a conditional formatting rule
            with a cell comparison operator
            TODO - formulas containing cell references are currently not Parsed properly
            </summary>
            <param name="comparisonOperation">a constant value from HSSFConditionalFormattingRule.ComparisonOperator</param>
            <param name="formula1">formula for the valued, Compared with the cell</param>
            <param name="formula2">second formula (only used with HSSFConditionalFormattingRule#COMPARISON_OPERATOR_BETWEEN 
            and HSSFConditionalFormattingRule#COMPARISON_OPERATOR_NOT_BETWEEN operations)</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheetConditionalFormatting.CreateConditionalFormattingRule(System.String)">
            <summary>
            A factory method allowing to Create a conditional formatting rule with a formula.
            The formatting rules are applied by Excel when the value of the formula not equal to 0.
            TODO - formulas containing cell references are currently not Parsed properly
            </summary>
            <param name="formula">formula for the valued, Compared with the cell</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheetConditionalFormatting.AddConditionalFormatting(NPOI.HSSF.UserModel.HSSFConditionalFormatting)">
            <summary>
            Adds a copy of HSSFConditionalFormatting object to the sheet
            This method could be used to copy HSSFConditionalFormatting object
            from one sheet to another.
            </summary>
            <param name="cf">HSSFConditionalFormatting object</param>
            <returns>index of the new Conditional Formatting object</returns>
            <example>
            HSSFConditionalFormatting cf = sheet.GetConditionalFormattingAt(index);
            newSheet.AddConditionalFormatting(cf);
            </example>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheetConditionalFormatting.AddConditionalFormatting(NPOI.SS.Util.CellRangeAddress[],NPOI.HSSF.UserModel.HSSFConditionalFormattingRule[])">
            <summary>
            Allows to Add a new Conditional Formatting Set to the sheet.
            </summary>
            <param name="regions">list of rectangular regions to apply conditional formatting rules</param>
            <param name="cfRules">Set of up to three conditional formatting rules</param>
            <returns>index of the newly Created Conditional Formatting object</returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheetConditionalFormatting.AddConditionalFormatting(NPOI.SS.Util.CellRangeAddress[],NPOI.HSSF.UserModel.HSSFConditionalFormattingRule)">
            <summary>
            Adds the conditional formatting.
            </summary>
            <param name="regions">The regions.</param>
            <param name="rule1">The rule1.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheetConditionalFormatting.AddConditionalFormatting(NPOI.SS.Util.CellRangeAddress[],NPOI.HSSF.UserModel.HSSFConditionalFormattingRule,NPOI.HSSF.UserModel.HSSFConditionalFormattingRule)">
            <summary>
            Adds the conditional formatting.
            </summary>
            <param name="regions">The regions.</param>
            <param name="rule1">The rule1.</param>
            <param name="rule2">The rule2.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheetConditionalFormatting.GetConditionalFormattingAt(System.Int32)">
            <summary>
            Gets Conditional Formatting object at a particular index
            @param index
            of the Conditional Formatting object to fetch
            </summary>
            <param name="index">Conditional Formatting object</param>
            <returns></returns>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFSheetConditionalFormatting.NumConditionalFormattings">
            <summary>
            the number of Conditional Formatting objects of the sheet
            </summary>
            <value>The num conditional formattings.</value>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSheetConditionalFormatting.RemoveConditionalFormatting(System.Int32)">
            <summary>
            Removes a Conditional Formatting object by index
            </summary>
            <param name="index">index of a Conditional Formatting object to Remove</param>
        </member>
        <member name="T:NPOI.HSSF.UserModel.HSSFSimpleShape">
            <summary>
            Represents a simple shape such as a line, rectangle or oval.
            @author Glen Stampoultzis (glens at apache.org)
            </summary>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFSimpleShape.#ctor(NPOI.HSSF.UserModel.HSSFShape,NPOI.HSSF.UserModel.HSSFAnchor)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.HSSF.UserModel.HSSFSimpleShape"/> class.
            </summary>
            <param name="parent">The parent.</param>
            <param name="anchor">The anchor.</param>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFSimpleShape.ShapeType">
            <summary>
            Gets the shape type.
            </summary>
            <value>One of the OBJECT_TYPE_* constants.</value>
            @see #OBJECT_TYPE_LINE
            @see #OBJECT_TYPE_OVAL
            @see #OBJECT_TYPE_RECTANGLE
            @see #OBJECT_TYPE_PICTURE
            @see #OBJECT_TYPE_COMMENT
        </member>
        <member name="T:NPOI.HSSF.UserModel.HSSFTextbox">
            <summary>
            A textbox Is a shape that may hold a rich text string.
            @author Glen Stampoultzis (glens at apache.org)
            </summary>
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFTextbox.HORIZONTAL_ALIGNMENT_LEFT">
            How to align text horizontally
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFTextbox.VERTICAL_ALIGNMENT_TOP">
            How to align text vertically
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFTextbox.#ctor(NPOI.HSSF.UserModel.HSSFShape,NPOI.HSSF.UserModel.HSSFAnchor)">
            <summary>
            Construct a new textbox with the given parent and anchor.
            </summary>
            <param name="parent">The parent.</param>
            <param name="anchor">One of HSSFClientAnchor or HSSFChildAnchor</param>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFTextbox.String">
            <summary>
            Gets or sets the rich text string for this textbox.
            </summary>
            <value>The string.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFTextbox.MarginLeft">
            <summary>
            Gets or sets the left margin within the textbox.
            </summary>
            <value>The margin left.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFTextbox.MarginRight">
            <summary>
            Gets or sets the right margin within the textbox.
            </summary>
            <value>The margin right.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFTextbox.MarginTop">
            <summary>
            Gets or sets the top margin within the textbox
            </summary>
            <value>The top margin.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFTextbox.MarginBottom">
            <summary>
            Gets or sets the bottom margin within the textbox.
            </summary>
            <value>The margin bottom.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFTextbox.HorizontalAlignment">
            <summary>
            Gets or sets the horizontal alignment.
            </summary>
            <value>The horizontal alignment.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFTextbox.VerticalAlignment">
            <summary>
            Gets or sets the vertical alignment.
            </summary>
            <value>The vertical alignment.</value>
        </member>
        <member name="T:NPOI.HSSF.UserModel.HSSFWorkbook">
            <summary>
            High level representation of a workbook.  This Is the first object most users
            will construct whether they are Reading or writing a workbook.  It Is also the
            top level object for creating new sheets/etc.
            </summary>
            @author  Andrew C. Oliver (acoliver at apache dot org)
            @author  Glen Stampoultzis (glens at apache.org)
            @author  Shawn Laubach (slaubach at apache dot org)
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFWorkbook.INITIAL_CAPACITY">
            used for compile-time performance/memory optimization.  This determines the
            initial capacity for the sheet collection.  Its currently Set to 3.
            Changing it in this release will decrease performance
            since you're never allowed to have more or less than three sheets!
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFWorkbook.workbook">
            this Is the reference to the low level Workbook object
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFWorkbook._sheets">
            this holds the HSSFSheet objects attached to this workbook
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFWorkbook.names">
            this holds the HSSFName objects attached to this workbook
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFWorkbook.preserveNodes">
            holds whether or not to preserve other nodes in the POIFS.  Used
            for macros and embedded objects.
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFWorkbook.formatter">
            Used to keep track of the data formatter so that all
            CreateDataFormatter calls return the same one for a given
            book.  This Ensures that updates from one places Is visible
            someplace else.
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFWorkbook.fonts">
            this holds the HSSFFont objects attached to this workbook.
            We only create these from the low level records as required.
        </member>
        <member name="T:NPOI.HSSF.UserModel.HSSFWorkbook.SheetRecordCollector">
            <summary>
            Totals the sizes of all sheet records and eventually serializes them
            </summary>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFWorkbook.#ctor">
            <summary>
            Creates new HSSFWorkbook from scratch (start here!)
            </summary>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFWorkbook.#ctor(NPOI.POIFS.FileSystem.POIFSFileSystem,System.Boolean)">
            <summary>
            given a POI POIFSFileSystem object, Read in its Workbook and populate the high and
            low level models.  If you're Reading in a workbook...start here.
            </summary>
            <param name="fs">the POI filesystem that Contains the Workbook stream.</param>
            <param name="preserveNodes">whether to preseve other nodes, such as
            macros.  This takes more memory, so only say yes if you
            need to. If Set, will store all of the POIFSFileSystem
            in memory</param>
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFWorkbook.WORKBOOK_DIR_ENTRY_NAMES">
            Normally, the Workbook will be in a POIFS Stream
            called "Workbook". However, some weird XLS generators use "WORKBOOK"
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFWorkbook.#ctor(NPOI.POIFS.FileSystem.DirectoryNode,NPOI.POIFS.FileSystem.POIFSFileSystem,System.Boolean)">
            <summary>
            given a POI POIFSFileSystem object, and a specific directory
            within it, Read in its Workbook and populate the high and
            low level models.  If you're Reading in a workbook...start here.
            </summary>
            <param name="directory">the POI filesystem directory to Process from</param>
            <param name="fs">the POI filesystem that Contains the Workbook stream.</param>
            <param name="preserveNodes">whether to preseve other nodes, such as
            macros.  This takes more memory, so only say yes if you
            need to. If Set, will store all of the POIFSFileSystem
            in memory</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFWorkbook.#ctor(System.IO.Stream,System.Boolean)">
             Companion to HSSFWorkbook(POIFSFileSystem), this constructs the POI filesystem around your
             inputstream.
            
             @param s  the POI filesystem that Contains the Workbook stream.
             @param preserveNodes whether to preseve other nodes, such as
                    macros.  This takes more memory, so only say yes if you
                    need to.
             @see org.apache.poi.poifs.filesystem.POIFSFileSystem
             @see #HSSFWorkbook(POIFSFileSystem)
             @exception IOException if the stream cannot be Read
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFWorkbook.SetPropertiesFromWorkbook(NPOI.HSSF.Model.Workbook)">
            used internally to Set the workbook properties.
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFWorkbook.ConvertLabelRecords(System.Collections.IList,System.Int32)">
            <summary>
            This is basically a kludge to deal with the now obsolete Label records.  If
            you have to read in a sheet that contains Label records, be aware that the rest
            of the API doesn't deal with them, the low level structure only provides Read-only
            semi-immutable structures (the Sets are there for interface conformance with NO
            impelmentation).  In short, you need to call this function passing it a reference
            to the Workbook object.  All labels will be converted to LabelSST records and their
            contained strings will be written to the Shared String tabel (SSTRecord) within
            the Workbook.
            </summary>
            <param name="records">The records.</param>
            <param name="offset">The offset.</param>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFWorkbook.MissingCellPolicy">
            <summary>
            Retrieves the current policy on what to do when
            getting missing or blank cells from a row.
            The default is to return blank and null cells.
            </summary>
            <value>The missing cell policy.</value>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFWorkbook.SetSheetOrder(System.String,System.Int32)">
            <summary>
            Sets the order of appearance for a given sheet.
            </summary>
            <param name="sheetname">the name of the sheet to reorder</param>
            <param name="pos">the position that we want to Insert the sheet into (0 based)</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFWorkbook.ValidateSheetIndex(System.Int32)">
            <summary>
            Validates the index of the sheet.
            </summary>
            <param name="index">The index.</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFWorkbook.SetSelectedTab(System.Int32)">
            <summary>
            Selects a single sheet. This may be different to
            the 'active' sheet (which Is the sheet with focus).
            </summary>
            <param name="index">The index.</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFWorkbook.SetSelectedTabs(System.Int32[])">
            <summary>
            Sets the selected tabs.
            </summary>
            <param name="indexes">The indexes.</param>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFWorkbook.ActiveSheetIndex">
            <summary>
            Gets or sets the tab whose data is actually seen when the sheet is opened.
            This may be different from the "selected sheet" since excel seems to
            allow you to show the data of one sheet when another Is seen "selected"
            in the tabs (at the bottom).
            </summary>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFWorkbook.FirstVisibleTab">
            <summary>
            Gets or sets the first tab that is displayed in the list of tabs
            in excel.
            </summary>
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFWorkbook.ENCODING_COMPRESSED_UNICODE">
            @deprecated POI will now properly handle Unicode strings without
            forceing an encoding
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFWorkbook.ENCODING_UTF_16">
            @deprecated POI will now properly handle Unicode strings without
            forceing an encoding
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFWorkbook.SetSheetName(System.Int32,System.String)">
            <summary>
            Set the sheet name.
            </summary>
            <param name="sheetIx">The sheet number(0 based).</param>
            <param name="name">The name.</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFWorkbook.GetSheetName(System.Int32)">
            <summary>
            Get the sheet name
            </summary>
            <param name="sheetIx">The sheet index.</param>
            <returns>Sheet name</returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFWorkbook.IsSheetHidden(System.Int32)">
            <summary>
            Check whether a sheet is hidden
            </summary>
            <param name="sheetIx">The sheet index.</param>
            <returns>
            	<c>true</c> if sheet is hidden; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFWorkbook.IsSheetVeryHidden(System.Int32)">
            <summary>
            Check whether a sheet is very hidden.
            This is different from the normal
            hidden status
            </summary>
            <param name="sheetIx">The sheet index.</param>
            <returns>
            	<c>true</c> if sheet is very hidden; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFWorkbook.SetSheetHidden(System.Int32,System.Boolean)">
            <summary>
            Hide or Unhide a sheet
            </summary>
            <param name="sheetIx">The sheet index</param>
            <param name="hidden">True to mark the sheet as hidden, false otherwise</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFWorkbook.SetSheetHidden(System.Int32,System.Int32)">
            <summary>
            Hide or unhide a sheet.
            </summary>
            <param name="sheetIx">The sheet number</param>
            <param name="hidden">0 for not hidden, 1 for hidden, 2 for very hidden</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFWorkbook.GetSheetIndex(System.String)">
            <summary>
            Returns the index of the sheet by his name
            </summary>
            <param name="name">the sheet name</param>
            <returns>index of the sheet (0 based)</returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFWorkbook.GetSheetIndex(NPOI.SS.UserModel.Sheet)">
            <summary>
            Returns the index of the given sheet
            </summary>
            <param name="sheet">the sheet to look up</param>
            <returns>index of the sheet (0 based).-1
             if not found </returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFWorkbook.GetExternalSheetIndex(System.Int32)">
            <summary>
            Returns the external sheet index of the sheet
            with the given internal index, creating one
            if needed.
            Used by some of the more obscure formula and
            named range things.
            </summary>
            <param name="internalSheetIndex">Index of the internal sheet.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFWorkbook.CreateSheet">
            <summary>
            Create an HSSFSheet for this HSSFWorkbook, Adds it to the sheets and returns
            the high level representation.  Use this to Create new sheets.
            </summary>
            <returns>HSSFSheet representing the new sheet.</returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFWorkbook.CloneSheet(System.Int32)">
            <summary>
            Create an HSSFSheet from an existing sheet in the HSSFWorkbook.
            </summary>
            <param name="sheetIndex">the sheet index</param>
            <returns>HSSFSheet representing the Cloned sheet.</returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFWorkbook.GetUniqueSheetName(System.String)">
            <summary>
            Gets the name of the unique sheet.
            </summary>
            <param name="srcName">Name of the SRC.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFWorkbook.CreateSheet(System.String)">
            <summary>
            Create an HSSFSheet for this HSSFWorkbook, Adds it to the sheets and
            returns the high level representation. Use this to Create new sheets.
            </summary>
            <param name="sheetname">sheetname to set for the sheet.</param>
            <returns>HSSFSheet representing the new sheet.</returns>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFWorkbook.NumberOfSheets">
            <summary>
            Get the number of spreadsheets in the workbook (this will be three after serialization)
            </summary>
            <value>The number of sheets.</value>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFWorkbook.GetSheets">
            <summary>
            Gets the sheets.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFWorkbook.GetSheetAt(System.Int32)">
            <summary>
             Get the HSSFSheet object at the given index.
            </summary>
             <param name="index">index of the sheet number (0-based)</param>
             <returns>HSSFSheet at the provided index</returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFWorkbook.GetSheet(System.String)">
            <summary>
            Get sheet with the given name (case insensitive match)
            </summary>
            <param name="name">name of the sheet</param>
            <returns>HSSFSheet with the name provided or null if it does not exist</returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFWorkbook.RemoveSheetAt(System.Int32)">
             <summary>
             Removes sheet at the given index.
             </summary>
             <param name="index">index of the sheet  (0-based)</param>
            <remarks>
             Care must be taken if the Removed sheet Is the currently active or only selected sheet in
             the workbook. There are a few situations when Excel must have a selection and/or active
             sheet. (For example when printing - see Bug 40414).
             This method makes sure that if the Removed sheet was active, another sheet will become
             active in its place.  Furthermore, if the Removed sheet was the only selected sheet, another
             sheet will become selected.  The newly active/selected sheet will have the same index, or
             one less if the Removed sheet was the last in the workbook.
             </remarks>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFWorkbook.BackupFlag">
            <summary>
            determine whether the Excel GUI will backup the workbook when saving.
            </summary>
            <value>the current Setting for backups.</value>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFWorkbook.SetRepeatingRowsAndColumns(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Sets the repeating rows and columns for a sheet (as found in
            File-&gt;PageSetup-&gt;Sheet).  This Is function Is included in the workbook
            because it Creates/modifies name records which are stored at the
            workbook level.
            </summary>
            <param name="sheetIndex">0 based index to sheet.</param>
            <param name="startColumn">0 based start of repeating columns.</param>
            <param name="endColumn">0 based end of repeating columns.</param>
            <param name="startRow">0 based start of repeating rows.</param>
            <param name="endRow">0 based end of repeating rows.</param>
            <example>
            To set just repeating columns:
            workbook.SetRepeatingRowsAndColumns(0,0,1,-1-1);
            To set just repeating rows:
            workbook.SetRepeatingRowsAndColumns(0,-1,-1,0,4);
            To remove all repeating rows and columns for a sheet.
            workbook.SetRepeatingRowsAndColumns(0,-1,-1,-1,-1);
            </example>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFWorkbook.CreateFont">
            <summary>
            Create a new Font and Add it to the workbook's font table
            </summary>
            <returns>new font object</returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFWorkbook.FindFont(System.Int16,System.Int16,System.Int16,System.String,System.Boolean,System.Boolean,System.Int16,System.Byte)">
            <summary>
            Finds a font that matches the one with the supplied attributes
            </summary>
            <param name="boldWeight">The bold weight.</param>
            <param name="color">The color.</param>
            <param name="fontHeight">Height of the font.</param>
            <param name="name">The name.</param>
            <param name="italic">if set to <c>true</c> [italic].</param>
            <param name="strikeout">if set to <c>true</c> [strikeout].</param>
            <param name="typeOffset">The type offset.</param>
            <param name="Underline">The underline.</param>
            <returns></returns>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFWorkbook.NumberOfFonts">
            <summary>
            Get the number of fonts in the font table
            </summary>
            <value>The number of fonts.</value>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFWorkbook.GetFontAt(System.Int16)">
            <summary>
            Get the font at the given index number
            </summary>
            <param name="idx">The index number</param>
            <returns>HSSFFont at the index</returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFWorkbook.ResetFontCache">
            <summary>
            Reset the fonts cache, causing all new calls
            to getFontAt() to create new objects.
            Should only be called after deleting fonts,
            and that's not something you should normally do
            </summary>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFWorkbook.CreateCellStyle">
            <summary>
            Create a new Cell style and Add it to the workbook's style table
            </summary>
            <returns>the new Cell Style object</returns>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFWorkbook.NumCellStyles">
            <summary>
            Get the number of styles the workbook Contains
            </summary>
            <value>count of cell styles</value>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFWorkbook.GetCellStyleAt(System.Int16)">
            <summary>
            Get the cell style object at the given index
            </summary>
            <param name="idx">index within the Set of styles</param>
            <returns>HSSFCellStyle object at the index</returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFWorkbook.Write(System.IO.Stream)">
            <summary>
            Write out this workbook to an Outputstream.  Constructs
            a new POI POIFSFileSystem, passes in the workbook binary representation  and
            Writes it out.
            </summary>
            <param name="stream">the java OutputStream you wish to Write the XLS to</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFWorkbook.GetBytes">
            <summary>
            Get the bytes of just the HSSF portions of the XLS file.
            Use this to construct a POI POIFSFileSystem yourself.
            </summary>
            <returns>byte[] array containing the binary representation of this workbook and all contained
            sheets, rows, cells, etc.</returns>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFWorkbook.Workbook">
            <summary>
            Gets the workbook.
            </summary>
            <value>The workbook.</value>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFWorkbook.NumberOfNames">
            <summary>
            Gets the total number of named ranges in the workboko
            </summary>
            <value>The number of named ranges</value>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFWorkbook.GetNameAt(System.Int32)">
            <summary>
            Gets the Named range
            </summary>
            <param name="index">position of the named range</param>
            <returns>named range high level</returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFWorkbook.GetNameName(System.Int32)">
            <summary>
            Gets the named range name
            </summary>
            <param name="index">the named range index (0 based)</param>
            <returns>named range name</returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFWorkbook.ResolveNameXText(System.Int32,System.Int32)">
            <summary>
            TODO - make this less cryptic / move elsewhere
            </summary>
            <param name="reFindex">Index to REF entry in EXTERNSHEET record in the Link Table</param>
            <param name="definedNameIndex">zero-based to DEFINEDNAME or EXTERNALNAME record</param>
            <returns>the string representation of the defined or external name</returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFWorkbook.SetPrintArea(System.Int32,System.String)">
            <summary>
            Sets the printarea for the sheet provided
            i.e. Reference = $A$1:$B$2
            </summary>
            <param name="sheetIndex">Zero-based sheet index (0 Represents the first sheet to keep consistent with java)</param>
            <param name="reference">Valid name Reference for the Print Area</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFWorkbook.SetPrintArea(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Sets the print area.
            </summary>
            <param name="sheetIndex">Zero-based sheet index (0 = First Sheet)</param>
            <param name="startColumn">Column to begin printarea</param>
            <param name="endColumn">Column to end the printarea</param>
            <param name="startRow">Row to begin the printarea</param>
            <param name="endRow">Row to end the printarea</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFWorkbook.GetPrintArea(System.Int32)">
            <summary>
            Retrieves the reference for the printarea of the specified sheet, the sheet name Is Appended to the reference even if it was not specified.
            </summary>
            <param name="sheetIndex">Zero-based sheet index (0 Represents the first sheet to keep consistent with java)</param>
            <returns>String Null if no print area has been defined</returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFWorkbook.RemovePrintArea(System.Int32)">
            <summary>
            Delete the printarea for the sheet specified
            </summary>
            <param name="sheetIndex">Zero-based sheet index (0 = First Sheet)</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFWorkbook.CreateName">
            <summary>
            Creates a new named range and Add it to the model
            </summary>
            <returns>named range high level</returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFWorkbook.GetNameIndex(System.String)">
            <summary>
            Gets the named range index by his name
            Note:
            Excel named ranges are case-insensitive and
            this method performs a case-insensitive search.
            </summary>
            <param name="name">named range name</param>
            <returns>named range index</returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFWorkbook.RemoveName(System.Int32)">
            <summary>
            Remove the named range by his index
            </summary>
            <param name="index">The named range index (0 based)</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFWorkbook.CreateDataFormat">
            <summary>
            Creates the instance of HSSFDataFormat for this workbook.
            </summary>
            <returns>the HSSFDataFormat object</returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFWorkbook.RemoveName(System.String)">
            <summary>
            Remove the named range by his name
            </summary>
            <param name="name">named range name</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFWorkbook.DumpDrawingGroupRecords(System.Boolean)">
            <summary>
            Spits out a list of all the drawing records in the workbook.
            </summary>
            <param name="fat">if set to <c>true</c> [fat].</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NPOI.HSSF.UserModel.HSSFWorkbook.AddPicture(System.Byte[],NPOI.SS.UserModel.PictureType)" -->
        <member name="M:NPOI.HSSF.UserModel.HSSFWorkbook.GetAllPictures">
            <summary>
            Gets all pictures from the Workbook.
            </summary>
            <returns>the list of pictures (a list of HSSFPictureData objects.)</returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFWorkbook.SearchForPictures(System.Collections.IList,System.Collections.Generic.List{NPOI.HSSF.UserModel.HSSFPictureData})">
            <summary>
            Performs a recursive search for pictures in the given list of escher records.
            </summary>
            <param name="escherRecords">the escher records.</param>
            <param name="pictures">the list to populate with the pictures.</param>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFWorkbook.IsWriteProtected">
            <summary>
            Is the workbook protected with a password (not encrypted)?
            </summary>
            <value>
            	<c>true</c> if this instance is write protected; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFWorkbook.WriteProtectWorkbook(System.String,System.String)">
            <summary>
            protect a workbook with a password (not encypted, just Sets Writeprotect
            flags and the password.
            </summary>
            <param name="password">password to set</param>
            <param name="username">The username.</param>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFWorkbook.UnwriteProtectWorkbook">
            <summary>
            Removes the Write protect flag
            </summary>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFWorkbook.GetAllEmbeddedObjects">
            <summary>
            Gets all embedded OLE2 objects from the Workbook.
            </summary>
            <returns>the list of embedded objects (a list of HSSFObjectData objects.)</returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFWorkbook.GetAllEmbeddedObjects(System.Collections.IList,System.Collections.IList)">
            <summary>
            Gets all embedded OLE2 objects from the Workbook.
            </summary>
            <param name="records">the list of records to search.</param>
            <param name="objects">the list of embedded objects to populate.</param>
        </member>
        <member name="P:NPOI.HSSF.UserModel.HSSFWorkbook.NewUID">
            <summary>
            Gets the new UID.
            </summary>
            <value>The new UID.</value>
        </member>
        <member name="T:NPOI.HSSF.UserModel.StaticFontMetrics">
             Allows the user to lookup the font metrics for a particular font without
             actually having the font on the system.  The font details are Loaded
             as a resource from the POI jar file (or classpath) and should be contained
             in path "/font_metrics.properties".  The font widths are for a 10 point
             version of the font.  Use a multiplier for other sizes.
            
             @author Glen Stampoultzis (glens at apache.org)
        </member>
        <member name="F:NPOI.HSSF.UserModel.StaticFontMetrics.fontMetricsProps">
            The font metrics property file we're using 
        </member>
        <member name="F:NPOI.HSSF.UserModel.StaticFontMetrics.fontDetailsMap">
            Our cache of font details we've alReady looked up 
        </member>
        <member name="T:NPOI.HSSF.UserModel.HSSFErrorConstants">
            <summary>
            Contains raw Excel error codes (as defined in OOO's excelfileformat.pdf (2.5.6)
            @author  Michael Harhen
            </summary>
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFErrorConstants.ERROR_NULL">
            <b>#NULL!</b>  - Intersection of two cell ranges is empty 
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFErrorConstants.ERROR_DIV_0">
            <b>#DIV/0!</b> - Division by zero 
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFErrorConstants.ERROR_VALUE">
            <b>#VALUE!</b> - Wrong type of operand 
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFErrorConstants.ERROR_REF">
            <b>#REF!</b> - Illegal or deleted cell reference 
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFErrorConstants.ERROR_NAME">
            <b>#NAME?</b> - Wrong function or range name 
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFErrorConstants.ERROR_NUM">
            <b>#NUM!</b> - Value range overflow 
        </member>
        <member name="F:NPOI.HSSF.UserModel.HSSFErrorConstants.ERROR_NA">
            <b>#N/A</b> - Argument or function not available 
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFErrorConstants.GetText(System.Int32)">
            <summary>
            Gets standard Excel error literal for the specified error code.
            @throws ArgumentException if the specified error code is not one of the 7
            standard error codes
            </summary>
            <param name="errorCode">The error code.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.HSSF.UserModel.HSSFErrorConstants.IsValidCode(System.Int32)">
            <summary>
            Determines whether [is valid code] [the specified error code].
            </summary>
            <param name="errorCode">The error code.</param>
            <returns>
            	<c>true</c> if the specified error code is a standard Excel error code.; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:NPOI.HSSF.Util.FormatBase">
            <summary>
            A substitute class for Format class in Java
            </summary>
        </member>
        <member name="T:NPOI.HSSF.Util.SSNFormat">
             Format class for Excel's SSN Format. This class mimics Excel's built-in
             SSN Formatting.
            
             @author James May
        </member>
        <member name="M:NPOI.HSSF.Util.SSNFormat.Format(System.Object)">
            Format a number as an SSN 
        </member>
        <member name="T:NPOI.HSSF.Util.ZipPlusFourFormat">
            Format class for Excel Zip + 4 Format. This class mimics Excel's
            built-in Formatting for Zip + 4.
            @author James May
        </member>
        <member name="M:NPOI.HSSF.Util.ZipPlusFourFormat.Format(System.Object)">
            Format a number as Zip + 4 
        </member>
        <member name="T:NPOI.HSSF.Util.PhoneFormat">
            Format class for Excel phone number Format. This class mimics Excel's
            built-in phone number Formatting.
            @author James May
        </member>
        <member name="M:NPOI.HSSF.Util.PhoneFormat.Format(System.Object)">
            Format a number as a phone number 
        </member>
        <member name="F:NPOI.HSSF.Util.GUID._d1">
            4 bytes - little endian 
        </member>
        <member name="F:NPOI.HSSF.Util.GUID._d2">
            2 bytes - little endian 
        </member>
        <member name="F:NPOI.HSSF.Util.GUID._d3">
            2 bytes - little endian 
        </member>
        <member name="F:NPOI.HSSF.Util.GUID._d4">
            8 bytes - serialized as big endian,  stored with inverted endianness here
        </member>
        <member name="M:NPOI.HSSF.Util.GUID.Parse(System.String)">
            Read a GUID in standard text form e.g.<br/>
            13579BDF-0246-8ACE-0123-456789ABCDEF 
            <br/> -&gt; <br/>
             0x13579BDF, 0x0246, 0x8ACE 0x0123456789ABCDEF
        </member>
        <member name="T:NPOI.HSSF.Util.HSSFColor">
             Intends to provide support for the very evil index to triplet Issue and
             will likely replace the color constants interface for HSSF 2.0.
             This class Contains static inner class members for representing colors.
             Each color has an index (for the standard palette in Excel (tm) ),
             native (RGB) triplet and string triplet.  The string triplet Is as the
             color would be represented by Gnumeric.  Having (string) this here Is a bit of a
             collusion of function between HSSF and the HSSFSerializer but I think its
             a reasonable one in this case.
            
             @author  Andrew C. Oliver (acoliver at apache dot org)
             @author  Brian Sanders (bsanders at risklabs dot com) - full default color palette
        </member>
        <member name="M:NPOI.HSSF.Util.HSSFColor.#ctor">
            Creates a new instance of HSSFColor 
        </member>
        <member name="M:NPOI.HSSF.Util.HSSFColor.GetIndexHash">
             this function returns all colors in a hastable.  Its not implemented as a
             static member/staticly initialized because that would be dirty in a
             server environment as it Is intended.  This means you'll eat the time
             it takes to Create it once per request but you will not hold onto it
             if you have none of those requests.
            
             @return a hashtable containing all colors keyed by <tt>int</tt> excel-style palette indexes
        </member>
        <member name="M:NPOI.HSSF.Util.HSSFColor.GetTripletHash">
            <summary>
            this function returns all colors in a hastable.  Its not implemented as a
            static member/staticly initialized because that would be dirty in a
            server environment as it Is intended.  This means you'll eat the time
            it takes to Create it once per request but you will not hold onto it
            if you have none of those requests.
            </summary>
            <returns>a hashtable containing all colors keyed by String gnumeric-like triplets</returns>
        </member>
        <member name="M:NPOI.HSSF.Util.HSSFColor.GetIndex">
            @return index to the standard palette
        </member>
        <member name="M:NPOI.HSSF.Util.HSSFColor.GetTriplet">
            @return  triplet representation like that in Excel
        </member>
        <member name="M:NPOI.HSSF.Util.HSSFColor.GetHexString">
            @return a hex string exactly like a gnumeric triplet
        </member>
        <member name="T:NPOI.HSSF.Util.HSSFColor.BLACK">
             Class BLACK
            
        </member>
        <member name="T:NPOI.HSSF.Util.HSSFColor.BROWN">
             Class BROWN
            
        </member>
        <member name="T:NPOI.HSSF.Util.HSSFColor.OLIVE_GREEN">
             Class OLIVE_GREEN
            
        </member>
        <member name="T:NPOI.HSSF.Util.HSSFColor.DARK_GREEN">
             Class DARK_GREEN
            
        </member>
        <member name="T:NPOI.HSSF.Util.HSSFColor.DARK_TEAL">
             Class DARK_TEAL
            
        </member>
        <member name="T:NPOI.HSSF.Util.HSSFColor.DARK_BLUE">
             Class DARK_BLUE
            
        </member>
        <member name="T:NPOI.HSSF.Util.HSSFColor.INDIGO">
             Class INDIGO
            
        </member>
        <member name="T:NPOI.HSSF.Util.HSSFColor.GREY_80_PERCENT">
             Class GREY_80_PERCENT
            
        </member>
        <member name="T:NPOI.HSSF.Util.HSSFColor.DARK_RED">
             Class DARK_RED
            
        </member>
        <member name="T:NPOI.HSSF.Util.HSSFColor.ORANGE">
             Class ORANGE
            
        </member>
        <member name="T:NPOI.HSSF.Util.HSSFColor.DARK_YELLOW">
             Class DARK_YELLOW
            
        </member>
        <member name="T:NPOI.HSSF.Util.HSSFColor.GREEN">
             Class GREEN
            
        </member>
        <member name="T:NPOI.HSSF.Util.HSSFColor.TEAL">
             Class TEAL
            
        </member>
        <member name="T:NPOI.HSSF.Util.HSSFColor.BLUE">
             Class BLUE
            
        </member>
        <member name="T:NPOI.HSSF.Util.HSSFColor.BLUE_GREY">
             Class BLUE_GREY
            
        </member>
        <member name="T:NPOI.HSSF.Util.HSSFColor.GREY_50_PERCENT">
             Class GREY_50_PERCENT
            
        </member>
        <member name="T:NPOI.HSSF.Util.HSSFColor.RED">
             Class RED
            
        </member>
        <member name="T:NPOI.HSSF.Util.HSSFColor.LIGHT_ORANGE">
             Class LIGHT_ORANGE
            
        </member>
        <member name="T:NPOI.HSSF.Util.HSSFColor.LIME">
             Class LIME
            
        </member>
        <member name="T:NPOI.HSSF.Util.HSSFColor.SEA_GREEN">
             Class SEA_GREEN
            
        </member>
        <member name="T:NPOI.HSSF.Util.HSSFColor.AQUA">
             Class AQUA
            
        </member>
        <member name="T:NPOI.HSSF.Util.HSSFColor.GREY_40_PERCENT">
             Class GREY_40_PERCENT
            
        </member>
        <member name="T:NPOI.HSSF.Util.HSSFColor.TURQUOISE">
             Class TURQUOISE
            
        </member>
        <member name="T:NPOI.HSSF.Util.HSSFColor.SKY_BLUE">
             Class SKY_BLUE
            
        </member>
        <member name="T:NPOI.HSSF.Util.HSSFColor.PLUM">
             Class PLUM
            
        </member>
        <member name="T:NPOI.HSSF.Util.HSSFColor.GREY_25_PERCENT">
             Class GREY_25_PERCENT
            
        </member>
        <member name="T:NPOI.HSSF.Util.HSSFColor.ROSE">
             Class ROSE
            
        </member>
        <member name="T:NPOI.HSSF.Util.HSSFColor.TAN">
             Class TAN
            
        </member>
        <member name="T:NPOI.HSSF.Util.HSSFColor.LIGHT_YELLOW">
             Class LIGHT_YELLOW
            
        </member>
        <member name="T:NPOI.HSSF.Util.HSSFColor.LIGHT_GREEN">
             Class LIGHT_GREEN
            
        </member>
        <member name="T:NPOI.HSSF.Util.HSSFColor.LIGHT_TURQUOISE">
             Class LIGHT_TURQUOISE
            
        </member>
        <member name="T:NPOI.HSSF.Util.HSSFColor.PALE_BLUE">
             Class PALE_BLUE
            
        </member>
        <member name="T:NPOI.HSSF.Util.HSSFColor.LAVENDER">
             Class LAVENDER
            
        </member>
        <member name="T:NPOI.HSSF.Util.HSSFColor.WHITE">
             Class WHITE
            
        </member>
        <member name="T:NPOI.HSSF.Util.HSSFColor.CORNFLOWER_BLUE">
            Class CORNFLOWER_BLUE
        </member>
        <member name="T:NPOI.HSSF.Util.HSSFColor.LEMON_CHIFFON">
            Class LEMON_CHIFFON
        </member>
        <member name="T:NPOI.HSSF.Util.HSSFColor.MAROON">
            Class MAROON
        </member>
        <member name="T:NPOI.HSSF.Util.HSSFColor.ORCHID">
            Class ORCHID
        </member>
        <member name="T:NPOI.HSSF.Util.HSSFColor.CORAL">
            Class CORAL
        </member>
        <member name="T:NPOI.HSSF.Util.HSSFColor.ROYAL_BLUE">
            Class ROYAL_BLUE
        </member>
        <member name="T:NPOI.HSSF.Util.HSSFColor.LIGHT_CORNFLOWER_BLUE">
            Class LIGHT_CORNFLOWER_BLUE
        </member>
        <member name="T:NPOI.HSSF.Util.HSSFColor.AUTOMATIC">
             Special Default/Normal/Automatic color.
             <i>Note:</i> This class Is NOT in the default HashTables returned by HSSFColor.
             The index Is a special case which Is interpreted in the various SetXXXColor calls.
            
             @author Jason
            
        </member>
        <!-- Badly formed XML comment ignored for member "T:NPOI.HSSF.Util.RangeAddress" -->
        <member name="M:NPOI.HSSF.Util.RangeAddress.#ctor(System.String)">
            Accepts an external reference from excel.
            
            i.e. Sheet1!$A$4:$B$9
            @param _url
        </member>
        <member name="P:NPOI.HSSF.Util.RangeAddress.Address">
            
            @return String <b>note: </b> All absolute references are Removed
        </member>
        <member name="T:NPOI.HSSF.Util.RKUtil">
             Utility class for helping convert RK numbers.
            
             @author Andrew C. Oliver (acoliver at apache dot org)
             @author Glen Stampoultzis (glens at apache.org)
             @author Rolf-J黵gen Moll
            
             @see org.apache.poi.hssf.record.MulRKRecord
             @see org.apache.poi.hssf.record.RKRecord
        </member>
        <member name="M:NPOI.HSSF.Util.RKUtil.DecodeNumber(System.Int32)">
            Do the dirty work of decoding; made a private static method to
            facilitate testing the algorithm
        </member>
        <member name="T:NPOI.POIDocument">
            <summary>
            This holds the common functionality for all POI
            Document classes.
            Currently, this relates to Document Information Properties
            </summary>
            <remarks>@author Nick Burch</remarks>
        </member>
        <member name="F:NPOI.POIDocument.sInf">
            Holds metadata on our document 
        </member>
        <member name="F:NPOI.POIDocument.dsInf">
            Holds further metadata on our document 
        </member>
        <member name="F:NPOI.POIDocument.filesystem">
            The open POIFS FileSystem that contains our document 
        </member>
        <member name="F:NPOI.POIDocument.directory">
            The directory that our document lives in 
        </member>
        <member name="F:NPOI.POIDocument.initialized">
            For our own logging use 
        </member>
        <member name="M:NPOI.POIDocument.#ctor(NPOI.POIFS.FileSystem.DirectoryNode,NPOI.POIFS.FileSystem.POIFSFileSystem)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.POIDocument"/> class.
            </summary>
            <param name="dir">The dir.</param>
            <param name="fs">The fs.</param>
        </member>
        <member name="M:NPOI.POIDocument.#ctor(NPOI.POIFS.FileSystem.POIFSFileSystem)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.POIDocument"/> class.
            </summary>
            <param name="fs">The fs.</param>
        </member>
        <member name="P:NPOI.POIDocument.DocumentSummaryInformation">
            <summary>
            Fetch the Document Summary Information of the document
            </summary>
            <value>The document summary information.</value>
        </member>
        <member name="P:NPOI.POIDocument.SummaryInformation">
            <summary>
            Fetch the Summary Information of the document
            </summary>
            <value>The summary information.</value>
        </member>
        <member name="M:NPOI.POIDocument.ReadProperties">
            <summary>
            Find, and Create objects for, the standard
            Documment Information Properties (HPSF).
            If a given property Set is missing or corrupt,
            it will remain null;
            </summary>
        </member>
        <member name="M:NPOI.POIDocument.GetPropertySet(System.String)">
            <summary>
            For a given named property entry, either return it or null if
            if it wasn't found
            </summary>
            <param name="SetName">Name of the set.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.POIDocument.WriteProperties(NPOI.POIFS.FileSystem.POIFSFileSystem)">
            <summary>
            Writes out the standard Documment Information Properties (HPSF)
            </summary>
            <param name="outFS">the POIFSFileSystem to Write the properties into</param>
        </member>
        <member name="M:NPOI.POIDocument.WriteProperties(NPOI.POIFS.FileSystem.POIFSFileSystem,System.Collections.IList)">
            <summary>
            Writes out the standard Documment Information Properties (HPSF)
            </summary>
            <param name="outFS">the POIFSFileSystem to Write the properties into.</param>
            <param name="writtenEntries">a list of POIFS entries to Add the property names too.</param>
        </member>
        <member name="M:NPOI.POIDocument.WritePropertySet(System.String,NPOI.HPSF.PropertySet,NPOI.POIFS.FileSystem.POIFSFileSystem)">
            <summary>
            Writes out a given ProperySet
            </summary>
            <param name="name">the (POIFS Level) name of the property to Write.</param>
            <param name="Set">the PropertySet to Write out.</param>
            <param name="outFS">the POIFSFileSystem to Write the property into.</param>
        </member>
        <member name="M:NPOI.POIDocument.Write(System.IO.Stream)">
            <summary>
            Writes the document out to the specified output stream
            </summary>
            <param name="out1">The out1.</param>
        </member>
        <member name="M:NPOI.POIDocument.CopyNodes(NPOI.POIFS.FileSystem.POIFSFileSystem,NPOI.POIFS.FileSystem.POIFSFileSystem,System.Collections.IList)">
            <summary>
            Copies nodes from one POIFS to the other minus the excepts
            </summary>
            <param name="source">the source POIFS to copy from.</param>
            <param name="target">the target POIFS to copy to</param>
            <param name="excepts">a list of Strings specifying what nodes NOT to copy</param>
        </member>
        <member name="M:NPOI.POIDocument.isInList(System.String,System.Collections.IList)">
            <summary>
            Checks to see if the String is in the list, used when copying
            nodes between one POIFS and another
            </summary>
            <param name="entry">The entry.</param>
            <param name="list">The list.</param>
            <returns>
            	<c>true</c> if [is in list] [the specified entry]; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NPOI.POIDocument.CopyNodeRecursively(NPOI.POIFS.FileSystem.Entry,NPOI.POIFS.FileSystem.DirectoryEntry)">
            <summary>
            Copies an Entry into a target POIFS directory, recursively
            </summary>
            <param name="entry">The entry.</param>
            <param name="target">The target.</param>
        </member>
        <member name="T:NPOI.POIOLE2TextExtractor">
            <summary>
            Common Parent for OLE2 based Text Extractors
            of POI Documents, such as .doc, .xls
            You will typically find the implementation of
            a given format's text extractor under NPOI.Format.Extractor
            </summary>
            <remarks>
            @see org.apache.poi.hssf.extractor.ExcelExtractor
            @see org.apache.poi.hslf.extractor.PowerPointExtractor
            @see org.apache.poi.hdgf.extractor.VisioTextExtractor
            @see org.apache.poi.hwpf.extractor.WordExtractor
            </remarks>
        </member>
        <member name="M:NPOI.POIOLE2TextExtractor.#ctor(NPOI.POIDocument)">
            <summary>
            Creates a new text extractor for the given document
            </summary>
            <param name="document"></param>
        </member>
        <member name="P:NPOI.POIOLE2TextExtractor.DocSummaryInformation">
            <summary>
            Returns the document information metadata for the document
            </summary>
            <value>The doc summary information.</value>
        </member>
        <member name="P:NPOI.POIOLE2TextExtractor.SummaryInformation">
            <summary>
            Returns the summary information metadata for the document
            </summary>
            <value>The summary information.</value>
        </member>
        <member name="P:NPOI.POIOLE2TextExtractor.MetadataTextExtractor">
            <summary>
            Returns an HPSF powered text extractor for the
            document properties metadata, such as title and author.
            </summary>
            <value></value>
        </member>
        <member name="T:NPOI.POITextExtractor">
            <summary>
            Common Parent for Text Extractors
            of POI Documents.
            You will typically find the implementation of
            a given format's text extractor under
            org.apache.poi.[format].extractor .
            </summary>
            @see org.apache.poi.hssf.extractor.ExcelExtractor
            @see org.apache.poi.hslf.extractor.PowerPointExtractor
            @see org.apache.poi.hdgf.extractor.VisioTextExtractor
            @see org.apache.poi.hwpf.extractor.WordExtractor
        </member>
        <member name="F:NPOI.POITextExtractor.document">
            The POIDocument that's open 
        </member>
        <member name="M:NPOI.POITextExtractor.#ctor(NPOI.POIDocument)">
            <summary>
            Creates a new text extractor for the given document
            </summary>
            <param name="document">The document.</param>
        </member>
        <member name="M:NPOI.POITextExtractor.#ctor(NPOI.POITextExtractor)">
            <summary>
            Creates a new text extractor, using the same
            document as another text extractor. Normally
            only used by properties extractors.
            </summary>
            <param name="otherExtractor">The other extractor.</param>
        </member>
        <member name="P:NPOI.POITextExtractor.Text">
            <summary>
            Retrieves all the text from the document.
            How cells, paragraphs etc are separated in the text
            is implementation specific - see the javadocs for
            a specific project for details.
            </summary>
            <value>All the text from the document.</value>
        </member>
        <member name="P:NPOI.POITextExtractor.MetadataTextExtractor">
            <summary>
            Returns another text extractor, which is able to
            output the textual content of the document
            metadata / properties, such as author and title.
            </summary>
            <value>The metadata text extractor.</value>
        </member>
        <member name="T:NPOI.POIFS.Common.POIFSConstants">
            <summary>
            A repository for constants shared by POI classes.
            @author Marc Johnson (mjohnson at apache dot org)
            </summary>
        </member>
        <member name="F:NPOI.POIFS.Common.POIFSConstants.BIG_BLOCK_SIZE">
            Most files use 512 bytes as their big block size 
        </member>
        <member name="F:NPOI.POIFS.Common.POIFSConstants.MINI_BLOCK_SIZE">
            Most files use 512 bytes as their big block size 
        </member>
        <member name="F:NPOI.POIFS.Common.POIFSConstants.LARGER_BIG_BLOCK_SIZE">
            Some use 4096 bytes 
        </member>
        <member name="T:NPOI.POIFS.Dev.POIFSViewable">
            <summary>
            Interface for a drill-down viewable object. Such an object has
            content that may or may not be displayed, at the discretion of the
            viewer. The content is returned to the viewer as an array or as an
            Iterator, and the object provides a clue as to which technique the
            viewer should use to get its content.
            A POIFSViewable object is also expected to provide a short
            description of itself, that can be used by a viewer when the
            viewable object is collapsed.
            @author Marc Johnson (mjohnson at apache dot org)
            </summary>
        </member>
        <member name="P:NPOI.POIFS.Dev.POIFSViewable.PreferArray">
            <summary>
            Provides a short description of the object to be used when a 
            POIFSViewable object has not provided its contents.
            </summary>
            <value><c>true</c> if [prefer array]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:NPOI.POIFS.Dev.POIFSViewable.ShortDescription">
            <summary>
            Gets the short description.
            </summary>
            <value>The short description.</value>
        </member>
        <member name="P:NPOI.POIFS.Dev.POIFSViewable.ViewableArray">
            <summary>
            Get an array of objects, some of which may implement POIFSViewable
            </summary>
            <value>The viewable array.</value>
        </member>
        <member name="P:NPOI.POIFS.Dev.POIFSViewable.ViewableIterator">
            <summary>
            Give viewers a hint as to whether to call ViewableArray or ViewableIterator
            </summary>
            <value>The viewable iterator.</value>
        </member>
        <member name="T:NPOI.POIFS.Dev.POIFSViewEngine">
            <summary>
            This class contains methods used to inspect POIFSViewable objects
            @author Marc Johnson (mjohnson at apache dot org)
            </summary>
        </member>
        <member name="M:NPOI.POIFS.Dev.POIFSViewEngine.InspectViewable(System.Object,System.Boolean,System.Int32,System.String)">
            <summary>
            Inspect an object that may be viewable, and drill down if told to
            </summary>
            <param name="viewable">the object to be viewed</param>
            <param name="drilldown">if <c>true</c> and the object implements POIFSViewable, inspect the objects' contents</param>
            <param name="indentLevel">how far in to indent each string</param>
            <param name="indentString">string to use for indenting</param>
            <returns>a List of Strings holding the content</returns>
        </member>
        <member name="M:NPOI.POIFS.Dev.POIFSViewEngine.Indent(System.Int32,System.String,System.String)">
            <summary>
            Indents the specified indent level.
            </summary>
            <param name="indentLevel">how far in to indent each string</param>
            <param name="indentString">string to use for indenting</param>
            <param name="data">The data.</param>
            <returns></returns>
        </member>
        <member name="T:NPOI.POIFS.EventFileSystem.POIFSReader">
            <summary>
            An event-driven Reader for POIFS file systems. Users of this class
            first Create an instance of it, then use the RegisterListener
            methods to Register POIFSReaderListener instances for specific
            documents. Once all the listeners have been Registered, the Read()
            method is called, which results in the listeners being notified as
            their documents are Read.
            @author Marc Johnson (mjohnson at apache dot org)
            </summary>
        </member>
        <member name="M:NPOI.POIFS.EventFileSystem.POIFSReader.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.POIFS.EventFileSystem.POIFSReader"/> class.
            </summary>
        </member>
        <member name="M:NPOI.POIFS.EventFileSystem.POIFSReader.Read(System.IO.Stream)">
            <summary>
            Read from an InputStream and Process the documents we Get
            </summary>
            <param name="stream">the InputStream from which to Read the data</param>
            <returns>POIFSDocument list</returns>
        </member>
        <member name="M:NPOI.POIFS.EventFileSystem.POIFSReader.ProcessProperties(NPOI.POIFS.Storage.BlockList,NPOI.POIFS.Storage.BlockList,System.Collections.IEnumerator,NPOI.POIFS.FileSystem.POIFSDocumentPath)">
            <summary>
            Processes the properties.
            </summary>
            <param name="small_blocks">The small_blocks.</param>
            <param name="big_blocks">The big_blocks.</param>
            <param name="properties">The properties.</param>
            <param name="path">The path.</param>
            <returns></returns>
        </member>
        <member name="T:NPOI.POIFS.EventFileSystem.POIFSReaderEventArgs">
            <summary>
            EventArgs for POIFSReader
            author: Tony Qu
            </summary>
        </member>
        <member name="T:NPOI.POIFS.EventFileSystem.POIFSWriterEvent">
            <summary>
            Class POIFSWriterEvent
            @author Marc Johnson (mjohnson at apache dot org)
            </summary>
        </member>
        <member name="M:NPOI.POIFS.EventFileSystem.POIFSWriterEvent.#ctor(System.IO.Stream,NPOI.POIFS.FileSystem.POIFSDocumentPath,System.String,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.POIFS.EventFileSystem.POIFSWriterEvent"/> class.
            </summary>
            <param name="stream">the DocumentOutputStream, freshly opened</param>
            <param name="path">the path of the document</param>
            <param name="documentName">the name of the document</param>
            <param name="limit">the limit, in bytes, that can be written to the stream</param>
        </member>
        <member name="P:NPOI.POIFS.EventFileSystem.POIFSWriterEvent.Limit">
            <summary>
            Gets the limit on writing, in bytes
            </summary>
            <value>The limit.</value>
        </member>
        <member name="P:NPOI.POIFS.EventFileSystem.POIFSWriterEvent.Name">
            <summary>
            Gets the document's name
            </summary>
            <value>The name.</value>
        </member>
        <member name="P:NPOI.POIFS.EventFileSystem.POIFSWriterEvent.Path">
            <summary>
            Gets the document's path
            </summary>
            <value>The path.</value>
        </member>
        <member name="P:NPOI.POIFS.EventFileSystem.POIFSWriterEvent.Stream">
            <summary>
            the DocumentOutputStream, freshly opened
            </summary>
            <value>The stream.</value>
        </member>
        <member name="T:NPOI.POIFS.EventFileSystem.POIFSWriterEventArgs">
            <summary>
            EventArgs for POIFSWriter
            author: Tony Qu
            </summary>
        </member>
        <member name="M:NPOI.POIFS.EventFileSystem.POIFSWriterEventArgs.#ctor(NPOI.POIFS.FileSystem.POIFSDocumentWriter,NPOI.POIFS.FileSystem.POIFSDocumentPath,System.String,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.POIFS.EventFileSystem.POIFSWriterEvent"/> class.
            </summary>
            <param name="stream">the POIFSDocumentWriter, freshly opened</param>
            <param name="path">the path of the document</param>
            <param name="documentName">the name of the document</param>
            <param name="limit">the limit, in bytes, that can be written to the stream</param>
        </member>
        <member name="P:NPOI.POIFS.EventFileSystem.POIFSWriterEventArgs.Limit">
            <summary>
            Gets the limit on writing, in bytes
            </summary>
            <value>The limit.</value>
        </member>
        <member name="P:NPOI.POIFS.EventFileSystem.POIFSWriterEventArgs.Name">
            <summary>
            Gets the document's name
            </summary>
            <value>The name.</value>
        </member>
        <member name="P:NPOI.POIFS.EventFileSystem.POIFSWriterEventArgs.Path">
            <summary>
            Gets the document's path
            </summary>
            <value>The path.</value>
        </member>
        <member name="P:NPOI.POIFS.EventFileSystem.POIFSWriterEventArgs.Stream">
            <summary>
            the POIFSDocumentWriter, freshly opened
            </summary>
            <value>The stream.</value>
        </member>
        <member name="T:NPOI.POIFS.EventFileSystem.POIFSWriterListener">
            <summary>
            Interface POIFSWriterListener
            @author Marc Johnson (mjohnson at apache dot org)
            </summary>
        </member>
        <member name="M:NPOI.POIFS.EventFileSystem.POIFSWriterListener.ProcessPOIFSWriterEvent(NPOI.POIFS.EventFileSystem.POIFSWriterEvent)">
            <summary>
             Process a POIFSWriterEvent that this listener had registered for
            </summary>
            <param name="evt">the POIFSWriterEvent</param>
        </member>
        <member name="T:NPOI.POIFS.FileSystem.BATManaged">
            <summary>
            This interface defines behaviors for objects managed by the Block
            Allocation Table (BAT).
            @author Marc Johnson (mjohnson at apache dot org)
            </summary>
        </member>
        <member name="P:NPOI.POIFS.FileSystem.BATManaged.CountBlocks">
            <summary>
            Gets the number of BigBlock's this instance uses
            </summary>
            <value>count of BigBlock instances</value>
        </member>
        <member name="P:NPOI.POIFS.FileSystem.BATManaged.StartBlock">
            <summary>
            Sets the start block for this instance
            </summary>
            <value>index into the array of BigBlock instances making up the the filesystem</value>
        </member>
        <member name="T:NPOI.POIFS.FileSystem.DirectoryEntry">
            <summary>
            This interface defines methods specific to Directory objects
            managed by a Filesystem instance.
            @author Marc Johnson (mjohnson at apache dot org)
            </summary>
        </member>
        <member name="P:NPOI.POIFS.FileSystem.DirectoryEntry.Entries">
            <summary>
            get an iterator of the Entry instances contained directly in
            this instance (in other words, children only; no grandchildren
            etc.)
            </summary>
            <value>The entries.never null, but hasNext() may return false
            immediately (i.e., this DirectoryEntry is empty). All
            objects retrieved by next() are guaranteed to be
            implementations of Entry.</value>
        </member>
        <member name="P:NPOI.POIFS.FileSystem.DirectoryEntry.IsEmpty">
             <summary>
            is this DirectoryEntry empty?
             </summary>
             <value><c>true</c> if this instance contains no Entry instances; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:NPOI.POIFS.FileSystem.DirectoryEntry.EntryCount">
            <summary>
            find out how many Entry instances are contained directly within
            this DirectoryEntry
            </summary>
            <value>number of immediately (no grandchildren etc.) contained
            Entry instances</value>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.DirectoryEntry.GetEntry(System.String)">
            <summary>
            get a specified Entry by name
            </summary>
            <param name="name">the name of the Entry to obtain.</param>
            <returns>the specified Entry, if it is directly contained in
            this DirectoryEntry</returns>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.DirectoryEntry.CreateDocument(System.String,System.IO.Stream)">
            <summary>
            Create a new DocumentEntry
            </summary>
            <param name="name">the name of the new DocumentEntry</param>
            <param name="stream">the Stream from which to Create the new DocumentEntry</param>
            <returns>the new DocumentEntry</returns>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.DirectoryEntry.CreateDocument(System.String,System.Int32)">
            <summary>
            Create a new DocumentEntry; the data will be provided later
            </summary>
            <param name="name">the name of the new DocumentEntry</param>
            <param name="size">the size of the new DocumentEntry</param>
            <returns>the new DocumentEntry</returns>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.DirectoryEntry.CreateDocument(System.String,System.Int32,NPOI.POIFS.EventFileSystem.POIFSWriterEventHandler)">
            <summary>
            Create a new DocumentEntry; the data will be provided later
            </summary>
            <param name="name">the name of the new DocumentEntry</param>
            <param name="size">the size of the new DocumentEntry</param>
            <param name="writer">BeforeWriting event handler</param>
            <returns>the new DocumentEntry</returns>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.DirectoryEntry.CreateDirectory(System.String)">
            <summary>
            Create a new DirectoryEntry
            </summary>
            <param name="name">the name of the new DirectoryEntry</param>
            <returns>the name of the new DirectoryEntry</returns>
        </member>
        <member name="P:NPOI.POIFS.FileSystem.DirectoryEntry.StorageClsid">
            <summary>
            Gets or sets the storage ClassID.
            </summary>
            <value>The storage ClassID.</value>
        </member>
        <member name="T:NPOI.POIFS.FileSystem.DirectoryNode">
            <summary>
            Simple implementation of DirectoryEntry
            @author Marc Johnson (mjohnson at apache dot org)
            </summary>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.DirectoryNode.#ctor(NPOI.POIFS.Properties.DirectoryProperty,NPOI.POIFS.FileSystem.POIFSFileSystem,NPOI.POIFS.FileSystem.DirectoryNode)">
            <summary>
            Create a DirectoryNode. This method Is not public by design; it
            Is intended strictly for the internal use of this package
            </summary>
            <param name="property">the DirectoryProperty for this DirectoryEntry</param>
            <param name="filesystem">the POIFSFileSystem we belong to</param>
            <param name="parent">the parent of this entry</param>
        </member>
        <member name="P:NPOI.POIFS.FileSystem.DirectoryNode.Path">
            <summary>
            Gets the path.
            </summary>
            <value>this directory's path representation</value>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.DirectoryNode.CreatePOIFSDocumentReader(System.String)">
            <summary>
            open a document in the directory's entry's list of entries
            </summary>
            <param name="documentName">the name of the document to be opened</param>
            <returns>a newly opened DocumentStream</returns>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.DirectoryNode.CreateDocument(NPOI.POIFS.FileSystem.POIFSDocument)">
            <summary>
            Create a new DocumentEntry
            </summary>
            <param name="document">the new document</param>
            <returns>the new DocumentEntry</returns>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.DirectoryNode.ChangeName(System.String,System.String)">
            <summary>
            Change a contained Entry's name
            </summary>
            <param name="oldName">the original name</param>
            <param name="newName">the new name</param>
            <returns>true if the operation succeeded, else false</returns>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.DirectoryNode.DeleteEntry(NPOI.POIFS.FileSystem.EntryNode)">
            <summary>
            Deletes the entry.
            </summary>
            <param name="entry">the EntryNode to be Deleted</param>
            <returns>true if the entry was Deleted, else false</returns>
        </member>
        <member name="P:NPOI.POIFS.FileSystem.DirectoryNode.Entries">
            <summary>
            get an iterator of the Entry instances contained directly in
            this instance (in other words, children only; no grandchildren
            etc.)
            </summary>
            <value>
            The entries.never null, but hasNext() may return false
            immediately (i.e., this DirectoryEntry is empty). All
            objects retrieved by next() are guaranteed to be
            implementations of Entry.
            </value>
        </member>
        <member name="P:NPOI.POIFS.FileSystem.DirectoryNode.IsEmpty">
            <summary>
            is this DirectoryEntry empty?
            </summary>
            <value>
            	<c>true</c> if this instance contains no Entry instances; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:NPOI.POIFS.FileSystem.DirectoryNode.EntryCount">
            <summary>
            find out how many Entry instances are contained directly within
            this DirectoryEntry
            </summary>
            <value>
            number of immediately (no grandchildren etc.) contained
            Entry instances
            </value>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.DirectoryNode.GetEntry(System.String)">
            <summary>
            get a specified Entry by name
            </summary>
            <param name="name">the name of the Entry to obtain.</param>
            <returns>
            the specified Entry, if it is directly contained in
            this DirectoryEntry
            </returns>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.DirectoryNode.CreateDocument(System.String,System.IO.Stream)">
            <summary>
            Create a new DocumentEntry
            </summary>
            <param name="name">the name of the new DocumentEntry</param>
            <param name="stream">the Stream from which to Create the new DocumentEntry</param>
            <returns>the new DocumentEntry</returns>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.DirectoryNode.CreateDocument(System.String,System.Int32)">
            <summary>
            Create a new DocumentEntry; the data will be provided later
            </summary>
            <param name="name">the name of the new DocumentEntry</param>
            <param name="size">the size of the new DocumentEntry</param>
            <returns>the new DocumentEntry</returns>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.DirectoryNode.CreateDocument(System.String,System.Int32,NPOI.POIFS.EventFileSystem.POIFSWriterEventHandler)">
            <summary>
            Create a new DocumentEntry; the data will be provided later
            </summary>
            <param name="name">the name of the new DocumentEntry</param>
            <param name="size">the size of the new DocumentEntry</param>
            <param name="beforewriting"></param>
            <returns>the new DocumentEntry</returns>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.DirectoryNode.CreateDirectory(System.String)">
            <summary>
            Create a new DirectoryEntry
            </summary>
            <param name="name">the name of the new DirectoryEntry</param>
            <returns>the name of the new DirectoryEntry</returns>
        </member>
        <member name="P:NPOI.POIFS.FileSystem.DirectoryNode.StorageClsid">
            <summary>
            Gets or Sets the storage clsid for the directory entry
            </summary>
            <value>The storage ClassID.</value>
        </member>
        <member name="P:NPOI.POIFS.FileSystem.DirectoryNode.IsDirectoryEntry">
            <summary>
            Is this a DirectoryEntry?
            </summary>
            <value>true if the Entry Is a DirectoryEntry, else false</value>
        </member>
        <member name="P:NPOI.POIFS.FileSystem.DirectoryNode.IsDeleteOK">
            <summary>
            extensions use this method to verify internal rules regarding
            deletion of the underlying store.
            </summary>
            <value> true if it's ok to Delete the underlying store, else
            false</value>
        </member>
        <member name="P:NPOI.POIFS.FileSystem.DirectoryNode.ViewableArray">
            <summary>
            Get an array of objects, some of which may implement POIFSViewable
            </summary>
            <value>an array of Object; may not be null, but may be empty</value>
        </member>
        <member name="P:NPOI.POIFS.FileSystem.DirectoryNode.ViewableIterator">
            <summary>
            Get an Iterator of objects, some of which may implement
            POIFSViewable
            </summary>
            <value>an Iterator; may not be null, but may have an empty
            back end store</value>
        </member>
        <member name="P:NPOI.POIFS.FileSystem.DirectoryNode.PreferArray">
            <summary>
            Give viewers a hint as to whether to call GetViewableArray or
            GetViewableIterator
            </summary>
            <value><c>true</c> if a viewer should call GetViewableArray; otherwise, <c>false</c>if
            a viewer should call GetViewableIterator</value>
        </member>
        <member name="P:NPOI.POIFS.FileSystem.DirectoryNode.ShortDescription">
            <summary>
            Provides a short description of the object, to be used when a
            POIFSViewable object has not provided its contents.
            </summary>
            <value>The short description.</value>
        </member>
        <member name="T:NPOI.POIFS.FileSystem.DocumentDescriptor">
            <summary>
            Class DocumentDescriptor
            @author Marc Johnson (mjohnson at apache dot org)
            </summary>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.DocumentDescriptor.#ctor(NPOI.POIFS.FileSystem.POIFSDocumentPath,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.POIFS.FileSystem.DocumentDescriptor"/> class.
            </summary>
            <param name="path">the Document path</param>
            <param name="name">the Document name</param>
        </member>
        <member name="P:NPOI.POIFS.FileSystem.DocumentDescriptor.Path">
            <summary>
            Gets the path.
            </summary>
            <value>The path.</value>
        </member>
        <member name="P:NPOI.POIFS.FileSystem.DocumentDescriptor.Name">
            <summary>
            Gets the name.
            </summary>
            <value>The name.</value>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.DocumentDescriptor.Equals(System.Object)">
            <summary>
            equality. Two DocumentDescriptor instances are equal if they
            have equal paths and names
            </summary>
            <param name="o">the object we're checking equality for</param>
            <returns>true if the object is equal to this object</returns>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.DocumentDescriptor.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <returns>
            hashcode
            </returns>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.DocumentDescriptor.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="T:NPOI.POIFS.FileSystem.DocumentEntry">
            <summary>
            This interface defines methods specific to Document objects
            managed by a Filesystem instance.
            @author Marc Johnson (mjohnson at apache dot org)
            </summary>
        </member>
        <member name="P:NPOI.POIFS.FileSystem.DocumentEntry.Size">
            <summary>
            get the size of the document, in bytes
            </summary>
            <value>size in bytes</value>
        </member>
        <member name="T:NPOI.POIFS.FileSystem.DocumentNode">
            <summary>
            Simple implementation of DocumentEntry
            @author Marc Johnson (mjohnson at apache dot org)
            </summary>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.DocumentNode.#ctor(NPOI.POIFS.Properties.DocumentProperty,NPOI.POIFS.FileSystem.DirectoryNode)">
             create a DocumentNode. This method Is not public by design; it
             Is intended strictly for the internal use of this package
            
             @param property the DocumentProperty for this DocumentEntry
             @param parent the parent of this entry
        </member>
        <member name="P:NPOI.POIFS.FileSystem.DocumentNode.Document">
             get the POIFSDocument
            
             @return the internal POIFSDocument
        </member>
        <member name="P:NPOI.POIFS.FileSystem.DocumentNode.Size">
             get the zize of the document, in bytes
            
             @return size in bytes
        </member>
        <member name="P:NPOI.POIFS.FileSystem.DocumentNode.IsDocumentEntry">
             Is this a DocumentEntry?
            
             @return true if the Entry Is a DocumentEntry, else false
        </member>
        <member name="P:NPOI.POIFS.FileSystem.DocumentNode.IsDeleteOK">
             extensions use this method to verify internal rules regarding
             deletion of the underlying store.
            
             @return true if it's ok to delete the underlying store, else
                     false
        </member>
        <member name="P:NPOI.POIFS.FileSystem.DocumentNode.ViewableArray">
             Get an array of objects, some of which may implement
             POIFSViewable
            
             @return an array of Object; may not be null, but may be empty
        </member>
        <member name="P:NPOI.POIFS.FileSystem.DocumentNode.ViewableIterator">
             Get an Iterator of objects, some of which may implement
             POIFSViewable
            
             @return an Iterator; may not be null, but may have an empty
             back end store
        </member>
        <member name="P:NPOI.POIFS.FileSystem.DocumentNode.PreferArray">
             Give viewers a hint as to whether to call getViewableArray or
             getViewableIterator
            
             @return true if a viewer should call getViewableArray, false if
                     a viewer should call getViewableIterator
        </member>
        <member name="P:NPOI.POIFS.FileSystem.DocumentNode.ShortDescription">
             Provides a short description of the object, to be used when a
             POIFSViewable object has not provided its contents.
            
             @return short description
        </member>
        <member name="T:NPOI.POIFS.FileSystem.Entry">
            <summary>
            This interface provides access to an object managed by a Filesystem
            instance. Entry objects are further divided into DocumentEntry and
            DirectoryEntry instances.
            @author Marc Johnson (mjohnson at apache dot org)
            </summary>
        </member>
        <member name="P:NPOI.POIFS.FileSystem.Entry.Name">
            <summary>
            Get the name of the Entry
            </summary>
            <value>The name.</value>
        </member>
        <member name="P:NPOI.POIFS.FileSystem.Entry.IsDirectoryEntry">
            <summary>
            Is this a DirectoryEntry?
            </summary>
            <value>
            	<c>true</c> if the Entry Is a DirectoryEntry; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:NPOI.POIFS.FileSystem.Entry.IsDocumentEntry">
            <summary>
            Is this a DocumentEntry?
            </summary>
            <value>
            	<c>true</c> if the Entry Is a DocumentEntry; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.Entry.Delete">
            <summary>
            Delete this Entry. ThIs operation should succeed, but there are
            special circumstances when it will not:
            If this Entry Is the root of the Entry tree, it cannot be
            deleted, as there Is no way to Create another one.
            If this Entry Is a directory, it cannot be deleted unless it Is
            empty.
            </summary>
            <returns>true if the Entry was successfully deleted, else false</returns>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.Entry.RenameTo(System.String)">
            <summary>
            Rename this Entry. ThIs operation will fail if:
            There Is a sibling Entry (i.e., an Entry whose parent Is the
            same as this Entry's parent) with the same name.
            ThIs Entry Is the root of the Entry tree. Its name Is dictated
            by the Filesystem and many not be Changed.
            </summary>
            <param name="newName">the new name for this Entry</param>
            <returns>true if the operation succeeded, else false</returns>
        </member>
        <member name="T:NPOI.POIFS.FileSystem.EntryNode">
            <summary>
            Abstract implementation of Entry
            Extending classes should override isDocument() or isDirectory(), as
            appropriate
            Extending classes must override isDeleteOK()
            @author Marc Johnson (mjohnson at apache dot org)
            </summary>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.EntryNode.#ctor(NPOI.POIFS.Properties.Property,NPOI.POIFS.FileSystem.DirectoryNode)">
            <summary>
            Create a DocumentNode. ThIs method Is not public by design; it
            Is intended strictly for the internal use of extending classes
            </summary>
            <param name="property">the Property for this Entry</param>
            <param name="parent">the parent of this entry</param>
        </member>
        <member name="P:NPOI.POIFS.FileSystem.EntryNode.Property">
            <summary>
            grant access to the property
            </summary>
            <value>the property backing this entry</value>
        </member>
        <member name="P:NPOI.POIFS.FileSystem.EntryNode.IsRoot">
            <summary>
            Is this the root of the tree?
            </summary>
            <value><c>true</c> if this instance is root; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:NPOI.POIFS.FileSystem.EntryNode.IsDeleteOK">
            <summary>
            extensions use this method to verify internal rules regarding
            deletion of the underlying store.
            </summary>
            <value>
            	<c>true</c> if it's ok to Delete the underlying store; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:NPOI.POIFS.FileSystem.EntryNode.Name">
            <summary>
            Get the name of the Entry
            </summary>
            <value>The name.</value>
            Get the name of the Entry
            @return name
        </member>
        <member name="P:NPOI.POIFS.FileSystem.EntryNode.IsDirectoryEntry">
            <summary>
            Is this a DirectoryEntry?
            </summary>
            <value>
            	<c>true</c> if the Entry Is a DirectoryEntry; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:NPOI.POIFS.FileSystem.EntryNode.IsDocumentEntry">
            <summary>
            Is this a DocumentEntry?
            </summary>
            <value>
            	<c>true</c> if the Entry Is a DocumentEntry; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:NPOI.POIFS.FileSystem.EntryNode.Parent">
            <summary>
            Get this Entry's parent (the DocumentEntry that owns this
            Entry). All Entry objects, except the root Entry, has a parent.
            </summary>
            <value>this Entry's parent; null iff this Is the root Entry</value>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.EntryNode.Delete">
            <summary>
            Delete this Entry. ThIs operation should succeed, but there are
            special circumstances when it will not:
            If this Entry Is the root of the Entry tree, it cannot be
            deleted, as there Is no way to Create another one.
            If this Entry Is a directory, it cannot be deleted unless it Is
            empty.
            </summary>
            <returns>
            true if the Entry was successfully deleted, else false
            </returns>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.EntryNode.RenameTo(System.String)">
            <summary>
            Rename this Entry. ThIs operation will fail if:
            There Is a sibling Entry (i.e., an Entry whose parent Is the
            same as this Entry's parent) with the same name.
            ThIs Entry Is the root of the Entry tree. Its name Is dictated
            by the Filesystem and many not be Changed.
            </summary>
            <param name="newName">the new name for this Entry</param>
            <returns>
            true if the operation succeeded, else false
            </returns>
        </member>
        <member name="T:NPOI.POIFS.FileSystem.OfficeXmlFileException">
            <summary>
            This exception is thrown when we try to open a file that's actually
            an Office 2007+ XML file, rather than an OLE2 file (which is what
            POI works with)
            @author Nick Burch
            </summary>
        </member>
        <member name="T:NPOI.POIFS.FileSystem.POIFSDocument">
            <summary>
            This class manages a document in the POIFS filesystem.
            @author Marc Johnson (mjohnson at apache dot org)
            </summary>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.POIFSDocument.#ctor(System.String,System.IO.Stream)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.POIFS.FileSystem.POIFSDocument"/> class.
            </summary>
            <param name="name">the name of the POIFSDocument</param>
            <param name="stream">the InputStream we read data from</param>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.POIFSDocument.#ctor(System.String,NPOI.POIFS.Storage.ListManagedBlock[],System.Int32)">
            <summary>
            Constructor from small blocks
            </summary>
            <param name="name">the name of the POIFSDocument</param>
            <param name="blocks">the small blocks making up the POIFSDocument</param>
            <param name="length">the actual length of the POIFSDocument</param>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.POIFSDocument.#ctor(System.String,NPOI.POIFS.Storage.RawDataBlock[],System.Int32)">
            <summary>
            Constructor from large blocks
            </summary>
            <param name="name">the name of the POIFSDocument</param>
            <param name="blocks">the big blocks making up the POIFSDocument</param>
            <param name="length">the actual length of the POIFSDocument</param>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.POIFSDocument.#ctor(System.String,NPOI.POIFS.Storage.SmallDocumentBlock[],System.Int32)">
            <summary>
            Constructor from small blocks
            </summary>
            <param name="name">the name of the POIFSDocument</param>
            <param name="blocks">Tthe small blocks making up the POIFSDocument</param>
            <param name="length">the actual length of the POIFSDocument</param>
        </member>
        <member name="E:NPOI.POIFS.FileSystem.POIFSDocument.BeforeWriting">
            <summary>
            Occurs when [before writing].
            </summary>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.POIFSDocument.#ctor(System.String,System.Int32,NPOI.POIFS.FileSystem.POIFSDocumentPath)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.POIFS.FileSystem.POIFSDocument"/> class.
            </summary>
            <param name="name">the name of the POIFSDocument</param>
            <param name="size">the length of the POIFSDocument</param>
            <param name="path">the path of the POIFSDocument</param>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.POIFSDocument.Read(System.Byte[],System.Int32)">
            <summary>
            read data from the internal stores
            </summary>
            <param name="buffer">the buffer to write to</param>
            <param name="offset">the offset into our storage to read from</param>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.POIFSDocument.WriteBlocks(System.IO.Stream)">
            <summary>
            Writes the blocks.
            </summary>
            <param name="stream">The stream.</param>
        </member>
        <member name="P:NPOI.POIFS.FileSystem.POIFSDocument.CountBlocks">
            <summary>
            Gets the number of BigBlock's this instance uses
            </summary>
            <value>count of BigBlock instances</value>
        </member>
        <member name="P:NPOI.POIFS.FileSystem.POIFSDocument.DocumentProperty">
            <summary>
            Gets the document property.
            </summary>
            <value>The document property.</value>
        </member>
        <member name="P:NPOI.POIFS.FileSystem.POIFSDocument.PreferArray">
            <summary>
            Provides a short description of the object to be used when a
            POIFSViewable object has not provided its contents.
            </summary>
            <value><c>true</c> if [prefer array]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:NPOI.POIFS.FileSystem.POIFSDocument.ShortDescription">
            <summary>
            Gets the short description.
            </summary>
            <value>The short description.</value>
        </member>
        <member name="P:NPOI.POIFS.FileSystem.POIFSDocument.Size">
            <summary>
            Gets the size.
            </summary>
            <value>The size.</value>
        </member>
        <member name="P:NPOI.POIFS.FileSystem.POIFSDocument.SmallBlocks">
            <summary>
            Gets the small blocks.
            </summary>
            <value>The small blocks.</value>
        </member>
        <member name="P:NPOI.POIFS.FileSystem.POIFSDocument.StartBlock">
            <summary>
            Sets the start block for this instance
            </summary>
            <value>
            index into the array of BigBlock instances making up the the filesystem
            </value>
        </member>
        <member name="P:NPOI.POIFS.FileSystem.POIFSDocument.ViewableArray">
            <summary>
            Get an array of objects, some of which may implement POIFSViewable
            </summary>
            <value>The viewable array.</value>
        </member>
        <member name="P:NPOI.POIFS.FileSystem.POIFSDocument.ViewableIterator">
            <summary>
            Give viewers a hint as to whether to call ViewableArray or ViewableIterator
            </summary>
            <value>The viewable iterator.</value>
        </member>
        <member name="T:NPOI.POIFS.FileSystem.POIFSDocumentPath">
            <summary>
            Class POIFSDocumentPath
            @author Marc Johnson (mjohnson at apache dot org)
            </summary>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.POIFSDocumentPath.#ctor">
            <summary>
            simple constructor for the path of a document that is in the
            root of the POIFSFileSystem. The constructor that takes an
            array of Strings can also be used to create such a
            POIFSDocumentPath by passing it a null or empty String array
            </summary>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.POIFSDocumentPath.#ctor(System.String[])">
            <summary>
            constructor for the path of a document that is not in the root
            of the POIFSFileSystem
            </summary>
            <param name="components">the Strings making up the path to a document.
            The Strings must be ordered as they appear in
            the directory hierarchy of the the document
            -- the first string must be the name of a
            directory in the root of the POIFSFileSystem,
            and every Nth (for N &gt; 1) string thereafter
            must be the name of a directory in the
            directory identified by the (N-1)th string.
            If the components parameter is null or has
            zero length, the POIFSDocumentPath is
            appropriate for a document that is in the
            root of a POIFSFileSystem</param>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.POIFSDocumentPath.#ctor(NPOI.POIFS.FileSystem.POIFSDocumentPath,System.String[])">
            <summary>
            constructor that adds additional subdirectories to an existing
            path
            </summary>
            <param name="path">the existing path</param>
            <param name="components">the additional subdirectory names to be added</param>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.POIFSDocumentPath.Equals(System.Object)">
            <summary>
            equality. Two POIFSDocumentPath instances are equal if they
            have the same number of component Strings, and if each
            component String is equal to its coresponding component String
            </summary>
            <param name="o">the object we're checking equality for</param>
            <returns>true if the object is equal to this object</returns>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.POIFSDocumentPath.GetComponent(System.Int32)">
            <summary>
            get the specified component
            </summary>
            <param name="n">which component (0 ... length() - 1)</param>
            <returns>the nth component;</returns>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.POIFSDocumentPath.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.POIFSDocumentPath.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="P:NPOI.POIFS.FileSystem.POIFSDocumentPath.Length">
            <summary>
            Gets the length.
            </summary>
            <value>the number of components</value>
        </member>
        <member name="P:NPOI.POIFS.FileSystem.POIFSDocumentPath.Parent">
            <summary>
            Returns the path's parent or <c>null</c> if this path
            is the root path.
            </summary>
            <value>path of parent, or null if this path is the root path</value>
        </member>
        <member name="T:NPOI.POIFS.FileSystem.POIFSDocumentReader">
            <summary>
            This class provides methods to read a DocumentEntry managed by a
            Filesystem instance.
            @author Marc Johnson (mjohnson at apache dot org)
            </summary>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.POIFSDocumentReader.#ctor(NPOI.POIFS.FileSystem.DocumentEntry)">
            <summary>
            Create an InputStream from the specified DocumentEntry
            </summary>
            <param name="document">the DocumentEntry to be read</param>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.POIFSDocumentReader.#ctor(NPOI.POIFS.FileSystem.POIFSDocument)">
            <summary>
            Create an InputStream from the specified Document
            </summary>
            <param name="document">the Document to be read</param>
        </member>
        <member name="P:NPOI.POIFS.FileSystem.POIFSDocumentReader.EOD">
            <summary>
            at the end Of document.
            </summary>
            <returns></returns>
        </member>
        <member name="P:NPOI.POIFS.FileSystem.POIFSDocumentReader.Available">
            <summary>
            Returns the number of bytes that can be read (or skipped over)
            from this input stream without blocking by the next caller of a
            method for this input stream. The next caller might be the same
            thread or or another thread.
            </summary>
            <value>the number of bytes that can be read from this input
            stream without blocking.</value>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.POIFSDocumentReader.Close">
            <summary>
            Closes the current stream and releases any resources (such as sockets and file handles) associated with the current stream.
            </summary>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.POIFSDocumentReader.Read(System.Byte[])">
            <summary>
            Reads some number of bytes from the input stream and stores
            them into the buffer array b. The number of bytes actually read
            is returned as an integer. The definition of this method in
            java.io.InputStream allows this method to block, but it won't.
            If b is null, a NullPointerException is thrown. If the length
            of b is zero, then no bytes are read and 0 is returned;
            otherwise, there is an attempt to read at least one byte. If no
            byte is available because the stream is at end of file, the
            value -1 is returned; otherwise, at least one byte is read and
            stored into b.
            The first byte read is stored into element b[0], the next one
            into b[1], and so on. The number of bytes read is, at most,
            equal to the length of b. Let k be the number of bytes actually
            read; these bytes will be stored in elements b[0] through
            b[k-1], leaving elements b[k] through b[b.length-1] unaffected.
            If the first byte cannot be read for any reason other than end
            of file, then an IOException is thrown. In particular, an
            IOException is thrown if the input stream has been closed.
            The read(b) method for class InputStream has the same effect as:
            </summary>
            <param name="b">the buffer into which the data is read.</param>
            <returns>the total number of bytes read into the buffer, or -1
            if there is no more data because the end of the stream
            has been reached.</returns>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.POIFSDocumentReader.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads up to len bytes of data from the input stream into an
            array of bytes. An attempt is made to read as many as len
            bytes, but a smaller number may be read, possibly zero. The
            number of bytes actually read is returned as an integer.
            The definition of this method in java.io.InputStream allows it
            to block, but it won't.
            If b is null, a NullPointerException is thrown.
            If off is negative, or len is negative, or off+len is greater
            than the length of the array b, then an
            IndexOutOfBoundsException is thrown.
            If len is zero, then no bytes are read and 0 is returned;
            otherwise, there is an attempt to read at least one byte. If no
            byte is available because the stream is at end of file, the
            value -1 is returned; otherwise, at least one byte is read and
            stored into b.
            The first byte read is stored into element b[off], the next one
            into b[off+1], and so on. The number of bytes read is, at most,
            equal to len. Let k be the number of bytes actually read; these
            bytes will be stored in elements b[off] through b[off+k-1],
            leaving elements b[off+k] through b[off+len-1] unaffected.
            In every case, elements b[0] through b[off] and elements
            b[off+len] through b[b.length-1] are unaffected.
            If the first byte cannot be read for any reason other than end
            of file, then an IOException is thrown. In particular, an
            IOException is thrown if the input stream has been closed.
            </summary>
            <param name="b">the buffer into which the data is read.</param>
            <param name="off">the start offset in array b at which the data is
                       written.</param>
            <param name="len">the maximum number of bytes to read.</param>
            <returns>the total number of bytes read into the buffer, or -1
                    if there is no more data because the end of the stream
                    has been reached.</returns>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.POIFSDocumentReader.ReadByte">
            <summary>
            Reads the next byte of data from the input stream. The value
            byte is returned as an int in the range 0 to 255. If no byte is
            available because the end of the stream has been reached, the
            value -1 is returned. The definition of this method in
            java.io.InputStream allows this method to block, but it won't.        
            </summary>
            <returns>the next byte of data, or -1 if the end of the stream
            is reached.
            </returns>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.POIFSDocumentReader.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            When overridden in a derived class, sets the position within the current stream.
            </summary>
            <param name="offset">A byte offset relative to the <paramref name="origin"/> parameter.</param>
            <param name="origin">A value of type <see cref="T:System.IO.SeekOrigin"/> indicating the reference point used to obtain the new position.</param>
            <returns>
            The new position within the current stream.
            </returns>
            <exception cref="T:System.IO.IOException">
            An I/O error occurs.
            </exception>
            <exception cref="T:System.NotSupportedException">
            The stream does not support seeking, such as if the stream is constructed from a pipe or console output.
            </exception>
            <exception cref="T:System.ObjectDisposedException">
            Methods were called after the stream was closed.
            </exception>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.POIFSDocumentReader.Skip(System.Int64)">
            <summary>
            Skips the specified n.
            </summary>
            <param name="n">The n.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.POIFSDocumentReader.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            When overridden in a derived class, writes a sequence of bytes to the current stream and advances the current position within this stream by the number of bytes written.
            </summary>
            <param name="buffer">An array of bytes. This method copies <paramref name="count"/> bytes from <paramref name="buffer"/> to the current stream.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at which to begin copying bytes to the current stream.</param>
            <param name="count">The number of bytes to be written to the current stream.</param>
            <exception cref="T:System.ArgumentException">
            The sum of <paramref name="offset"/> and <paramref name="count"/> is greater than the buffer length.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="buffer"/> is null.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="offset"/> or <paramref name="count"/> is negative.
            </exception>
            <exception cref="T:System.IO.IOException">
            An I/O error occurs.
            </exception>
            <exception cref="T:System.NotSupportedException">
            The stream does not support writing.
            </exception>
            <exception cref="T:System.ObjectDisposedException">
            Methods were called after the stream was closed.
            </exception>
        </member>
        <member name="P:NPOI.POIFS.FileSystem.POIFSDocumentReader.CanRead">
            <summary>
            When overridden in a derived class, gets a value indicating whether the current stream supports reading.
            </summary>
            <value></value>
            <returns>true if the stream supports reading; otherwise, false.
            </returns>
        </member>
        <member name="P:NPOI.POIFS.FileSystem.POIFSDocumentReader.CanSeek">
            <summary>
            When overridden in a derived class, gets a value indicating whether the current stream supports seeking.
            </summary>
            <value></value>
            <returns>true if the stream supports seeking; otherwise, false.
            </returns>
        </member>
        <member name="P:NPOI.POIFS.FileSystem.POIFSDocumentReader.CanWrite">
            <summary>
            When overridden in a derived class, gets a value indicating whether the current stream supports writing.
            </summary>
            <value></value>
            <returns>true if the stream supports writing; otherwise, false.
            </returns>
        </member>
        <member name="P:NPOI.POIFS.FileSystem.POIFSDocumentReader.Length">
            <summary>
            When overridden in a derived class, gets the length in bytes of the stream.
            </summary>
            <value></value>
            <returns>
            A long value representing the length of the stream in bytes.
            </returns>
            <exception cref="T:System.NotSupportedException">
            A class derived from Stream does not support seeking.
            </exception>
            <exception cref="T:System.ObjectDisposedException">
            Methods were called after the stream was closed.
            </exception>
        </member>
        <member name="P:NPOI.POIFS.FileSystem.POIFSDocumentReader.Position">
            <summary>
            When overridden in a derived class, gets or sets the position within the current stream.
            </summary>
            <value></value>
            <returns>
            The current position within the stream.
            </returns>
            <exception cref="T:System.IO.IOException">
            An I/O error occurs.
            </exception>
            <exception cref="T:System.NotSupportedException">
            The stream does not support seeking.
            </exception>
            <exception cref="T:System.ObjectDisposedException">
            Methods were called after the stream was closed.
            </exception>
        </member>
        <member name="T:NPOI.POIFS.FileSystem.POIFSDocumentWriter">
            <summary>
            This class provides a wrapper over an OutputStream so that Document
            writers can't accidently go over their size limits
            @author Marc Johnson (mjohnson at apache dot org)
            </summary>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.POIFSDocumentWriter.#ctor(System.IO.Stream,System.Int32)">
            <summary>
            Create a POIFSDocumentWriter
            </summary>
            <param name="stream">the OutputStream to which the data is actually</param>
            <param name="limit">the maximum number of bytes that can be written</param>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.POIFSDocumentWriter.Close">
            <summary>
            Closes this output stream and releases any system resources
            associated with this stream. The general contract of close is
            that it closes the output stream. A closed stream cannot
            perform output operations and cannot be reopened.
            </summary>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.POIFSDocumentWriter.Flush">
            <summary>
            Flushes this output stream and forces any buffered output bytes
            to be written out.
            </summary>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.POIFSDocumentWriter.Write(System.Byte[])">
            <summary>
            Writes b.length bytes from the specified byte array
            to this output stream.
            </summary>
            <param name="b">the data.</param>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.POIFSDocumentWriter.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes len bytes from the specified byte array starting at
            offset off to this output stream.  The general contract for
            write(b, off, len) is that some of the bytes in the array b are
            written to the output stream in order; element b[off] is the
            first byte written and b[off+len-1] is the last byte written by
            this operation.
            If b is null, a NullPointerException is thrown.
            If off is negative, or len is negative, or off+len is greater
            than the length of the array b, then an
            IndexOutOfBoundsException is thrown.
            </summary>
            <param name="b">the data.</param>
            <param name="off">the start offset in the data.</param>
            <param name="len">the number of bytes to write.</param>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.POIFSDocumentWriter.WriteByte(System.Byte)">
            <summary>
            Writes the specified byte to this output stream. The general
            contract for write is that one byte is written to the output
            stream. The byte to be written is the eight low-order bits of
            the argument b. The 24 high-order bits of b are ignored.
            </summary>
            <param name="b">the byte.</param>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.POIFSDocumentWriter.WriteFiller(System.Int32,System.Byte)">
            <summary>
            write the rest of the document's data (fill in at the end)
            </summary>
            <param name="totalLimit">the actual number of bytes the corresponding         
            document must fill</param>
            <param name="fill">the byte to fill remaining space with</param>
        </member>
        <member name="P:NPOI.POIFS.FileSystem.POIFSDocumentWriter.CanRead">
            <summary>
            When overridden in a derived class, gets a value indicating whether the current stream supports reading.
            </summary>
            <value></value>
            <returns>true if the stream supports reading; otherwise, false.
            </returns>
        </member>
        <member name="P:NPOI.POIFS.FileSystem.POIFSDocumentWriter.CanSeek">
            <summary>
            When overridden in a derived class, gets a value indicating whether the current stream supports seeking.
            </summary>
            <value></value>
            <returns>true if the stream supports seeking; otherwise, false.
            </returns>
        </member>
        <member name="P:NPOI.POIFS.FileSystem.POIFSDocumentWriter.CanWrite">
            <summary>
            When overridden in a derived class, gets a value indicating whether the current stream supports writing.
            </summary>
            <value></value>
            <returns>true if the stream supports writing; otherwise, false.
            </returns>
        </member>
        <member name="P:NPOI.POIFS.FileSystem.POIFSDocumentWriter.Length">
            <summary>
            When overridden in a derived class, gets the length in bytes of the stream.
            </summary>
            <value></value>
            <returns>
            A long value representing the length of the stream in bytes.
            </returns>
            <exception cref="T:System.NotSupportedException">
            A class derived from Stream does not support seeking.
            </exception>
            <exception cref="T:System.ObjectDisposedException">
            Methods were called after the stream was closed.
            </exception>
        </member>
        <member name="P:NPOI.POIFS.FileSystem.POIFSDocumentWriter.Position">
            <summary>
            When overridden in a derived class, gets or sets the position within the current stream.
            </summary>
            <value></value>
            <returns>
            The current position within the stream.
            </returns>
            <exception cref="T:System.IO.IOException">
            An I/O error occurs.
            </exception>
            <exception cref="T:System.NotSupportedException">
            The stream does not support seeking.
            </exception>
            <exception cref="T:System.ObjectDisposedException">
            Methods were called after the stream was closed.
            </exception>
        </member>
        <member name="T:NPOI.POIFS.FileSystem.POIFSFileSystem">
            <summary>
            This is the main class of the POIFS system; it manages the entire
            life cycle of the filesystem.
            @author Marc Johnson (mjohnson at apache dot org) 
            </summary>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.POIFSFileSystem.CreateNonClosingInputStream(System.IO.Stream)">
            <summary>
            Convenience method for clients that want to avoid the auto-Close behaviour of the constructor.
            </summary>
            <param name="stream">The stream.</param>
            <example>
            A convenience method (
            CreateNonClosingInputStream()) has been provided for this purpose:
            StreamwrappedStream = POIFSFileSystem.CreateNonClosingInputStream(is);
            HSSFWorkbook wb = new HSSFWorkbook(wrappedStream);
            is.reset();
            doSomethingElse(is);
            </example>
            <returns></returns>
        </member>
        <member name="F:NPOI.POIFS.FileSystem.POIFSFileSystem.bigBlockSize">
            What big block size the file uses. Most files
             use 512 bytes, but a few use 4096
        </member>
        <member name="M:NPOI.POIFS.FileSystem.POIFSFileSystem.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.POIFS.FileSystem.POIFSFileSystem"/> class.  intended for writing
            </summary>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.POIFSFileSystem.#ctor(System.IO.Stream)">
            <summary>
            Create a POIFSFileSystem from an Stream. Normally the stream is Read until
            EOF.  The stream is always Closed.  In the unlikely case that the caller has such a stream and
            needs to use it after this constructor completes, a work around is to wrap the
            stream in order to trap the Close() call.  
            </summary>
            <param name="stream">the Streamfrom which to Read the data</param>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.POIFSFileSystem.CloseInputStream(System.IO.Stream,System.Boolean)">
            @param stream the stream to be Closed
            @param success <c>false</c> if an exception is currently being thrown in the calling method
        </member>
        <member name="M:NPOI.POIFS.FileSystem.POIFSFileSystem.HasPOIFSHeader(System.IO.Stream)">
            <summary>
            Checks that the supplied Stream(which MUST
            support mark and reset, or be a PushbackInputStream)
            has a POIFS (OLE2) header at the start of it.
            If your Streamdoes not support mark / reset,
            then wrap it in a PushBackInputStream, then be
            sure to always use that, and not the original!
            </summary>
            <param name="inp">An Streamwhich supports either mark/reset, or is a PushbackStream</param>
            <returns>
            	<c>true</c> if [has POIFS header] [the specified inp]; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.POIFSFileSystem.CreateDocument(System.IO.Stream,System.String)">
            <summary>
            Create a new document to be Added to the root directory
            </summary>
            <param name="stream"> the Streamfrom which the document's data will be obtained</param>
            <param name="name">the name of the new POIFSDocument</param>
            <returns>the new DocumentEntry</returns>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.POIFSFileSystem.CreateDocument(System.String,System.Int32,NPOI.POIFS.EventFileSystem.POIFSWriterEventHandler)">
            <summary>
            Create a new DocumentEntry in the root entry; the data will be
            provided later
            </summary>
            <param name="name">the name of the new DocumentEntry</param>
            <param name="size">the size of the new DocumentEntry</param>
            <param name="writer">the Writer of the new DocumentEntry</param>
            <returns>the new DocumentEntry</returns>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.POIFSFileSystem.CreateDirectory(System.String)">
            <summary>
            Create a new DirectoryEntry in the root directory
            </summary>
            <param name="name">the name of the new DirectoryEntry</param>
            <returns>the new DirectoryEntry</returns>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.POIFSFileSystem.WriteFileSystem(System.IO.Stream)">
            <summary>
            Writes the file system.
            </summary>
            <param name="stream">the OutputStream to which the filesystem will be
            written</param>
        </member>
        <member name="P:NPOI.POIFS.FileSystem.POIFSFileSystem.Root">
            <summary>
            Get the root entry
            </summary>
            <value>The root.</value>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.POIFSFileSystem.CreatePOIFSDocumentReader(System.String)">
            <summary>
            open a document in the root entry's list of entries
            </summary>
            <param name="documentName">the name of the document to be opened</param>
            <returns>a newly opened POIFSDocumentReader</returns>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.POIFSFileSystem.AddDocument(NPOI.POIFS.FileSystem.POIFSDocument)">
            <summary>
            Add a new POIFSDocument
            </summary>
            <param name="document">the POIFSDocument being Added</param>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.POIFSFileSystem.AddDirectory(NPOI.POIFS.Properties.DirectoryProperty)">
            <summary>
            Add a new DirectoryProperty
            </summary>
            <param name="directory">The directory.</param>
        </member>
        <member name="M:NPOI.POIFS.FileSystem.POIFSFileSystem.Remove(NPOI.POIFS.FileSystem.EntryNode)">
            <summary>
            Removes the specified entry.
            </summary>
            <param name="entry">The entry.</param>
        </member>
        <member name="P:NPOI.POIFS.FileSystem.POIFSFileSystem.ViewableArray">
            <summary>
            Get an array of objects, some of which may implement
            POIFSViewable        
            </summary>
            <value>an array of Object; may not be null, but may be empty</value>
        </member>
        <member name="P:NPOI.POIFS.FileSystem.POIFSFileSystem.ViewableIterator">
            <summary>
            Get an Iterator of objects, some of which may implement
            POIFSViewable
            </summary>
            <value>an Iterator; may not be null, but may have an empty
            back end store</value>
        </member>
        <member name="P:NPOI.POIFS.FileSystem.POIFSFileSystem.PreferArray">
            <summary>
            Give viewers a hint as to whether to call GetViewableArray or
            GetViewableIterator
            </summary>
            <value><c>true</c> if a viewer should call GetViewableArray, <c>false</c> if
            a viewer should call GetViewableIterator </value>
        </member>
        <member name="P:NPOI.POIFS.FileSystem.POIFSFileSystem.ShortDescription">
            <summary>
            Provides a short description of the object, to be used when a
            POIFSViewable object has not provided its contents.
            </summary>
            <value>The short description.</value>
        </member>
        <member name="P:NPOI.POIFS.FileSystem.POIFSFileSystem.BigBlockSize">
            <summary>
            Gets The Big Block size, normally 512 bytes, sometimes 4096 bytes
            </summary>
            <value>The size of the big block.</value>
        </member>
        <member name="T:NPOI.POIFS.Properties.Child">
            <summary>
            This interface defines methods for finding and setting sibling
            Property instances
            @author Marc Johnson (mjohnson at apache dot org)
            </summary>
        </member>
        <member name="P:NPOI.POIFS.Properties.Child.PreviousChild">
            <summary>
            Gets or sets the previous child.
            </summary>
            <value>The previous child.</value>
        </member>
        <member name="P:NPOI.POIFS.Properties.Child.NextChild">
            <summary>
            Gets or sets the next child.
            </summary>
            <value>The next child.</value>
        </member>
        <member name="T:NPOI.POIFS.Properties.DirectoryProperty">
            <summary>
            Trivial extension of Property for POIFSDocuments
            @author Marc Johnson (mjohnson at apache dot org)
            </summary>
        </member>
        <member name="M:NPOI.POIFS.Properties.DirectoryProperty.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.POIFS.Properties.DirectoryProperty"/> class.
            </summary>
            <param name="name">the name of the directory</param>
        </member>
        <member name="M:NPOI.POIFS.Properties.DirectoryProperty.#ctor(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.POIFS.Properties.DirectoryProperty"/> class.
            </summary>
            <param name="index">index number</param>
            <param name="array">byte data</param>
            <param name="offset">offset into byte data</param>
        </member>
        <member name="M:NPOI.POIFS.Properties.DirectoryProperty.ChangeName(NPOI.POIFS.Properties.Property,System.String)">
            <summary>
            Change a Property's name
            </summary>
            <param name="property">the Property whose name Is being Changed.</param>
            <param name="newName">the new name for the Property</param>
            <returns>true if the name Change could be made, else false</returns>
        </member>
        <member name="M:NPOI.POIFS.Properties.DirectoryProperty.DeleteChild(NPOI.POIFS.Properties.Property)">
            <summary>
            Delete a Property
            </summary>
            <param name="property">the Property being Deleted</param>
            <returns>true if the Property could be Deleted, else false</returns>
        </member>
        <member name="T:NPOI.POIFS.Properties.DirectoryProperty.PropertyComparator">
            <summary>
            Directory Property Comparer
            </summary>
        </member>
        <member name="M:NPOI.POIFS.Properties.DirectoryProperty.PropertyComparator.Equals(System.Object)">
            <summary>
            Object equality, implemented as object identity
            </summary>
            <param name="o">Object we're being Compared to</param>
            <returns>true if identical, else false</returns>
        </member>
        <member name="M:NPOI.POIFS.Properties.DirectoryProperty.PropertyComparator.Compare(System.Object,System.Object)">
            <summary>
            Compare method. Assumes both parameters are non-null
            instances of Property. One property Is less than another if
            its name Is shorter than the other property's name. If the
            names are the same length, the property whose name comes
            before the other property's name, alphabetically, Is less
            than the other property.
            </summary>
            <param name="o1">first object to Compare, better be a Property</param>
            <param name="o2">second object to Compare, better be a Property</param>
            <returns>negative value if o1 smaller than o2,
                    zero           if o1 equals o2,
                   positive value if o1 bigger than  o2.</returns>
        </member>
        <member name="P:NPOI.POIFS.Properties.DirectoryProperty.IsDirectory">
            <summary>
            Gets a value indicating whether this instance is directory.
            </summary>
            <value>
            	<c>true</c> if a directory type Property; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:NPOI.POIFS.Properties.DirectoryProperty.PreWrite">
            <summary>
            Perform whatever activities need to be performed prior to
            writing
            </summary>
        </member>
        <member name="P:NPOI.POIFS.Properties.DirectoryProperty.Children">
            <summary>
            Get an iterator over the children of this Parent; all elements
            are instances of Property.
            </summary>
            <value>Iterator of children; may refer to an empty collection</value>
        </member>
        <member name="M:NPOI.POIFS.Properties.DirectoryProperty.AddChild(NPOI.POIFS.Properties.Property)">
            <summary>
            Add a new child to the collection of children
            </summary>
            <param name="property">the new child to be added; must not be null</param>
        </member>
        <member name="T:NPOI.POIFS.Properties.DocumentProperty">
            <summary>
            Trivial extension of Property for POIFSDocuments
            @author Marc Johnson (mjohnson at apache dot org)
            </summary>
        </member>
        <member name="M:NPOI.POIFS.Properties.DocumentProperty.#ctor(System.String,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.POIFS.Properties.DocumentProperty"/> class.
            </summary>
            <param name="name">POIFSDocument name</param>
            <param name="size">POIFSDocument size</param>
        </member>
        <member name="M:NPOI.POIFS.Properties.DocumentProperty.#ctor(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.POIFS.Properties.DocumentProperty"/> class.
            </summary>
            <param name="index">index number</param>
            <param name="array">byte data</param>
            <param name="offset">offset into byte data</param> 
        </member>
        <member name="P:NPOI.POIFS.Properties.DocumentProperty.Document">
            <summary>
            Gets or sets the document.
            </summary>
            <value>the associated POIFSDocument</value>
        </member>
        <member name="P:NPOI.POIFS.Properties.DocumentProperty.IsDirectory">
            <summary>
            Determines whether this instance is directory.
            </summary>
            <returns>
            	<c>true</c> if this instance is directory; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NPOI.POIFS.Properties.DocumentProperty.PreWrite">
            <summary>
            Perform whatever activities need to be performed prior to
            writing
            </summary>
        </member>
        <member name="T:NPOI.POIFS.Properties.Parent">
            <summary>
            Behavior for parent (directory) properties
            @author Marc Johnson27591@hotmail.com
            </summary>
        </member>
        <member name="P:NPOI.POIFS.Properties.Parent.Children">
            <summary>
            Get an iterator over the children of this Parent
            all elements are instances of Property.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NPOI.POIFS.Properties.Parent.AddChild(NPOI.POIFS.Properties.Property)">
            <summary>
            Add a new child to the collection of children
            </summary>
            <param name="property">the new child to be added; must not be null</param>
        </member>
        <member name="P:NPOI.POIFS.Properties.Parent.PreviousChild">
            <summary>
            Sets the previous child.
            </summary>
        </member>
        <member name="P:NPOI.POIFS.Properties.Parent.NextChild">
            <summary>
            Sets the next child.
            </summary>
        </member>
        <member name="T:NPOI.POIFS.Properties.Property">
            <summary>
            This abstract base class is the ancestor of all classes
            implementing POIFS Property behavior.
            @author Marc Johnson (mjohnson at apache dot org)
            </summary>
        </member>
        <member name="M:NPOI.POIFS.Properties.Property.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.POIFS.Properties.Property"/> class.
            </summary>
        </member>
        <member name="M:NPOI.POIFS.Properties.Property.#ctor(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Constructor from byte data
            </summary>
            <param name="index">index number</param>
            <param name="array">byte data</param>
            <param name="offset">offset into byte data</param>
        </member>
        <member name="M:NPOI.POIFS.Properties.Property.WriteData(System.IO.Stream)">
            <summary>
            Write the raw data to an OutputStream.
            </summary>
            <param name="stream">the OutputStream to which the data Should be
            written.</param>
        </member>
        <member name="P:NPOI.POIFS.Properties.Property.StartBlock">
            <summary>
            Gets or sets the start block for the document referred to by this
            Property.
            </summary>
            <value>the start block index</value>
        </member>
        <member name="P:NPOI.POIFS.Properties.Property.ShouldUseSmallBlocks">
            <summary>
            Based on the currently defined size, Should this property use
            small blocks?
            </summary>
            <returns>true if the size Is less than _big_block_minimum_bytes</returns>
        </member>
        <member name="M:NPOI.POIFS.Properties.Property.IsSmall(System.Int32)">
            <summary>
            does the length indicate a small document?
            </summary>
            <param name="length">length in bytes</param>
            <returns>
            	<c>true</c> if the length Is less than
            _big_block_minimum_bytes; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="P:NPOI.POIFS.Properties.Property.Name">
            <summary>
            Gets or sets the name of this property
            </summary>
            <value>property name</value>
        </member>
        <member name="P:NPOI.POIFS.Properties.Property.IsDirectory">
            <summary>
            Gets a value indicating whether this instance is directory.
            </summary>
            <value>
            	<c>true</c> if a directory type Property; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:NPOI.POIFS.Properties.Property.StorageClsid">
            <summary>
            Gets or sets the storage class ID for this property stream. ThIs Is the Class ID
            of the COM object which can read and write this property stream </summary>
            <value>Storage Class ID</value>
        </member>
        <member name="P:NPOI.POIFS.Properties.Property.PropertyType">
            <summary>
            Set the property type. Makes no attempt to validate the value.
            </summary>
            <value>the property type (root, file, directory)</value>
        </member>
        <member name="P:NPOI.POIFS.Properties.Property.NodeColor">
            <summary>
            Sets the color of the node.
            </summary>
            <value>the node color (red or black)</value>
        </member>
        <member name="P:NPOI.POIFS.Properties.Property.ChildProperty">
            <summary>
            Sets the child property.
            </summary>
            <value>the child property's index in the Property Table</value>
        </member>
        <member name="P:NPOI.POIFS.Properties.Property.ChildIndex">
            <summary>
            Get the child property (its index in the Property Table)
            </summary>
            <value>The index of the child.</value>
        </member>
        <member name="P:NPOI.POIFS.Properties.Property.Size">
            <summary>
            Gets or sets the size of the document associated with this Property
            </summary>
            <value>the size of the document, in bytes</value>
        </member>
        <member name="P:NPOI.POIFS.Properties.Property.Index">
            <summary>
            Gets or sets the index.
            </summary>
            <value>The index.</value>
            Get the index for this Property
            @return the index of this Property within its Property Table
        </member>
        <member name="M:NPOI.POIFS.Properties.Property.PreWrite">
            <summary>
            Perform whatever activities need to be performed prior to
            writing
            </summary>
        </member>
        <member name="P:NPOI.POIFS.Properties.Property.NextChildIndex">
            <summary>
            Gets the index of the next child.
            </summary>
            <value>The index of the next child.</value>
        </member>
        <member name="P:NPOI.POIFS.Properties.Property.PreviousChildIndex">
            <summary>
            Gets the index of the previous child.
            </summary>
            <value>The index of the previous child.</value>
        </member>
        <member name="M:NPOI.POIFS.Properties.Property.IsValidIndex(System.Int32)">
            <summary>
            Determines whether the specified index Is valid
            </summary>
            <param name="index">value to be checked</param>
            <returns>
            	<c>true</c> if the index Is valid; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="P:NPOI.POIFS.Properties.Property.PreviousChild">
            <summary>
            Gets or sets the previous child.
            </summary>
            <value>the new 'previous' child; may be null, which has
            the effect of saying there Is no 'previous' child</value>
        </member>
        <member name="P:NPOI.POIFS.Properties.Property.NextChild">
            <summary>
            Gets or sets the next Child
            </summary>
            <value> the new 'next' child; may be null, which has the
            effect of saying there Is no 'next' child</value>
        </member>
        <member name="P:NPOI.POIFS.Properties.Property.ViewableArray">
            <summary>
            Get an array of objects, some of which may implement
            POIFSViewable
            </summary>
            <value>an array of Object; may not be null, but may be empty</value>
        </member>
        <member name="P:NPOI.POIFS.Properties.Property.ViewableIterator">
            <summary>
            Get an Iterator of objects, some of which may implement POIFSViewable
            </summary>
            <value> may not be null, but may have an empty
            back end store</value>
        </member>
        <member name="P:NPOI.POIFS.Properties.Property.PreferArray">
            <summary>
            Give viewers a hint as to whether to call GetViewableArray or
            GetViewableIterator
            </summary>
            <value><c>true</c> if a viewer Should call GetViewableArray; otherwise, <c>false</c>
            if a viewer Should call GetViewableIterator
            </value>
        </member>
        <member name="P:NPOI.POIFS.Properties.Property.ShortDescription">
            <summary>
            Provides a short description of the object, to be used when a
            POIFSViewable object has not provided its contents.
            </summary>
            <value>The short description.</value>
        </member>
        <member name="T:NPOI.POIFS.Properties.PropertyConstants">
            <summary>
            Constants used by Properties namespace
            </summary>
        </member>
        <member name="M:NPOI.POIFS.Properties.PropertyFactory.ConvertToProperties(NPOI.POIFS.Storage.ListManagedBlock[])">
            <summary>
            Convert raw data blocks to an array of Property's
            </summary>
            <param name="blocks">The blocks to be converted</param>
            <returns>the converted List of Property objects. May contain
            nulls, but will not be null</returns>
        </member>
        <member name="M:NPOI.POIFS.Properties.PropertyTable.#ctor">
            Default constructor
        </member>
        <member name="M:NPOI.POIFS.Properties.PropertyTable.#ctor(System.Int32,NPOI.POIFS.Storage.RawDataBlockList)">
             reading constructor (used when we've read in a file and we want
             to extract the property table from it). Populates the
             properties thoroughly
            
             @param startBlock the first block of the property table
             @param blockList the list of blocks
            
             @exception IOException if anything goes wrong (which should be
                        a result of the input being NFG)
        </member>
        <member name="M:NPOI.POIFS.Properties.PropertyTable.AddProperty(NPOI.POIFS.Properties.Property)">
             Add a property to the list of properties we manage
            
             @param property the new Property to manage
        </member>
        <member name="M:NPOI.POIFS.Properties.PropertyTable.RemoveProperty(NPOI.POIFS.Properties.Property)">
             Remove a property from the list of properties we manage
            
             @param property the Property to be Removed
        </member>
        <member name="P:NPOI.POIFS.Properties.PropertyTable.Root">
             Get the root property
            
             @return the root property
        </member>
        <member name="M:NPOI.POIFS.Properties.PropertyTable.PreWrite">
            Prepare to be written
        </member>
        <member name="P:NPOI.POIFS.Properties.PropertyTable.StartBlock">
             Get the start block for the property table
            
             @return start block index
        </member>
        <member name="P:NPOI.POIFS.Properties.PropertyTable.CountBlocks">
             Return the number of BigBlock's this instance uses
            
             @return count of BigBlock instances
        </member>
        <member name="M:NPOI.POIFS.Properties.PropertyTable.WriteBlocks(System.IO.Stream)">
             Write the storage to an Stream
            
             @param stream the Stream to which the stored data should
                           be written
            
             @exception IOException on problems writing to the specified
                        stream
        </member>
        <member name="M:NPOI.POIFS.Properties.RootProperty.#ctor(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.POIFS.Properties.RootProperty"/> class.
            </summary>
            <param name="index">index number</param>
            <param name="array">byte data</param>
            <param name="offset">offset into byte data</param>
        </member>
        <member name="P:NPOI.POIFS.Properties.RootProperty.Size">
            <summary>
            Gets or sets the size of the document associated with this Property
            </summary>
            <value>the size of the document, in bytes</value>
        </member>
        <member name="T:NPOI.POIFS.Storage.BATBlock">
            <summary>
            A block of block allocation table entries. BATBlocks are created
            only through a static factory method: createBATBlocks.
            @author Marc Johnson (mjohnson at apache dot org)
            </summary>
        </member>
        <member name="M:NPOI.POIFS.Storage.BATBlock.#ctor">
            <summary>
            Create a single instance initialized with default values
            </summary>
        </member>
        <member name="M:NPOI.POIFS.Storage.BATBlock.CreateBATBlocks(System.Int32[])">
            <summary>
            Create an array of BATBlocks from an array of int block
            allocation table entries
            </summary>
            <param name="entries">the array of int entries</param>
            <returns>the newly created array of BATBlocks</returns>
        </member>
        <member name="M:NPOI.POIFS.Storage.BATBlock.CreateXBATBlocks(System.Int32[],System.Int32)">
            <summary>
            Create an array of XBATBlocks from an array of int block
            allocation table entries
            </summary>
            <param name="entries">the array of int entries</param>
            <param name="startBlock">the start block of the array of XBAT blocks</param>
            <returns>the newly created array of BATBlocks</returns>
        </member>
        <member name="M:NPOI.POIFS.Storage.BATBlock.CalculateStorageRequirements(System.Int32)">
            <summary>
            Calculate how many BATBlocks are needed to hold a specified
            number of BAT entries.
            </summary>
            <param name="entryCount">the number of entries</param>
            <returns>the number of BATBlocks needed</returns>
        </member>
        <member name="M:NPOI.POIFS.Storage.BATBlock.CalculateXBATStorageRequirements(System.Int32)">
            <summary>
            Calculate how many XBATBlocks are needed to hold a specified
            number of BAT entries.
            </summary>
            <param name="entryCount">the number of entries</param>
            <returns>the number of XBATBlocks needed</returns>
        </member>
        <member name="P:NPOI.POIFS.Storage.BATBlock.EntriesPerBlock">
            <summary>
            Gets the entries per block.
            </summary>
            <value>The number of entries per block</value>
        </member>
        <member name="P:NPOI.POIFS.Storage.BATBlock.EntriesPerXBATBlock">
            <summary>
            Gets the entries per XBAT block.
            </summary>
            <value>number of entries per XBAT block</value>
        </member>
        <member name="P:NPOI.POIFS.Storage.BATBlock.XBATChainOffset">
            <summary>
            Gets the XBAT chain offset.
            </summary>
            <value>offset of chain index of XBAT block</value>
        </member>
        <member name="M:NPOI.POIFS.Storage.BATBlock.#ctor(System.Int32[],System.Int32,System.Int32)">
            <summary>
            Create a single instance initialized (perhaps partially) with entries
            </summary>
            <param name="entries">the array of block allocation table entries</param>
            <param name="start_index">the index of the first entry to be written
            to the block</param>
            <param name="end_index">the index, plus one, of the last entry to be
            written to the block (writing is for all index
            k, start_index less than k less than end_index)
            </param>
        </member>
        <member name="M:NPOI.POIFS.Storage.BATBlock.WriteData(System.IO.Stream)">
            <summary>
            Write the block's data to an Stream
            </summary>
            <param name="stream">the Stream to which the stored data should
            be written</param>
        </member>
        <member name="T:NPOI.POIFS.Storage.BigBlock">
            <summary>
            Abstract base class of all POIFS block storage classes. All
            extensions of BigBlock should write 512 bytes of data when
            requested to write their data.
            This class has package scope, as there is no reason at this time to
            make the class public.
            @author Marc Johnson (mjohnson at apache dot org)
            </summary>
        </member>
        <member name="M:NPOI.POIFS.Storage.BigBlock.WriteData(System.IO.Stream,System.Byte[])">
            <summary>
            Default implementation of write for extending classes that
            contain their data in a simple array of bytes.
            </summary>
            <param name="stream">the OutputStream to which the data should be written.</param>
            <param name="data">the byte array of to be written.</param>
        </member>
        <member name="M:NPOI.POIFS.Storage.BigBlock.WriteBlocks(System.IO.Stream)">
            <summary>
            Write the block's data to an OutputStream
            </summary>
            <param name="stream">the OutputStream to which the stored data should be written</param>
        </member>
        <member name="M:NPOI.POIFS.Storage.BigBlock.WriteData(System.IO.Stream)">
            <summary>
            Write the storage to an OutputStream
            </summary>
            <param name="stream">the OutputStream to which the stored data should be written </param>
        </member>
        <member name="T:NPOI.POIFS.Storage.BlockAllocationTableReader">
            <summary>
            This class manages and creates the Block Allocation Table, which is
            basically a set of linked lists of block indices.
            Each block of the filesystem has an index. The first block, the
            header, is skipped; the first block after the header is index 0,
            the next is index 1, and so on.
            A block's index is also its index into the Block Allocation
            Table. The entry that it finds in the Block Allocation Table is the
            index of the next block in the linked list of blocks making up a
            file, or it is set to -2: end of list.
            
            @author Marc Johnson (mjohnson at apache dot org)
            </summary>
        </member>
        <member name="M:NPOI.POIFS.Storage.BlockAllocationTableReader.#ctor(System.Int32,System.Int32[],System.Int32,System.Int32,NPOI.POIFS.Storage.BlockList)">
            <summary>
            create a BlockAllocationTableReader for an existing filesystem. Side
            effect: when this method finishes, the BAT blocks will have
            been Removed from the raw block list, and any blocks labeled as
            'unused' in the block allocation table will also have been
            Removed from the raw block list. </summary>
            <param name="block_count">the number of BAT blocks making up the block allocation table</param>
            <param name="block_array">the array of BAT block indices from the
            filesystem's header</param>
            <param name="xbat_count">the number of XBAT blocks</param>
            <param name="xbat_index">the index of the first XBAT block</param>
            <param name="raw_block_list">the list of RawDataBlocks</param>
        </member>
        <member name="M:NPOI.POIFS.Storage.BlockAllocationTableReader.#ctor(NPOI.POIFS.Storage.ListManagedBlock[],NPOI.POIFS.Storage.BlockList)">
            <summary>
            create a BlockAllocationTableReader from an array of raw data blocks
            </summary>
            <param name="blocks">the raw data</param>
            <param name="raw_block_list">the list holding the managed blocks</param>
        </member>
        <member name="M:NPOI.POIFS.Storage.BlockAllocationTableReader.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.POIFS.Storage.BlockAllocationTableReader"/> class.
            </summary>
        </member>
        <member name="M:NPOI.POIFS.Storage.BlockAllocationTableReader.FetchBlocks(System.Int32,System.Int32,NPOI.POIFS.Storage.BlockList)">
            <summary>
            walk the entries from a specified point and return the
            associated blocks. The associated blocks are Removed from the block list
            </summary>
            <param name="startBlock">the first block in the chain</param>
            <param name="blockList">the raw data block list</param>
            <returns>array of ListManagedBlocks, in their correct order</returns>
        </member>
        <member name="M:NPOI.POIFS.Storage.BlockAllocationTableReader.IsUsed(System.Int32)">
            <summary>
            determine whether the block specified by index is used or not
            </summary>
            <param name="index">determine whether the block specified by index is used or not</param>
            <returns>
            	<c>true</c> if the specified block is used; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NPOI.POIFS.Storage.BlockAllocationTableReader.GetNextBlockIndex(System.Int32)">
            <summary>
            return the next block index
            </summary>
            <param name="index">The index of the current block</param>
            <returns>index of the next block (may be
            POIFSConstants.END_OF_CHAIN, indicating end of chain
            (duh))</returns>
        </member>
        <member name="M:NPOI.POIFS.Storage.BlockAllocationTableReader.SetEntries(NPOI.POIFS.Storage.ListManagedBlock[],NPOI.POIFS.Storage.BlockList)">
            <summary>
            Convert an array of blocks into a Set of integer indices
            </summary>
            <param name="blocks">the array of blocks containing the indices</param>
            <param name="raw_blocks">the list of blocks being managed. Unused
            blocks will be eliminated from the list</param>
        </member>
        <member name="T:NPOI.POIFS.Storage.BlockAllocationTableWriter">
            <summary>
            This class manages and creates the Block Allocation Table, which is
            basically a set of linked lists of block indices.
            Each block of the filesystem has an index. The first block, the
            header, is skipped; the first block after the header is index 0,
            the next is index 1, and so on.
            A block's index is also its index into the Block Allocation
            Table. The entry that it finds in the Block Allocation Table is the
            index of the next block in the linked list of blocks making up a
            file, or it is set to -2: end of list.
            *
            @author Marc Johnson (mjohnson at apache dot org)
            </summary>
        </member>
        <member name="M:NPOI.POIFS.Storage.BlockAllocationTableWriter.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.POIFS.Storage.BlockAllocationTableWriter"/> class.
            </summary>
        </member>
        <member name="M:NPOI.POIFS.Storage.BlockAllocationTableWriter.CreateBlocks">
            <summary>
            Create the BATBlocks we need
            </summary>
            <returns>start block index of BAT blocks</returns>
        </member>
        <member name="M:NPOI.POIFS.Storage.BlockAllocationTableWriter.AllocateSpace(System.Int32)">
            <summary>
            Allocate space for a block of indices
            </summary>
            <param name="blockCount">the number of blocks to allocate space for</param>
            <returns>the starting index of the blocks</returns>
        </member>
        <member name="P:NPOI.POIFS.Storage.BlockAllocationTableWriter.StartBlock">
            <summary>
            Sets the start block for this instance
            </summary>
            <value>
            index into the array of BigBlock instances making up the the filesystem
            </value>
        </member>
        <member name="M:NPOI.POIFS.Storage.BlockAllocationTableWriter.SimpleCreateBlocks">
            <summary>
            create the BATBlocks
            </summary>
        </member>
        <member name="M:NPOI.POIFS.Storage.BlockAllocationTableWriter.WriteBlocks(System.IO.Stream)">
            <summary>
            Write the storage to an OutputStream
            </summary>
            <param name="stream">the OutputStream to which the stored data should be written</param>
        </member>
        <member name="P:NPOI.POIFS.Storage.BlockAllocationTableWriter.CountBlocks">
            <summary>
            Gets the number of BigBlock's this instance uses
            </summary>
            <value>count of BigBlock instances</value>
        </member>
        <member name="T:NPOI.POIFS.Storage.BlockList">
            <summary>
            Interface for lists of blocks that are mapped by block allocation
            tables
            @author Marc Johnson (mjohnson at apache dot org)
            </summary>
        </member>
        <member name="M:NPOI.POIFS.Storage.BlockList.Zap(System.Int32)">
            <summary>
            remove the specified block from the list
            </summary>
            <param name="index">the index of the specified block; if the index is
            out of range, that's ok</param>
        </member>
        <member name="M:NPOI.POIFS.Storage.BlockList.Remove(System.Int32)">
            <summary>
            Remove and return the specified block from the list
            </summary>
            <param name="index">the index of the specified block</param>
            <returns>the specified block</returns>
        </member>
        <member name="M:NPOI.POIFS.Storage.BlockList.FetchBlocks(System.Int32,System.Int32)">
            <summary>
            get the blocks making up a particular stream in the list. The
            blocks are removed from the list.
            </summary>
            <param name="startBlock">the index of the first block in the stream</param>
            <returns>the stream as an array of correctly ordered blocks</returns>
        </member>
        <member name="P:NPOI.POIFS.Storage.BlockList.BAT">
            <summary>
            set the associated BlockAllocationTable
            </summary>
            <value>the associated BlockAllocationTable</value>
        </member>
        <member name="M:NPOI.POIFS.Storage.BlockListImpl.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.POIFS.Storage.BlockListImpl"/> class.
            </summary>
        </member>
        <member name="M:NPOI.POIFS.Storage.BlockListImpl.SetBlocks(NPOI.POIFS.Storage.ListManagedBlock[]@)">
            <summary>
            provide blocks to manage
            </summary>
            <param name="blocks">blocks to be managed</param> 
        </member>
        <member name="M:NPOI.POIFS.Storage.BlockListImpl.Zap(System.Int32)">
            <summary>
            remove the specified block from the list
            </summary>
            <param name="index">the index of the specified block; if the index is
            out of range, that's ok</param>
        </member>
        <member name="M:NPOI.POIFS.Storage.BlockListImpl.Remove(System.Int32)">
            <summary>
            Remove and return the specified block from the list
            </summary>
            <param name="index">the index of the specified block</param>
            <returns>the specified block</returns>
        </member>
        <member name="M:NPOI.POIFS.Storage.BlockListImpl.FetchBlocks(System.Int32,System.Int32)">
            <summary>
            get the blocks making up a particular stream in the list. The
            blocks are removed from the list.
            </summary>
            <param name="startBlock">the index of the first block in the stream</param>
            <returns>
            the stream as an array of correctly ordered blocks
            </returns>
        </member>
        <member name="P:NPOI.POIFS.Storage.BlockListImpl.BAT">
            <summary>
            set the associated BlockAllocationTable
            </summary>
            <value>the associated BlockAllocationTable</value>
        </member>
        <member name="T:NPOI.POIFS.Storage.BlockWritable">
            <summary>
            An interface for persisting block storage of POIFS components.
             @author Marc Johnson (mjohnson at apache dot org)
            </summary>
        </member>
        <member name="M:NPOI.POIFS.Storage.BlockWritable.WriteBlocks(System.IO.Stream)">
            <summary>
            Writes the blocks.
            </summary>
            <param name="stream">The stream.</param>
        </member>
        <member name="M:NPOI.POIFS.Storage.DocumentBlock.#ctor(NPOI.POIFS.Storage.RawDataBlock)">
            <summary>
            create a document block from a raw data block
            </summary>
            <param name="block">The block.</param>
        </member>
        <member name="M:NPOI.POIFS.Storage.DocumentBlock.#ctor(System.IO.Stream)">
            <summary>
            Create a single instance initialized with data.
            </summary>
            <param name="stream">the InputStream delivering the data.</param>
        </member>
        <member name="M:NPOI.POIFS.Storage.DocumentBlock.#ctor">
            <summary>
            Create a single instance initialized with default values
            </summary>
        </member>
        <member name="P:NPOI.POIFS.Storage.DocumentBlock.Size">
            <summary>
            Get the number of bytes Read for this block.
            </summary>
            <value>bytes Read into the block</value>
        </member>
        <member name="P:NPOI.POIFS.Storage.DocumentBlock.PartiallyRead">
            <summary>
            Was this a partially Read block?
            </summary>
            <value><c>true</c> if the block was only partially filled with data</value>
        </member>
        <member name="P:NPOI.POIFS.Storage.DocumentBlock.FillByte">
            <summary>
            Gets the fill byte used
            </summary>
            <value>The fill byte.</value>
        </member>
        <member name="M:NPOI.POIFS.Storage.DocumentBlock.Convert(System.Byte[],System.Int32)">
            <summary>
            convert a single long array into an array of DocumentBlock
            instances
            </summary>
            <param name="array">the byte array to be converted</param>
            <param name="size">the intended size of the array (which may be smaller)</param>
            <returns>an array of DocumentBlock instances, filled from the
            input array</returns>
        </member>
        <member name="M:NPOI.POIFS.Storage.DocumentBlock.Read(NPOI.POIFS.Storage.DocumentBlock[],System.Byte[],System.Int32)">
            <summary>
            Read data from an array of DocumentBlocks
            </summary>
            <param name="blocks">the blocks to Read from</param>
            <param name="buffer">the buffer to Write the data into</param>
            <param name="offset">the offset into the array of blocks to Read from</param>
        </member>
        <member name="M:NPOI.POIFS.Storage.DocumentBlock.WriteData(System.IO.Stream)">
            <summary>
            Write the storage to an OutputStream
            </summary>
            <param name="stream">the OutputStream to which the stored data should
            be written</param>
        </member>
        <member name="T:NPOI.POIFS.Storage.HeaderBlockConstants">
            <summary>
            Constants used in reading/writing the Header block
            @author Marc Johnson (mjohnson at apache dot org)
            </summary>
        </member>
        <member name="T:NPOI.POIFS.Storage.HeaderBlockReader">
            <summary>
            The block containing the archive header
            @author Marc Johnson (mjohnson at apache dot org)
            </summary>
        </member>
        <member name="F:NPOI.POIFS.Storage.HeaderBlockReader.bigBlockSize">
            What big block Size the file uses. Most files
             use 512 bytes, but a few use 4096
        </member>
        <member name="M:NPOI.POIFS.Storage.HeaderBlockReader.#ctor(System.IO.Stream)">
            <summary>
            create a new HeaderBlockReader from an Stream
            </summary>
            <param name="stream">the source Stream</param>
        </member>
        <member name="M:NPOI.POIFS.Storage.HeaderBlockReader.AlertShortRead(System.Int32)">
            <summary>
            Alerts the short read.
            </summary>
            <param name="Read">The read.</param>
        </member>
        <member name="P:NPOI.POIFS.Storage.HeaderBlockReader.PropertyStart">
            <summary>
            Get start of Property Table
            </summary>
            <value>the index of the first block of the Property Table</value>
        </member>
        <member name="P:NPOI.POIFS.Storage.HeaderBlockReader.SBATStart">
            <summary>
            Gets start of small block allocation table
            </summary>
            <value>The SBAT start.</value>
        </member>
        <member name="P:NPOI.POIFS.Storage.HeaderBlockReader.BATCount">
            <summary>
            Gets number of BAT blocks
            </summary>
            <value>The BAT count.</value>
        </member>
        <member name="P:NPOI.POIFS.Storage.HeaderBlockReader.BATArray">
            <summary>
            Gets the BAT array.
            </summary>
            <value>The BAT array.</value>
        </member>
        <member name="P:NPOI.POIFS.Storage.HeaderBlockReader.XBATCount">
            <summary>
            Gets the XBAT count.
            </summary>
            <value>The XBAT count.</value>
            @return XBAT count
        </member>
        <member name="P:NPOI.POIFS.Storage.HeaderBlockReader.XBATIndex">
            <summary>
            Gets the index of the XBAT.
            </summary>
            <value>The index of the XBAT.</value>
        </member>
        <member name="P:NPOI.POIFS.Storage.HeaderBlockReader.BigBlockSize">
            <summary>
            Gets The Big Block Size, normally 512 bytes, sometimes 4096 bytes
            </summary>
            <value>The size of the big block.</value>
            @return 
        </member>
        <member name="T:NPOI.POIFS.Storage.HeaderBlockWriter">
            <summary>
            The block containing the archive header
            @author Marc Johnson (mjohnson at apache dot org)
            </summary>
        </member>
        <member name="M:NPOI.POIFS.Storage.HeaderBlockWriter.#ctor">
            <summary>
            Create a single instance initialized with default values
            </summary>
        </member>
        <member name="M:NPOI.POIFS.Storage.HeaderBlockWriter.SetBATBlocks(System.Int32,System.Int32)">
            <summary>
            Set BAT block parameters. Assumes that all BAT blocks are
            contiguous. Will construct XBAT blocks if necessary and return
            the array of newly constructed XBAT blocks.
            </summary>
            <param name="blockCount">count of BAT blocks</param>
            <param name="startBlock">index of first BAT block</param>
            <returns>array of XBAT blocks; may be zero Length, will not be
            null</returns>
        </member>
        <member name="P:NPOI.POIFS.Storage.HeaderBlockWriter.PropertyStart">
            <summary>
            Set start of Property Table
            </summary>
            <value>the index of the first block of the Property
            Table</value>
        </member>
        <member name="P:NPOI.POIFS.Storage.HeaderBlockWriter.SBATStart">
            <summary>
            Set start of small block allocation table
            </summary>
            <value>the index of the first big block of the small
            block allocation table</value>
        </member>
        <member name="P:NPOI.POIFS.Storage.HeaderBlockWriter.SBATBlockCount">
            <summary>
            Set count of SBAT blocks
            </summary>
            <value>the number of SBAT blocks</value>
        </member>
        <member name="M:NPOI.POIFS.Storage.HeaderBlockWriter.CalculateXBATStorageRequirements(System.Int32)">
            <summary>
            For a given number of BAT blocks, calculate how many XBAT
            blocks will be needed
            </summary>
            <param name="blockCount">number of BAT blocks</param>
            <returns>number of XBAT blocks needed</returns>
        </member>
        <member name="M:NPOI.POIFS.Storage.HeaderBlockWriter.WriteData(System.IO.Stream)">
            <summary>
            Write the block's data to an Stream
            </summary>
            <param name="stream">the Stream to which the stored data should
            be written
            </param>
        </member>
        <member name="T:NPOI.POIFS.Storage.ListManagedBlock">
            <summary>
            An interface for blocks managed by a list that works with a
            BlockAllocationTable to keep block sequences straight
            @author Marc Johnson (mjohnson at apache dot org
            </summary>
        </member>
        <member name="P:NPOI.POIFS.Storage.ListManagedBlock.Data">
            <summary>
            Get the data from the block
            </summary>
            <value>the block's data as a byte array</value>
        </member>
        <member name="T:NPOI.POIFS.Storage.PropertyBlock">
            <summary>
            A block of Property instances
            @author Marc Johnson (mjohnson at apache dot org)
            </summary>
        </member>
        <member name="M:NPOI.POIFS.Storage.PropertyBlock.#ctor(NPOI.POIFS.Properties.Property[],System.Int32)">
            <summary>
            Create a single instance initialized with default values
            </summary>
            <param name="properties">the properties to be inserted</param>
            <param name="offset">the offset into the properties array</param>
        </member>
        <member name="M:NPOI.POIFS.Storage.PropertyBlock.CreatePropertyBlockArray(System.Collections.IList)">
            <summary>
            Create an array of PropertyBlocks from an array of Property
            instances, creating empty Property instances to make up any
            shortfall
            </summary>
            <param name="properties">the Property instances to be converted into PropertyBlocks, in a java List</param>
            <returns>the array of newly created PropertyBlock instances</returns>
        </member>
        <member name="M:NPOI.POIFS.Storage.PropertyBlock.WriteData(System.IO.Stream)">
            <summary>
            Write the block's data to an OutputStream
            </summary>
            <param name="stream">the OutputStream to which the stored data should be written</param>
        </member>
        <member name="T:NPOI.POIFS.Storage.RawDataBlock">
            <summary>
            A big block created from an InputStream, holding the raw data
            @author Marc Johnson (mjohnson at apache dot org
            </summary>
        </member>
        <member name="M:NPOI.POIFS.Storage.RawDataBlock.#ctor(System.IO.Stream)">
            <summary>
            Constructor RawDataBlock
            </summary>
            <param name="stream">the Stream from which the data will be read</param>
        </member>
        <member name="M:NPOI.POIFS.Storage.RawDataBlock.#ctor(System.IO.Stream,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.POIFS.Storage.RawDataBlock"/> class.
            </summary>
            <param name="stream">the Stream from which the data will be read</param>
            <param name="blockSize">the size of the POIFS blocks, normally 512 bytes {@link POIFSConstants#BIG_BLOCK_SIZE}</param>
        </member>
        <member name="P:NPOI.POIFS.Storage.RawDataBlock.EOF">
            <summary>
            When we read the data, did we hit end of file?
            </summary>
            <value><c>true</c> if the EoF was hit during this block, or; otherwise, <c>false</c>if not. If you have a dodgy short last block, then
            it's possible to both have data, and also hit EoF...</value>
        </member>
        <member name="P:NPOI.POIFS.Storage.RawDataBlock.HasData">
            <summary>
            Did we actually find any data to read? It's possible,
            in the event of a short last block, to both have hit
            the EoF, but also to have data
            </summary>
            <value><c>true</c> if this instance has data; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:NPOI.POIFS.Storage.RawDataBlock.Data">
            <summary>
            Get the data from the block
            </summary>
            <value>the block's data as a byte array</value>
        </member>
        <member name="T:NPOI.POIFS.Storage.RawDataBlockList">
            <summary>
            A list of RawDataBlocks instances, and methods to manage the list
            @author Marc Johnson (mjohnson at apache dot org
            </summary>
        </member>
        <member name="M:NPOI.POIFS.Storage.RawDataBlockList.#ctor(System.IO.Stream,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.POIFS.Storage.RawDataBlockList"/> class.
            </summary>
            <param name="stream">the InputStream from which the data will be read</param>
            <param name="bigBlockSize">The big block size, either 512 bytes or 4096 bytes</param>
        </member>
        <member name="T:NPOI.POIFS.Storage.SmallBlockTableReader">
            <summary>
            This class implements reading the small document block list from an
            existing file
            @author Marc Johnson (mjohnson at apache dot org)
            </summary>
        </member>
        <member name="M:NPOI.POIFS.Storage.SmallBlockTableReader.GetSmallDocumentBlocks(NPOI.POIFS.Storage.RawDataBlockList,NPOI.POIFS.Properties.RootProperty,System.Int32)">
            <summary>
            fetch the small document block list from an existing file
            </summary>
            <param name="blockList">the raw data from which the small block table will be extracted</param>
            <param name="root">the root property (which contains the start block and small block table size)</param>
            <param name="sbatStart">the start block of the SBAT</param>
            <returns>the small document block list</returns>
        </member>
        <member name="T:NPOI.POIFS.Storage.SmallBlockTableWriter">
            <summary>
            This class implements reading the small document block list from an
            existing file
            @author Marc Johnson (mjohnson at apache dot org)
            </summary>
        </member>
        <member name="M:NPOI.POIFS.Storage.SmallBlockTableWriter.#ctor(System.Collections.IList,NPOI.POIFS.Properties.RootProperty)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.POIFS.Storage.SmallBlockTableWriter"/> class.
            </summary>
            <param name="documents">a IList of POIFSDocument instances</param>
            <param name="root">the Filesystem's root property</param>
        </member>
        <member name="P:NPOI.POIFS.Storage.SmallBlockTableWriter.SBATBlockCount">
            <summary>
            Get the number of SBAT blocks
            </summary>
            <value>number of SBAT big blocks</value>
        </member>
        <member name="P:NPOI.POIFS.Storage.SmallBlockTableWriter.SBAT">
            <summary>
            Gets the SBAT.
            </summary>
            <value>the Small Block Allocation Table</value>
        </member>
        <member name="P:NPOI.POIFS.Storage.SmallBlockTableWriter.CountBlocks">
            <summary>
            Return the number of BigBlock's this instance uses
            </summary>
            <value>count of BigBlock instances</value>
        </member>
        <member name="P:NPOI.POIFS.Storage.SmallBlockTableWriter.StartBlock">
            <summary>
            Sets the start block.
            </summary>
            <value>The start block.</value>
        </member>
        <member name="M:NPOI.POIFS.Storage.SmallBlockTableWriter.WriteBlocks(System.IO.Stream)">
            <summary>
            Write the storage to an OutputStream
            </summary>
            <param name="stream">the OutputStream to which the stored data should be written</param>
        </member>
        <member name="T:NPOI.POIFS.Storage.SmallDocumentBlock">
            <summary>
            Storage for documents that are too small to use regular
            DocumentBlocks for their data
            @author  Marc Johnson (mjohnson at apache dot org)
            </summary>
        </member>
        <member name="M:NPOI.POIFS.Storage.SmallDocumentBlock.Convert(System.Byte[],System.Int32)">
            <summary>
            convert a single long array into an array of SmallDocumentBlock
            instances
            </summary>
            <param name="array">the byte array to be converted</param>
            <param name="size">the intended size of the array (which may be smaller)</param>
            <returns>an array of SmallDocumentBlock instances, filled from
            the array</returns>
        </member>
        <member name="M:NPOI.POIFS.Storage.SmallDocumentBlock.Fill(System.Collections.IList)">
            <summary>
            fill out a List of SmallDocumentBlocks so that it fully occupies
            a Set of big blocks
            </summary>
            <param name="blocks">the List to be filled out.</param>
            <returns>number of big blocks the list encompasses</returns>
        </member>
        <member name="M:NPOI.POIFS.Storage.SmallDocumentBlock.Convert(NPOI.POIFS.Storage.BlockWritable[],System.Int32)">
            <summary>
            Factory for creating SmallDocumentBlocks from DocumentBlocks
            </summary>
            <param name="store">the original DocumentBlocks</param>
            <param name="size">the total document size</param>
            <returns>an array of new SmallDocumentBlocks instances</returns>
        </member>
        <member name="M:NPOI.POIFS.Storage.SmallDocumentBlock.Extract(NPOI.POIFS.Storage.ListManagedBlock[])">
            <summary>
            create a list of SmallDocumentBlock's from raw data
            </summary>
            <param name="blocks">the raw data containing the SmallDocumentBlock</param>
            <returns>a List of SmallDocumentBlock's extracted from the input</returns>
        </member>
        <member name="M:NPOI.POIFS.Storage.SmallDocumentBlock.Read(NPOI.POIFS.Storage.BlockWritable[],System.Byte[],System.Int32)">
            <summary>
            Read data from an array of SmallDocumentBlocks
            </summary>
            <param name="blocks">the blocks to Read from.</param>
            <param name="buffer">the buffer to Write the data into.</param>
            <param name="offset">the offset into the array of blocks to Read from</param>
        </member>
        <member name="M:NPOI.POIFS.Storage.SmallDocumentBlock.CalcSize(System.Int32)">
            <summary>
            Calculate the storage size of a Set of SmallDocumentBlocks
            </summary>
            <param name="size"> number of SmallDocumentBlocks</param>
            <returns>total size</returns>
        </member>
        <member name="M:NPOI.POIFS.Storage.SmallDocumentBlock.MakeEmptySmallDocumentBlock">
            <summary>
            Makes the empty small document block.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NPOI.POIFS.Storage.SmallDocumentBlock.ConvertToBlockCount(System.Int32)">
            <summary>
            Converts to block count.
            </summary>
            <param name="size">The size.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.POIFS.Storage.SmallDocumentBlock.WriteBlocks(System.IO.Stream)">
            <summary>
            Write the storage to an OutputStream
            </summary>
            <param name="stream">the OutputStream to which the stored data should
            be written</param>
        </member>
        <member name="P:NPOI.POIFS.Storage.SmallDocumentBlock.Data">
            <summary>
            Get the data from the block
            </summary>
            <value>the block's data as a byte array</value>
        </member>
        <member name="T:NPOI.POIFS.Storage.SmallDocumentBlockList">
            <summary>
            A list of SmallDocumentBlocks instances, and methods to manage the list
            @author Marc Johnson (mjohnson at apache dot org)
            </summary>
        </member>
        <member name="M:NPOI.POIFS.Storage.SmallDocumentBlockList.#ctor(System.Collections.IList)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.POIFS.Storage.SmallDocumentBlockList"/> class.
            </summary>
            <param name="blocks">a list of SmallDocumentBlock instances</param>
        </member>
        <member name="T:NPOI.SS.Formula.CellCacheEntry">
            Stores the parameters that identify the evaluation of one cell.<br/>
        </member>
        <member name="M:NPOI.SS.Formula.CellCacheEntry.RecurseClearCachedFormulaResults">
            Calls formulaCell.SetFormulaResult(null, null) recursively all the way up the tree of 
            dependencies. Calls usedCell.ClearConsumingCell(fc) for each child of a cell that Is
            Cleared along the way.
            @param formulaCells
        </member>
        <member name="M:NPOI.SS.Formula.CellCacheEntry.RecurseClearCachedFormulaResults(NPOI.SS.Formula.IEvaluationListener,System.Int32)">
            Identical To {@link #RecurseClearCachedFormulaResults()} except for the listener call-backs
        </member>
        <member name="T:NPOI.SS.Formula.CellEvaluationFrame">
            Stores details about the current evaluation of a cell.<br/>
        </member>
        <member name="M:NPOI.SS.Formula.CellEvaluationFrame.AddSensitiveInputCell(NPOI.SS.Formula.CellCacheEntry)">
            @param inputCell a cell directly used by the formula of this evaluation frame
        </member>
        <member name="M:NPOI.SS.Formula.CellEvaluationFrame.GetSensitiveInputCells">
            @return never <c>null</c>, (possibly empty) array of all cells directly used while 
            evaluating the formula of this frame.
        </member>
        <member name="T:NPOI.SS.Formula.CollaboratingWorkbooksEnvironment">
             Manages a collection of {@link WorkbookEvaluator}s, in order To support evaluation of formulas
             across spreadsheets.<p/>
            
             For POI internal use only
            
             @author Josh Micich
        </member>
        <member name="M:NPOI.SS.Formula.CollaboratingWorkbooksEnvironment.Unhook">
            
        </member>
        <member name="T:NPOI.SS.Formula.EvaluationCache">
            Performance optimisation for {@link HSSFFormulaEvaluator}. This class stores previously
            calculated values of already visited cells, To avoid unnecessary re-calculation when the 
            same cells are referenced multiple times
            
            
            @author Josh Micich
        </member>
        <member name="F:NPOI.SS.Formula.EvaluationCache._evaluationListener">
            only used for testing. <c>null</c> otherwise 
        </member>
        <member name="M:NPOI.SS.Formula.EvaluationCache.Clear">
            Should be called whenever there are Changes To input cells in the evaluated workbook.
        </member>
        <member name="T:NPOI.SS.Formula.EvaluationCell">
            Abstracts a cell for the purpose of formula evaluation.  This interface represents both formula
            and non-formula cells.<br/>
            
            Implementors of this class must implement {@link #HashCode()} and {@link #Equals(Object)}
            To provide an <em>identity</em> relationship based on the underlying HSSF or XSSF cell <p/>
            
            For POI internal use only
            
            @author Josh Micich
        </member>
        <member name="T:NPOI.SS.Formula.EvaluationName">
            Abstracts a name record for formula evaluation.<br/>
            
            For POI internal use only
            
            @author Josh Micich
        </member>
        <member name="T:NPOI.SS.Formula.EvaluationSheet">
            Abstracts a sheet for the purpose of formula evaluation.<br/>
            
            For POI internal use only
            
            @author Josh Micich
        </member>
        <member name="M:NPOI.SS.Formula.EvaluationSheet.GetCell(System.Int32,System.Int32)">
            @return <c>null</c> if there is no cell at the specified coordinates
        </member>
        <member name="T:NPOI.SS.Formula.EvaluationTracker">
            <summary>
            Instances of this class keep track of multiple dependent cell evaluations due
            To recursive calls To <see cref="M:NPOI.SS.Formula.WorkbookEvaluator.Evaluate(NPOI.SS.Formula.EvaluationCell)"/>
            The main purpose of this class is To detect an attempt To evaluate a cell
            that is already being evaluated. In other words, it detects circular
            references in spreadsheet formulas.
            </summary>
            <remarks>
            @author Josh Micich 
            </remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NPOI.SS.Formula.EvaluationTracker.StartEvaluate(NPOI.SS.Formula.FormulaCellCacheEntry)" -->
        <member name="M:NPOI.SS.Formula.EvaluationTracker.EndEvaluate(NPOI.SS.Formula.CellCacheEntry)">
             Notifies this evaluation tracker that the evaluation of the specified cell is complete. <p/>
            
             Every successful call To <tt>startEvaluate</tt> must be followed by a call To <tt>endEvaluate</tt> (recommended in a finally block) To enable
             proper tracking of which cells are being evaluated at any point in time.<p/>
            
             Assuming a well behaved client, parameters To this method would not be
             required. However, they have been included To assert correct behaviour,
             and form more meaningful error messages.
        </member>
        <member name="T:NPOI.SS.Formula.EvaluationWorkbook">
            Abstracts a workbook for the purpose of formula evaluation.<br/>
            
            For POI internal use only
            
            @author Josh Micich
        </member>
        <member name="M:NPOI.SS.Formula.EvaluationWorkbook.GetSheetIndex(NPOI.SS.Formula.EvaluationSheet)">
            @return -1 if the specified sheet is from a different book
        </member>
        <member name="M:NPOI.SS.Formula.EvaluationWorkbook.GetExternalSheet(System.Int32)">
            @return <c>null</c> if externSheetIndex refers To a sheet inside the current workbook
        </member>
        <member name="T:NPOI.SS.Formula.ExternSheetReferenceToken">
            Should be implemented by any {@link Ptg} subclass that needs Has an extern sheet index <br/>
            
            For POI internal use only
            
            @author Josh Micich
        </member>
        <member name="T:NPOI.SS.Formula.Formula">
            Encapsulates an encoded formula token array. 
            
            @author Josh Micich
        </member>
        <member name="F:NPOI.SS.Formula.Formula._byteEncoding">
            immutable 
        </member>
        <member name="M:NPOI.SS.Formula.Formula.Read(System.Int32,NPOI.Util.IO.LittleEndianInput)">
            Convenience method for {@link #read(int, LittleEndianInput, int)}
        </member>
        <member name="M:NPOI.SS.Formula.Formula.Read(System.Int32,NPOI.Util.IO.LittleEndianInput,System.Int32)">
            When there are no array constants present, <tt>encodedTokenLen</tt>==<tt>totalEncodedLen</tt>
            @param encodedTokenLen number of bytes in the stream taken by the plain formula tokens
            @param totalEncodedLen the total number of bytes in the formula (includes trailing encoding
            for array constants, but does not include 2 bytes for initial <tt>ushort encodedTokenLen</tt> field.
            @return A new formula object as read from the stream.  Possibly empty, never <code>null</code>.
        </member>
        <member name="M:NPOI.SS.Formula.Formula.Serialize(NPOI.Util.IO.LittleEndianOutput)">
            Writes  The formula encoding is includes:
            <ul>
            <li>ushort tokenDataLen</li>
            <li>tokenData</li>
            <li>arrayConstantData (if present)</li>
            </ul>
        </member>
        <member name="P:NPOI.SS.Formula.Formula.EncodedSize">
            @return total formula encoding length.  The formula encoding includes:
            <ul>
            <li>ushort tokenDataLen</li>
            <li>tokenData</li>
            <li>arrayConstantData (optional)</li>
            </ul>
            Note - this value is different to <tt>tokenDataLength</tt>
        </member>
        <member name="P:NPOI.SS.Formula.Formula.EncodedTokenSize">
            This method is often used when the formula length does not appear immediately before
            the encoded token data.
            
            @return the encoded length of the plain formula tokens.  This does <em>not</em> include
            the leading ushort field, nor any trailing array constant data.
        </member>
        <member name="M:NPOI.SS.Formula.Formula.Create(NPOI.HSSF.Record.Formula.Ptg[])">
            Creates a {@link Formula} object from a supplied {@link Ptg} array. 
            Handles <code>null</code>s OK.
            @param ptgs may be <code>null</code>
            @return Never <code>null</code> (Possibly empty if the supplied <tt>ptgs</tt> is <code>null</code>)
        </member>
        <member name="M:NPOI.SS.Formula.Formula.GetTokens(NPOI.SS.Formula.Formula)">
            Gets the {@link Ptg} array from the supplied {@link Formula}. 
            Handles <code>null</code>s OK.
            
            @param formula may be <code>null</code>
            @return possibly <code>null</code> (if the supplied <tt>formula</tt> is <code>null</code>)
        </member>
        <!-- Badly formed XML comment ignored for member "P:NPOI.SS.Formula.Formula.ExpReference" -->
        <member name="T:NPOI.SS.Formula.FormulaCellCache">
            
            @author Josh Micich
        </member>
        <member name="M:NPOI.SS.Formula.FormulaCellCache.Get(NPOI.SS.Formula.EvaluationCell)">
            @return <c>null</c> if not found
        </member>
        <member name="T:NPOI.SS.Formula.FormulaCellCacheEntry">
            Stores the cached result of a formula evaluation, along with the Set of sensititive input cells
            
            @author Josh Micich
        </member>
        <member name="F:NPOI.SS.Formula.FormulaCellCacheEntry._sensitiveInputCells">
             Cells 'used' in the current evaluation of the formula corresponding To this cache entry
            
             If any of the following cells Change, this cache entry needs To be Cleared
        </member>
        <member name="T:NPOI.SS.Formula.FormulaCellCacheEntrySet">
             A custom implementation of {@link java.util.HashSet} in order To reduce memory consumption.
            
             Profiling tests (Oct 2008) have shown that each element {@link FormulaCellCacheEntry} takes
             around 32 bytes To store in a HashSet, but around 6 bytes To store here.  For Spreadsheets with
             thousands of formula cells with multiple interdependencies, the savings can be very significant.
            
             @author Josh Micich
        </member>
        <!-- Badly formed XML comment ignored for member "T:NPOI.SS.Formula.FormulaParser" -->
        <member name="T:NPOI.SS.Formula.FormulaParser.FormulaParseException">
            <summary>
            Specific exception thrown when a supplied formula does not Parse properly.
             Primarily used by test cases when testing for specific parsing exceptions.
            </summary>
        </member>
        <member name="M:NPOI.SS.Formula.FormulaParser.FormulaParseException.#ctor(System.String)">
             <summary>
            This class was given package scope until it would become Clear that it is useful to general client code.
             </summary>
             <param name="msg"></param>
        </member>
        <member name="F:NPOI.SS.Formula.FormulaParser.look">
            Lookahead Character.
            Gets value '\0' when the input string is exhausted
        </member>
        <member name="M:NPOI.SS.Formula.FormulaParser.#ctor(System.String,NPOI.SS.Formula.FormulaParsingWorkbook,System.Int32)">
             Create the formula Parser, with the string that is To be
              Parsed against the supplied workbook.
             A later call the Parse() method To return ptg list in
              rpn order, then call the GetRPNPtg() To retrive the
              Parse results.
             This class is recommended only for single threaded use.
            
             If you only have a usermodel.HSSFWorkbook, and not a
              model.Workbook, then use the convenience method on
              usermodel.HSSFFormulaEvaluator
        </member>
        <member name="M:NPOI.SS.Formula.FormulaParser.Parse(System.String,NPOI.SS.Formula.FormulaParsingWorkbook,NPOI.SS.Formula.FormulaType,System.Int32)">
             Parse a formula into a array of tokens
            
             @param formula	 the formula to parse
             @param workbook	the parent workbook
             @param formulaType the type of the formula, see {@link FormulaType}
             @param sheetIndex  the 0-based index of the sheet this formula belongs to.
             The sheet index is required to resolve sheet-level names. <code>-1</code> means that
             the scope of the name will be ignored and  the parser will match names only by name
            
             @return array of parsed tokens
             @throws FormulaParseException if the formula is unparsable
        </member>
        <member name="M:NPOI.SS.Formula.FormulaParser.GetChar">
            Read New Character From Input Stream 
        </member>
        <member name="M:NPOI.SS.Formula.FormulaParser.expected(System.String)">
            Report What Was Expected 
        </member>
        <member name="M:NPOI.SS.Formula.FormulaParser.IsAlpha(System.Char)">
            Recognize an Alpha Character 
        </member>
        <member name="M:NPOI.SS.Formula.FormulaParser.IsDigit(System.Char)">
            Recognize a Decimal Digit 
        </member>
        <member name="M:NPOI.SS.Formula.FormulaParser.IsAlNum(System.Char)">
            Recognize an Alphanumeric 
        </member>
        <member name="M:NPOI.SS.Formula.FormulaParser.IsWhite(System.Char)">
            Recognize White Space 
        </member>
        <member name="M:NPOI.SS.Formula.FormulaParser.SkipWhite">
            Skip Over Leading White Space 
        </member>
        <member name="M:NPOI.SS.Formula.FormulaParser.Match(System.Char)">
            Consumes the next input character if it is equal To the one specified otherwise throws an
            unchecked exception. This method does <b>not</b> consume whitespace (before or after the
            matched character).
        </member>
        <member name="M:NPOI.SS.Formula.FormulaParser.ParseIdentifier">
            Parses a sheet name, named range name, or simple cell reference.<br/>
            Note - identifiers in Excel can contain dots, so this method may return a String
            which may need To be converted To an area reference.  For example, this method
            may return a value like "A1..B2", in which case the caller must convert it To
            an area reference like "A1:B2"
        </member>
        <member name="M:NPOI.SS.Formula.FormulaParser.GetNum">
            Get a Number 
        </member>
        <member name="T:NPOI.SS.Formula.FormulaParser.SimpleRangePart">
            A1, $A1, A$1, $A$1, A, 1
        </member>
        <member name="M:NPOI.SS.Formula.FormulaParser.SimpleRangePart.IsCompatibleForArea(NPOI.SS.Formula.FormulaParser.SimpleRangePart)">
            @return <code>true</code> if the two range parts can be combined in an
            {@link AreaPtg} ( Note - the explicit range operator (:) may still be valid
            when this method returns <code>false</code> )
        </member>
        <member name="M:NPOI.SS.Formula.FormulaParser.ParseSheetName">
            Note - caller should reset {@link #_pointer} upon <code>null</code> result
            @return The sheet name as an identifier <code>null</code> if '!' is not found in the right place
        </member>
        <member name="M:NPOI.SS.Formula.FormulaParser.IsUnquotedSheetNameChar(System.Char)">
            very similar to {@link SheetNameFormatter#isSpecialChar(char)}
        </member>
        <member name="M:NPOI.SS.Formula.FormulaParser.IsValidDefinedNameChar(System.Char)">
            
             @return <code>true</code> if the specified character may be used in a defined name
        </member>
        <member name="M:NPOI.SS.Formula.FormulaParser.ParseNonRange(System.Int32)">
            Parses simple factors that are not primitive ranges or range components
            i.e. '!', ':'(and equiv '...') do not appear
            Examples
            <pre>
              my.named...range.
              foo.bar(123.456, "abc")
              123.456
              "abc"
              true
            </pre>
        </member>
        <member name="M:NPOI.SS.Formula.FormulaParser.ParseRangeable">
             Parses area refs (things which could be the operand of ':') and simple factors
             Examples
             <pre>
               A$1
               $A$1 :  $B1
               A1 .......	C2
               Sheet1 !$A1
               a..b!A1
               'my sheet'!A1
               .my.sheet!A1
               my.named..range.
               foo.bar(123.456, "abc")
               123.456
               "abc"
               true
             </pre>
            
        </member>
        <member name="M:NPOI.SS.Formula.FormulaParser.CreateAreaRefParseNode(NPOI.SS.Formula.FormulaParser.SheetIdentifier,NPOI.SS.Formula.FormulaParser.SimpleRangePart,NPOI.SS.Formula.FormulaParser.SimpleRangePart)">
            
             @param sheetIden may be <code>null</code>
             @param part1
             @param part2 may be <code>null</code>
        </member>
        <member name="M:NPOI.SS.Formula.FormulaParser.NeedsMemFunc(NPOI.SS.Formula.ParseNode)">
             From OOO doc: "Whenever one operand of the reference subexpression is a function,
              a defined name, a 3D reference, or an external reference (and no error occurs),
              a tMemFunc token is used"
            
        </member>
        <member name="M:NPOI.SS.Formula.FormulaParser.CheckValidRangeOperand(System.String,System.Int32,NPOI.SS.Formula.ParseNode)">
            @param currentParsePosition used to format a potential error message
        </member>
        <member name="M:NPOI.SS.Formula.FormulaParser.IsValidRangeOperand(NPOI.SS.Formula.ParseNode)">
            @return false if sub-expression represented the specified ParseNode definitely
            cannot appear on either side of the range (':') operator
        </member>
        <member name="M:NPOI.SS.Formula.FormulaParser.ReduceRangeExpression(NPOI.HSSF.Record.Formula.Ptg,NPOI.HSSF.Record.Formula.Ptg)">
            
            "A1", "B3" -> "A1:B3"   
            "sheet1!A1", "B3" -> "sheet1!A1:B3"
            
            @return <c>null</c> if the range expression cannot / shouldn't be reduced.
        </member>
        <member name="M:NPOI.SS.Formula.FormulaParser.ParseArea(System.String)">
            @param name an 'identifier' like string (i.e. contains alphanums, and dots)
            @return <c>null</c> if name cannot be split at a dot
        </member>
        <member name="M:NPOI.SS.Formula.FormulaParser.IsValidCellReference(System.String)">
            @return <c>true</c> if the specified name is a valid cell reference
        </member>
        <member name="M:NPOI.SS.Formula.FormulaParser.Function(System.String)">
             Note - Excel Function names are 'case aware but not case sensitive'.  This method may end
             up creating a defined name record in the workbook if the specified name is not an internal
             Excel Function, and Has not been encountered before.
            
             @param name case preserved Function name (as it was entered/appeared in the formula).
        </member>
        <member name="M:NPOI.SS.Formula.FormulaParser.GetFunction(System.String,NPOI.HSSF.Record.Formula.Ptg,NPOI.SS.Formula.ParseNode[])">
            Generates the variable Function ptg for the formula.
            
            For IF Formulas, Additional PTGs are Added To the Tokens
            @param name a {@link NamePtg} or {@link NameXPtg} or <c>null</c>
            @param numArgs
            @return Ptg a null is returned if we're in an IF formula, it needs extreme manipulation and is handled in this Function
        </member>
        <member name="M:NPOI.SS.Formula.FormulaParser.Arguments">
            Get arguments To a Function 
        </member>
        <member name="M:NPOI.SS.Formula.FormulaParser.PowerFactor">
            Parse and Translate a Math Factor  
        </member>
        <member name="M:NPOI.SS.Formula.FormulaParser.ParseSimpleRangePart">
            Parses out a potential LHS or RHS of a ':' intended to produce a plain AreaRef.  Normally these are
            proper cell references but they could also be row or column refs like "$AC" or "10"
            @return <code>null</code> (and leaves {@link #_pointer} unchanged if a proper range part does not parse out
        </member>
        <member name="M:NPOI.SS.Formula.FormulaParser.ParseSimpleFactor">
            factors (without ^ or % )
        </member>
        <member name="M:NPOI.SS.Formula.FormulaParser.GetNumberPtgFromString(System.String,System.String,System.String)">
            Get a PTG for an integer from its string representation.
            return Int or Number Ptg based on size of input
        </member>
        <member name="M:NPOI.SS.Formula.FormulaParser.Term">
            Parse and Translate a Math Term 
        </member>
        <member name="M:NPOI.SS.Formula.FormulaParser.AdditiveExpression">
            Parse and Translate an Expression 
        </member>
        <member name="M:NPOI.SS.Formula.FormulaParser.Parse">
                procedure Assignment;
                var Name: string[8];
                begin
                   Name := GetName;
                   Match('=');
                   Expression;
            
                end;
                     *
             API call To execute the parsing of the formula
            
        </member>
        <member name="T:NPOI.SS.Formula.FormulaParsingWorkbook">
            Abstracts a workbook for the purpose of formula parsing.<br/>
            
            For POI internal use only
            
            @author Josh Micich
        </member>
        <member name="M:NPOI.SS.Formula.FormulaParsingWorkbook.GetName(System.String,System.Int32)">
            <summary>
            named range name matching is case insensitive
            </summary>
            <param name="name">The name.</param>
            <param name="sheetIndex">Index of the sheet.</param>
            <returns></returns>        
        </member>
        <member name="M:NPOI.SS.Formula.FormulaParsingWorkbook.GetNameXPtg(System.String)">
            <summary>
            Gets the name XPTG.
            </summary>
            <param name="name">The name.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.SS.Formula.FormulaParsingWorkbook.GetExternalSheetIndex(System.String)">
            <summary>
            Gets the externSheet index for a sheet from this workbook
            </summary>
            <param name="sheetName">Name of the sheet.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.SS.Formula.FormulaParsingWorkbook.GetExternalSheetIndex(System.String,System.String)">
            <summary>
            Gets the externSheet index for a sheet from an external workbook
            </summary>
            <param name="workbookName">Name of the workbook, e.g. "BudGet.xls"</param>
            <param name="sheetName">a name of a sheet in that workbook</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.SS.Formula.FormulaParsingWorkbook.GetSpreadsheetVersion">
            <summary>
            Returns an enum holding spReadhseet properties specific to an Excel version (
            max column and row numbers, max arguments to a function, etc.)
            </summary>
            <returns></returns>
        </member>
        <member name="T:NPOI.SS.Formula.FormulaRenderer">
            Common logic for rendering formulas.<br/>
            
            For POI internal use only
            
            @author Josh Micich
        </member>
        <member name="M:NPOI.SS.Formula.FormulaRenderer.ToFormulaString(NPOI.SS.Formula.FormulaRenderingWorkbook,NPOI.HSSF.Record.Formula.Ptg[])">
            Static method To convert an array of {@link Ptg}s in RPN order
            To a human readable string format in infix mode.
            @param book  used for defined names and 3D references
            @param ptgs  must not be <c>null</c>
            @return a human readable String
        </member>
        <member name="T:NPOI.SS.Formula.FormulaRenderingWorkbook">
            Abstracts a workbook for the purpose of converting formula To text.<br/>
            
            For POI internal use only
            
            @author Josh Micich
        </member>
        <member name="M:NPOI.SS.Formula.FormulaRenderingWorkbook.GetExternalSheet(System.Int32)">
            @return <c>null</c> if externSheetIndex refers To a sheet inside the current workbook
        </member>
        <member name="T:NPOI.SS.Formula.FormulaType">
            Enumeration of various formula types.<br/>
            
            For POI internal use only
            
            @author Josh Micich
        </member>
        <member name="T:NPOI.SS.Formula.FormulaUsedBlankCellSet">
            Optimisation - compacts many blank cell references used by a single formula. 
            
            @author Josh Micich
        </member>
        <member name="T:NPOI.SS.Formula.ICacheEntry">
            A (mostly) opaque interface To allow test clients To trace cache values
            Each spreadsheet cell Gets one unique cache entry instance.  These objects
            are safe To use as keys in {@link java.util.HashMap}s 
        </member>
        <member name="T:NPOI.SS.Formula.IEvaluationListener">
            Tests can implement this class To track the internal working of the {@link WorkbookEvaluator}.<br/>
            
            For POI internal testing use only
            
            @author Josh Micich
        </member>
        <member name="M:NPOI.SS.Formula.IEvaluationListener.SortDependentCachedValues(NPOI.SS.Formula.ICacheEntry[])">
            Internally, formula {@link ICacheEntry}s are stored in Sets which may Change ordering due 
            To seemingly trivial Changes.  This method is provided To make the order of call-backs To 
            {@link #onClearDependentCachedValue(ICacheEntry, int)} more deterministic.
        </member>
        <member name="T:NPOI.SS.Formula.IStabilityClassifier">
            Used to help optimise cell evaluation result caching by allowing applications to specify which
            parts of a workbook are <em>final</em>.<br/>
            The term <b>final</b> is introduced here to denote immutability or 'having constant definition'.
            This classification refers to potential actions (on the evaluated workbook) by the evaluating
            application.  It does not refer to operations performed by the evaluator ({@link 
            WorkbookEvaluator}).<br/>
            <br/>
            <b>General guidelines</b>:
            <ul>
            <li>a plain value cell can be marked as 'final' if it will not be changed after the first call
            to {@link WorkbookEvaluator#evaluate(EvaluationCell)}.
            </li>
            <li>a formula cell can be marked as 'final' if its formula will not be changed after the first
            call to {@link WorkbookEvaluator#evaluate(EvaluationCell)}.  This remains true even if changes 
            in dependent values may cause the evaluated value to change.</li>
            <li>plain value cells should be marked as 'not final' if their plain value value may change.
            </li>  
            <li>formula cells should be marked as 'not final' if their formula definition may change.</li>  
            <li>cells which may switch between plain value and formula should also be marked as 'not final'.
            </li>  
            </ul>
            <b>Notes</b>:
            <ul>
            <li>If none of the spreadsheet cells is expected to have its definition changed after evaluation
            begins, every cell can be marked as 'final'. This is the most efficient / least resource 
            intensive option.</li>
            <li>To retain freedom to change any cell definition at any time, an application may classify all
            cells as 'not final'.  This freedom comes at the expense of greater memory consumption.</li>
            <li>For the purpose of these classifications, setting the cached formula result of a cell (for 
            example in {@link HSSFFormulaEvaluator#evaluateFormulaCell(org.apache.poi.ss.usermodel.Cell)})
            does not constitute changing the definition of the cell.</li>
            <li>Updating cells which have been classified as 'final' will cause the evaluator to behave 
            unpredictably (typically ignoring the update).</li> 
            </ul>
            
            @author Josh Micich
        </member>
        <member name="F:NPOI.SS.Formula.IStabilityClassifier.TOTALLY_IMMUTABLE">
            Convenience implementation for situations where all cell definitions remain fixed after
            evaluation begins.
        </member>
        <member name="M:NPOI.SS.Formula.IStabilityClassifier.IsCellFinal(System.Int32,System.Int32,System.Int32)">
            Checks if a cell's value(/formula) is fixed - in other words - not expected to be modified
            between calls to the evaluator. (Note - this is an independent concept from whether a 
            formula cell's evaluated value may change during successive calls to the evaluator).
            
            @param sheetIndex zero based index into workbook sheet list
            @param rowIndex zero based row index of cell
            @param columnIndex zero based column index of cell
            @return <code>false</code> if the evaluating application may need to modify the specified 
            cell between calls to the evaluator. 
        </member>
        <member name="T:NPOI.SS.Formula.LazyAreaEval">
            
             @author Josh Micich 
        </member>
        <member name="T:NPOI.SS.Formula.LazyRefEval">
            
             @author Josh Micich 
        </member>
        <member name="T:NPOI.SS.Formula.OperandClassTransformer">
            This class performs 'operand class' transformation. Non-base Tokens are classified into three 
            operand classes:
            <ul>
            <li>reference</li> 
            <li>value</li> 
            <li>array</li> 
            </ul>
            <p/>
            
            The operand class chosen for each Token depends on the formula type and the Token's place
            in the formula. If POI Gets the operand class wrong, Excel <em>may</em> interpret the formula
            incorrectly.  This condition is typically manifested as a formula cell that displays as '#VALUE!',
            but resolves correctly when the user presses F2, enter.<p/>
            
            The logic implemented here was partially inspired by the description in
            "OpenOffice.org's Documentation of the Microsoft Excel File Format".  The model presented there
            seems To be inconsistent with observed Excel behaviour (These differences have not been fully
            investigated). The implementation in this class Has been heavily modified in order To satisfy
            concrete examples of how Excel performs the same logic (see TestRVA).<p/>
            
            Hopefully, as Additional important test cases are identified and Added To the test suite, 
            patterns might become more obvious in this code and allow for simplification.
            
            @author Josh Micich
        </member>
        <member name="M:NPOI.SS.Formula.OperandClassTransformer.TransformFormula(NPOI.SS.Formula.ParseNode)">
            Traverses the supplied formula parse tree, calling <tt>Ptg.SetClass()</tt> for each non-base
            Token To Set its operand class.
        </member>
        <member name="M:NPOI.SS.Formula.OperandClassTransformer.TransformNode(NPOI.SS.Formula.ParseNode,System.Byte,System.Boolean)">
            @param callerForceArrayFlag <c>true</c> if one of the current node's parents is a 
            function Ptg which Has been Changed from default 'V' To 'A' type (due To requirements on
            the function return value).
        </member>
        <member name="T:NPOI.SS.Formula.OperationEvaluationContext">
             Contains all the contextual information required to Evaluate an operation
             within a formula
            
             For POI internal use only
            
             @author Josh Micich
        </member>
        <member name="M:NPOI.SS.Formula.OperationEvaluationContext.CreateExternSheetRefEvaluator(System.String,System.String)">
            @return <code>null</code> if either workbook or sheet is not found
        </member>
        <member name="M:NPOI.SS.Formula.OperationEvaluationContext.GetDynamicReference(System.String,System.String,System.String,System.String,System.Boolean)">
            Resolves a cell or area reference dynamically.
            @param workbookName the name of the workbook Containing the reference.  If <code>null</code>
            the current workbook is assumed.  Note - to Evaluate formulas which use multiple workbooks,
            a {@link CollaboratingWorkbooksEnvironment} must be set up.
            @param sheetName the name of the sheet Containing the reference.  May be <code>null</code>
            (when <tt>workbookName</tt> is also null) in which case the current workbook and sheet is
            assumed.
            @param refStrPart1 the single cell reference or first part of the area reference.  Must not
            be <code>null</code>.
            @param refStrPart2 the second part of the area reference. For single cell references this
            parameter must be <code>null</code>
            @param isA1Style specifies the format for <tt>refStrPart1</tt> and <tt>refStrPart2</tt>.
            Pass <code>true</code> for 'A1' style and <code>false</code> for 'R1C1' style.
            TODO - currently POI only supports 'A1' reference style
            @return a {@link RefEval} or {@link AreaEval}
        </member>
        <member name="T:NPOI.SS.Formula.OperationEvaluatorFactory">
            This class Creates <tt>OperationEval</tt> instances To help evaluate <tt>OperationPtg</tt>
            formula Tokens.
            
            @author Josh Micich
        </member>
        <member name="M:NPOI.SS.Formula.OperationEvaluatorFactory.Evaluate(NPOI.HSSF.Record.Formula.OperationPtg,NPOI.HSSF.Record.Formula.Eval.ValueEval[],NPOI.SS.Formula.OperationEvaluationContext)">
            returns the OperationEval concrete impl instance corresponding
            to the supplied operationPtg
        </member>
        <member name="T:NPOI.SS.Formula.ParseNode">
            Represents a syntactic element from a formula by encapsulating the corresponding <tt>Ptg</tt>
            Token.  Each <tt>ParseNode</tt> may have child <tt>ParseNode</tt>s in the case when the wrapped
            <tt>Ptg</tt> is non-atomic.
            
            @author Josh Micich
        </member>
        <member name="M:NPOI.SS.Formula.ParseNode.ToTokenArray(NPOI.SS.Formula.ParseNode)">
            Collects the array of <tt>Ptg</tt> Tokens for the specified tree.
        </member>
        <member name="M:NPOI.SS.Formula.ParseNode.CollectIfPtgs(NPOI.SS.Formula.ParseNode.TokenCollector)">
            The IF() function Gets marked up with two or three tAttr Tokens.
            Similar logic will be required for CHOOSE() when it is supported
            
            See excelfileformat.pdf sec 3.10.5 "tAttr (19H)
        </member>
        <member name="T:NPOI.SS.Formula.PlainCellCache">
            
             @author Josh Micich
        </member>
        <member name="T:NPOI.SS.Formula.PlainValueCellCacheEntry">
            Used for non-formula cells, primarily To keep track of the referencing (formula) cells.
            
            @author Josh Micich
        </member>
        <member name="T:NPOI.SS.Formula.SheetRefEvaluator">
            
            
            @author Josh Micich
        </member>
        <member name="T:NPOI.SS.Formula.WorkbookDependentFormula">
            Should be implemented by any {@link Ptg} subclass that needs a workbook To render its formula.
            <br/>
            
            For POI internal use only
            
            @author Josh Micich
        </member>
        <member name="T:NPOI.SS.Formula.WorkbookEvaluator">
             Evaluates formula cells.<p/>
            
             For performance reasons, this class keeps a cache of all previously calculated intermediate
             cell values.  Be sure To call {@link #ClearCache()} if any workbook cells are Changed between
             calls To evaluate~ methods on this class.<br/>
            
             For POI internal use only
            
             @author Josh Micich
        </member>
        <member name="M:NPOI.SS.Formula.WorkbookEvaluator.GetSheetName(System.Int32)">
            also for debug use. Used in ToString methods
        </member>
        <member name="M:NPOI.SS.Formula.WorkbookEvaluator.ClearAllCachedResultValues">
            Should be called whenever there are Changes To input cells in the evaluated workbook.
            Failure To call this method after changing cell values will cause incorrect behaviour
            of the evaluate~ methods of this class
        </member>
        <member name="M:NPOI.SS.Formula.WorkbookEvaluator.NotifyUpdateCell(NPOI.SS.Formula.EvaluationCell)">
            Should be called To tell the cell value cache that the specified (value or formula) cell 
            Has Changed.
        </member>
        <member name="M:NPOI.SS.Formula.WorkbookEvaluator.NotifyDeleteCell(NPOI.SS.Formula.EvaluationCell)">
            Should be called To tell the cell value cache that the specified cell Has just been
            deleted. 
        </member>
        <member name="M:NPOI.SS.Formula.WorkbookEvaluator.GetSheetIndex(System.String)">
            Case-insensitive.
            @return -1 if sheet with specified name does not exist
        </member>
        <member name="M:NPOI.SS.Formula.WorkbookEvaluator.EvaluateAny(NPOI.SS.Formula.EvaluationCell,System.Int32,System.Int32,System.Int32,NPOI.SS.Formula.EvaluationTracker)">
            @return never <c>null</c>, never {@link BlankEval}
        </member>
        <member name="M:NPOI.SS.Formula.WorkbookEvaluator.GetValueFromNonFormulaCell(NPOI.SS.Formula.EvaluationCell)">
            Gets the value from a non-formula cell.
            @param cell may be <c>null</c>
            @return {@link BlankEval} if cell is <c>null</c> or blank, never <c>null</c>
        </member>
        <member name="M:NPOI.SS.Formula.WorkbookEvaluator.CountTokensToBeSkipped(NPOI.HSSF.Record.Formula.Ptg[],System.Int32,System.Int32)">
             Calculates the number of tokens that the evaluator should skip upon reaching a tAttrSkip.
            
             @return the number of tokens (starting from <tt>startIndex+1</tt>) that need to be skipped
             to achieve the specified <tt>distInBytes</tt> skip distance.
        </member>
        <member name="M:NPOI.SS.Formula.WorkbookEvaluator.DereferenceValue(NPOI.HSSF.Record.Formula.Eval.ValueEval,System.Int32,System.Int32)">
            Dereferences a single value from any AreaEval or RefEval evaluation result.
            If the supplied evaluationResult is just a plain value, it is returned as-is.
            @return a <tt>NumberEval</tt>, <tt>StringEval</tt>, <tt>BoolEval</tt>,
             <tt>BlankEval</tt> or <tt>ErrorEval</tt>. Never <c>null</c>.
        </member>
        <member name="M:NPOI.SS.Formula.WorkbookEvaluator.GetEvalForPtg(NPOI.HSSF.Record.Formula.Ptg,NPOI.SS.Formula.OperationEvaluationContext)">
            returns an appropriate Eval impl instance for the Ptg. The Ptg must be
            one of: Area3DPtg, AreaPtg, ReferencePtg, Ref3DPtg, IntPtg, NumberPtg,
            StringPtg, BoolPtg <br/>special Note: OperationPtg subtypes cannot be
            passed here!
        </member>
        <member name="M:NPOI.SS.Formula.WorkbookEvaluator.EvaluateReference(NPOI.SS.Formula.EvaluationSheet,System.Int32,System.Int32,System.Int32,NPOI.SS.Formula.EvaluationTracker)">
            Used by the lazy ref evals whenever they need To Get the value of a contained cell.
        </member>
        <member name="T:NPOI.SS.SpreadsheetVersion">
             This enum allows spReadsheets from multiple Excel versions to be handled by the common code.
             Properties of this enum correspond to attributes of the <i>spReadsheet</i> that are easily
             discernable to the user.  It is not intended to deal with low-level issues like file formats.
             <p/>
            
             @author Josh Micich
             @author Yegor Kozlov
        </member>
        <member name="F:NPOI.SS.SpreadsheetVersion.EXCEL97">
            Excel97 format aka BIFF8
            <ul>
            <li>The total number of available columns is 256 (2^8)</li>
            <li>The total number of available rows is 64k (2^16)</li>
            <li>The maximum number of arguments to a function is 30</li>
            <li>Number of conditional format conditions on a cell is 3</li>
            <li>Length of text cell contents is unlimited </li>
            <li>Length of text cell contents is 32767</li>
            </ul>
        </member>
        <!-- Badly formed XML comment ignored for member "F:NPOI.SS.SpreadsheetVersion.EXCEL2007" -->
        <member name="P:NPOI.SS.SpreadsheetVersion.MaxRows">
            @return the maximum number of usable rows in each spReadsheet
        </member>
        <member name="P:NPOI.SS.SpreadsheetVersion.LastRowIndex">
            @return the last (maximum) valid row index, equals to <code> GetMaxRows() - 1 </code>
        </member>
        <member name="P:NPOI.SS.SpreadsheetVersion.MaxColumns">
            @return the maximum number of usable columns in each spReadsheet
        </member>
        <member name="P:NPOI.SS.SpreadsheetVersion.LastColumnIndex">
            @return the last (maximum) valid column index, equals to <code> GetMaxColumns() - 1 </code>
        </member>
        <member name="P:NPOI.SS.SpreadsheetVersion.MaxFunctionArgs">
            @return the maximum number arguments that can be passed to a multi-arg function (e.g. COUNTIF)
        </member>
        <member name="P:NPOI.SS.SpreadsheetVersion.MaxConditionalFormats">
            
             @return the maximum number of conditional format conditions on a cell
        </member>
        <member name="P:NPOI.SS.SpreadsheetVersion.LastColumnName">
            
             @return the last valid column index in a ALPHA-26 representation
              (<code>IV</code> or <code>XFD</code>).
        </member>
        <member name="P:NPOI.SS.SpreadsheetVersion.MaxTextLength">
            @return the maximum length of a text cell
        </member>
        <member name="T:NPOI.SS.UserModel.BorderStyle">
            The enumeration value indicating the line style of a border in a cell,
            i.e., whether it is borded dash dot, dash dot dot, dashed, dotted, double, hair, medium, 
            medium dash dot, medium dash dot dot, medium dashed, none, slant dash dot, thick or thin.
        </member>
        <member name="F:NPOI.SS.UserModel.BorderStyle.NONE">
            No border
        </member>
        <member name="F:NPOI.SS.UserModel.BorderStyle.THIN">
            Thin border
        </member>
        <member name="F:NPOI.SS.UserModel.BorderStyle.MEDIUM">
            Medium border
        </member>
        <member name="F:NPOI.SS.UserModel.BorderStyle.DASHED">
            dash border
        </member>
        <member name="F:NPOI.SS.UserModel.BorderStyle.HAIR">
            dot border
        </member>
        <member name="F:NPOI.SS.UserModel.BorderStyle.THICK">
            Thick border
        </member>
        <member name="F:NPOI.SS.UserModel.BorderStyle.DOUBLE">
            double-line border
        </member>
        <member name="F:NPOI.SS.UserModel.BorderStyle.DOTTED">
            hair-line border
        </member>
        <member name="F:NPOI.SS.UserModel.BorderStyle.MEDIUM_DASHED">
            Medium dashed border
        </member>
        <member name="F:NPOI.SS.UserModel.BorderStyle.DASH_DOT">
            dash-dot border
        </member>
        <member name="F:NPOI.SS.UserModel.BorderStyle.MEDIUM_DASH_DOT">
            medium dash-dot border
        </member>
        <member name="F:NPOI.SS.UserModel.BorderStyle.DASH_DOT_DOT">
            dash-dot-dot border
        </member>
        <member name="F:NPOI.SS.UserModel.BorderStyle.MEDIUM_DASH_DOT_DOTC">
            medium dash-dot-dot border
        </member>
        <member name="F:NPOI.SS.UserModel.BorderStyle.SLANTED_DASH_DOT">
            slanted dash-dot border
        </member>
        <member name="T:NPOI.SS.UserModel.Cell">
            High level representation of a cell in a row of a spreadsheet.
            <p>
            Cells can be numeric, formula-based or string-based (text).  The cell type
            specifies this.  String cells cannot conatin numbers and numeric cells cannot
            contain strings (at least according to our model).  Client apps should do the
            conversions themselves.  Formula cells have the formula string, as well as
            the formula result, which can be numeric or string.
            </p>
            <p>
            Cells should have their number (0 based) before being Added to a row.
            </p>
        </member>
        <member name="P:NPOI.SS.UserModel.Cell.ColumnIndex">
             Returns column index of this cell
            
             @return zero-based column index of a column in a sheet.
        </member>
        <member name="P:NPOI.SS.UserModel.Cell.RowIndex">
             Returns row index of a row in the sheet that Contains this cell
            
             @return zero-based row index of a row in the sheet that Contains this cell
        </member>
        <member name="P:NPOI.SS.UserModel.Cell.Sheet">
             Returns the sheet this cell belongs to
            
             @return the sheet this cell belongs to
        </member>
        <member name="P:NPOI.SS.UserModel.Cell.Row">
             Returns the Row this cell belongs to
            
             @return the Row that owns this cell
        </member>
        <member name="P:NPOI.SS.UserModel.Cell.CellType">
             Set the cells type (numeric, formula or string)
            
             @throws ArgumentException if the specified cell type is invalid
             @see #CELL_TYPE_NUMERIC
             @see #CELL_TYPE_STRING
             @see #CELL_TYPE_FORMULA
             @see #CELL_TYPE_BLANK
             @see #CELL_TYPE_BOOLEAN
             @see #CELL_TYPE_ERROR
        </member>
        <member name="M:NPOI.SS.UserModel.Cell.SetCellType(NPOI.SS.UserModel.CellType)">
             Set the cells type (numeric, formula or string)
            
             @throws IllegalArgumentException if the specified cell type is invalid
             @see #CELL_TYPE_NUMERIC
             @see #CELL_TYPE_STRING
             @see #CELL_TYPE_FORMULA
             @see #CELL_TYPE_BLANK
             @see #CELL_TYPE_BOOLEAN
             @see #CELL_TYPE_ERROR
             Set a error value for the cell
            
             @param value the error value to set this cell to.  For formulas we'll set the
                    precalculated value , for errors we'll set
                    its value. For other types we will change the cell to an error
                    cell and set its value.
             @see FormulaError
        </member>
        <member name="P:NPOI.SS.UserModel.Cell.CachedFormulaResultType">
            Only valid for formula cells
            @return one of ({@link #CELL_TYPE_NUMERIC}, {@link #CELL_TYPE_STRING},
                {@link #CELL_TYPE_BOOLEAN}, {@link #CELL_TYPE_ERROR}) depending
            on the cached value of the formula
        </member>
        <member name="M:NPOI.SS.UserModel.Cell.SetCellValue(System.Double)">
             Set a numeric value for the cell
            
             @param value  the numeric value to set this cell to.  For formulas we'll set the
                    precalculated value, for numerics we'll set its value. For other types we
                    will change the cell to a numeric cell and set its value.
        </member>
        <member name="M:NPOI.SS.UserModel.Cell.SetCellErrorValue(System.Byte)">
             Set a error value for the cell
            
             @param value the error value to set this cell to.  For formulas we'll set the
                    precalculated value , for errors we'll set
                    its value. For other types we will change the cell to an error
                    cell and set its value.
             @see FormulaError
        </member>
        <member name="M:NPOI.SS.UserModel.Cell.SetCellValue(System.DateTime)">
             Converts the supplied date to its equivalent Excel numeric value and Sets
             that into the cell.
             <p/>
             <b>Note</b> - There is actually no 'DATE' cell type in Excel. In many
             cases (when entering date values), Excel automatically adjusts the
             <i>cell style</i> to some date format, creating the illusion that the cell
             data type is now something besides {@link Cell#CELL_TYPE_NUMERIC}.  POI
             does not attempt to replicate this behaviour.  To make a numeric cell
             display as a date, use {@link #SetCellStyle(CellStyle)} etc.
            
             @param value the numeric value to set this cell to.  For formulas we'll set the
                    precalculated value, for numerics we'll set its value. For other types we
                    will change the cell to a numerics cell and set its value.
        </member>
        <member name="M:NPOI.SS.UserModel.Cell.SetCellValue(NPOI.SS.UserModel.RichTextString)">
             Set a rich string value for the cell.
            
             @param value  value to set the cell to.  For formulas we'll set the formula
             string, for String cells we'll set its value.  For other types we will
             change the cell to a string cell and set its value.
             If value is null then we will change the cell to a Blank cell.
        </member>
        <member name="M:NPOI.SS.UserModel.Cell.SetCellValue(System.String)">
             Set a string value for the cell.
            
             @param value  value to set the cell to.  For formulas we'll set the formula
             string, for String cells we'll set its value.  For other types we will
             change the cell to a string cell and set its value.
             If value is null then we will change the cell to a Blank cell.
        </member>
        <member name="P:NPOI.SS.UserModel.Cell.CellFormula">
             Return a formula for the cell, for example, <code>SUM(C4:E4)</code>
            
             @return a formula for the cell
             @throws InvalidOperationException if the cell type returned by {@link #GetCellType()} is not CELL_TYPE_FORMULA
        </member>
        <member name="P:NPOI.SS.UserModel.Cell.NumericCellValue">
            Get the value of the cell as a number.
            <p>
            For strings we throw an exception. For blank cells we return a 0.
            For formulas or error cells we return the precalculated value;
            </p>
            @return the value of the cell as a number
            @throws InvalidOperationException if the cell type returned by {@link #GetCellType()} is CELL_TYPE_STRING
            @exception FormatException if the cell value isn't a parsable <code>double</code>.
            @see DataFormatter for turning this number into a string similar to that which Excel would render this number as.
        </member>
        <member name="P:NPOI.SS.UserModel.Cell.DateCellValue">
            Get the value of the cell as a date.
            <p>
            For strings we throw an exception. For blank cells we return a null.
            </p>
            @return the value of the cell as a date
            @throws InvalidOperationException if the cell type returned by {@link #GetCellType()} is CELL_TYPE_STRING
            @exception FormatException if the cell value isn't a parsable <code>double</code>.
            @see DataFormatter for formatting  this date into a string similar to how excel does.
        </member>
        <member name="P:NPOI.SS.UserModel.Cell.RichStringCellValue">
            Get the value of the cell as a XSSFRichTextString
            <p>
            For numeric cells we throw an exception. For blank cells we return an empty string.
            For formula cells we return the pre-calculated value.
            </p>
            @return the value of the cell as a XSSFRichTextString
        </member>
        <member name="P:NPOI.SS.UserModel.Cell.ErrorCellValue">
             Get the value of the cell as an error code.
             <p>
             For strings, numbers, and booleans, we throw an exception.
             For blank cells we return a 0.
             </p>
            
             @return the value of the cell as an error code
             @throws IllegalStateException if the cell type returned by {@link #getCellType()} isn't CELL_TYPE_ERROR
             @see FormulaError for error codes
        </member>
        <member name="P:NPOI.SS.UserModel.Cell.StringCellValue">
            Get the value of the cell as a string
            <p>
            For numeric cells we throw an exception. For blank cells we return an empty string.
            For formulaCells that are not string Formulas, we return empty String.
            </p>
            @return the value of the cell as a string
        </member>
        <member name="M:NPOI.SS.UserModel.Cell.SetCellValue(System.Boolean)">
             Set a bool value for the cell
            
             @param value the bool value to set this cell to.  For formulas we'll set the
                    precalculated value, for bools we'll set its value. For other types we
                    will change the cell to a bool cell and set its value.
        </member>
        <member name="P:NPOI.SS.UserModel.Cell.CellErrorValue">
             Set a error value for the cell
            
             @param value the error value to set this cell to.  For formulas we'll set the
                    precalculated value , for errors we'll set
                    its value. For other types we will change the cell to an error
                    cell and set its value.
             @see FormulaError
        </member>
        <member name="P:NPOI.SS.UserModel.Cell.BooleanCellValue">
            Get the value of the cell as a bool.
            <p>
            For strings, numbers, and errors, we throw an exception. For blank cells we return a false.
            </p>
            @return the value of the cell as a bool
            @throws InvalidOperationException if the cell type returned by {@link #GetCellType()}
              is not CELL_TYPE_BOOLEAN, CELL_TYPE_BLANK or CELL_TYPE_FORMULA
        </member>
        <member name="P:NPOI.SS.UserModel.Cell.CellStyle">
             Return the cell's style.
            
             @return the cell's style. Always not-null. Default cell style has zero index and can be obtained as
             <code>workbook.GetCellStyleAt(0)</code>
             @see Workbook#GetCellStyleAt(short)
        </member>
        <member name="M:NPOI.SS.UserModel.Cell.SetAsActiveCell">
            Sets this cell as the active cell for the worksheet
        </member>
        <member name="P:NPOI.SS.UserModel.Cell.CellComment">
             Returns comment associated with this cell
            
             @return comment associated with this cell or <code>null</code> if not found
        </member>
        <member name="M:NPOI.SS.UserModel.Cell.RemoveCellComment">
            Removes the comment for this cell, if there is one.
        </member>
        <member name="P:NPOI.SS.UserModel.Cell.Hyperlink">
             Returns hyperlink associated with this cell
            
             @return hyperlink associated with this cell or <code>null</code> if not found
        </member>
        <member name="F:NPOI.SS.UserModel.CellBorderType.NONE">
            <summary>
            No border
            </summary>
        </member>
        <member name="F:NPOI.SS.UserModel.CellBorderType.THIN">
            <summary>
            Thin border
            </summary>
        </member>
        <member name="F:NPOI.SS.UserModel.CellBorderType.MEDIUM">
            <summary>
            Medium border
            </summary>
        </member>
        <member name="F:NPOI.SS.UserModel.CellBorderType.DASHED">
             <summary>
            dash border 
             </summary>
        </member>
        <member name="F:NPOI.SS.UserModel.CellBorderType.HAIR">
             <summary>
            dot border 
             </summary>
        </member>
        <member name="F:NPOI.SS.UserModel.CellBorderType.THICK">
             <summary>
            Thick border 
             </summary>
        </member>
        <member name="F:NPOI.SS.UserModel.CellBorderType.DOUBLE">
            <summary>
            double-line border
            </summary>
        </member>
        <member name="F:NPOI.SS.UserModel.CellBorderType.DOTTED">
            <summary>
            hair-line border
            </summary>
        </member>
        <member name="F:NPOI.SS.UserModel.CellBorderType.MEDIUM_DASHED">
            <summary>
            Medium dashed border
            </summary>
        </member>
        <member name="F:NPOI.SS.UserModel.CellBorderType.DASH_DOT">
            <summary>
            dash-dot border
            </summary>
        </member>
        <member name="F:NPOI.SS.UserModel.CellBorderType.MEDIUM_DASH_DOT">
            <summary>
            medium dash-dot border
            </summary>
        </member>
        <member name="F:NPOI.SS.UserModel.CellBorderType.DASH_DOT_DOT">
            <summary>
            dash-dot-dot border
            </summary>
        </member>
        <member name="F:NPOI.SS.UserModel.CellBorderType.MEDIUM_DASH_DOT_DOT">
            <summary>
            medium dash-dot-dot border
            </summary>
        </member>
        <member name="F:NPOI.SS.UserModel.CellBorderType.SLANTED_DASH_DOT">
            <summary>
            slanted dash-dot border
            </summary>
        </member>
        <member name="P:NPOI.SS.UserModel.CellStyle.Index">
            get the index within the Workbook (sequence within the collection of ExtnededFormat objects)
            @return unique index number of the underlying record this style represents (probably you don't care
             unless you're comparing which one is which)
        </member>
        <member name="P:NPOI.SS.UserModel.CellStyle.DataFormat">
            get the index of the format
            @see DataFormat
        </member>
        <member name="M:NPOI.SS.UserModel.CellStyle.GetDataFormatString">
            Get the format string
        </member>
        <member name="M:NPOI.SS.UserModel.CellStyle.SetFont(NPOI.SS.UserModel.Font)">
            set the font for this style
            @param font  a font object Created or retreived from the Workbook object
            @see Workbook#CreateFont()
            @see Workbook#GetFontAt(short)
        </member>
        <member name="P:NPOI.SS.UserModel.CellStyle.FontIndex">
            Gets the index of the font for this style
            @see Workbook#GetFontAt(short)
        </member>
        <member name="P:NPOI.SS.UserModel.CellStyle.IsHidden">
            get whether the cell's using this style are to be hidden
            @return hidden - whether the cell using this style should be hidden
        </member>
        <member name="P:NPOI.SS.UserModel.CellStyle.IsLocked">
            get whether the cell's using this style are to be locked
            @return hidden - whether the cell using this style should be locked
        </member>
        <member name="P:NPOI.SS.UserModel.CellStyle.Alignment">
            get the type of horizontal alignment for the cell
            @return align - the type of alignment
            @see #ALIGN_GENERAL
            @see #ALIGN_LEFT
            @see #ALIGN_CENTER
            @see #ALIGN_RIGHT
            @see #ALIGN_FILL
            @see #ALIGN_JUSTIFY
            @see #ALIGN_CENTER_SELECTION
        </member>
        <member name="P:NPOI.SS.UserModel.CellStyle.WrapText">
            get whether the text should be wrapped
            @return wrap text or not
        </member>
        <member name="P:NPOI.SS.UserModel.CellStyle.VerticalAlignment">
            get the type of vertical alignment for the cell
            @return align the type of alignment
            @see #VERTICAL_TOP
            @see #VERTICAL_CENTER
            @see #VERTICAL_BOTTOM
            @see #VERTICAL_JUSTIFY
        </member>
        <member name="P:NPOI.SS.UserModel.CellStyle.Rotation">
            get the degree of rotation for the text in the cell
            @return rotation degrees (between -90 and 90 degrees)
        </member>
        <member name="P:NPOI.SS.UserModel.CellStyle.Indention">
            get the number of spaces to indent the text in the cell
            @return indent - number of spaces
        </member>
        <member name="P:NPOI.SS.UserModel.CellStyle.BorderLeft">
            get the type of border to use for the left border of the cell
            @return border type
            @see #BORDER_NONE
            @see #BORDER_THIN
            @see #BORDER_MEDIUM
            @see #BORDER_DASHED
            @see #BORDER_DOTTED
            @see #BORDER_THICK
            @see #BORDER_DOUBLE
            @see #BORDER_HAIR
            @see #BORDER_MEDIUM_DASHED
            @see #BORDER_DASH_DOT
            @see #BORDER_MEDIUM_DASH_DOT
            @see #BORDER_DASH_DOT_DOT
            @see #BORDER_MEDIUM_DASH_DOT_DOT
            @see #BORDER_SLANTED_DASH_DOT
        </member>
        <member name="P:NPOI.SS.UserModel.CellStyle.BorderRight">
            get the type of border to use for the right border of the cell
            @return border type
            @see #BORDER_NONE
            @see #BORDER_THIN
            @see #BORDER_MEDIUM
            @see #BORDER_DASHED
            @see #BORDER_DOTTED
            @see #BORDER_THICK
            @see #BORDER_DOUBLE
            @see #BORDER_HAIR
            @see #BORDER_MEDIUM_DASHED
            @see #BORDER_DASH_DOT
            @see #BORDER_MEDIUM_DASH_DOT
            @see #BORDER_DASH_DOT_DOT
            @see #BORDER_MEDIUM_DASH_DOT_DOT
            @see #BORDER_SLANTED_DASH_DOT
        </member>
        <member name="P:NPOI.SS.UserModel.CellStyle.BorderTop">
            get the type of border to use for the top border of the cell
            @return border type
            @see #BORDER_NONE
            @see #BORDER_THIN
            @see #BORDER_MEDIUM
            @see #BORDER_DASHED
            @see #BORDER_DOTTED
            @see #BORDER_THICK
            @see #BORDER_DOUBLE
            @see #BORDER_HAIR
            @see #BORDER_MEDIUM_DASHED
            @see #BORDER_DASH_DOT
            @see #BORDER_MEDIUM_DASH_DOT
            @see #BORDER_DASH_DOT_DOT
            @see #BORDER_MEDIUM_DASH_DOT_DOT
            @see #BORDER_SLANTED_DASH_DOT
        </member>
        <member name="P:NPOI.SS.UserModel.CellStyle.BorderBottom">
            get the type of border to use for the bottom border of the cell
            @return border type
            @see #BORDER_NONE
            @see #BORDER_THIN
            @see #BORDER_MEDIUM
            @see #BORDER_DASHED
            @see #BORDER_DOTTED
            @see #BORDER_THICK
            @see #BORDER_DOUBLE
            @see #BORDER_HAIR
            @see #BORDER_MEDIUM_DASHED
            @see #BORDER_DASH_DOT
            @see #BORDER_MEDIUM_DASH_DOT
            @see #BORDER_DASH_DOT_DOT
            @see #BORDER_MEDIUM_DASH_DOT_DOT
            @see #BORDER_SLANTED_DASH_DOT
        </member>
        <member name="P:NPOI.SS.UserModel.CellStyle.LeftBorderColor">
            get the color to use for the left border
        </member>
        <member name="P:NPOI.SS.UserModel.CellStyle.RightBorderColor">
            get the color to use for the left border
            @return the index of the color defInition
        </member>
        <member name="P:NPOI.SS.UserModel.CellStyle.TopBorderColor">
            get the color to use for the top border
            @return hhe index of the color defInition
        </member>
        <member name="P:NPOI.SS.UserModel.CellStyle.BottomBorderColor">
            get the color to use for the left border
            @return the index of the color defInition
        </member>
        <member name="P:NPOI.SS.UserModel.CellStyle.FillPattern">
            get the fill pattern (??) - set to 1 to fill with foreground color
            @return fill pattern
        </member>
        <member name="P:NPOI.SS.UserModel.CellStyle.FillBackgroundColor">
            get the background fill color
            @return fill color
        </member>
        <member name="P:NPOI.SS.UserModel.CellStyle.FillForegroundColor">
            get the foreground fill color
            @return fill color
        </member>
        <member name="M:NPOI.SS.UserModel.CellStyle.CloneStyleFrom(NPOI.SS.UserModel.CellStyle)">
             Clones all the style information from another
              CellStyle, onto this one. This 
              CellStyle will then have all the same
              properties as the source, but the two may
              be edited independently.
             Any stylings on this CellStyle will be lost! 
              
             The source CellStyle could be from another
              Workbook if you like. This allows you to
              copy styles from one Workbook to another.
            
             However, both of the CellStyles will need
              to be of the same type (HSSFCellStyle or
              XSSFCellStyle)
        </member>
        <member name="T:NPOI.SS.UserModel.CellValue">
            Mimics the 'data view' of a cell. This allows formula Evaluator
            to return a CellValue instead of precasting the value to String
            or Number or bool type.
            @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
        </member>
        <member name="P:NPOI.SS.UserModel.CellValue.BooleanValue">
            @return Returns the boolValue.
        </member>
        <member name="P:NPOI.SS.UserModel.CellValue.NumberValue">
            @return Returns the numberValue.
        </member>
        <member name="P:NPOI.SS.UserModel.CellValue.StringValue">
            @return Returns the stringValue.
        </member>
        <member name="P:NPOI.SS.UserModel.CellValue.CellType">
            @return Returns the cellType.
        </member>
        <member name="P:NPOI.SS.UserModel.CellValue.ErrorValue">
            @return Returns the errorValue.
        </member>
        <member name="F:NPOI.SS.UserModel.AnchorType.MOVE_AND_RESIZE">
            Move and Resize With Anchor Cells
            <p>
            Specifies that the current drawing shall move and
            resize to maintain its row and column anchors (i.e. the
            object is anchored to the actual from and to row and column)
            </p>
        </member>
        <member name="F:NPOI.SS.UserModel.AnchorType.MOVE_DONT_RESIZE">
            Move With Cells but Do Not Resize
            <p>
            Specifies that the current drawing shall move with its
            row and column (i.e. the object is anchored to the
            actual from row and column), but that the size shall remain absolute.
            </p>
            <p>
            If Additional rows/columns are Added between the from and to locations of the drawing,
            the drawing shall move its to anchors as needed to maintain this same absolute size.
            </p>
        </member>
        <member name="F:NPOI.SS.UserModel.AnchorType.DONT_MOVE_AND_RESIZE">
            Do Not Move or Resize With Underlying Rows/Columns
            <p>
            Specifies that the current start and end positions shall
            be maintained with respect to the distances from the
            absolute start point of the worksheet.
            </p>
            <p>
            If Additional rows/columns are Added before the
            drawing, the drawing shall move its anchors as needed
            to maintain this same absolute position.
            </p>
        </member>
        <member name="T:NPOI.SS.UserModel.ClientAnchor">
             A client anchor is attached to an excel worksheet.  It anchors against a
             top-left and bottom-right cell.
            
             @author Yegor Kozlov
        </member>
        <member name="P:NPOI.SS.UserModel.ClientAnchor.Col1">
             Returns the column (0 based) of the first cell.
            
             @return 0-based column of the first cell.
        </member>
        <member name="P:NPOI.SS.UserModel.ClientAnchor.Col2">
             Returns the column (0 based) of the second cell.
            
             @return 0-based column of the second cell.
        </member>
        <member name="P:NPOI.SS.UserModel.ClientAnchor.Row1">
             Returns the row (0 based) of the first cell.
            
             @return 0-based row of the first cell.
        </member>
        <member name="P:NPOI.SS.UserModel.ClientAnchor.Row2">
             Returns the row (0 based) of the second cell.
            
             @return 0-based row of the second cell.
        </member>
        <member name="P:NPOI.SS.UserModel.ClientAnchor.Dx1">
             Returns the x coordinate within the first cell
            
             @return the x coordinate within the first cell
        </member>
        <member name="P:NPOI.SS.UserModel.ClientAnchor.Dy1">
             Returns the y coordinate within the first cell
            
             @return the y coordinate within the first cell
        </member>
        <member name="P:NPOI.SS.UserModel.ClientAnchor.Dy2">
             Sets the y coordinate within the second cell
            
             @return the y coordinate within the second cell
        </member>
        <member name="P:NPOI.SS.UserModel.ClientAnchor.Dx2">
             Returns the x coordinate within the second cell
            
             @return the x coordinate within the second cell
        </member>
        <member name="P:NPOI.SS.UserModel.ClientAnchor.AnchorType">
            s the anchor type
            <p>
            0 = Move and size with Cells, 2 = Move but don't size with cells, 3 = Don't move or size with cells.
            </p>
            @return the anchor type
            @see #MOVE_AND_RESIZE
            @see #MOVE_DONT_RESIZE
            @see #DONT_MOVE_AND_RESIZE
        </member>
        <member name="P:NPOI.SS.UserModel.Comment.Visible">
             Sets whether this comment is visible.
            
             @return <code>true</code> if the comment is visible, <code>false</code> otherwise
        </member>
        <member name="P:NPOI.SS.UserModel.Comment.Row">
             Return the row of the cell that Contains the comment
            
             @return the 0-based row of the cell that Contains the comment
        </member>
        <member name="P:NPOI.SS.UserModel.Comment.Column">
             Return the column of the cell that Contains the comment
            
             @return the 0-based column of the cell that Contains the comment
        </member>
        <member name="P:NPOI.SS.UserModel.Comment.Author">
             Name of the original comment author
            
             @return the name of the original author of the comment
        </member>
        <member name="P:NPOI.SS.UserModel.Comment.String">
            Fetches the rich text string of the comment
        </member>
        <member name="T:NPOI.SS.UserModel.CreationHelper">
            An object that handles instantiating concrete
             classes of the various instances one needs for
             HSSF and XSSF.
            Works around a major shortcoming in Java, where we
             can't have static methods on interfaces or abstract
             classes.
            This allows you to get the appropriate class for
             a given interface, without you having to worry
             about if you're dealing with HSSF or XSSF, despite
             Java being quite rubbish.
        </member>
        <member name="M:NPOI.SS.UserModel.CreationHelper.CreateRichTextString(System.String)">
            Creates a new RichTextString instance
            @param text The text to Initialise the RichTextString with
        </member>
        <member name="M:NPOI.SS.UserModel.CreationHelper.CreateDataFormat">
            Creates a new DataFormat instance
        </member>
        <member name="M:NPOI.SS.UserModel.CreationHelper.CreateHyperlink(NPOI.SS.UserModel.HyperlinkType)">
            Creates a new Hyperlink, of the given type
        </member>
        <member name="M:NPOI.SS.UserModel.CreationHelper.CreateFormulaEvaluator">
             Creates FormulaEvaluator - an object that Evaluates formula cells.
            
             @return a FormulaEvaluator instance
        </member>
        <member name="M:NPOI.SS.UserModel.DataFormat.GetFormat(System.String)">
            get the format index that matches the given format string.
            Creates a new format if one is not found.  Aliases text to the proper format.
            @param format string matching a built in format
            @return index of format.
        </member>
        <member name="M:NPOI.SS.UserModel.DataFormat.GetFormat(System.Int16)">
            get the format string that matches the given format index
            @param index of a format
            @return string represented at index of format or null if there is not a  format at that index
        </member>
        <member name="T:NPOI.SS.UserModel.DataFormatter">
             HSSFDataFormatter contains methods for Formatting the value stored in an
             Cell. This can be useful for reports and GUI presentations when you
             need to display data exactly as it appears in Excel. Supported Formats
             include currency, SSN, percentages, decimals, dates, phone numbers, zip
             codes, etc.
             
             Internally, Formats will be implemented using subclasses of {@link FormatBase}
             such as {@link DecimalFormat} and {@link SimpleDateFormat}. Therefore the
             Formats used by this class must obey the same pattern rules as these FormatBase
             subclasses. This means that only legal number pattern characters ("0", "#",
             ".", "," etc.) may appear in number formats. Other characters can be
             inserted <em>before</em> or <em> after</em> the number pattern to form a
             prefix or suffix.
             
             
             For example the Excel pattern <c>"$#,##0.00 "USD"_);($#,##0.00 "USD")"
             </c> will be correctly Formatted as "$1,000.00 USD" or "($1,000.00 USD)".
             However the pattern <c>"00-00-00"</c> is incorrectly Formatted by
             DecimalFormat as "000000--". For Excel Formats that are not compatible with
             DecimalFormat, you can provide your own custom {@link FormatBase} implementation
             via <c>HSSFDataFormatter.AddFormat(String,FormatBase)</c>. The following
             custom Formats are already provided by this class:
             
             <pre>
             <ul><li>SSN "000-00-0000"</li>
                 <li>Phone Number "(###) ###-####"</li>
                 <li>Zip plus 4 "00000-0000"</li>
             </ul>
             </pre>
             
             If the Excel FormatBase pattern cannot be Parsed successfully, then a default
             FormatBase will be used. The default number FormatBase will mimic the Excel General
             FormatBase: "#" for whole numbers and "#.##########" for decimal numbers. You
             can override the default FormatBase pattern with <c>
             HSSFDataFormatter.setDefaultNumberFormat(FormatBase)</c>. <b>Note:</b> the
             default FormatBase will only be used when a FormatBase cannot be Created from the
             cell's data FormatBase string.
            
             @author James May (james dot may at fmr dot com)
            
        </member>
        <member name="F:NPOI.SS.UserModel.DataFormatter.numPattern">
            Pattern to find a number FormatBase: "0" or  "#" 
        </member>
        <member name="F:NPOI.SS.UserModel.DataFormatter.daysAsText">
            Pattern to find days of week as text "ddd...." 
        </member>
        <member name="F:NPOI.SS.UserModel.DataFormatter.amPmPattern">
            Pattern to find "AM/PM" marker 
        </member>
        <member name="F:NPOI.SS.UserModel.DataFormatter.specialPatternGroup">
            A regex to find patterns like [$$-1009] and [$�-452]. 
        </member>
        <member name="F:NPOI.SS.UserModel.DataFormatter.generalWholeNumFormat">
            <em>General</em> FormatBase for whole numbers. 
        </member>
        <member name="F:NPOI.SS.UserModel.DataFormatter.generalDecimalNumFormat">
            <em>General</em> FormatBase for decimal numbers. 
        </member>
        <member name="F:NPOI.SS.UserModel.DataFormatter.defaultNumFormat">
            A default FormatBase to use when a number pattern cannot be Parsed. 
        </member>
        <!-- Badly formed XML comment ignored for member "F:NPOI.SS.UserModel.DataFormatter.formats" -->
        <member name="M:NPOI.SS.UserModel.DataFormatter.#ctor">
            Constructor
        </member>
        <member name="M:NPOI.SS.UserModel.DataFormatter.GetFormat(NPOI.SS.UserModel.Cell)">
             Return a FormatBase for the given cell if one exists, otherwise try to
             Create one. This method will return <c>null</c> if the any of the
             following is true:
             <ul>
             <li>the cell's style is null</li>
             <li>the style's data FormatBase string is null or empty</li>
             <li>the FormatBase string cannot be recognized as either a number or date</li>
             </ul>
            
             @param cell The cell to retrieve a FormatBase for
             @return A FormatBase for the FormatBase String
        </member>
        <member name="M:NPOI.SS.UserModel.DataFormatter.CreateFormat(NPOI.SS.UserModel.Cell)">
             Create and return a FormatBase based on the FormatBase string from a  cell's
             style. If the pattern cannot be Parsed, return a default pattern.
            
             @param cell The Excel cell
             @return A FormatBase representing the excel FormatBase. May return null.
        </member>
        <member name="M:NPOI.SS.UserModel.DataFormatter.IsWholeNumber(System.Double)">
            Return true if the double value represents a whole number
            @param d the double value to check
            @return <c>true</c> if d is a whole number
        </member>
        <member name="M:NPOI.SS.UserModel.DataFormatter.GetDefaultFormat(NPOI.SS.UserModel.Cell)">
            Returns a default FormatBase for a cell.
            @param cell The cell
            @return a default FormatBase
        </member>
        <member name="M:NPOI.SS.UserModel.DataFormatter.GetFormattedDateString(NPOI.SS.UserModel.Cell)">
             Returns the Formatted value of an Excel date as a <tt>String</tt> based
             on the cell's <c>DataFormat</c>. i.e. "Thursday, January 02, 2003"
             , "01/02/2003" , "02-Jan" , etc.
            
             @param cell The cell
             @return a Formatted date string
        </member>
        <member name="M:NPOI.SS.UserModel.DataFormatter.GetFormattedNumberString(NPOI.SS.UserModel.Cell)">
             Returns the Formatted value of an Excel number as a <tt>String</tt>
             based on the cell's <c>DataFormat</c>. Supported Formats include
             currency, percents, decimals, phone number, SSN, etc.:
             "61.54%", "$100.00", "(800) 555-1234".
            
             @param cell The cell
             @return a Formatted number string
        </member>
        <member name="M:NPOI.SS.UserModel.DataFormatter.FormatRawCellContents(System.Double,System.Int32,System.String)">
            Formats the given raw cell value, based on the supplied
             FormatBase index and string, according to excel style rules.
            @see #FormatCellValue(Cell)
        </member>
        <member name="M:NPOI.SS.UserModel.DataFormatter.FormatCellValue(NPOI.SS.UserModel.Cell)">
             
             Returns the Formatted value of a cell as a <tt>String</tt> regardless
             of the cell type. If the Excel FormatBase pattern cannot be Parsed then the
             cell value will be Formatted using a default FormatBase.
             
             When passed a null or blank cell, this method will return an empty
             String (""). Formulas in formula type cells will not be evaluated.
             
            
             @param cell The cell
             @return the Formatted cell value as a String
        </member>
        <member name="M:NPOI.SS.UserModel.DataFormatter.FormatCellValue(NPOI.SS.UserModel.Cell,NPOI.SS.UserModel.FormulaEvaluator)">
             
             Returns the Formatted value of a cell as a <tt>String</tt> regardless
             of the cell type. If the Excel FormatBase pattern cannot be Parsed then the
             cell value will be Formatted using a default FormatBase.
             
             When passed a null or blank cell, this method will return an empty
             String (""). Formula cells will be evaluated using the given
             {@link HSSFFormulaEvaluator} if the evaluator is non-null. If the
             evaluator is null, then the formula String will be returned. The caller
             is responsible for setting the currentRow on the evaluator
            
            
             @param cell The cell (can be null)
             @param evaluator The HSSFFormulaEvaluator (can be null)
             @return a string value of the cell
        </member>
        <member name="M:NPOI.SS.UserModel.DataFormatter.SetDefaultNumberFormat(NPOI.SS.Util.FormatBase)">
             
             Sets a default number FormatBase to be used when the Excel FormatBase cannot be
             Parsed successfully. <b>Note:</b> This is a fall back for when an error
             occurs while parsing an Excel number FormatBase pattern. This will not
             affect cells with the <em>General</em> FormatBase.
             
             
             The value that will be passed to the FormatBase's FormatBase method (specified
             by <c>java.text.FormatBase#FormatBase</c>) will be a double value from a
             numeric cell. Therefore the code in the FormatBase method should expect a
             <c>Number</c> value.
             
            
             @param FormatBase A FormatBase instance to be used as a default
             @see java.text.FormatBase#FormatBase
        </member>
        <member name="M:NPOI.SS.UserModel.DataFormatter.AddFormat(System.String,NPOI.SS.Util.FormatBase)">
            Adds a new FormatBase to the available formats.
            
            The value that will be passed to the FormatBase's FormatBase method (specified
            by <c>java.text.FormatBase#FormatBase</c>) will be a double value from a
            numeric cell. Therefore the code in the FormatBase method should expect a
            <c>Number</c> value.
            
            @param excelformatStr The data FormatBase string
            @param FormatBase A FormatBase instance
        </member>
        <member name="T:NPOI.SS.UserModel.DateUtil">
            <summary>
            Contains methods for dealing with Excel dates.
            @author  Michael Harhen
            @author  Glen Stampoultzis (glens at apache.org)
            @author  Dan Sherman (dsherman at Isisph.com)
            @author  Hack Kampbjorn (hak at 2mba.dk)
            @author  Alex Jacoby (ajacoby at gmail.com)
            @author  Pavel Krupets (pkrupets at palmtreebusiness dot com)
            </summary>
        </member>
        <member name="M:NPOI.SS.UserModel.DateUtil.AbsoluteDay(System.DateTime,System.Boolean)">
            <summary>
            Given a Calendar, return the number of days since 1899/12/31.
            </summary>
            <param name="cal">the date</param>
            <param name="use1904windowing">if set to <c>true</c> [use1904windowing].</param>
            <returns>number of days since 1899/12/31</returns>
        </member>
        <member name="M:NPOI.SS.UserModel.DateUtil.GetExcelDate(System.DateTime)">
            <summary>
            Given a Date, Converts it into a double representing its internal Excel representation,
            which Is the number of days since 1/1/1900. Fractional days represent hours, minutes, and seconds.
            </summary>
            <param name="date">Excel representation of Date (-1 if error - test for error by Checking for less than 0.1)</param>
            <returns>the Date</returns>
        </member>
        <member name="M:NPOI.SS.UserModel.DateUtil.GetExcelDate(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Gets the excel date.
            </summary>
            <param name="year">The year.</param>
            <param name="month">The month.</param>
            <param name="day">The day.</param>
            <param name="hour">The hour.</param>
            <param name="minute">The minute.</param>
            <param name="second">The second.</param>
            <param name="use1904windowing">Should 1900 or 1904 date windowing be used?</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.SS.UserModel.DateUtil.GetExcelDate(System.DateTime,System.Boolean)">
            <summary>
            Given a Date, Converts it into a double representing its internal Excel representation,
            which Is the number of days since 1/1/1900. Fractional days represent hours, minutes, and seconds.
            </summary>
            <param name="date">The date.</param>
            <param name="use1904windowing">Should 1900 or 1904 date windowing be used?</param>
            <returns>Excel representation of Date (-1 if error - test for error by Checking for less than 0.1)</returns>
        </member>
        <member name="M:NPOI.SS.UserModel.DateUtil.GetJavaDate(System.Double)">
            <summary>
            Given an Excel date with using 1900 date windowing, and
            Converts it to a Date.
            </summary>
            <param name="date">The Excel date.</param>
            <returns>Java representation of the date, or null if date Is not a valid Excel date</returns>
            <remarks>
            NOTE: If the default 
            <c>TimeZone</c>
             in Java uses Daylight
            Saving Time then the conversion back to an Excel date may not give
            the same value, that Is the comparison
            <CODE>excelDate == GetExcelDate(GetJavaDate(excelDate,false))</CODE>
            Is not always true. For example if default timezone Is
            <c>Europe/Copenhagen</c>
            , on 2004-03-28 the minute after
            01:59 CET Is 03:00 CEST, if the excel date represents a time between
            02:00 and 03:00 then it Is Converted to past 03:00 summer time
            </remarks>        
        </member>
        <member name="M:NPOI.SS.UserModel.DateUtil.GetJavaDate(System.Double,System.Boolean)">
              Given an Excel date with either 1900 or 1904 date windowing,
              Converts it to a Date.
            
              NOTE: If the default <c>TimeZone</c> in Java uses Daylight
              Saving Time then the conversion back to an Excel date may not give
              the same value, that Is the comparison
              <CODE>excelDate == GetExcelDate(GetJavaDate(excelDate,false))</CODE>
              Is not always true. For example if default timezone Is
              <c>Europe/Copenhagen</c>, on 2004-03-28 the minute after
              01:59 CET Is 03:00 CEST, if the excel date represents a time between
              02:00 and 03:00 then it Is Converted to past 03:00 summer time
            
              @param date  The Excel date.
              @param use1904windowing  true if date uses 1904 windowing,
               or false if using 1900 date windowing.
              @return Java representation of the date, or null if date Is not a valid Excel date
              @see TimeZone
        </member>
        <member name="M:NPOI.SS.UserModel.DateUtil.ConvertTime(System.String)">
            <summary>
            Converts a string of format "HH:MM" or "HH:MM:SS" to its (Excel) numeric equivalent
            </summary>
            <param name="timeStr">The time STR.</param>
            <returns> a double between 0 and 1 representing the fraction of the day</returns>
        </member>
        <member name="M:NPOI.SS.UserModel.DateUtil.ConvertTimeInternal(System.String)">
            <summary>
            Converts the time internal.
            </summary>
            <param name="timeStr">The time STR.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.SS.UserModel.DateUtil.IsADateFormat(System.Int32,System.String)">
            <summary>
            Given a format ID and its format String, will Check to see if the
            format represents a date format or not.
            Firstly, it will Check to see if the format ID corresponds to an
            internal excel date format (eg most US date formats)
            If not, it will Check to see if the format string only Contains
            date formatting Chars (ymd-/), which covers most
            non US date formats.
            </summary>
            <param name="formatIndex">The index of the format, eg from ExtendedFormatRecord.GetFormatIndex</param>
            <param name="formatString">The format string, eg from FormatRecord.GetFormatString</param>
            <returns>
            	<c>true</c> if [is A date format] [the specified format index]; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NPOI.SS.UserModel.DateUtil.ParseYYYYMMDDDate(System.String)">
            <summary>
            Converts a string of format "YYYY/MM/DD" to its (Excel) numeric equivalent
            </summary>
            <param name="dateStr">The date STR.</param>
            <returns>a double representing the (integer) number of days since the start of the Excel epoch</returns>
        </member>
        <member name="M:NPOI.SS.UserModel.DateUtil.ParseYYYYMMDDDateInternal(System.String)">
            <summary>
            Parses the YYYYMMDD date internal.
            </summary>
            <param name="timeStr">The time string.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.SS.UserModel.DateUtil.ParseInt(System.String,System.String,System.Int32)">
            <summary>
            Parses the int.
            </summary>
            <param name="strVal">The string value.</param>
            <param name="fieldName">Name of the field.</param>
            <param name="rangeMax">The range max.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.SS.UserModel.DateUtil.ParseInt(System.String,System.String,System.Int32,System.Int32)">
            <summary>
            Parses the int.
            </summary>
            <param name="strVal">The STR val.</param>
            <param name="fieldName">Name of the field.</param>
            <param name="lowerLimit">The lower limit.</param>
            <param name="upperLimit">The upper limit.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.SS.UserModel.DateUtil.IsInternalDateFormat(System.Int32)">
            <summary>
            Given a format ID this will Check whether the format represents
            an internal excel date format or not.
            </summary>
            <param name="format">The format.</param>
            <returns>
            	<c>true</c> if [is internal date format] [the specified format]; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NPOI.SS.UserModel.DateUtil.IsCellDateFormatted(NPOI.SS.UserModel.Cell)">
            <summary>
            Check if a cell Contains a date
            Since dates are stored internally in Excel as double values
            we infer it Is a date if it Is formatted as such.
            </summary>
            <param name="cell">The cell.</param>
            <returns>
            	<c>true</c> if [is cell date formatted] [the specified cell]; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NPOI.SS.UserModel.DateUtil.IsCellInternalDateFormatted(NPOI.SS.UserModel.Cell)">
            <summary>
            Check if a cell Contains a date, Checking only for internal
            excel date formats.
            As Excel stores a great many of its dates in "non-internal"
            date formats, you will not normally want to use this method.
            </summary>
            <param name="cell">The cell.</param>
            <returns>
            	<c>true</c> if [is cell internal date formatted] [the specified cell]; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NPOI.SS.UserModel.DateUtil.IsValidExcelDate(System.Double)">
            <summary>
            Given a double, Checks if it Is a valid Excel date.
            </summary>
            <param name="value">the double value.</param>
            <returns>
            	<c>true</c> if [is valid excel date] [the specified value]; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:NPOI.SS.UserModel.Drawing">
            @author Yegor Kozlov
        </member>
        <member name="T:NPOI.SS.UserModel.ErrorConstants">
            Contains raw Excel error codes (as defined in OOO's excelfileformat.pdf (2.5.6)
            
            @author  Michael Harhen
        </member>
        <member name="F:NPOI.SS.UserModel.ErrorConstants.ERROR_NULL">
            <b>#NULL!</b>  - Intersection of two cell ranges is empty 
        </member>
        <member name="F:NPOI.SS.UserModel.ErrorConstants.ERROR_DIV_0">
            <b>#DIV/0!</b> - Division by zero 
        </member>
        <member name="F:NPOI.SS.UserModel.ErrorConstants.ERROR_VALUE">
            <b>#VALUE!</b> - Wrong type of operand 
        </member>
        <member name="F:NPOI.SS.UserModel.ErrorConstants.ERROR_REF">
            <b>#REF!</b> - Illegal or deleted cell reference 
        </member>
        <member name="F:NPOI.SS.UserModel.ErrorConstants.ERROR_NAME">
            <b>#NAME?</b> - Wrong function or range name 
        </member>
        <member name="F:NPOI.SS.UserModel.ErrorConstants.ERROR_NUM">
            <b>#NUM!</b> - Value range overflow 
        </member>
        <member name="F:NPOI.SS.UserModel.ErrorConstants.ERROR_NA">
            <b>#N/A</b> - Argument or function not available 
        </member>
        <member name="M:NPOI.SS.UserModel.ErrorConstants.GetText(System.Int32)">
            @return Standard Excel error literal for the specified error code. 
            @throws ArgumentException if the specified error code is not one of the 7 
            standard error codes
        </member>
        <member name="M:NPOI.SS.UserModel.ErrorConstants.IsValidCode(System.Int32)">
            @return <code>true</code> if the specified error code is a standard Excel error code. 
        </member>
        <member name="T:NPOI.SS.UserModel.FillPatternType">
            The enumeration value indicating the style of fill pattern being used for a cell format.
            
        </member>
        <member name="F:NPOI.SS.UserModel.FillPatternType.NO_FILL">
             No background 
        </member>
        <member name="F:NPOI.SS.UserModel.FillPatternType.SOLID_FOREGROUND">
             Solidly Filled 
        </member>
        <member name="F:NPOI.SS.UserModel.FillPatternType.FINE_DOTS">
             Small fine dots 
        </member>
        <member name="F:NPOI.SS.UserModel.FillPatternType.ALT_BARS">
             Wide dots 
        </member>
        <member name="F:NPOI.SS.UserModel.FillPatternType.SPARSE_DOTS">
             Sparse dots 
        </member>
        <member name="F:NPOI.SS.UserModel.FillPatternType.THICK_HORZ_BANDS">
             Thick horizontal bands 
        </member>
        <member name="F:NPOI.SS.UserModel.FillPatternType.THICK_VERT_BANDS">
             Thick vertical bands 
        </member>
        <member name="F:NPOI.SS.UserModel.FillPatternType.THICK_BACKWARD_DIAG">
             Thick backward facing diagonals 
        </member>
        <member name="F:NPOI.SS.UserModel.FillPatternType.THICK_FORWARD_DIAG">
             Thick forward facing diagonals 
        </member>
        <member name="F:NPOI.SS.UserModel.FillPatternType.BIG_SPOTS">
             Large spots 
        </member>
        <member name="F:NPOI.SS.UserModel.FillPatternType.BRICKS">
             Brick-like layout 
        </member>
        <member name="F:NPOI.SS.UserModel.FillPatternType.THIN_HORZ_BANDS">
             Thin horizontal bands 
        </member>
        <member name="F:NPOI.SS.UserModel.FillPatternType.THIN_VERT_BANDS">
             Thin vertical bands 
        </member>
        <member name="F:NPOI.SS.UserModel.FillPatternType.THIN_BACKWARD_DIAG">
             Thin backward diagonal 
        </member>
        <member name="F:NPOI.SS.UserModel.FillPatternType.THIN_FORWARD_DIAG">
             Thin forward diagonal 
        </member>
        <member name="F:NPOI.SS.UserModel.FillPatternType.SQUARES">
             Squares 
        </member>
        <member name="F:NPOI.SS.UserModel.FillPatternType.DIAMONDS">
             Diamonds 
        </member>
        <member name="F:NPOI.SS.UserModel.FillPatternType.LESS_DOTS">
             Less Dots 
        </member>
        <member name="F:NPOI.SS.UserModel.FillPatternType.LEAST_DOTS">
             Least Dots 
        </member>
        <member name="F:NPOI.SS.UserModel.FontSuperScript.NONE">
            no type Offsetting (not super or subscript)
        </member>
        <member name="F:NPOI.SS.UserModel.FontSuperScript.SUPER">
            superscript
        </member>
        <member name="F:NPOI.SS.UserModel.FontSuperScript.SUB">
            subscript
        </member>
        <member name="F:NPOI.SS.UserModel.FontColor.NORMAL">
            normal type of black color.
        </member>
        <member name="F:NPOI.SS.UserModel.FontColor.RED">
            Dark Red color
        </member>
        <member name="F:NPOI.SS.UserModel.FontBoldWeight.NORMAL">
            Normal boldness (not bold)
        </member>
        <member name="F:NPOI.SS.UserModel.FontBoldWeight.BOLD">
            Bold boldness (bold)
        </member>
        <member name="F:NPOI.SS.UserModel.FontCharsetType.ANSI">
            ANSI character set
        </member>
        <member name="F:NPOI.SS.UserModel.FontCharsetType.DEFAULT">
            Default character Set.
        </member>
        <member name="F:NPOI.SS.UserModel.FontCharsetType.SYMBOL">
            Symbol character set
        </member>
        <member name="P:NPOI.SS.UserModel.Font.FontName">
            get the name for the font (i.e. Arial)
            @return String representing the name of the font to use
        </member>
        <member name="P:NPOI.SS.UserModel.Font.FontHeight">
            get the font height in unit's of 1/20th of a point.  Maybe you might want to
            use the GetFontHeightInPoints which matches to the familiar 10, 12, 14 etc..
            @return short - height in 1/20ths of a point
            @see #GetFontHeightInPoints()
        </member>
        <member name="P:NPOI.SS.UserModel.Font.FontHeightInPoints">
            get the font height
            @return short - height in the familiar unit of measure - points
            @see #GetFontHeight()
        </member>
        <member name="P:NPOI.SS.UserModel.Font.IsItalic">
            get whether to use italics or not
            @return italics or not
        </member>
        <member name="P:NPOI.SS.UserModel.Font.IsStrikeout">
            get whether to use a strikeout horizontal line through the text or not
            @return strikeout or not
        </member>
        <member name="P:NPOI.SS.UserModel.Font.Color">
            get the color for the font
            @return color to use
            @see #COLOR_NORMAL
            @see #COLOR_RED
            @see NPOI.HSSF.usermodel.HSSFPalette#GetColor(short)
        </member>
        <member name="P:NPOI.SS.UserModel.Font.TypeOffset">
            get normal,super or subscript.
            @return offset type to use (none,super,sub)
            @see #SS_NONE
            @see #SS_SUPER
            @see #SS_SUB
        </member>
        <member name="P:NPOI.SS.UserModel.Font.Underline">
            get type of text underlining to use
            @return underlining type
            @see #U_NONE
            @see #U_SINGLE
            @see #U_DOUBLE
            @see #U_SINGLE_ACCOUNTING
            @see #U_DOUBLE_ACCOUNTING
        </member>
        <member name="P:NPOI.SS.UserModel.Font.Charset">
            get character-set to use.
            @return character-set
            @see #ANSI_CHARSET
            @see #DEFAULT_CHARSET
            @see #SYMBOL_CHARSET
        </member>
        <member name="P:NPOI.SS.UserModel.Font.Index">
            get the index within the XSSFWorkbook (sequence within the collection of Font objects)
            
            @return unique index number of the underlying record this Font represents (probably you don't care
             unless you're comparing which one is which)
        </member>
        <member name="T:NPOI.SS.UserModel.FontCharset">
            Charset represents the basic set of characters associated with a font (that it can display), and 
            corresponds to the ANSI codepage (8-bit or DBCS) of that character set used by a given language. 
            
            @author Gisella Bronzetti
        </member>
        <member name="P:NPOI.SS.UserModel.FontCharset.Value">
             Returns value of this charset
            
             @return value of this charset
        </member>
        <member name="T:NPOI.SS.UserModel.FontFamily">
             The font family this font belongs to. A font family is a set of fonts having common stroke width and serif
             characteristics. The font name overrides when there are conflicting values.
            
             @author Gisella Bronzetti
        </member>
        <member name="P:NPOI.SS.UserModel.FontFamily.Value">
             Returns index of this font family
            
             @return index of this font family
        </member>
        <!-- Badly formed XML comment ignored for member "T:NPOI.SS.UserModel.FontScheme" -->
        <member name="F:NPOI.SS.UserModel.FontUnderlineType.NONE">
            not underlined
        </member>
        <member name="F:NPOI.SS.UserModel.FontUnderlineType.SINGLE">
            single (normal) underline
        </member>
        <member name="F:NPOI.SS.UserModel.FontUnderlineType.DOUBLE">
            double underlined
        </member>
        <member name="F:NPOI.SS.UserModel.FontUnderlineType.SINGLE_ACCOUNTING">
            accounting style single underline
        </member>
        <member name="F:NPOI.SS.UserModel.FontUnderlineType.DOUBLE_ACCOUNTING">
            accounting style double underline
        </member>
        <member name="T:NPOI.SS.UserModel.FontUnderline">
             the different types of possible underline formatting
            
             @author Gisella Bronzetti
        </member>
        <member name="F:NPOI.SS.UserModel.FontUnderline.SINGLE">
            Single-line underlining under each character in the cell.
            The underline is drawn through the descenders of
            characters such as g and p..
        </member>
        <member name="F:NPOI.SS.UserModel.FontUnderline.DOUBLE">
            Double-line underlining under each character in the
            cell. underlines are drawn through the descenders of
            characters such as g and p.
        </member>
        <member name="F:NPOI.SS.UserModel.FontUnderline.SINGLE_ACCOUNTING">
            Single-line accounting underlining under each
            character in the cell. The underline is drawn under the
            descenders of characters such as g and p.
        </member>
        <member name="F:NPOI.SS.UserModel.FontUnderline.DOUBLE_ACCOUNTING">
            Double-line accounting underlining under each
            character in the cell. The underlines are drawn under
            the descenders of characters such as g and p.
        </member>
        <member name="F:NPOI.SS.UserModel.FontUnderline.NONE">
            No underline.
        </member>
        <member name="T:NPOI.SS.UserModel.Footer">
            <summary>
            Common defInition of a HSSF or XSSF page footer.
            For a list of all the different fields that can be
            placed into a footer, such as page number,
            bold, underline etc, see
            </summary>
        </member>
        <member name="P:NPOI.SS.UserModel.Footer.Left">
            <summary>
            Get the left side of the footer.
            </summary>
            <value>The string representing the left side.</value>
        </member>
        <member name="P:NPOI.SS.UserModel.Footer.Center">
            <summary>
            Get the center of the footer.
            </summary>
            <value>The string representing the center.</value>
        </member>
        <member name="P:NPOI.SS.UserModel.Footer.Right">
            <summary>
            Get the right side of the footer.
            </summary>
            <value>The string representing the right side.</value>
        </member>
        <member name="T:NPOI.SS.UserModel.FormulaError">
             Enumerates error values in SpreadsheetML formula calculations.
            
             @author Yegor Kozlov
        </member>
        <member name="F:NPOI.SS.UserModel.FormulaError.NULL">
            Intended to indicate when two areas are required to intersect, but do not.
            <p>Example:
            In the case of SUM(B1 C1), the space between B1 and C1 is treated as the binary
            intersection operator, when a comma was intended. end example]
            </p>
        </member>
        <member name="F:NPOI.SS.UserModel.FormulaError.DIV0">
            Intended to indicate when any number, including zero, is divided by zero.
            Note: However, any error code divided by zero results in that error code.
        </member>
        <member name="F:NPOI.SS.UserModel.FormulaError.VALUE">
            Intended to indicate when an incompatible type argument is passed to a function, or
            an incompatible type operand is used with an operator.
            <p>Example:
            In the case of a function argument, text was expected, but a number was provided
            </p>
        </member>
        <member name="F:NPOI.SS.UserModel.FormulaError.REF">
            Intended to indicate when a cell reference is invalid.
            <p>Example:
            If a formula Contains a reference to a cell, and then the row or column Containing that cell is deleted,
            a #REF! error results. If a worksheet does not support 20,001 columns,
            OFFSET(A1,0,20000) will result in a #REF! error.
            </p>
        </member>
        <!-- Badly formed XML comment ignored for member "F:NPOI.SS.UserModel.FormulaError.NAME" -->
        <member name="F:NPOI.SS.UserModel.FormulaError.NUM">
            Intended to indicate when an argument to a function has a compatible type, but has a
            value that is outside the domain over which that function is defined. (This is known as
            a domain error.)
            <p>Example:
            Certain calls to ASIN, ATANH, FACT, and SQRT might result in domain errors.
            </p>
            Intended to indicate that the result of a function cannot be represented in a value of
            the specified type, typically due to extreme magnitude. (This is known as a range
            error.)
            <p>Example: FACT(1000) might result in a range error. </p>
        </member>
        <member name="F:NPOI.SS.UserModel.FormulaError.NA">
            Intended to indicate when a designated value is not available.
            <p>Example:
            Some functions, such as SUMX2MY2, perform a series of operations on corresponding
            elements in two arrays. If those arrays do not have the same number of elements, then
            for some elements in the longer array, there are no corresponding elements in the
            shorter one; that is, one or more values in the shorter array are not available.
            </p>
            This error value can be produced by calling the function NA
        </member>
        <member name="P:NPOI.SS.UserModel.FormulaError.Code">
            @return numeric code of the error
        </member>
        <member name="P:NPOI.SS.UserModel.FormulaError.String">
            @return string representation of the error
        </member>
        <member name="T:NPOI.SS.UserModel.FormulaEvaluator">
            Evaluates formula cells.<p/>
            
            For performance reasons, this class keeps a cache of all previously calculated intermediate
            cell values.  Be sure to call {@link #ClearAllCachedResultValues()} if any workbook cells are Changed between
            calls to Evaluate~ methods on this class.
            
            @author Amol S. Deshmukh &lt; amolweb at ya hoo dot com &gt;
            @author Josh Micich
        </member>
        <member name="M:NPOI.SS.UserModel.FormulaEvaluator.ClearAllCachedResultValues">
            Should be called whenever there are Changes to input cells in the Evaluated workbook.
            Failure to call this method after changing cell values will cause incorrect behaviour
            of the Evaluate~ methods of this class
        </member>
        <member name="M:NPOI.SS.UserModel.FormulaEvaluator.NotifySetFormula(NPOI.SS.UserModel.Cell)">
            Should be called to tell the cell value cache that the specified (value or formula) cell 
            has Changed.
            Failure to call this method after changing cell values will cause incorrect behaviour
            of the Evaluate~ methods of this class
        </member>
        <member name="M:NPOI.SS.UserModel.FormulaEvaluator.NotifyDeleteCell(NPOI.SS.UserModel.Cell)">
            Should be called to tell the cell value cache that the specified cell has just become a
            formula cell, or the formula text has Changed 
        </member>
        <member name="M:NPOI.SS.UserModel.FormulaEvaluator.Evaluate(NPOI.SS.UserModel.Cell)">
            If cell Contains a formula, the formula is Evaluated and returned,
            else the CellValue simply copies the appropriate cell value from
            the cell and also its cell type. This method should be preferred over
            EvaluateInCell() when the call should not modify the contents of the
            original cell.
            @param cell
        </member>
        <member name="M:NPOI.SS.UserModel.FormulaEvaluator.EvaluateFormulaCell(NPOI.SS.UserModel.Cell)">
            If cell Contains formula, it Evaluates the formula,
             and saves the result of the formula. The cell
             remains as a formula cell.
            Else if cell does not contain formula, this method leaves
             the cell unChanged.
            Note that the type of the formula result is returned,
             so you know what kind of value is also stored with
             the formula.
            <pre>
            int EvaluatedCellType = Evaluator.evaluateFormulaCell(cell);
            </pre>
            Be aware that your cell will hold both the formula,
             and the result. If you want the cell Replaced with
             the result of the formula, use {@link #EvaluateInCell(Cell)}
            @param cell The cell to Evaluate
            @return The type of the formula result (the cell's type remains as Cell.CELL_TYPE_FORMULA however)
        </member>
        <member name="M:NPOI.SS.UserModel.FormulaEvaluator.EvaluateInCell(NPOI.SS.UserModel.Cell)">
            If cell Contains formula, it Evaluates the formula, and
             Puts the formula result back into the cell, in place
             of the old formula.
            Else if cell does not contain formula, this method leaves
             the cell unChanged.
            Note that the same instance of Cell is returned to
            allow chained calls like:
            <pre>
            int EvaluatedCellType = Evaluator.evaluateInCell(cell).getCellType();
            </pre>
            Be aware that your cell value will be Changed to hold the
             result of the formula. If you simply want the formula
             value comPuted for you, use {@link #EvaluateFormulaCell(Cell)}
            @param cell
        </member>
        <member name="T:NPOI.SS.UserModel.Header">
            <summary>
            Common defInition of a HSSF or XSSF page header.
            For a list of all the different fields that can be
            placed into a header, such as page number,
            bold, underline etc, see
            </summary>
        </member>
        <member name="P:NPOI.SS.UserModel.Header.Left">
            <summary>
            Get the left side of the header.
            </summary>
            <value>The string representing the left side.</value>
        </member>
        <member name="P:NPOI.SS.UserModel.Header.Center">
            <summary>
            Get the center of the header.
            </summary>
            <value>The string representing the center.</value>
        </member>
        <member name="P:NPOI.SS.UserModel.Header.Right">
            <summary>
            Get the right side of the header.
            </summary>
            <value>The string representing the right side.</value>
        </member>
        <member name="T:NPOI.SS.UserModel.HeaderFooter">
            <summary>
            Common interface for NPOI.SS.UserModel.Header and NPOI.SS.UserModel.Footer
            </summary>
        </member>
        <member name="P:NPOI.SS.UserModel.HeaderFooter.Left">
            <summary>
            Gets or sets the left side of the header or footer.
            </summary>
            <value>The string representing the left side.</value>
        </member>
        <member name="P:NPOI.SS.UserModel.HeaderFooter.Center">
            <summary>
            Gets or sets the center of the header or footer.
            </summary>
            <value>The string representing the center.</value>
        </member>
        <member name="P:NPOI.SS.UserModel.HeaderFooter.Right">
            <summary>
            Gets or sets the right side of the header or footer.
            </summary>
            <value>The string representing the right side.</value>
        </member>
        <member name="T:NPOI.SS.UserModel.HorizontalAlignment">
            The enumeration value indicating horizontal alignment of a cell,
            i.e., whether it is aligned general, left, right, horizontally centered, Filled (replicated),
            justified, centered across multiple cells, or distributed.
        </member>
        <member name="F:NPOI.SS.UserModel.HorizontalAlignment.GENERAL">
            The horizontal alignment is general-aligned. Text data is left-aligned.
            Numbers, dates, and times are rightaligned. Boolean types are centered.
            Changing the alignment does not change the type of data.
        </member>
        <member name="F:NPOI.SS.UserModel.HorizontalAlignment.LEFT">
            The horizontal alignment is left-aligned, even in Rightto-Left mode.
            Aligns contents at the left edge of the cell. If an indent amount is specified, the contents of
            the cell is indented from the left by the specified number of character spaces. The character spaces are
            based on the default font and font size for the workbook.
        </member>
        <member name="F:NPOI.SS.UserModel.HorizontalAlignment.CENTER">
            The horizontal alignment is centered, meaning the text is centered across the cell.
        </member>
        <member name="F:NPOI.SS.UserModel.HorizontalAlignment.RIGHT">
            The horizontal alignment is right-aligned, meaning that cell contents are aligned at the right edge of the cell,
            even in Right-to-Left mode.
        </member>
        <member name="F:NPOI.SS.UserModel.HorizontalAlignment.FILL">
            Indicates that the value of the cell should be Filled
            across the entire width of the cell. If blank cells to the right also have the fill alignment,
            they are also Filled with the value, using a convention similar to centerContinuous.
            <p>
            Additional rules:
            <ol>
            <li>Only whole values can be Appended, not partial values.</li>
            <li>The column will not be widened to 'best fit' the Filled value</li>
            <li>If Appending an Additional occurrence of the value exceeds the boundary of the cell
            left/right edge, don't append the Additional occurrence of the value.</li>
            <li>The display value of the cell is Filled, not the underlying raw number.</li>
            </ol>
            </p>
        </member>
        <member name="F:NPOI.SS.UserModel.HorizontalAlignment.JUSTIFY">
            The horizontal alignment is justified (flush left and right).
            For each line of text, aligns each line of the wrapped text in a cell to the right and left
            (except the last line). If no single line of text wraps in the cell, then the text is not justified.
        </member>
        <member name="F:NPOI.SS.UserModel.HorizontalAlignment.CENTER_SELECTION">
            The horizontal alignment is centered across multiple cells.
            The information about how many cells to span is expressed in the Sheet Part,
            in the row of the cell in question. For each cell that is spanned in the alignment,
            a cell element needs to be written out, with the same style Id which references the centerContinuous alignment.
        </member>
        <member name="F:NPOI.SS.UserModel.HorizontalAlignment.DISTRIBUTED">
            Indicates that each 'word' in each line of text inside the cell is evenly distributed
            across the width of the cell, with flush right and left margins.
            <p>
            When there is also an indent value to apply, both the left and right side of the cell
            are pAdded by the indent value.
            </p>
            <p> A 'word' is a set of characters with no space character in them. </p>
            <p> Two lines inside a cell are Separated by a carriage return. </p>
        </member>
        <member name="F:NPOI.SS.UserModel.HyperlinkType.URL">
            <summary>
            Link to a existing file or web page
            </summary>
        </member>
        <member name="F:NPOI.SS.UserModel.HyperlinkType.DOCUMENT">
            <summary>
            Link to a place in this document
            </summary>
        </member>
        <member name="F:NPOI.SS.UserModel.HyperlinkType.EMAIL">
            <summary>
            Link to an E-mail Address
            </summary>
        </member>
        <member name="F:NPOI.SS.UserModel.HyperlinkType.FILE">
            <summary>
            Link to a file
            </summary>
        </member>
        <member name="T:NPOI.SS.UserModel.Hyperlink">
            Represents an Excel hyperlink.
        </member>
        <member name="P:NPOI.SS.UserModel.Hyperlink.Address">
             Hypelink address. Depending on the hyperlink type it can be URL, e-mail, patrh to a file, etc.
            
             @return  the address of this hyperlink
        </member>
        <member name="P:NPOI.SS.UserModel.Hyperlink.Label">
             Return text label for this hyperlink
            
             @return  text to display
        </member>
        <member name="P:NPOI.SS.UserModel.Hyperlink.Type">
             Return the type of this hyperlink
            
             @return the type of this hyperlink
        </member>
        <member name="P:NPOI.SS.UserModel.Hyperlink.FirstRow">
             Return the row of the first cell that Contains the hyperlink
            
             @return the 0-based row of the cell that Contains the hyperlink
        </member>
        <member name="P:NPOI.SS.UserModel.Hyperlink.LastRow">
             Return the row of the last cell that Contains the hyperlink
            
             @return the 0-based row of the last cell that Contains the hyperlink
        </member>
        <member name="P:NPOI.SS.UserModel.Hyperlink.FirstColumn">
             Return the column of the first cell that Contains the hyperlink
            
             @return the 0-based column of the first cell that Contains the hyperlink
        </member>
        <member name="P:NPOI.SS.UserModel.Hyperlink.LastColumn">
             Return the column of the last cell that Contains the hyperlink
            
             @return the 0-based column of the last cell that Contains the hyperlink
        </member>
        <member name="T:NPOI.SS.UserModel.IndexedColors">
             A deprecated indexing scheme for colours that is still required for some records, and for backwards
              compatibility with OLE2 formats.
            
             <p>
             Each element corresponds to a color index (zero-based). When using the default indexed color palette,
             the values are not written out, but instead are implied. When the color palette has been modified from default,
             then the entire color palette is used.
             </p>
            
             @author Yegor Kozlov
        </member>
        <member name="P:NPOI.SS.UserModel.IndexedColors.Index">
             Returns index of this color
            
             @return index of this color
        </member>
        <member name="T:NPOI.SS.UserModel.Name">
            Represents a defined name for a range of cells.
            A name is a meaningful shorthand that makes it easier to understand the purpose of a
            cell reference, constant or a formula.
        </member>
        <member name="P:NPOI.SS.UserModel.Name.SheetName">
             Get the sheets name which this named range is referenced to
            
             @return sheet name, which this named range refered to
        </member>
        <member name="P:NPOI.SS.UserModel.Name.NameName">
             Gets the name of the named range
            
             @return named range name
        </member>
        <member name="P:NPOI.SS.UserModel.Name.RefersToFormula">
             Returns the formula that the name is defined to refer to.
            
             @return the reference for this name, <code>null</code> if it has not been set yet. Never empty string
             @see #SetRefersToFormula(String)
        </member>
        <member name="P:NPOI.SS.UserModel.Name.IsFunctionName">
             Checks if this name is a function name
            
             @return true if this name is a function name
        </member>
        <member name="P:NPOI.SS.UserModel.Name.IsDeleted">
             Checks if this name points to a cell that no longer exists
            
             @return <code>true</code> if the name refers to a deleted cell, <code>false</code> otherwise
        </member>
        <member name="P:NPOI.SS.UserModel.Name.SheetIndex">
             Returns the sheet index this name applies to.
            
             @return the sheet index this name applies to, -1 if this name applies to the entire workbook
        </member>
        <member name="P:NPOI.SS.UserModel.Name.Comment">
             Returns the comment the user provided when the name was Created.
            
             @return the user comment for this named range
        </member>
        <member name="T:NPOI.SS.UserModel.PageOrder">
             Specifies printed page order.
            
             @author Gisella Bronzetti
        </member>
        <member name="F:NPOI.SS.UserModel.PageOrder.DOWN_THEN_OVER">
            Order pages vertically first, then move horizontally.
        </member>
        <member name="F:NPOI.SS.UserModel.PageOrder.OVER_THEN_DOWN">
            Order pages horizontally first, then move vertically
        </member>
        <member name="T:NPOI.SS.UserModel.PaperSize">
              The enumeration value indicating the possible paper size for a sheet
            
             @author Daniele Montagni
        </member>
        <member name="F:NPOI.SS.UserModel.PictureType.EMF">
            Extended windows meta file 
        </member>
        <member name="F:NPOI.SS.UserModel.PictureType.WMF">
            Windows Meta File 
        </member>
        <member name="F:NPOI.SS.UserModel.PictureType.PICT">
            Mac PICT format 
        </member>
        <member name="F:NPOI.SS.UserModel.PictureType.JPEG">
            JPEG format 
        </member>
        <member name="F:NPOI.SS.UserModel.PictureType.PNG">
            PNG format 
        </member>
        <member name="F:NPOI.SS.UserModel.PictureType.DIB">
            Device independant bitmap 
        </member>
        <member name="T:NPOI.SS.UserModel.Picture">
             Repersents a picture in a SpreadsheetML document
            
             @author Yegor Kozlov
        </member>
        <member name="M:NPOI.SS.UserModel.Picture.Resize">
            Reset the image to the original size.
        </member>
        <member name="M:NPOI.SS.UserModel.Picture.Resize(System.Double)">
             Reset the image to the original size.
            
             @param scale the amount by which image dimensions are multiplied relative to the original size.
             <code>resize(1.0)</code> Sets the original size, <code>resize(0.5)</code> resize to 50% of the original,
             <code>resize(2.0)</code> resizes to 200% of the original.
        </member>
        <member name="M:NPOI.SS.UserModel.PictureData.GetData">
             Gets the picture data.
            
             @return the picture data.
        </member>
        <member name="M:NPOI.SS.UserModel.PictureData.SuggestFileExtension">
             Suggests a file extension for this image.
            
             @return the file extension.
        </member>
        <member name="T:NPOI.SS.UserModel.PrintCellComments">
             These enumerations specify how cell comments shall be displayed for paper printing purposes.
            
             @author Gisella Bronzetti
        </member>
        <member name="F:NPOI.SS.UserModel.PrintCellComments.NONE">
            Do not print cell comments.
        </member>
        <member name="F:NPOI.SS.UserModel.PrintCellComments.AS_DISPLAYED">
            Print cell comments as displayed.
        </member>
        <member name="F:NPOI.SS.UserModel.PrintCellComments.AT_END">
            Print cell comments at end of document.
        </member>
        <member name="T:NPOI.SS.UserModel.PrintOrientation">
             The enumeration value indicating the print orientation for a sheet.
            
             @author Gisella Bronzetti
        </member>
        <member name="F:NPOI.SS.UserModel.PrintOrientation.DEFAULT">
            orientation not specified
        </member>
        <member name="F:NPOI.SS.UserModel.PrintOrientation.PORTRAIT">
            portrait orientation
        </member>
        <member name="F:NPOI.SS.UserModel.PrintOrientation.LANDSCAPE">
            landscape orientations
        </member>
        <member name="T:NPOI.SS.UserModel.DisplayCellErrorType">
            <summary>
            Used by HSSFPrintSetup.CellError property
            </summary>
        </member>
        <member name="P:NPOI.SS.UserModel.PrintSetup.PaperSize">
            Returns the paper size.    
            @return paper size    
        </member>
        <member name="P:NPOI.SS.UserModel.PrintSetup.Scale">
            Returns the scale.    
            @return scale    
        </member>
        <member name="P:NPOI.SS.UserModel.PrintSetup.PageStart">
            Returns the page start.    
            @return page start    
        </member>
        <member name="P:NPOI.SS.UserModel.PrintSetup.FitWidth">
            Returns the number of pages wide to fit sheet in.    
            @return number of pages wide to fit sheet in    
        </member>
        <member name="P:NPOI.SS.UserModel.PrintSetup.FitHeight">
            Returns the number of pages high to fit the sheet in.    
            @return number of pages high to fit the sheet in    
        </member>
        <member name="P:NPOI.SS.UserModel.PrintSetup.LeftToRight">
            Returns the left to right print order.    
            @return left to right print order    
        </member>
        <member name="P:NPOI.SS.UserModel.PrintSetup.Landscape">
            Returns the landscape mode.    
            @return landscape mode    
        </member>
        <member name="P:NPOI.SS.UserModel.PrintSetup.ValidSettings">
            Returns the valid Settings.    
            @return valid Settings    
        </member>
        <member name="P:NPOI.SS.UserModel.PrintSetup.NoColor">
            Returns the black and white Setting.    
            @return black and white Setting    
        </member>
        <member name="P:NPOI.SS.UserModel.PrintSetup.Draft">
            Returns the draft mode.    
            @return draft mode    
        </member>
        <member name="P:NPOI.SS.UserModel.PrintSetup.Notes">
            Returns the print notes.    
            @return print notes    
        </member>
        <member name="P:NPOI.SS.UserModel.PrintSetup.NoOrientation">
            Returns the no orientation.    
            @return no orientation    
        </member>
        <member name="P:NPOI.SS.UserModel.PrintSetup.UsePage">
            Returns the use page numbers.    
            @return use page numbers    
        </member>
        <member name="P:NPOI.SS.UserModel.PrintSetup.HResolution">
            Returns the horizontal resolution.    
            @return horizontal resolution    
        </member>
        <member name="P:NPOI.SS.UserModel.PrintSetup.VResolution">
            Returns the vertical resolution.    
            @return vertical resolution    
        </member>
        <member name="P:NPOI.SS.UserModel.PrintSetup.HeaderMargin">
            Returns the header margin.    
            @return header margin    
        </member>
        <member name="P:NPOI.SS.UserModel.PrintSetup.FooterMargin">
            Returns the footer margin.    
            @return footer margin    
        </member>
        <member name="P:NPOI.SS.UserModel.PrintSetup.Copies">
            Returns the number of copies.    
            @return number of copies    
        </member>
        <member name="T:NPOI.SS.UserModel.RichTextString">
            Rich text unicode string.  These strings can have fonts 
             applied to arbitary parts of the string.
             
            @author Glen Stampoultzis (glens at apache.org)
            @author Jason Height (jheight at apache.org)
        </member>
        <member name="M:NPOI.SS.UserModel.RichTextString.ApplyFont(System.Int32,System.Int32,System.Int16)">
             Applies a font to the specified characters of a string.
            
             @param startIndex    The start index to apply the font to (inclusive)
             @param endIndex      The end index to apply the font to (exclusive)
             @param fontIndex     The font to use.
        </member>
        <member name="M:NPOI.SS.UserModel.RichTextString.ApplyFont(System.Int32,System.Int32,NPOI.SS.UserModel.Font)">
             Applies a font to the specified characters of a string.
            
             @param startIndex    The start index to apply the font to (inclusive)
             @param endIndex      The end index to apply to font to (exclusive)
             @param font          The index of the font to use.
        </member>
        <member name="M:NPOI.SS.UserModel.RichTextString.ApplyFont(NPOI.SS.UserModel.Font)">
            Sets the font of the entire string.
            @param font          The font to use.
        </member>
        <member name="M:NPOI.SS.UserModel.RichTextString.ClearFormatting">
            Removes any formatting that may have been applied to the string.
        </member>
        <member name="P:NPOI.SS.UserModel.RichTextString.String">
            Returns the plain string representation.
        </member>
        <member name="P:NPOI.SS.UserModel.RichTextString.Length">
            @return  the number of characters in the font.
        </member>
        <member name="P:NPOI.SS.UserModel.RichTextString.NumFormattingRuns">
             @return  The number of formatting Runs used.
            
        </member>
        <member name="M:NPOI.SS.UserModel.RichTextString.GetIndexOfFormattingRun(System.Int32)">
            The index within the string to which the specified formatting run applies.
            @param index     the index of the formatting run
            @return  the index within the string.
        </member>
        <member name="M:NPOI.SS.UserModel.RichTextString.ApplyFont(System.Int16)">
             Applies the specified font to the entire string.
            
             @param fontIndex  the font to apply.
        </member>
        <member name="T:NPOI.SS.UserModel.MissingCellPolicy">
            Used to specify the different possible policies
             if for the case of null and blank cells
        </member>
        <member name="F:NPOI.SS.UserModel.MissingCellPolicy.RETURN_NULL_AND_BLANK">
            Missing cells are returned as null, Blank cells are returned as normal 
        </member>
        <member name="F:NPOI.SS.UserModel.MissingCellPolicy.RETURN_BLANK_AS_NULL">
            Missing cells are returned as null, as are blank cells 
        </member>
        <member name="F:NPOI.SS.UserModel.MissingCellPolicy.CREATE_NULL_AS_BLANK">
            A new, blank cell is Created for missing cells. Blank cells are returned as normal 
        </member>
        <member name="T:NPOI.SS.UserModel.Row">
            High level representation of a row of a spreadsheet.
        </member>
        <!-- Badly formed XML comment ignored for member "M:NPOI.SS.UserModel.Row.CreateCell(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:NPOI.SS.UserModel.Row.CreateCell(System.Int32,NPOI.SS.UserModel.CellType)" -->
        <member name="M:NPOI.SS.UserModel.Row.RemoveCell(NPOI.SS.UserModel.Cell)">
             Remove the Cell from this row.
            
             @param cell the cell to remove
        </member>
        <member name="P:NPOI.SS.UserModel.Row.RowNum">
             Get row number this row represents
            
             @return the row number (0 based)
        </member>
        <member name="M:NPOI.SS.UserModel.Row.GetCell(System.Int32)">
             Get the cell representing a given column (logical cell) 0-based.  If you
             ask for a cell that is not defined....you get a null.
            
             @param cellnum  0 based column number
             @return Cell representing that column or null if undefined.
             @see #GetCell(int, NPOI.SS.usermodel.Row.MissingCellPolicy)
        </member>
        <!-- Badly formed XML comment ignored for member "M:NPOI.SS.UserModel.Row.GetCell(System.Int32,NPOI.SS.UserModel.MissingCellPolicy)" -->
        <member name="P:NPOI.SS.UserModel.Row.FirstCellNum">
             Get the number of the first cell Contained in this row.
            
             @return short representing the first logical cell in the row,
              or -1 if the row does not contain any cells.
        </member>
        <member name="P:NPOI.SS.UserModel.Row.LastCellNum">
             Gets the index of the last cell Contained in this row <b>PLUS ONE</b>. The result also
             happens to be the 1-based column number of the last cell.  This value can be used as a
             standard upper bound when iterating over cells:
             <pre>
             short minColIx = row.GetFirstCellNum();
             short maxColIx = row.GetLastCellNum();
             for(short colIx=minColIx; colIx&lt;maxColIx; colIx++) {
               Cell cell = row.GetCell(colIx);
               if(cell == null) {
                 continue;
               }
               //... do something with cell
             }
             </pre>
            
             @return short representing the last logical cell in the row <b>PLUS ONE</b>,
               or -1 if the row does not contain any cells.
        </member>
        <member name="P:NPOI.SS.UserModel.Row.PhysicalNumberOfCells">
             Gets the number of defined cells (NOT number of cells in the actual row!).
             That is to say if only columns 0,4,5 have values then there would be 3.
            
             @return int representing the number of defined cells in the row.
        </member>
        <member name="P:NPOI.SS.UserModel.Row.ZeroHeight">
             Get whether or not to display this row with 0 height
            
             @return - zHeight height is zero or not.
        </member>
        <member name="P:NPOI.SS.UserModel.Row.Height">
             Get the row's height measured in twips (1/20th of a point). If the height is not Set, the default worksheet value is returned,
             See {@link Sheet#GetDefaultRowHeightInPoints()}
            
             @return row height measured in twips (1/20th of a point)
        </member>
        <member name="P:NPOI.SS.UserModel.Row.HeightInPoints">
             Returns row height measured in point size. If the height is not Set, the default worksheet value is returned,
             See {@link Sheet#GetDefaultRowHeightInPoints()}
            
             @return row height measured in point size
             @see Sheet#GetDefaultRowHeightInPoints()
        </member>
        <member name="M:NPOI.SS.UserModel.Row.GetCellEnumerator">
            @return Cell iterator of the physically defined cells.  Note element 4 may
            actually be row cell depending on how many are defined!
        </member>
        <member name="P:NPOI.SS.UserModel.Row.Sheet">
             Returns the Sheet this row belongs to
            
             @return the Sheet that owns this row
        </member>
        <member name="T:NPOI.SS.UserModel.ShapeTypes">
             All known types of automatic shapes in DrawingML
            
             @author Yegor Kozlov
        </member>
        <member name="T:NPOI.SS.UserModel.Sheet">
            <summary>
            High level representation of a Excel worksheet.
            </summary>
            <remarks>
            Sheets are the central structures within a workbook, and are where a user does most of his spreadsheet work.
            The most common type of sheet is the worksheet, which is represented as a grid of cells. Worksheet cells can
            contain text, numbers, dates, and formulas. Cells can also be formatted.
            </remarks>
        </member>
        <member name="M:NPOI.SS.UserModel.Sheet.CreateRow(System.Int32)">
            <summary>
            Create a new row within the sheet and return the high level representation
            </summary>
            <param name="rownum">The row number.</param>
            <returns>high level Row object representing a row in the sheet</returns>
            <see>RemoveRow(Row)</see>
        </member>
        <member name="M:NPOI.SS.UserModel.Sheet.RemoveRow(NPOI.SS.UserModel.Row)">
            <summary>
            Remove a row from this sheet.  All cells Contained in the row are Removed as well
            </summary>
            <param name="row">a row to Remove.</param>
        </member>
        <member name="M:NPOI.SS.UserModel.Sheet.GetRow(System.Int32)">
            <summary>
            Returns the logical row (not physical) 0-based.  If you ask for a row that is not
            defined you get a null.  This is to say row 4 represents the fifth row on a sheet.
            </summary>
            <param name="rownum">row to get (0-based).</param>
            <returns>the rownumber or null if its not defined on the sheet</returns>
        </member>
        <member name="P:NPOI.SS.UserModel.Sheet.PhysicalNumberOfRows">
            <summary>
            Returns the number of physically defined rows (NOT the number of rows in the sheet)
            </summary>
            <value>the number of physically defined rows in this sheet.</value>
        </member>
        <member name="P:NPOI.SS.UserModel.Sheet.FirstRowNum">
            <summary>
            Gets the first row on the sheet
            </summary>
            <value>the number of the first logical row on the sheet (0-based).</value>
        </member>
        <member name="P:NPOI.SS.UserModel.Sheet.LastRowNum">
            <summary>
            Gets the last row on the sheet
            </summary>
            <value>last row contained n this sheet (0-based)</value>
        </member>
        <member name="P:NPOI.SS.UserModel.Sheet.ForceFormulaRecalculation">
            <summary>
            whether force formula recalculation.
            </summary>
        </member>
        <member name="M:NPOI.SS.UserModel.Sheet.SetColumnHidden(System.Int32,System.Boolean)">
             Get the visibility state for a given column
            
             @param columnIndex - the column to get (0-based)
             @param hidden - the visiblity state of the column
        </member>
        <member name="M:NPOI.SS.UserModel.Sheet.IsColumnHidden(System.Int32)">
             Get the hidden state for a given column
            
             @param columnIndex - the column to set (0-based)
             @return hidden - <code>false</code> if the column is visible
        </member>
        <member name="M:NPOI.SS.UserModel.Sheet.SetColumnWidth(System.Int32,System.Int32)">
             Set the width (in units of 1/256th of a character width)
             <p>
             The maximum column width for an individual cell is 255 characters.
             This value represents the number of characters that can be displayed
             in a cell that is formatted with the standard font.
             </p>
            
             @param columnIndex - the column to set (0-based)
             @param width - the width in units of 1/256th of a character width
        </member>
        <member name="M:NPOI.SS.UserModel.Sheet.GetColumnWidth(System.Int32)">
            get the width (in units of 1/256th of a character width )
            @param columnIndex - the column to set (0-based)
            @return width - the width in units of 1/256th of a character width
        </member>
        <member name="P:NPOI.SS.UserModel.Sheet.DefaultColumnWidth">
            <summary>
            Get the default column width for the sheet (if the columns do not define their own width)
            in characters
            </summary>
            <value>default column width measured in characters.</value>
        </member>
        <member name="P:NPOI.SS.UserModel.Sheet.DefaultRowHeight">
            <summary>
            Get the default row height for the sheet (if the rows do not define their own height) in
            twips (1/20 of  a point)
            </summary>
            <value>default row height measured in twips (1/20 of  a point)</value>
        </member>
        <member name="P:NPOI.SS.UserModel.Sheet.DefaultRowHeightInPoints">
            <summary>
            Get the default row height for the sheet (if the rows do not define their own height) in
            points.
            </summary>
            <value>The default row height in points.</value>
        </member>
        <member name="M:NPOI.SS.UserModel.Sheet.GetColumnStyle(System.Int32)">
            <summary>
            Returns the CellStyle that applies to the given
            (0 based) column, or null if no style has been
            set for that column
            </summary>
            <param name="column">The column.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.SS.UserModel.Sheet.AddMergedRegion(NPOI.SS.Util.CellRangeAddress)">
            <summary>
            Adds a merged region of cells (hence those cells form one)
            </summary>
            <param name="region">(rowfrom/colfrom-rowto/colto) to merge.</param>
            <returns>index of this region</returns>
        </member>
        <member name="P:NPOI.SS.UserModel.Sheet.HorizontallyCenter">
            <summary>
            Determine whether printed output for this sheet will be horizontally centered.
            </summary>
        </member>
        <member name="P:NPOI.SS.UserModel.Sheet.VerticallyCenter">
            <summary>
            Determine whether printed output for this sheet will be vertically centered.
            </summary>
        </member>
        <member name="M:NPOI.SS.UserModel.Sheet.RemoveMergedRegion(System.Int32)">
            <summary>
            Removes a merged region of cells (hence letting them free)
            </summary>
            <param name="index">index of the region to unmerge</param>
        </member>
        <member name="P:NPOI.SS.UserModel.Sheet.NumMergedRegions">
            <summary>
            Returns the number of merged regions
            </summary>
        </member>
        <member name="M:NPOI.SS.UserModel.Sheet.GetMergedRegion(System.Int32)">
            <summary>
            Returns the merged region at the specified index
            </summary>
            <param name="index">The index.</param>      
        </member>
        <member name="M:NPOI.SS.UserModel.Sheet.GetRowEnumerator">
            <summary>
            Returns an iterator of the physical rows
            </summary>
        </member>
        <member name="P:NPOI.SS.UserModel.Sheet.DisplayZeros">
            <summary>
            Gets the flag indicating whether the window should show 0 (zero) in cells Containing zero value.
            When false, cells with zero value appear blank instead of showing the number zero.
            </summary>
            <value>whether all zero values on the worksheet are displayed.</value>
        </member>
        <member name="P:NPOI.SS.UserModel.Sheet.Autobreaks">
            <summary>
            Gets or sets a value indicating whether the sheet displays Automatic Page Breaks.
            </summary>
        </member>
        <member name="P:NPOI.SS.UserModel.Sheet.DisplayGuts">
            <summary>
            Get whether to display the guts or not,
            </summary>
            <value>default value is true</value>
        </member>
        <member name="P:NPOI.SS.UserModel.Sheet.FitToPage">
            <summary>
            Flag indicating whether the Fit to Page print option is enabled.
            </summary>
        </member>
        <member name="P:NPOI.SS.UserModel.Sheet.RowSumsBelow">
             Flag indicating whether summary rows appear below detail in an outline, when applying an outline.
            
             <p>
             When true a summary row is inserted below the detailed data being summarized and a
             new outline level is established on that row.
             </p>
             <p>
             When false a summary row is inserted above the detailed data being summarized and a new outline level
             is established on that row.
             </p>
             @return <code>true</code> if row summaries appear below detail in the outline
        </member>
        <member name="P:NPOI.SS.UserModel.Sheet.RowSumsRight">
             Flag indicating whether summary columns appear to the right of detail in an outline, when applying an outline.
            
             <p>
             When true a summary column is inserted to the right of the detailed data being summarized
             and a new outline level is established on that column.
             </p>
             <p>
             When false a summary column is inserted to the left of the detailed data being
             summarized and a new outline level is established on that column.
             </p>
             @return <code>true</code> if col summaries appear right of the detail in the outline
        </member>
        <member name="P:NPOI.SS.UserModel.Sheet.IsPrintGridlines">
             Gets the flag indicating whether this sheet displays the lines
             between rows and columns to make editing and Reading easier.
            
             @return <code>true</code> if this sheet displays gridlines.
             @see #isPrintGridlines() to check if printing of gridlines is turned on or off
        </member>
        <member name="P:NPOI.SS.UserModel.Sheet.PrintSetup">
             Gets the print Setup object.
            
             @return The user model for the print Setup object.
        </member>
        <!-- Badly formed XML comment ignored for member "P:NPOI.SS.UserModel.Sheet.Header" -->
        <member name="P:NPOI.SS.UserModel.Sheet.Footer">
             Gets the user model for the default document footer.
             <p/>
             Note that XSSF offers more kinds of document footers than HSSF does.
            
             @return the document footer. Never <code>null</code>
        </member>
        <member name="M:NPOI.SS.UserModel.Sheet.GetMargin(NPOI.SS.UserModel.MarginType)">
             Gets the size of the margin in inches.
            
             @param margin which margin to get
             @return the size of the margin
        </member>
        <member name="M:NPOI.SS.UserModel.Sheet.SetMargin(NPOI.SS.UserModel.MarginType,System.Double)">
             Sets the size of the margin in inches.
            
             @param margin which margin to get
             @param size the size of the margin
        </member>
        <member name="P:NPOI.SS.UserModel.Sheet.Protect">
             Answer whether protection is enabled or disabled
            
             @return true => protection enabled; false => protection disabled
        </member>
        <member name="P:NPOI.SS.UserModel.Sheet.ScenarioProtect">
             Answer whether scenario protection is enabled or disabled
            
             @return true => protection enabled; false => protection disabled
        </member>
        <member name="M:NPOI.SS.UserModel.Sheet.SetZoom(System.Int32,System.Int32)">
             Sets the zoom magnication for the sheet.  The zoom is expressed as a
             fraction.  For example to express a zoom of 75% use 3 for the numerator
             and 4 for the denominator.
            
             @param numerator     The numerator for the zoom magnification.
             @param denominator   The denominator for the zoom magnification.
        </member>
        <member name="P:NPOI.SS.UserModel.Sheet.TopRow">
            <summary>
            The top row in the visible view when the sheet is
            first viewed after opening it in a viewer
            </summary>
            <value>the rownum (0 based) of the top row.</value>
        </member>
        <member name="P:NPOI.SS.UserModel.Sheet.LeftCol">
            <summary>
            The left col in the visible view when the sheet is
            first viewed after opening it in a viewer
            </summary>
            <value>the rownum (0 based) of the top row</value>
        </member>
        <member name="M:NPOI.SS.UserModel.Sheet.ShowInPane(System.Int16,System.Int16)">
             Sets desktop window pane display area, when the
             file is first opened in a viewer.
            
             @param toprow the top row to show in desktop window pane
             @param leftcol the left column to show in desktop window pane
        </member>
        <!-- Badly formed XML comment ignored for member "M:NPOI.SS.UserModel.Sheet.ShiftRows(System.Int32,System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:NPOI.SS.UserModel.Sheet.ShiftRows(System.Int32,System.Int32,System.Int32,System.Boolean,System.Boolean)" -->
        <member name="M:NPOI.SS.UserModel.Sheet.CreateFreezePane(System.Int32,System.Int32,System.Int32,System.Int32)">
            Creates a split (freezepane). Any existing freezepane or split pane is overwritten.
            @param colSplit      Horizonatal position of split.
            @param rowSplit      Vertical position of split.
            @param topRow        Top row visible in bottom pane
            @param leftmostColumn   Left column visible in right pane.
        </member>
        <member name="M:NPOI.SS.UserModel.Sheet.CreateFreezePane(System.Int32,System.Int32)">
            Creates a split (freezepane). Any existing freezepane or split pane is overwritten.
            @param colSplit      Horizonatal position of split.
            @param rowSplit      Vertical position of split.
        </member>
        <member name="M:NPOI.SS.UserModel.Sheet.CreateSplitPane(System.Int32,System.Int32,System.Int32,System.Int32,NPOI.SS.UserModel.PanePosition)">
            Creates a split pane. Any existing freezepane or split pane is overwritten.
            @param xSplitPos      Horizonatal position of split (in 1/20th of a point).
            @param ySplitPos      Vertical position of split (in 1/20th of a point).
            @param topRow        Top row visible in bottom pane
            @param leftmostColumn   Left column visible in right pane.
            @param activePane    Active pane.  One of: PANE_LOWER_RIGHT,
                                 PANE_UPPER_RIGHT, PANE_LOWER_LEFT, PANE_UPPER_LEFT
            @see #PANE_LOWER_LEFT
            @see #PANE_LOWER_RIGHT
            @see #PANE_UPPER_LEFT
            @see #PANE_UPPER_RIGHT
        </member>
        <member name="P:NPOI.SS.UserModel.Sheet.PaneInformation">
            <summary>
            Returns the information regarding the currently configured pane (split or freeze)
            </summary>
            <value>if no pane configured returns <c>null</c> else return the pane information.</value>
        </member>
        <member name="P:NPOI.SS.UserModel.Sheet.DisplayGridlines">
            <summary>
            Returns if gridlines are displayed
            </summary>
        </member>
        <member name="P:NPOI.SS.UserModel.Sheet.DisplayFormulas">
            <summary>
            Returns if formulas are displayed
            </summary>
        </member>
        <member name="P:NPOI.SS.UserModel.Sheet.DisplayRowColHeadings">
            <summary>
            Returns if RowColHeadings are displayed.
            </summary>
        </member>
        <member name="P:NPOI.SS.UserModel.Sheet.IsActive">
            <summary>
            Returns if RowColHeadings are displayed.
            </summary>
        </member>
        <member name="M:NPOI.SS.UserModel.Sheet.IsRowBroken(System.Int32)">
            <summary>
            Determines if there is a page break at the indicated row
            </summary>
            <param name="row">The row.</param>
        </member>
        <member name="M:NPOI.SS.UserModel.Sheet.RemoveRowBreak(System.Int32)">
            <summary>
            Removes the page break at the indicated row
            </summary>
            <param name="row">The row index.</param>
        </member>
        <member name="P:NPOI.SS.UserModel.Sheet.RowBreaks">
            <summary>
            Retrieves all the horizontal page breaks
            </summary>
            <value>all the horizontal page breaks, or null if there are no row page breaks</value>
        </member>
        <member name="P:NPOI.SS.UserModel.Sheet.ColumnBreaks">
            <summary>
            Retrieves all the vertical page breaks
            </summary>
            <value>all the vertical page breaks, or null if there are no column page breaks.</value>
        </member>
        <member name="M:NPOI.SS.UserModel.Sheet.SetColumnBreak(System.Int32)">
            <summary>
            Sets a page break at the indicated column
            </summary>
            <param name="column">The column.</param>
        </member>
        <member name="M:NPOI.SS.UserModel.Sheet.SetRowBreak(System.Int32)">
            <summary>
            Sets the row break.
            </summary>
            <param name="row">The row.</param>
        </member>
        <member name="M:NPOI.SS.UserModel.Sheet.IsColumnBroken(System.Int32)">
            <summary>
            Determines if there is a page break at the indicated column
            </summary>
            <param name="column">The column index.</param>
        </member>
        <member name="M:NPOI.SS.UserModel.Sheet.RemoveColumnBreak(System.Int32)">
            <summary>
            Removes a page break at the indicated column
            </summary>
            <param name="column">The column.</param>
        </member>
        <member name="M:NPOI.SS.UserModel.Sheet.SetColumnGroupCollapsed(System.Int32,System.Boolean)">
            <summary>
            Expands or collapses a column group.
            </summary>
            <param name="columnNumber">One of the columns in the group.</param>
            <param name="collapsed">if set to <c>true</c>collapse group.<c>false</c>expand group.</param>
        </member>
        <member name="M:NPOI.SS.UserModel.Sheet.GroupColumn(System.Int32,System.Int32)">
            <summary>
            Create an outline for the provided column range.
            </summary>
            <param name="fromColumn">beginning of the column range.</param>
            <param name="toColumn">end of the column range.</param>
        </member>
        <member name="M:NPOI.SS.UserModel.Sheet.UngroupColumn(System.Int32,System.Int32)">
            <summary>
            Ungroup a range of columns that were previously groupped
            </summary>
            <param name="fromColumn">start column (0-based).</param>
            <param name="toColumn">end column (0-based).</param>
        </member>
        <member name="M:NPOI.SS.UserModel.Sheet.GroupRow(System.Int32,System.Int32)">
            <summary>
            Tie a range of rows toGether so that they can be collapsed or expanded
            </summary>
            <param name="fromRow">start row (0-based)</param>
            <param name="toRow">end row (0-based)</param>
        </member>
        <member name="M:NPOI.SS.UserModel.Sheet.UngroupRow(System.Int32,System.Int32)">
            <summary>
            Ungroup a range of rows that were previously groupped
            </summary>
            <param name="fromRow">start row (0-based)</param>
            <param name="toRow">end row (0-based)</param>
        </member>
        <member name="M:NPOI.SS.UserModel.Sheet.SetRowGroupCollapsed(System.Int32,System.Boolean)">
            <summary>
            Set view state of a groupped range of rows
            </summary>
            <param name="row">start row of a groupped range of rows (0-based).</param>
            <param name="collapse">whether to expand/collapse the detail rows.</param>
        </member>
        <member name="M:NPOI.SS.UserModel.Sheet.SetDefaultColumnStyle(System.Int32,NPOI.SS.UserModel.CellStyle)">
            <summary>
            Sets the default column style for a given column.  POI will only apply this style to new cells Added to the sheet.
            </summary>
            <param name="column">the column index</param>
            <param name="style">the style to set</param>
        </member>
        <member name="M:NPOI.SS.UserModel.Sheet.AutoSizeColumn(System.Int32)">
            <summary>
            Adjusts the column width to fit the contents.
            </summary>
            <param name="column">the column index</param>
            <remarks>
            This process can be relatively slow on large sheets, so this should
            normally only be called once per column, at the end of your
            processing.
            </remarks>
        </member>
        <member name="M:NPOI.SS.UserModel.Sheet.AutoSizeColumn(System.Int32,System.Boolean)">
            <summary>
            Adjusts the column width to fit the contents.
            </summary>
            <param name="column">the column index.</param>
            <param name="useMergedCells">whether to use the contents of merged cells when calculating the width of the column. Default is to ignore merged cells.</param>
            <remarks>
            This process can be relatively slow on large sheets, so this should
            normally only be called once per column, at the end of your
            processing.
            </remarks>
        </member>
        <member name="M:NPOI.SS.UserModel.Sheet.GetCellComment(System.Int32,System.Int32)">
            <summary>
            Returns cell comment for the specified row and column
            </summary>
            <param name="row">The row.</param>
            <param name="column">The column.</param>
        </member>
        <member name="M:NPOI.SS.UserModel.Sheet.CreateDrawingPatriarch">
            <summary>
            Creates the top-level drawing patriarch.
            </summary>
            <returns></returns>
        </member>
        <member name="P:NPOI.SS.UserModel.Sheet.Workbook">
            <summary>
            Gets the parent workbook.
            </summary>
        </member>
        <member name="P:NPOI.SS.UserModel.Sheet.SheetName">
            <summary>
            Gets the name of the sheet.
            </summary>
        </member>
        <member name="P:NPOI.SS.UserModel.Sheet.IsSelected">
            <summary>
            Gets or sets a value indicating whether this sheet is currently selected.
            </summary>
        </member>
        <member name="P:NPOI.SS.UserModel.Textbox.String">
            @return  the rich text string for this textbox.
        </member>
        <member name="P:NPOI.SS.UserModel.Textbox.MarginLeft">
            @return  Returns the left margin within the textbox.
        </member>
        <member name="P:NPOI.SS.UserModel.Textbox.MarginRight">
            @return    returns the right margin within the textbox.
        </member>
        <member name="P:NPOI.SS.UserModel.Textbox.MarginTop">
            @return  returns the top margin within the textbox.
        </member>
        <member name="P:NPOI.SS.UserModel.Textbox.MarginBottom">
            s the bottom margin within the textbox.
        </member>
        <member name="T:NPOI.SS.UserModel.VerticalAlignment">
            This enumeration value indicates the type of vertical alignment for a cell, i.e.,
            whether it is aligned top, bottom, vertically centered, justified or distributed.
        </member>
        <member name="F:NPOI.SS.UserModel.VerticalAlignment.TOP">
            The vertical alignment is aligned-to-top.
        </member>
        <member name="F:NPOI.SS.UserModel.VerticalAlignment.CENTER">
            The vertical alignment is centered across the height of the cell.
        </member>
        <member name="F:NPOI.SS.UserModel.VerticalAlignment.BOTTOM">
            The vertical alignment is aligned-to-bottom.
        </member>
        <member name="F:NPOI.SS.UserModel.VerticalAlignment.JUSTIFY">
            <p>
            When text direction is horizontal: the vertical alignment of lines of text is distributed vertically,
            where each line of text inside the cell is evenly distributed across the height of the cell,
            with flush top and bottom margins.
            </p>
            <p>
            When text direction is vertical: similar behavior as horizontal justification.
            The alignment is justified (flush top and bottom in this case). For each line of text, each
            line of the wrapped text in a cell is aligned to the top and bottom (except the last line).
            If no single line of text wraps in the cell, then the text is not justified.
             </p>
        </member>
        <member name="F:NPOI.SS.UserModel.VerticalAlignment.DISTRIBUTED">
            <p>
            When text direction is horizontal: the vertical alignment of lines of text is distributed vertically,
            where each line of text inside the cell is evenly distributed across the height of the cell,
            with flush top
            </p>
            <p>
            When text direction is vertical: behaves exactly as distributed horizontal alignment.
            The first words in a line of text (appearing at the top of the cell) are flush
            with the top edge of the cell, and the last words of a line of text are flush with the bottom edge of the cell,
            and the line of text is distributed evenly from top to bottom.
            </p>
        </member>
        <member name="T:NPOI.SS.UserModel.Workbook">
            High level representation of a Excel workbook.  This is the first object most users
            will construct whether they are Reading or writing a workbook.  It is also the
            top level object for creating new sheets/etc.
        </member>
        <member name="P:NPOI.SS.UserModel.Workbook.ActiveSheetIndex">
             Convenience method to get the active sheet.  The active sheet is is the sheet
             which is currently displayed when the workbook is viewed in Excel.
             'Selected' sheet(s) is a distinct concept.
            
             @return the index of the active sheet (0-based)
        </member>
        <member name="P:NPOI.SS.UserModel.Workbook.FirstVisibleTab">
             Gets the first tab that is displayed in the list of tabs in excel.
            
             @return the first tab that to display in the list of tabs (0-based).
        </member>
        <member name="M:NPOI.SS.UserModel.Workbook.SetSheetOrder(System.String,System.Int32)">
             Sets the order of appearance for a given sheet.
            
             @param sheetname the name of the sheet to reorder
             @param pos the position that we want to insert the sheet into (0 based)
        </member>
        <member name="M:NPOI.SS.UserModel.Workbook.SetSelectedTab(System.Int32)">
             Sets the tab whose data is actually seen when the sheet is opened.
             This may be different from the "selected sheet" since excel seems to
             allow you to show the data of one sheet when another is seen "selected"
             in the tabs (at the bottom).
            
             @see Sheet#SetSelected(bool)
             @param index the index of the sheet to select (0 based)
        </member>
        <member name="M:NPOI.SS.UserModel.Workbook.GetSheetName(System.Int32)">
             Set the sheet name
            
             @param sheet sheet number (0 based)
             @return Sheet name
        </member>
        <member name="M:NPOI.SS.UserModel.Workbook.GetSheetIndex(System.String)">
             Returns the index of the sheet by his name
            
             @param name the sheet name
             @return index of the sheet (0 based)
        </member>
        <member name="M:NPOI.SS.UserModel.Workbook.GetSheetIndex(NPOI.SS.UserModel.Sheet)">
             Returns the index of the given sheet
            
             @param sheet the sheet to look up
             @return index of the sheet (0 based)
        </member>
        <member name="M:NPOI.SS.UserModel.Workbook.CreateSheet">
             Sreate an Sheet for this Workbook, Adds it to the sheets and returns
             the high level representation.  Use this to create new sheets.
            
             @return Sheet representing the new sheet.
        </member>
        <member name="M:NPOI.SS.UserModel.Workbook.CreateSheet(System.String)">
             Create an Sheet for this Workbook, Adds it to the sheets and returns
             the high level representation.  Use this to create new sheets.
            
             @param sheetname  sheetname to set for the sheet.
             @return Sheet representing the new sheet.
             @throws ArgumentException if the name is greater than 31 chars or Contains <code>/\?*[]</code>
        </member>
        <member name="M:NPOI.SS.UserModel.Workbook.CloneSheet(System.Int32)">
             Create an Sheet from an existing sheet in the Workbook.
            
             @return Sheet representing the Cloned sheet.
        </member>
        <member name="P:NPOI.SS.UserModel.Workbook.NumberOfSheets">
             Get the number of spreadsheets in the workbook
            
             @return the number of sheets
        </member>
        <!-- Badly formed XML comment ignored for member "M:NPOI.SS.UserModel.Workbook.GetSheetAt(System.Int32)" -->
        <member name="M:NPOI.SS.UserModel.Workbook.GetSheet(System.String)">
             Get sheet with the given name
            
             @param name of the sheet
             @return Sheet with the name provided or <code>null</code> if it does not exist
        </member>
        <member name="M:NPOI.SS.UserModel.Workbook.RemoveSheetAt(System.Int32)">
             Removes sheet at the given index
            
             @param index of the sheet to remove (0-based)
        </member>
        <!-- Badly formed XML comment ignored for member "M:NPOI.SS.UserModel.Workbook.SetRepeatingRowsAndColumns(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" -->
        <member name="M:NPOI.SS.UserModel.Workbook.CreateFont">
             Create a new Font and add it to the workbook's font table
            
             @return new font object
        </member>
        <member name="M:NPOI.SS.UserModel.Workbook.FindFont(System.Int16,System.Int16,System.Int16,System.String,System.Boolean,System.Boolean,System.Int16,System.Byte)">
             Finds a font that matches the one with the supplied attributes
            
             @return the font with the matched attributes or <code>null</code>
        </member>
        <member name="P:NPOI.SS.UserModel.Workbook.NumberOfFonts">
             Get the number of fonts in the font table
            
             @return number of fonts
        </member>
        <member name="M:NPOI.SS.UserModel.Workbook.GetFontAt(System.Int16)">
             Get the font at the given index number
            
             @param idx  index number (0-based)
             @return font at the index
        </member>
        <member name="M:NPOI.SS.UserModel.Workbook.CreateCellStyle">
             Create a new Cell style and add it to the workbook's style table
            
             @return the new Cell Style object
        </member>
        <member name="P:NPOI.SS.UserModel.Workbook.NumCellStyles">
             Get the number of styles the workbook Contains
            
             @return count of cell styles
        </member>
        <member name="M:NPOI.SS.UserModel.Workbook.GetCellStyleAt(System.Int16)">
             Get the cell style object at the given index
            
             @param idx  index within the set of styles (0-based)
             @return CellStyle object at the index
        </member>
        <member name="M:NPOI.SS.UserModel.Workbook.Write(System.IO.Stream)">
             Write out this workbook to an OutPutstream.
            
             @param stream - the java OutPutStream you wish to write to
             @exception IOException if anything can't be written.
        </member>
        <member name="P:NPOI.SS.UserModel.Workbook.NumberOfNames">
            @return the total number of defined names in this workbook
        </member>
        <member name="M:NPOI.SS.UserModel.Workbook.GetName(System.String)">
            @param name the name of the defined name
            @return the defined name with the specified name. <code>null</code> if not found.
        </member>
        <member name="M:NPOI.SS.UserModel.Workbook.GetNameAt(System.Int32)">
            @param nameIndex position of the named range (0-based)
            @return the defined name at the specified index
            @throws ArgumentException if the supplied index is invalid
        </member>
        <member name="M:NPOI.SS.UserModel.Workbook.CreateName">
             Creates a new (unInitialised) defined name in this workbook
            
             @return new defined name object
        </member>
        <member name="M:NPOI.SS.UserModel.Workbook.GetNameIndex(System.String)">
             Gets the defined name index by name<br/>
             <i>Note:</i> Excel defined names are case-insensitive and
             this method performs a case-insensitive search.
            
             @param name the name of the defined name
             @return zero based index of the defined name. <tt>-1</tt> if not found.
        </member>
        <member name="M:NPOI.SS.UserModel.Workbook.RemoveName(System.Int32)">
             Remove the defined name at the specified index
            
             @param index named range index (0 based)
        </member>
        <member name="M:NPOI.SS.UserModel.Workbook.RemoveName(System.String)">
                     * Remove a defined name by name
                     *
                      * @param name the name of the defined name
        </member>
        <!-- Badly formed XML comment ignored for member "M:NPOI.SS.UserModel.Workbook.SetPrintArea(System.Int32,System.String)" -->
        <member name="M:NPOI.SS.UserModel.Workbook.SetPrintArea(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            For the Convenience of Java Programmers maintaining pointers.
            @see #SetPrintArea(int, String)
            @param sheetIndex Zero-based sheet index (0 = First Sheet)
            @param startColumn Column to begin printarea
            @param endColumn Column to end the printarea
            @param startRow Row to begin the printarea
            @param endRow Row to end the printarea
        </member>
        <member name="M:NPOI.SS.UserModel.Workbook.GetPrintArea(System.Int32)">
             Retrieves the reference for the printarea of the specified sheet,
             the sheet name is Appended to the reference even if it was not specified.
            
             @param sheetIndex Zero-based sheet index (0 Represents the first sheet to keep consistent with java)
             @return String Null if no print area has been defined
        </member>
        <member name="M:NPOI.SS.UserModel.Workbook.RemovePrintArea(System.Int32)">
             Delete the printarea for the sheet specified
            
             @param sheetIndex Zero-based sheet index (0 = First Sheet)
        </member>
        <member name="P:NPOI.SS.UserModel.Workbook.MissingCellPolicy">
            Retrieves the current policy on what to do when
             Getting missing or blank cells from a row.
            <p>
            The default is to return blank and null cells.
             {@link MissingCellPolicy}
            </p>
        </member>
        <member name="M:NPOI.SS.UserModel.Workbook.CreateDataFormat">
             Returns the instance of DataFormat for this workbook.
            
             @return the DataFormat object
        </member>
        <member name="M:NPOI.SS.UserModel.Workbook.AddPicture(System.Byte[],NPOI.SS.UserModel.PictureType)">
             Adds a picture to the workbook.
            
             @param pictureData       The bytes of the picture
             @param format            The format of the picture.
            
             @return the index to this picture (1 based).
             @see #PICTURE_TYPE_EMF
             @see #PICTURE_TYPE_WMF
             @see #PICTURE_TYPE_PICT
             @see #PICTURE_TYPE_JPEG
             @see #PICTURE_TYPE_PNG
             @see #PICTURE_TYPE_DIB
        </member>
        <member name="M:NPOI.SS.UserModel.Workbook.GetAllPictures">
             Gets all pictures from the Workbook.
            
             @return the list of pictures (a list of {@link PictureData} objects.)
        </member>
        <member name="M:NPOI.SS.UserModel.Workbook.GetCreationHelper">
            Returns an object that handles instantiating concrete
            classes of the various instances one needs for  HSSF and XSSF.
        </member>
        <member name="P:NPOI.SS.UserModel.Workbook.IsHidden">
            @return <code>false</code> if this workbook is not visible in the GUI
        </member>
        <member name="M:NPOI.SS.UserModel.Workbook.IsSheetHidden(System.Int32)">
            Check whether a sheet is hidden.
            <p>
            Note that a sheet could instead be set to be very hidden, which is different
             ({@link #isSheetVeryHidden(int)})
            </p>
            @param sheetIx Number
            @return <code>true</code> if sheet is hidden
        </member>
        <member name="M:NPOI.SS.UserModel.Workbook.IsSheetVeryHidden(System.Int32)">
            Check whether a sheet is very hidden.
            <p>
            This is different from the normal hidden status
             ({@link #isSheetHidden(int)})
            </p>
            @param sheetIx sheet index to check
            @return <code>true</code> if sheet is very hidden
        </member>
        <member name="M:NPOI.SS.UserModel.Workbook.SetSheetHidden(System.Int32,System.Boolean)">
             Hide or unhide a sheet
            
             @param sheetIx the sheet index (0-based)
             @param hidden True to mark the sheet as hidden, false otherwise
        </member>
        <member name="M:NPOI.SS.UserModel.Workbook.SetSheetHidden(System.Int32,System.Int32)">
            Hide or unhide a sheet.
            <pre>
             0 = not hidden
             1 = hidden
             2 = very hidden.
            </pre>
            @param sheetIx The sheet number
            @param hidden 0 for not hidden, 1 for hidden, 2 for very hidden
        </member>
        <member name="F:NPOI.SS.Util.AreaReference.SHEET_NAME_DELIMITER">
            The Char (!) that Separates sheet names from cell references 
        </member>
        <member name="F:NPOI.SS.Util.AreaReference.CELL_DELIMITER">
            The Char (:) that Separates the two cell references in a multi-cell area reference 
        </member>
        <member name="F:NPOI.SS.Util.AreaReference.SPECIAL_NAME_DELIMITER">
            The Char (') used to quote sheet names when they contain special Chars 
        </member>
        <member name="M:NPOI.SS.Util.AreaReference.#ctor(System.String)">
            Create an area ref from a string representation.  Sheet names containing special Chars should be
            delimited and escaped as per normal syntax rules for formulas.<br/> 
            The area reference must be contiguous (i.e. represent a single rectangle, not a Union of rectangles)
        </member>
        <member name="M:NPOI.SS.Util.AreaReference.#ctor(NPOI.SS.Util.CellReference,NPOI.SS.Util.CellReference)">
            Creates an area ref from a pair of Cell References.
        </member>
        <member name="M:NPOI.SS.Util.AreaReference.IsContiguous(System.String)">
            is the reference for a contiguous (i.e.
             Unbroken) area, or is it made up of
             several different parts?
            (If it Is, you will need to call
             ....
        </member>
        <member name="M:NPOI.SS.Util.AreaReference.IsWholeColumnReference(NPOI.SS.Util.CellReference,NPOI.SS.Util.CellReference)">
            is the reference for a whole-column reference,
             such as C:C or D:G ?
        </member>
        <member name="M:NPOI.SS.Util.AreaReference.GenerateContiguous(System.String)">
            Takes a non-contiguous area reference, and
             returns an array of contiguous area references.
        </member>
        <member name="P:NPOI.SS.Util.AreaReference.IsSingleCell">
            @return <c>false</c> if this area reference involves more than one cell
        </member>
        <member name="P:NPOI.SS.Util.AreaReference.FirstCell">
            @return the first cell reference which defines this area. Usually this cell is in the upper
            left corner of the area (but this is not a requirement).
        </member>
        <member name="P:NPOI.SS.Util.AreaReference.LastCell">
            Note - if this area reference refers to a single cell, the return value of this method will
            be identical to that of <tt>GetFirstCell()</tt>
            @return the second cell reference which defines this area.  For multi-cell areas, this is 
            cell diagonally opposite the 'first cell'.  Usually this cell is in the lower right corner 
            of the area (but this is not a requirement).
        </member>
        <member name="M:NPOI.SS.Util.AreaReference.GetAllReferencedCells">
            Returns a reference to every cell covered by this area
        </member>
        <!-- Badly formed XML comment ignored for member "M:NPOI.SS.Util.AreaReference.FormatAsString" -->
        <member name="M:NPOI.SS.Util.AreaReference.SeparateAreaRefs(System.String)">
            Separates Area refs in two parts and returns them as Separate elements in a String array,
            each qualified with the sheet name (if present)
            
            @return array with one or two elements. never <c>null</c>
        </member>
        <member name="T:NPOI.SS.Util.CellRangeAddressBase">
            See OOO documentation: excelfileformat.pdf sec 2.5.14 - 'Cell Range Address'<p/>
            
            Common subclass of 8-bit and 16-bit versions
            
            @author Josh Micich
        </member>
        <member name="F:NPOI.SS.Util.CellRangeAddressBase.LAST_ROW_INDEX">
            max 65536 rows in BIFF8 
        </member>
        <member name="F:NPOI.SS.Util.CellRangeAddressBase.LAST_COLUMN_INDEX">
            max 256 columns in BIFF8 
        </member>
        <member name="P:NPOI.SS.Util.CellRangeAddressBase.FirstColumn">
            @return column number for the upper left hand corner
        </member>
        <member name="P:NPOI.SS.Util.CellRangeAddressBase.FirstRow">
            @return row number for the upper left hand corner
        </member>
        <member name="P:NPOI.SS.Util.CellRangeAddressBase.LastColumn">
            @return column number for the lower right hand corner
        </member>
        <member name="P:NPOI.SS.Util.CellRangeAddressBase.LastRow">
            @return row number for the lower right hand corner
        </member>
        <member name="F:NPOI.SS.Util.CellRangeAddressList._list">
            List of <tt>CellRangeAddress</tt>es. Each structure represents a cell range
        </member>
        <member name="M:NPOI.SS.Util.CellRangeAddressList.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            Convenience constructor for creating a <tt>CellRangeAddressList</tt> with a single 
            <tt>CellRangeAddress</tt>.  Other <tt>CellRangeAddress</tt>es may be Added later.
        </member>
        <member name="M:NPOI.SS.Util.CellRangeAddressList.#ctor(NPOI.HSSF.Record.RecordInputStream)">
            @param in the RecordInputstream to read the record from
        </member>
        <member name="M:NPOI.SS.Util.CellRangeAddressList.CountRanges">
            Get the number of following ADDR structures. The number of this
            structures is automatically set when reading an Excel file and/or
            increased when you manually Add a new ADDR structure . This is the reason
            there isn't a set method for this field .
            
            @return number of ADDR structures
        </member>
        <member name="M:NPOI.SS.Util.CellRangeAddressList.AddCellRangeAddress(System.Int32,System.Int32,System.Int32,System.Int32)">
            Add a cell range structure.
            
            @param firstRow - the upper left hand corner's row
            @param firstCol - the upper left hand corner's col
            @param lastRow - the lower right hand corner's row
            @param lastCol - the lower right hand corner's col
            @return the index of this ADDR structure
        </member>
        <member name="M:NPOI.SS.Util.CellRangeAddressList.GetCellRangeAddress(System.Int32)">
            @return <tt>CellRangeAddress</tt> at the given index
        </member>
        <member name="M:NPOI.SS.Util.CellRangeAddressList.GetEncodedSize(System.Int32)">
            @return the total size of for the specified number of ranges,
             including the initial 2 byte range count
        </member>
        <member name="T:NPOI.SS.Util.CellReference">
            
             @author  Avik Sengupta
             @author  Dennis doubleday (patch to seperateRowColumns())
        </member>
        <member name="F:NPOI.SS.Util.CellReference.ABSOLUTE_REFERENCE_MARKER">
            The character ($) that signifies a row or column value is absolute instead of relative 
        </member>
        <member name="F:NPOI.SS.Util.CellReference.SHEET_NAME_DELIMITER">
            The character (!) that Separates sheet names from cell references 
        </member>
        <member name="F:NPOI.SS.Util.CellReference.SPECIAL_NAME_DELIMITER">
            The character (') used to quote sheet names when they contain special characters 
        </member>
        <member name="F:NPOI.SS.Util.CellReference.CELL_REF_PATTERN">
            Matches a run of one or more letters followed by a run of one or more digits.
            The run of letters is group 1 and the run of digits is group 2.  
            Each group may optionally be prefixed with a single '$'.
        </member>
        <member name="F:NPOI.SS.Util.CellReference.COLUMN_REF_PATTERN">
            Matches a run of one or more letters.  The run of letters is group 1.  
            The text may optionally be prefixed with a single '$'.
        </member>
        <member name="F:NPOI.SS.Util.CellReference.ROW_REF_PATTERN">
            Matches a run of one or more digits.  The run of digits is group 1.
            The text may optionally be prefixed with a single '$'.
        </member>
        <member name="F:NPOI.SS.Util.CellReference.NAMED_RANGE_NAME_PATTERN">
            Named range names must start with a letter or underscore.  Subsequent characters may include
            digits or dot.  (They can even end in dot).
        </member>
        <member name="M:NPOI.SS.Util.CellReference.#ctor(System.String)">
            Create an cell ref from a string representation.  Sheet names containing special characters should be
            delimited and escaped as per normal syntax rules for formulas.
        </member>
        <member name="P:NPOI.SS.Util.CellReference.SheetName">
            @return possibly <c>null</c> if this is a 2D reference.  Special characters are not
            escaped or delimited
        </member>
        <member name="M:NPOI.SS.Util.CellReference.ConvertColStringToIndex(System.String)">
            takes in a column reference portion of a CellRef and converts it from
            ALPHA-26 number format to 0-based base 10.
            'A' -> 0
            'Z' -> 25
            'AA' -> 26
            'IV' -> 255
            @return zero based column index
        </member>
        <member name="M:NPOI.SS.Util.CellReference.ConvertNumToColString(System.Int32)">
            Takes in a 0-based base-10 column and returns a ALPHA-26
             representation.
            eg column #3 -> D
        </member>
        <member name="M:NPOI.SS.Util.CellReference.SeparateRefParts(System.String)">
            Separates the row from the columns and returns an array of three Strings.  The first element
            is the sheet name. Only the first element may be null.  The second element in is the column 
            name still in ALPHA-26 number format.  The third element is the row.
        </member>
        <member name="M:NPOI.SS.Util.CellReference.FormatAsString">
             Example return values:
               <table border="0" cellpAdding="1" cellspacing="0" summary="Example return values">
                 <tr><th align='left'>Result</th><th align='left'>Comment</th></tr>
                 <tr><td>A1</td><td>Cell reference without sheet</td></tr>
                 <tr><td>Sheet1!A1</td><td>Standard sheet name</td></tr>
                 <tr><td>'O''Brien''s Sales'!A1'</td><td>Sheet name with special characters</td></tr>
               </table>
            @return the text representation of this cell reference as it would appear in a formula.
        </member>
        <member name="P:NPOI.SS.Util.CellReference.CellRefParts">
            Returns the three parts of the cell reference, the
             Sheet name (or null if none supplied), the 1 based
             row number, and the A based column letter.
            This will not include any markers for absolute
             references, so use {@link #formatAsString()}
             to properly turn references into strings. 
        </member>
        <member name="M:NPOI.SS.Util.CellReference.AppendCellReference(System.Text.StringBuilder)">
            Appends cell reference with '$' markers for absolute values as required.
            Sheet name is not included.
        </member>
        <!-- Badly formed XML comment ignored for member "M:NPOI.SS.Util.CellReference.CellReferenceIsWithinRange(System.String,System.String,NPOI.SS.SpreadsheetVersion)" -->
        <member name="T:NPOI.SS.Util.FormatBase">
            <summary>
            A substitute class for Format class in Java
            </summary>
        </member>
        <member name="T:NPOI.SS.Util.SSNFormat">
             Format class for Excel's SSN Format. This class mimics Excel's built-in
             SSN Formatting.
            
             @author James May
        </member>
        <member name="M:NPOI.SS.Util.SSNFormat.Format(System.Object)">
            Format a number as an SSN 
        </member>
        <member name="T:NPOI.SS.Util.ZipPlusFourFormat">
            Format class for Excel Zip + 4 Format. This class mimics Excel's
            built-in Formatting for Zip + 4.
            @author James May
        </member>
        <member name="M:NPOI.SS.Util.ZipPlusFourFormat.Format(System.Object)">
            Format a number as Zip + 4 
        </member>
        <member name="T:NPOI.SS.Util.PhoneFormat">
            Format class for Excel phone number Format. This class mimics Excel's
            built-in phone number Formatting.
            @author James May
        </member>
        <member name="M:NPOI.SS.Util.PhoneFormat.Format(System.Object)">
            Format a number as a phone number 
        </member>
        <member name="F:NPOI.SS.Util.IEEEDouble.BIASED_EXPONENT_SPECIAL_VALUE">
            The value the exponent field Gets for all <i>NaN</i> and <i>InfInity</i> values
        </member>
        <member name="M:NPOI.SS.Util.IEEEDouble.GetBiasedExponent(System.Int64)">
            @param rawBits the 64 bit binary representation of the double value
            @return the top 12 bits (sign and biased exponent value)
        </member>
        <member name="T:NPOI.SS.Util.PaneInformation">
             Holds information regarding a split plane or freeze plane for a sheet.
            
        </member>
        <member name="F:NPOI.SS.Util.PaneInformation.PANE_LOWER_RIGHT">
            Constant for active pane being the lower right
        </member>
        <member name="F:NPOI.SS.Util.PaneInformation.PANE_UPPER_RIGHT">
            Constant for active pane being the upper right
        </member>
        <member name="F:NPOI.SS.Util.PaneInformation.PANE_LOWER_LEFT">
            Constant for active pane being the lower left
        </member>
        <member name="F:NPOI.SS.Util.PaneInformation.PANE_UPPER_LEFT">
            Constant for active pane being the upper left
        </member>
        <member name="P:NPOI.SS.Util.PaneInformation.VerticalSplitPosition">
            Returns the vertical position of the split.
            @return 0 if there is no vertical spilt,
                    or for a freeze pane the number of columns in the TOP pane,
                    or for a split plane the position of the split in 1/20th of a point.
        </member>
        <member name="P:NPOI.SS.Util.PaneInformation.HorizontalSplitPosition">
            Returns the horizontal position of the split.
            @return 0 if there is no horizontal spilt,
                    or for a freeze pane the number of rows in the LEFT pane,
                    or for a split plane the position of the split in 1/20th of a point.
        </member>
        <member name="P:NPOI.SS.Util.PaneInformation.HorizontalSplitTopRow">
            For a horizontal split returns the top row in the BOTTOM pane.
            @return 0 if there is no horizontal split, or the top row of the bottom pane.
        </member>
        <member name="P:NPOI.SS.Util.PaneInformation.VerticalSplitLeftColumn">
            For a vertical split returns the left column in the RIGHT pane.
            @return 0 if there is no vertical split, or the left column in the RIGHT pane.
        </member>
        <member name="P:NPOI.SS.Util.PaneInformation.ActivePane">
            Returns the active pane
            @see #PANE_LOWER_RIGHT
            @see #PANE_UPPER_RIGHT
            @see #PANE_LOWER_LEFT
            @see #PANE_UPPER_LEFT
            @return the active pane.
        </member>
        <member name="M:NPOI.SS.Util.PaneInformation.IsFreezePane">
            Returns true if this is a Freeze pane, false if it is a split pane.
        </member>
        <member name="T:NPOI.SS.Util.Region">
             Represents a from/to row/col square.  This is a object primitive
             that can be used to represent row,col - row,col just as one would use String
             to represent a string of characters.  Its really only useful for HSSF though.
            
             @author  Andrew C. Oliver acoliver at apache dot org
        </member>
        <member name="M:NPOI.SS.Util.Region.#ctor">
            Creates a new instance of Region (0,0 - 0,0)
        </member>
        <member name="P:NPOI.SS.Util.Region.ColumnFrom">
             Get the upper left hand corner column number
            
             @return column number for the upper left hand corner
        </member>
        <member name="P:NPOI.SS.Util.Region.RowFrom">
             Get the upper left hand corner row number
            
             @return row number for the upper left hand corner
        </member>
        <member name="P:NPOI.SS.Util.Region.ColumnTo">
             Get the lower right hand corner column number
            
             @return column number for the lower right hand corner
        </member>
        <member name="P:NPOI.SS.Util.Region.RowTo">
             Get the lower right hand corner row number
            
             @return row number for the lower right hand corner
        </member>
        <member name="M:NPOI.SS.Util.Region.ConvertCellRangesToRegions(NPOI.SS.Util.CellRangeAddress[])">
            Convert a List of CellRange objects to an array of regions 
             
            @param List of CellRange objects
            @return regions
        </member>
        <member name="T:NPOI.SS.Util.SheetReferences">
             Holds a collection of Sheet names and their associated
             reference numbers.
            
             @author Andrew C. Oliver (acoliver at apache dot org)
            
        </member>
        <member name="M:NPOI.Util.Arrays.Fill(System.Byte[],System.Byte)">
            <summary>
            Fills the specified array.
            </summary>
            <param name="array">The array.</param>
            <param name="defaultValue">The default value.</param>
        </member>
        <member name="M:NPOI.Util.Arrays.AsList(System.Array)">
            <summary>
            Convert Array to ArrayList
            </summary>
            <param name="arr">source array</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.Util.Arrays.Fill(System.Int32[],System.Byte)">
            <summary>
            Fills the specified array.
            </summary>
            <param name="array">The array.</param>
            <param name="defaultValue">The default value.</param>
        </member>
        <member name="M:NPOI.Util.Arrays.Equals(System.Object,System.Object)">
            <summary>
            Equals the specified a1.
            </summary>
            <param name="a1">The a1.</param>
            <param name="b1">The b1.</param>
            <returns></returns>
        </member>
        <member name="T:NPOI.Util.BitField">
            <summary>
            Manage operations dealing with bit-mapped fields.
            @author Marc Johnson (mjohnson at apache dot org)
            @author Andrew C. Oliver (acoliver at apache dot org)
            </summary>
        </member>
        <member name="M:NPOI.Util.BitField.#ctor(System.Int32)">
            <summary>
            Create a <see cref="T:NPOI.Util.BitField"/> instance
            </summary>
            <param name="mask">
            the mask specifying which bits apply to this
            BitField. Bits that are set in this mask are the
            bits that this BitField operates on
            </param>
        </member>
        <member name="M:NPOI.Util.BitField.#ctor(System.UInt32)">
            <summary>
            Create a <see cref="T:NPOI.Util.BitField"/> instance
            </summary>
            <param name="mask">
            the mask specifying which bits apply to this
            BitField. Bits that are set in this mask are the
            bits that this BitField operates on
            </param>
        </member>
        <member name="M:NPOI.Util.BitField.Clear(System.Int32)">
            <summary>
            Clear the bits.
            </summary>
            <param name="holder">the int data containing the bits we're interested in</param>
            <returns>the value of holder with the specified bits cleared (set to 0)</returns>
        </member>
        <member name="M:NPOI.Util.BitField.ClearShort(System.Int16)">
            <summary>
            Clear the bits.
            </summary>
            <param name="holder">the short data containing the bits we're interested in</param>
            <returns>the value of holder with the specified bits cleared (set to 0)</returns>
        </member>
        <member name="M:NPOI.Util.BitField.GetRawValue(System.Int32)">
            <summary>
            Obtain the value for the specified BitField, appropriately
            shifted right. Many users of a BitField will want to treat the
            specified bits as an int value, and will not want to be aware
            that the value is stored as a BitField (and so shifted left so
            many bits)
            </summary>
            <param name="holder">the int data containing the bits we're interested in</param>
            <returns>the selected bits, shifted right appropriately</returns>
        </member>
        <member name="M:NPOI.Util.BitField.GetShortRawValue(System.Int16)">
            <summary>
            Obtain the value for the specified BitField, unshifted
            </summary>
            <param name="holder">the short data containing the bits we're interested in</param>
            <returns>the selected bits</returns>
        </member>
        <member name="M:NPOI.Util.BitField.GetShortValue(System.Int16)">
            <summary>
            Obtain the value for the specified BitField, appropriately
            shifted right, as a short. Many users of a BitField will want
            to treat the specified bits as an int value, and will not want
            to be aware that the value is stored as a BitField (and so
            shifted left so many bits)
            </summary>
            <param name="holder">the short data containing the bits we're interested in</param>
            <returns>the selected bits, shifted right appropriately</returns>
        </member>
        <member name="M:NPOI.Util.BitField.GetValue(System.Int32)">
            <summary>
            Obtain the value for the specified BitField, appropriately
            shifted right. Many users of a BitField will want to treat the
            specified bits as an int value, and will not want to be aware
            that the value is stored as a BitField (and so shifted left so
            many bits)
            </summary>
            <param name="holder">the int data containing the bits we're interested in</param>
            <returns>the selected bits, shifted right appropriately</returns>
        </member>
        <member name="M:NPOI.Util.BitField.IsAllSet(System.Int32)">
            <summary>
            Are all of the bits set or not? This is a stricter test than
            isSet, in that all of the bits in a multi-bit set must be set
            for this method to return true
            </summary>
            <param name="holder">the int data containing the bits we're interested in</param>
            <returns>
            	<c>true</c> if all of the bits are set otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NPOI.Util.BitField.IsSet(System.Int32)">
            <summary>
            is the field set or not? This is most commonly used for a
            single-bit field, which is often used to represent a boolean
            value; the results of using it for a multi-bit field is to
            determine whether *any* of its bits are set
            </summary>
            <param name="holder">the int data containing the bits we're interested in</param>
            <returns>
            	<c>true</c> if any of the bits are set; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NPOI.Util.BitField.Set(System.Int32)">
            <summary>
            Set the bits.
            </summary>
            <param name="holder">the int data containing the bits we're interested in</param>
            <returns>the value of holder with the specified bits set to 1</returns>
        </member>
        <member name="M:NPOI.Util.BitField.SetBoolean(System.Int32,System.Boolean)">
            <summary>
            Set a boolean BitField
            </summary>
            <param name="holder">the int data containing the bits we're interested in</param>
            <param name="flag">indicating whether to set or clear the bits</param>
            <returns>the value of holder with the specified bits set or cleared</returns>
        </member>
        <member name="M:NPOI.Util.BitField.SetShort(System.Int16)">
            <summary>
            Set the bits.
            </summary>
            <param name="holder">the short data containing the bits we're interested in</param>
            <returns>the value of holder with the specified bits set to 1</returns>
        </member>
        <member name="M:NPOI.Util.BitField.SetShortBoolean(System.Int16,System.Boolean)">
            <summary>
            Set a boolean BitField
            </summary>
            <param name="holder">the short data containing the bits we're interested in</param>
            <param name="flag">indicating whether to set or clear the bits</param>
            <returns>the value of holder with the specified bits set or cleared</returns>
        </member>
        <member name="M:NPOI.Util.BitField.SetShortValue(System.Int16,System.Int16)">
            <summary>
            Obtain the value for the specified BitField, appropriately
            shifted right, as a short. Many users of a BitField will want
            to treat the specified bits as an int value, and will not want
            to be aware that the value is stored as a BitField (and so
            shifted left so many bits)
            </summary>
            <param name="holder">the short data containing the bits we're interested in</param>
            <param name="value">the new value for the specified bits</param>
            <returns>the selected bits, shifted right appropriately</returns>
        </member>
        <member name="M:NPOI.Util.BitField.SetValue(System.Int32,System.Int32)">
            <summary>
            Sets the value.
            </summary>
            <param name="holder">the byte data containing the bits we're interested in</param>
            <param name="value">The value.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.Util.BitField.SetByteBoolean(System.Byte,System.Boolean)">
            <summary>
            Set a boolean BitField
            </summary>
            <param name="holder"> the byte data containing the bits we're interested in</param>
            <param name="flag">indicating whether to set or clear the bits</param>
            <returns>the value of holder with the specified bits set or cleared</returns>
        </member>
        <member name="M:NPOI.Util.BitField.ClearByte(System.Byte)">
            <summary>
            Clears the bits.
            </summary>
            <param name="holder">the byte data containing the bits we're interested in</param>
            <returns>the value of holder with the specified bits cleared</returns>
        </member>
        <member name="M:NPOI.Util.BitField.SetByte(System.Byte)">
            <summary>
            Set the bits.
            </summary>
            <param name="holder">the byte data containing the bits we're interested in</param>
            <returns>the value of holder with the specified bits set to 1</returns>
        </member>
        <member name="T:NPOI.Util.BitFieldFactory">
            <summary>
            Returns immutable Btfield instances.
            @author Jason Height (jheight at apache dot org)
            </summary>
        </member>
        <member name="M:NPOI.Util.BitFieldFactory.GetInstance(System.Int32)">
            <summary>
            Gets the instance.
            </summary>
            <param name="mask">The mask.</param>
            <returns></returns>
        </member>
        <member name="T:NPOI.Util.ByteField">
            <summary>
            representation of a byte (8-bit) field at a fixed location within a
            byte array
            @author Marc Johnson (mjohnson at apache dot org    
            </summary>
        </member>
        <member name="M:NPOI.Util.ByteField.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.Util.ByteField"/> class.
            </summary>
            <param name="offset">The offset.</param>
        </member>
        <member name="M:NPOI.Util.ByteField.#ctor(System.Int32,System.Byte)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.Util.ByteField"/> class.
            </summary>
            <param name="offset">The offset.</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:NPOI.Util.ByteField.#ctor(System.Int32,System.Byte[])">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.Util.ByteField"/> class.
            </summary>
            <param name="offset">The offset.</param>
            <param name="data">The data.</param>
        </member>
        <member name="M:NPOI.Util.ByteField.#ctor(System.Int32,System.Byte,System.Byte[])">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.Util.ByteField"/> class.
            </summary>
            <param name="offset">The offset.</param>
            <param name="_value">The _value.</param>
            <param name="data">The data.</param>
        </member>
        <member name="P:NPOI.Util.ByteField.Value">
            <summary>
            Gets or sets the value.
            </summary>
            <value>The value.</value>
        </member>
        <member name="M:NPOI.Util.ByteField.ReadFromBytes(System.Byte[])">
            <summary>
            set the value from its offset into an array of bytes
            </summary>
            <param name="data">the byte array from which the value is to be read</param>
        </member>
        <member name="M:NPOI.Util.ByteField.ReadFromStream(System.IO.Stream)">
            <summary>
            set the value from an Stream
            </summary>
            <param name="stream">the Stream from which the value is to be read</param>
        </member>
        <member name="M:NPOI.Util.ByteField.Set(System.Byte,System.Byte[])">
            <summary>
            set the ByteField's current value and write it to a byte array
            </summary>
            <param name="value">value to be set</param>
            <param name="data">the byte array to write the value to</param>
        </member>
        <member name="M:NPOI.Util.ByteField.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="M:NPOI.Util.ByteField.WriteToBytes(System.Byte[])">
            <summary>
            write the value out to an array of bytes at the appropriate offset
            </summary>
            <param name="data">the array of bytes to which the value is to be written</param>
        </member>
        <member name="T:NPOI.Util.ClassID">
            <summary>
            Represents a class ID (16 bytes). Unlike other little-endian
            type the {@link ClassID} is not just 16 bytes stored in the wrong
            order. Instead, it is a double word (4 bytes) followed by two
            words (2 bytes each) followed by 8 bytes.
            @author Rainer Klute 
            <a href="mailto:klute@rainer-klute.de">klute@rainer-klute.de</a>
            @version $Id: ClassID.java 489730 2006-12-22 19:18:16Z bayard $
            @since 2002-02-09
            </summary>
        </member>
        <member name="F:NPOI.Util.ClassID.bytes">
            The bytes making out the class ID in correct order,
            i.e. big-endian.
        </member>
        <member name="M:NPOI.Util.ClassID.#ctor(System.Byte[],System.Int32)">
            <summary>
            Creates a <see cref="T:NPOI.Util.ClassID"/> and Reads its value from a byte array.
            </summary>
            <param name="src">The byte array to Read from.</param>
            <param name="offset">The offset of the first byte to Read.</param>
        </member>
        <member name="M:NPOI.Util.ClassID.#ctor">
            <summary>
            Creates a <see cref="T:NPOI.Util.ClassID"/> and initializes its value with 0x00 bytes.
            </summary>
        </member>
        <member name="F:NPOI.Util.ClassID.LENGTH">
            The number of bytes occupied by this object in the byte
            stream. 
        </member>
        <member name="P:NPOI.Util.ClassID.Length">
            <summary>
            Gets the length.
            </summary>
            <value>The number of bytes occupied by this object in the byte stream.</value>
        </member>
        <member name="P:NPOI.Util.ClassID.Bytes">
            <summary>
            Gets or sets the bytes making out the class ID. They are returned in correct order, i.e. big-endian.
            </summary>
            <value>the bytes making out the class ID..</value>
        </member>
        <member name="M:NPOI.Util.ClassID.Read(System.Byte[],System.Int32)">
            <summary>
            Reads the class ID's value from a byte array by turning little-endian into big-endian.
            </summary>
            <param name="src">The byte array to Read from</param>
            <param name="offset">The offset within the </param>
            <returns>A byte array containing the class ID.</returns>
        </member>
        <member name="M:NPOI.Util.ClassID.Write(System.Byte[],System.Int32)">
            <summary>
            Writes the class ID to a byte array in the little-endian format.
            </summary>
            <param name="dst">The byte array to Write to.</param>
            <param name="offset">The offset within the </param>
        </member>
        <member name="M:NPOI.Util.ClassID.Equals(System.Object)">
            <summary>
            Checks whether this ClassID is equal to another
            object.
            </summary>
            <param name="o">the object to compare this PropertySet with</param>
            <returns>true if the objects are equal, else
            false</returns>
        </member>
        <member name="M:NPOI.Util.ClassID.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="M:NPOI.Util.ClassID.ToString">
            <summary>
            Returns a human-Readable representation of the Class ID in standard
            format <c>"{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}"</c>.
            </summary>
            <returns>
            A String representation of the Class ID represented by this object..
            </returns>
        </member>
        <member name="T:NPOI.Util.Collections.HashSet">
            <summary>
            This class comes from Java
            </summary>
        </member>
        <member name="M:NPOI.Util.Collections.HashSet.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.Util.Collections.HashSet"/> class.
            </summary>
        </member>
        <member name="M:NPOI.Util.Collections.HashSet.#ctor(NPOI.Util.Collections.ISet)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.Util.Collections.HashSet"/> class.
            </summary>
            <param name="s">The s.</param>
        </member>
        <member name="M:NPOI.Util.Collections.HashSet.Add(System.Object)">
            <summary>
            Adds the specified o.
            </summary>
            <param name="o">The o.</param>
        </member>
        <member name="M:NPOI.Util.Collections.HashSet.Contains(System.Object)">
            <summary>
            Determines whether [contains] [the specified o].
            </summary>
            <param name="o">The o.</param>
            <returns>
            	<c>true</c> if [contains] [the specified o]; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NPOI.Util.Collections.HashSet.CopyTo(System.Array,System.Int32)">
            <summary>
            Copies the elements of the <see cref="T:System.Collections.ICollection"/> to an <see cref="T:System.Array"/>, starting at a particular <see cref="T:System.Array"/> index.
            </summary>
            <param name="array">The one-dimensional <see cref="T:System.Array"/> that is the destination of the elements copied from <see cref="T:System.Collections.ICollection"/>. The <see cref="T:System.Array"/> must have zero-based indexing.</param>
            <param name="index">The zero-based index in <paramref name="array"/> at which copying begins.</param>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="array"/> is null.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="index"/> is less than zero.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="array"/> is multidimensional.
            -or-
            <paramref name="index"/> is equal to or greater than the length of <paramref name="array"/>.
            -or-
            The number of elements in the source <see cref="T:System.Collections.ICollection"/> is greater than the available space from <paramref name="index"/> to the end of the destination <paramref name="array"/>.
            </exception>
            <exception cref="T:System.ArgumentException">
            The type of the source <see cref="T:System.Collections.ICollection"/> cannot be cast automatically to the type of the destination <paramref name="array"/>.
            </exception>
        </member>
        <member name="P:NPOI.Util.Collections.HashSet.Count">
            <summary>
            Gets the number of elements contained in the <see cref="T:System.Collections.ICollection"/>.
            </summary>
            <value></value>
            <returns>
            The number of elements contained in the <see cref="T:System.Collections.ICollection"/>.
            </returns>
        </member>
        <member name="M:NPOI.Util.Collections.HashSet.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="P:NPOI.Util.Collections.HashSet.IsSynchronized">
            <summary>
            Gets a value indicating whether access to the <see cref="T:System.Collections.ICollection"/> is synchronized (thread safe).
            </summary>
            <value></value>
            <returns>true if access to the <see cref="T:System.Collections.ICollection"/> is synchronized (thread safe); otherwise, false.
            </returns>
        </member>
        <member name="M:NPOI.Util.Collections.HashSet.Remove(System.Object)">
            <summary>
            Removes the specified o.
            </summary>
            <param name="o">The o.</param>
        </member>
        <member name="P:NPOI.Util.Collections.HashSet.SyncRoot">
            <summary>
            Gets an object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection"/>.
            </summary>
            <value></value>
            <returns>
            An object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection"/>.
            </returns>
        </member>
        <member name="T:NPOI.Util.Collections.IntMapper">
            <summary>
            A List of objects that are indexed AND keyed by an int; also allows for getting
            the index of a value in the list
            I am happy is someone wants to re-implement this without using the
            internal list and hashmap. If so could you please make sure that
            you can add elements half way into the list and have the value-key mappings
            update
            @author Jason Height
            </summary>
        </member>
        <member name="M:NPOI.Util.Collections.IntMapper.#ctor">
            <summary>
            create an IntMapper of default size
            </summary>
        </member>
        <member name="M:NPOI.Util.Collections.IntMapper.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.Util.Collections.IntMapper"/> class.
            </summary>
            <param name="initialCapacity">The initial capacity.</param>
        </member>
        <member name="M:NPOI.Util.Collections.IntMapper.Add(System.Object)">
            <summary>
            Appends the specified element to the end of this list
            @param value element to be appended to this list.
            @return true (as per the general contract of the Collection.add
            method).
            </summary>
            <param name="value">The value.</param>
            <returns></returns>
        </member>
        <member name="P:NPOI.Util.Collections.IntMapper.Size">
            <summary>
            Gets the size.
            </summary>
            <value>The size.</value>
        </member>
        <member name="P:NPOI.Util.Collections.IntMapper.Item(System.Int32)">
            <summary>
            Gets the <see cref="T:System.Object"/> at the specified index.
            </summary>
            <value></value>
        </member>
        <member name="M:NPOI.Util.Collections.IntMapper.GetIndex(System.Object)">
            <summary>
            Gets the index.
            </summary>
            <param name="o">The o.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.Util.Collections.IntMapper.GetEnumerator">
            <summary>
            Gets the enumerator.
            </summary>
            <returns></returns>
        </member>
        <member name="T:NPOI.Util.Collections.ISet">
            <summary>
            This interface comes from Java
            </summary>
        </member>
        <member name="M:NPOI.Util.Collections.ISet.Add(System.Object)">
            <summary>
            Adds the specified o.
            </summary>
            <param name="o">The o.</param>
        </member>
        <member name="M:NPOI.Util.Collections.ISet.Contains(System.Object)">
            <summary>
            Determines whether [contains] [the specified o].
            </summary>
            <param name="o">The o.</param>
            <returns>
            	<c>true</c> if [contains] [the specified o]; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NPOI.Util.Collections.ISet.Remove(System.Object)">
            <summary>
            Removes the specified o.
            </summary>
            <param name="o">The o.</param>
        </member>
        <member name="T:NPOI.Util.Collections.Properties">
            <summary>
            This class comes from Java
            </summary>
        </member>
        <member name="M:NPOI.Util.Collections.Properties.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.Util.Collections.Properties"/> class.
            </summary>
        </member>
        <member name="M:NPOI.Util.Collections.Properties.Remove(System.String)">
            <summary>
            Removes the specified key.
            </summary>
            <param name="key">The key.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.Util.Collections.Properties.GetEnumerator">
            <summary>
            Gets the enumerator.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NPOI.Util.Collections.Properties.ContainsKey(System.String)">
            <summary>
            Determines whether the specified key contains key.
            </summary>
            <param name="key">The key.</param>
            <returns>
            	<c>true</c> if the specified key contains key; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NPOI.Util.Collections.Properties.Add(System.String,System.String)">
            <summary>
            Adds the specified key.
            </summary>
            <param name="key">The key.</param>
            <param name="value">The value.</param>
        </member>
        <member name="P:NPOI.Util.Collections.Properties.Count">
            <summary>
            Gets the count.
            </summary>
            <value>The count.</value>
        </member>
        <member name="P:NPOI.Util.Collections.Properties.Item(System.String)">
            <summary>
            Gets or sets the <see cref="T:System.String"/> with the specified key.
            </summary>
            <value></value>
        </member>
        <member name="P:NPOI.Util.Collections.Properties.Keys">
            <summary>
            Gets the keys.
            </summary>
            <value>The keys.</value>
        </member>
        <member name="M:NPOI.Util.Collections.Properties.Clear">
            <summary>
            Clears this instance.
            </summary>
        </member>
        <member name="M:NPOI.Util.Collections.Properties.Load(System.IO.Stream)">
            <summary>
            Loads the specified in stream.
            </summary>
            <param name="inStream">The in stream.</param>
        </member>
        <member name="M:NPOI.Util.Collections.Properties.LoadConvert(System.String)">
            <summary>
            Loads the convert.
            </summary>
            <param name="theString">The string.</param>
            <returns></returns>
            <remarks>
            Converts encoded &#92;uxxxx to unicode chars
            and changes special saved chars to their original forms
            </remarks>
        </member>
        <member name="M:NPOI.Util.Collections.Properties.ContinueLine(System.String)">
            <summary>
            Continues the line.
            </summary>
            <param name="line">The line.</param>
            <returns></returns>
        </member>
        <member name="T:NPOI.Util.CRC32">
            <summary>
            CRC Verification
            </summary>
        </member>
        <member name="M:NPOI.Util.CRC32.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.Util.CRC32"/> class.
            </summary>
        </member>
        <member name="M:NPOI.Util.CRC32.ByteCRC(System.Byte[]@)">
            <summary>
             CRC Bytes.
            </summary>
            <param name="buffer">The buffer.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.Util.CRC32.StringCRC(System.String)">
            <summary>
            String CRC
            </summary>
            <param name="sInputString">the string</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.Util.CRC32.FileCRC(System.String)">
            <summary>
            File CRC
            </summary>
            <param name="sInputFilename">the input file</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.Util.CRC32.StreamCRC(System.IO.Stream)">
            <summary>
            Stream CRC
            </summary>
            <param name="sInputFilename">the input stream</param>
            <returns></returns>
        </member>
        <member name="T:NPOI.Util.FixedField">
            <summary>
            behavior of a field at a fixed location within a byte array
            @author Marc Johnson (mjohnson at apache dot org
            </summary>
        </member>
        <member name="M:NPOI.Util.FixedField.ReadFromBytes(System.Byte[])">
            <summary>
            set the value from its offset into an array of bytes
            </summary>
            <param name="data">the byte array from which the value is to be read</param>
        </member>
        <member name="M:NPOI.Util.FixedField.ReadFromStream(System.IO.Stream)">
            <summary>
            set the value from an Stream
            </summary>
            <param name="stream">the Stream from which the value is to be read</param>
        </member>
        <member name="M:NPOI.Util.FixedField.ToString">
            <summary>
            return the value as a String
            </summary>
            <returns></returns>
        </member>
        <member name="M:NPOI.Util.FixedField.WriteToBytes(System.Byte[])">
            <summary>
            write the value out to an array of bytes at the appropriate offset
            </summary>
            <param name="data">the array of bytes to which the value is to be written</param>
        </member>
        <member name="T:NPOI.Util.HexDump">
            <summary>
            dump data in hexadecimal format; derived from a HexDump utility I
            wrote in June 2001.
            @author Marc Johnson
            @author Glen Stampoultzis  (glens at apache.org)
            </summary>
        </member>
        <member name="M:NPOI.Util.HexDump.ShortToHex(System.Int32)">
            <summary>
            Shorts to hex.
            </summary>
            <param name="value">The value.</param>
            <returns>char array of 2 (zero padded) uppercase hex chars and prefixed with '0x'</returns>
        </member>
        <member name="M:NPOI.Util.HexDump.ByteToHex(System.Int32)">
            <summary>
            Bytes to hex.
            </summary>
            <param name="value">The value.</param>
            <returns>char array of 1 (zero padded) uppercase hex chars and prefixed with '0x'</returns>
        </member>
        <member name="M:NPOI.Util.HexDump.IntToHex(System.Int32)">
            <summary>
            Ints to hex.
            </summary>
            <param name="value">The value.</param>
            <returns>char array of 4 (zero padded) uppercase hex chars and prefixed with '0x'</returns>
        </member>
        <member name="M:NPOI.Util.HexDump.LongToHex(System.Int64)">
            <summary>
            char array of 4 (zero padded) uppercase hex chars and prefixed with '0x'
            </summary>
            <param name="value">The value.</param>
            <returns>char array of 4 (zero padded) uppercase hex chars and prefixed with '0x'</returns>
        </member>
        <member name="M:NPOI.Util.HexDump.ToHexChars(System.Int64,System.Int32)">
            <summary>
            Toes the hex chars.
            </summary>
            <param name="pValue">The p value.</param>
            <param name="nBytes">The n bytes.</param>
            <returns>char array of uppercase hex chars, zero padded and prefixed with '0x'</returns>
        </member>
        <member name="M:NPOI.Util.HexRead.ReadData(System.String)">
            <summary>
            This method reads hex data from a filename and returns a byte array.
            The file may contain line comments that are preceeded with a # symbol.
            </summary>
            <param name="filename">The filename to read</param>
            <returns>The bytes read from the file.</returns>
            <exception cref="T:System.IO.IOException">If there was a problem while reading the file.</exception>
        </member>
        <member name="M:NPOI.Util.HexRead.ReadData(System.IO.Stream,System.String)">
            <summary>
            Same as ReadData(String) except that this method allows you to specify sections within
            a file.  Sections are referenced using section headers in the form:
            </summary>
            <param name="stream">The stream.</param>
            <param name="section">The section.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.Util.HexRead.ReadData(System.String,System.String)">
            <summary>
            Reads the data.
            </summary>
            <param name="filename">The filename.</param>
            <param name="section">The section.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.Util.HexRead.ReadData(System.IO.Stream,System.Int32)">
            <summary>
            Reads the data.
            </summary>
            <param name="stream">The stream.</param>
            <param name="eofChar">The EOF char.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.Util.HexRead.ReadFromString(System.String)">
            <summary>
            Reads from string.
            </summary>
            <param name="data">The data.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.Util.HexRead.ReadToEOL(System.IO.Stream)">
            <summary>
            Reads to EOL.
            </summary>
            <param name="stream">The stream.</param>
        </member>
        <member name="M:NPOI.Util.IntegerField.#ctor(System.Int32)">
            <summary>
            construct the <see cref="T:NPOI.Util.IntegerField"/> with its offset into its containing byte array  class.
            </summary>
            <param name="offset">offset of the field within its byte array.</param>
        </member>
        <member name="M:NPOI.Util.IntegerField.#ctor(System.Int32,System.Int32)">
            <summary>
            construct the <see cref="T:NPOI.Util.IntegerField"/> with its offset into its containing
            byte array and initialize its value
            </summary>
            <param name="offset">offset of the field within its byte array</param>
            <param name="value">the initial value</param>
        </member>
        <member name="M:NPOI.Util.IntegerField.#ctor(System.Int32,System.Byte[])">
            <summary>
            Construct the <see cref="T:NPOI.Util.IntegerField"/> with its offset into its containing
            byte array and initialize its value from its byte array
            </summary>
            <param name="offset">offset of the field within its byte array</param>
            <param name="data">the byte array to Read the value from</param>
        </member>
        <member name="M:NPOI.Util.IntegerField.#ctor(System.Int32,System.Int32,System.Byte[])">
            <summary>
            construct the <see cref="T:NPOI.Util.IntegerField"/> with its offset into its containing 
            byte array, initialize its value, and write the value to a byte
            </summary>
            <param name="offset">offset of the field within its byte array</param>
            <param name="value">the initial value</param>
            <param name="data">the byte array to write the value to</param>
        </member>
        <member name="P:NPOI.Util.IntegerField.Value">
            <summary>
            get or Set the IntegerField's current value
            </summary>
            <value>The value.</value>
            <returns></returns>
        </member>
        <member name="M:NPOI.Util.IntegerField.Set(System.Int32,System.Byte[])">
            <summary>
            Set the IntegerField's current value and write it to a byte array
            </summary>
            <param name="value">value to be Set</param>
            <param name="data">the byte array to write the value to</param>
        </member>
        <member name="M:NPOI.Util.IntegerField.ReadFromBytes(System.Byte[])">
            <summary>
            Set the value from its offset into an array of bytes
            </summary>
            <param name="data">The data.</param>
        </member>
        <member name="M:NPOI.Util.IntegerField.ReadFromStream(System.IO.Stream)">
            <summary>
            Set the value from an Stream
            </summary>
            <param name="stream">the Stream from which the value is to be Read</param>
        </member>
        <member name="M:NPOI.Util.IntegerField.WriteToBytes(System.Byte[])">
            <summary>
            write the value out to an array of bytes at the appropriate offset
            </summary>
            <param name="data"> the array of bytes to which the value is to be written </param>
        </member>
        <member name="M:NPOI.Util.IntegerField.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="T:NPOI.Util.IO.DelayableLittleEndianOutput">
            Implementors of this interface allow client code to 'delay' writing to a certain section of a 
            data output stream.<br/>
            A typical application is for writing BIFF records when the size is not known until well after
            the header has been written.  The client code can call {@link #createDelayedOutput(int)}
            to reserve two bytes of the output for the 'ushort size' header field.  The delayed output can
            be written at any stage. 
            
            @author Josh Micich
        </member>
        <member name="M:NPOI.Util.IO.DelayableLittleEndianOutput.CreateDelayedOutput(System.Int32)">
            Creates an output stream intended for outputting a sequence of <tt>size</tt> bytes.
        </member>
        <member name="M:NPOI.Util.IO.IOUtils.ToByteArray(System.IO.Stream)">
            <summary>
            Reads all the data from the input stream, and returns
            the bytes Read.
            </summary>
            <param name="stream">The stream.</param>
            <returns></returns>
            <remarks>Tony Qu changed the code</remarks>
        </member>
        <member name="M:NPOI.Util.IO.IOUtils.ReadFully(System.IO.Stream,System.Byte[])">
            <summary>
            Reads the fully.
            </summary>
            <param name="stream">The stream.</param>
            <param name="b">The b.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.Util.IO.IOUtils.ReadFully(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Same as the normal 
            <tt>in.Read(b, off, len)</tt>
            , but tries to ensure that the entire len number of bytes is Read.
            If the end of file is reached before any bytes are Read, returns -1.
            If the end of the file is reached after some bytes are
            Read, returns the number of bytes Read.
            If the end of the file isn't reached before len
            bytes have been Read, will return len bytes.
            </summary>
            <param name="stream">The stream.</param>
            <param name="b">The b.</param>
            <param name="off">The off.</param>
            <param name="len">The len.</param>
            <returns></returns>
        </member>
        <member name="T:NPOI.Util.IO.LittleEndianByteArrayInputStream">
            Adapts a plain byte array to {@link LittleEndianInput} 
            
            
            @author Josh Micich
        </member>
        <member name="T:NPOI.Util.IO.LittleEndianByteArrayOutputStream">
            Adapts a plain byte array to {@link LittleEndianOutput} 
            
            
            @author Josh Micich
        </member>
        <member name="T:NPOI.Util.IO.LittleEndianInput">
            
            @author Josh Micich
        </member>
        <member name="T:NPOI.Util.IO.LittleEndianInputStream">
            Wraps an {@link InputStream} providing {@link LittleEndianInput}<p/>
            
            This class does not buffer any input, so the stream Read position maintained 
            by this class is consistent with that of the inner stream.
            
            @author Josh Micich
        </member>
        <member name="T:NPOI.Util.IO.LittleEndianOutput">
            
            @author Josh Micich
        </member>
        <member name="T:NPOI.Util.IO.LittleEndianOutputStream">
            
            @author Josh Micich
        </member>
        <member name="M:NPOI.Util.IO.PushbackStream.ReadByte">
            <summary>
            Reads a byte from the stream and advances the position within the stream by one byte, or returns -1 if at the end of the stream.
            </summary>
            <returns>
            The unsigned byte cast to an Int32, or -1 if at the end of the stream.
            </returns>
            <exception cref="T:System.NotSupportedException">
            The stream does not support reading.
            </exception>
            <exception cref="T:System.ObjectDisposedException">
            Methods were called after the stream was closed.
            </exception>
        </member>
        <member name="M:NPOI.Util.IO.PushbackStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            When overridden in a derived class, reads a sequence of bytes from the current stream and advances the position within the stream by the number of bytes read.
            </summary>
            <param name="buffer">An array of bytes. When this method returns, the buffer contains the specified byte array with the values between <paramref name="offset"/> and (<paramref name="offset"/> + <paramref name="count"/> - 1) replaced by the bytes read from the current source.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at which to begin storing the data read from the current stream.</param>
            <param name="count">The maximum number of bytes to be read from the current stream.</param>
            <returns>
            The total number of bytes read into the buffer. This can be less than the number of bytes requested if that many bytes are not currently available, or zero (0) if the end of the stream has been reached.
            </returns>
            <exception cref="T:System.ArgumentException">
            The sum of <paramref name="offset"/> and <paramref name="count"/> is larger than the buffer length.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="buffer"/> is null.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="offset"/> or <paramref name="count"/> is negative.
            </exception>
            <exception cref="T:System.IO.IOException">
            An I/O error occurs.
            </exception>
            <exception cref="T:System.NotSupportedException">
            The stream does not support reading.
            </exception>
            <exception cref="T:System.ObjectDisposedException">
            Methods were called after the stream was closed.
            </exception>
        </member>
        <member name="M:NPOI.Util.IO.PushbackStream.Unread(System.Int32)">
            <summary>
            Unreads the specified b.
            </summary>
            <param name="b">The b.</param>
        </member>
        <member name="P:NPOI.Util.IO.PushbackStream.CanRead">
            <summary>
            When overridden in a derived class, gets a value indicating whether the current stream supports reading.
            </summary>
            <value></value>
            <returns>true if the stream supports reading; otherwise, false.
            </returns>
        </member>
        <member name="P:NPOI.Util.IO.PushbackStream.CanSeek">
            <summary>
            When overridden in a derived class, gets a value indicating whether the current stream supports seeking.
            </summary>
            <value></value>
            <returns>true if the stream supports seeking; otherwise, false.
            </returns>
        </member>
        <member name="P:NPOI.Util.IO.PushbackStream.CanWrite">
            <summary>
            When overridden in a derived class, gets a value indicating whether the current stream supports writing.
            </summary>
            <value></value>
            <returns>true if the stream supports writing; otherwise, false.
            </returns>
        </member>
        <member name="P:NPOI.Util.IO.PushbackStream.Length">
            <summary>
            When overridden in a derived class, gets the length in bytes of the stream.
            </summary>
            <value></value>
            <returns>
            A long value representing the length of the stream in bytes.
            </returns>
            <exception cref="T:System.NotSupportedException">
            A class derived from Stream does not support seeking.
            </exception>
            <exception cref="T:System.ObjectDisposedException">
            Methods were called after the stream was closed.
            </exception>
        </member>
        <member name="P:NPOI.Util.IO.PushbackStream.Position">
            <summary>
            When overridden in a derived class, gets or sets the position within the current stream.
            </summary>
            <value></value>
            <returns>
            The current position within the stream.
            </returns>
            <exception cref="T:System.IO.IOException">
            An I/O error occurs.
            </exception>
            <exception cref="T:System.NotSupportedException">
            The stream does not support seeking.
            </exception>
            <exception cref="T:System.ObjectDisposedException">
            Methods were called after the stream was closed.
            </exception>
        </member>
        <member name="M:NPOI.Util.IO.PushbackStream.Close">
            <summary>
            Closes the current stream and releases any resources (such as sockets and file handles) associated with the current stream.
            </summary>
        </member>
        <member name="M:NPOI.Util.IO.PushbackStream.Flush">
            <summary>
            When overridden in a derived class, clears all buffers for this stream and causes any buffered data to be written to the underlying device.
            </summary>
            <exception cref="T:System.IO.IOException">
            An I/O error occurs.
            </exception>
        </member>
        <member name="M:NPOI.Util.IO.PushbackStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            When overridden in a derived class, sets the position within the current stream.
            </summary>
            <param name="offset">A byte offset relative to the <paramref name="origin"/> parameter.</param>
            <param name="origin">A value of type <see cref="T:System.IO.SeekOrigin"/> indicating the reference point used to obtain the new position.</param>
            <returns>
            The new position within the current stream.
            </returns>
            <exception cref="T:System.IO.IOException">
            An I/O error occurs.
            </exception>
            <exception cref="T:System.NotSupportedException">
            The stream does not support seeking, such as if the stream is constructed from a pipe or console output.
            </exception>
            <exception cref="T:System.ObjectDisposedException">
            Methods were called after the stream was closed.
            </exception>
        </member>
        <member name="M:NPOI.Util.IO.PushbackStream.SetLength(System.Int64)">
            <summary>
            When overridden in a derived class, sets the length of the current stream.
            </summary>
            <param name="value">The desired length of the current stream in bytes.</param>
            <exception cref="T:System.IO.IOException">
            An I/O error occurs.
            </exception>
            <exception cref="T:System.NotSupportedException">
            The stream does not support both writing and seeking, such as if the stream is constructed from a pipe or console output.
            </exception>
            <exception cref="T:System.ObjectDisposedException">
            Methods were called after the stream was closed.
            </exception>
        </member>
        <member name="M:NPOI.Util.IO.PushbackStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            When overridden in a derived class, writes a sequence of bytes to the current stream and advances the current position within this stream by the number of bytes written.
            </summary>
            <param name="buffer">An array of bytes. This method copies <paramref name="count"/> bytes from <paramref name="buffer"/> to the current stream.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at which to begin copying bytes to the current stream.</param>
            <param name="count">The number of bytes to be written to the current stream.</param>
            <exception cref="T:System.ArgumentException">
            The sum of <paramref name="offset"/> and <paramref name="count"/> is greater than the buffer length.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="buffer"/> is null.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="offset"/> or <paramref name="count"/> is negative.
            </exception>
            <exception cref="T:System.IO.IOException">
            An I/O error occurs.
            </exception>
            <exception cref="T:System.NotSupportedException">
            The stream does not support writing.
            </exception>
            <exception cref="T:System.ObjectDisposedException">
            Methods were called after the stream was closed.
            </exception>
        </member>
        <member name="M:NPOI.Util.IO.PushbackStream.WriteByte(System.Byte)">
            <summary>
            Writes a byte to the current position in the stream and advances the position within the stream by one byte.
            </summary>
            <param name="value">The byte to write to the stream.</param>
            <exception cref="T:System.IO.IOException">
            An I/O error occurs.
            </exception>
            <exception cref="T:System.NotSupportedException">
            The stream does not support writing, or the stream is already closed.
            </exception>
            <exception cref="T:System.ObjectDisposedException">
            Methods were called after the stream was closed.
            </exception>
        </member>
        <member name="M:NPOI.Util.TempFile.CreateTempFile(System.String,System.String)">
            Creates a temporary file.  Files are collected into one directory and by default are
            deleted on exit from the VM.  Files can be kept by defining the system property
            <c>poi.keep.tmp.files</c>.
            
            Dont forget to close all files or it might not be possible to delete them.
        </member>
        <member name="T:NPOI.Util.LittleEndian">
            <summary>
            a utility class for handling little-endian numbers, which the 80x86 world is
            replete with. The methods are all static, and input/output is from/to byte
            arrays, or from InputStreams.
            </summary>
            <remarks>
            @author     Marc Johnson (mjohnson at apache dot org)
            @author     Andrew Oliver (acoliver at apache dot org)
            </remarks>
        </member>
        <member name="M:NPOI.Util.LittleEndian.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.Util.LittleEndian"/> class.
            </summary>
        </member>
        <member name="M:NPOI.Util.LittleEndian.GetByteArray(System.Byte[],System.Int32,System.Int32)">
             <summary>
             Copy a portion of a byte array
             </summary>
             <param name="data"> the original byte array</param>
             <param name="offset">Where to start copying from.</param>
             <param name="size">Number of bytes to copy.</param>
             <returns>The byteArray value</returns>
            <exception cref="T:System.IndexOutOfRangeException">
            if copying would cause access ofdata outside array bounds.
            </exception>
        </member>
        <member name="M:NPOI.Util.LittleEndian.GetShort(System.Byte[])">
            <summary>
            get a short value from a byte array
            </summary>
            <param name="data">a starting offset into the byte array</param>
            <returns>the short (16-bit) value</returns>
        </member>
        <member name="M:NPOI.Util.LittleEndian.GetShort(System.Byte[],System.Int32)">
            <summary>
            get a short value from a byte array
            </summary>
            <param name="data">the byte array</param>
            <param name="offset">a starting offset into the byte array</param>
            <returns>the short (16-bit) value</returns>
        </member>
        <member name="M:NPOI.Util.LittleEndian.GetUInt(System.Byte[])">
            <summary>
            Gets the U int.
            </summary>
            <param name="data">the byte array</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.Util.LittleEndian.GetUInt(System.Byte[],System.Int32)">
            <summary>
            Gets the U int.
            </summary>
            <param name="data">the byte array</param>
            <param name="offset">a starting offset into the byte array</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.Util.LittleEndian.GetUByte(System.Byte[])">
            <summary>
            Gets the unsigned byte.
            </summary>
            <param name="data">the byte array</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.Util.LittleEndian.GetUByte(System.Byte[],System.Int32)">
            <summary>
            Gets the unsigned byte.
            </summary>
            <param name="data">the byte array</param>
            <param name="offset">a starting offset into the byte array</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.Util.LittleEndian.GetUShort(System.Byte[])">
            <summary>
            get a short value from a byte array
            </summary>
            <param name="data">the unsigned short (16-bit) value in an integer</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.Util.LittleEndian.GetUShort(System.Byte[],System.Int32)">
            <summary>
            get an unsigned short value from a byte array
            </summary>
            <param name="data">the byte array</param>
            <param name="offset">a starting offset into the byte array</param>
            <returns>the unsigned short (16-bit) value in an integer</returns>
        </member>
        <member name="M:NPOI.Util.LittleEndian.PutDouble(System.Byte[],System.Double)">
            <summary>
            Puts the double.
            </summary>
            <param name="data">the byte array</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:NPOI.Util.LittleEndian.PutDouble(System.Byte[],System.Int32,System.Double)">
            <summary>
            Puts the double.
            </summary>
            <param name="data">the byte array</param>
            <param name="offset">a starting offset into the byte array</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:NPOI.Util.LittleEndian.PutInt(System.Byte[],System.Int32)">
            <summary>
            Puts the int.
            </summary>
            <param name="data">the byte array</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:NPOI.Util.LittleEndian.PutInt(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Puts the int.
            </summary>
            <param name="data">the byte array</param>
            <param name="offset">a starting offset into the byte array</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:NPOI.Util.LittleEndian.PutUInt(System.Byte[],System.UInt32)">
            <summary>
            Puts the uint.
            </summary>
            <param name="data">the byte array</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:NPOI.Util.LittleEndian.PutUInt(System.Byte[],System.Int32,System.UInt32)">
            <summary>
            Puts the uint.
            </summary>
            <param name="data">the byte array</param>
            <param name="offset">a starting offset into the byte array</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:NPOI.Util.LittleEndian.PutLong(System.Byte[],System.Int64)">
            <summary>
            Puts the long.
            </summary>
            <param name="data">the byte array</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:NPOI.Util.LittleEndian.PutLong(System.Byte[],System.Int32,System.Int64)">
            <summary>
            Puts the long.
            </summary>
            <param name="data">the byte array</param>
            <param name="offset">a starting offset into the byte array</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:NPOI.Util.LittleEndian.PutULong(System.Byte[],System.UInt64)">
            <summary>
            Puts the long.
            </summary>
            <param name="data">the byte array</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:NPOI.Util.LittleEndian.PutULong(System.Byte[],System.Int32,System.UInt64)">
            <summary>
            Puts the ulong.
            </summary>
            <param name="data">the byte array</param>
            <param name="offset">a starting offset into the byte array</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:NPOI.Util.LittleEndian.PutNumber(System.Byte[],System.Int32,System.Int64,System.Int32)">
            <summary>
            Puts the number.
            </summary>
            <param name="data">the byte array</param>
            <param name="offset">a starting offset into the byte array</param>
            <param name="value">The value.</param>
            <param name="size">The size.</param>
        </member>
        <member name="M:NPOI.Util.LittleEndian.PutNumber(System.Byte[],System.Int32,System.UInt64,System.Int32)">
            <summary>
            Puts the number.
            </summary>
            <param name="data">the byte array</param>
            <param name="offset">a starting offset into the byte array</param>
            <param name="value">The value.</param>
            <param name="size">The size.</param>
        </member>
        <member name="M:NPOI.Util.LittleEndian.PutShort(System.Byte[],System.Int16)">
            <summary>
            Puts the short.
            </summary>
            <param name="data">the byte array</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:NPOI.Util.LittleEndian.PutShort(System.Byte[],System.Int32,System.Int16)">
            <summary>
            Puts the short.
            </summary>
            <param name="data">the byte array</param>
            <param name="offset">a starting offset into the byte array</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:NPOI.Util.LittleEndian.PutShortArray(System.Byte[],System.Int32,System.Int16[])">
            <summary>
            Puts the short array.
            </summary>
            <param name="data">the byte array</param>
            <param name="offset">a starting offset into the byte array</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:NPOI.Util.LittleEndian.PutByte(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Added for consistency with other put~() methods
            </summary>
            <param name="data">the byte array</param>
            <param name="offset">a starting offset into the byte array</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:NPOI.Util.LittleEndian.PutUShort(System.Byte[],System.Int32)">
            <summary>
            Puts the U short.
            </summary>
            <param name="data">the byte array</param>
            <param name="offset">a starting offset into the byte array</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:NPOI.Util.LittleEndian.PutUShort(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Puts the U short.
            </summary>
            <param name="data">the byte array</param>
            <param name="offset">a starting offset into the byte array</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:NPOI.Util.LittleEndian.ReadFromStream(System.IO.Stream,System.Int32)">
            <summary>
            Reads from stream.
            </summary>
            <param name="stream">The stream.</param>
            <param name="size">The size.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.Util.LittleEndian.ReadInt(System.IO.Stream)">
            <summary>
            Reads the int.
            </summary>
            <param name="stream">The stream.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.Util.LittleEndian.ReadLong(System.IO.Stream)">
            <summary>
            Reads the long.
            </summary>
            <param name="stream">The stream.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.Util.LittleEndian.ReadULong(System.IO.Stream)">
            <summary>
            Reads the long.
            </summary>
            <param name="stream">The stream.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.Util.LittleEndian.ReadShort(System.IO.Stream)">
            <summary>
            Reads the short.
            </summary>
            <param name="stream">The stream.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.Util.LittleEndian.UByteToInt(System.Byte)">
            <summary>
            Us the byte to int.
            </summary>
            <param name="b">The b.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.Util.LongField.#ctor(System.Int32)">
            <summary>
            construct the <see cref="T:NPOI.Util.LongField"/> with its offset into its containing byte array
            </summary>
            <param name="offset">The offset.</param>
        </member>
        <member name="M:NPOI.Util.LongField.#ctor(System.Int32,System.Int64)">
            <summary>
            construct the LongField with its offset into its containing
            byte array and initialize its value
            </summary>
            <param name="offset">offset of the field within its byte array</param>
            <param name="value">the initial value</param>
        </member>
        <member name="M:NPOI.Util.LongField.#ctor(System.Int32,System.Byte[])">
            <summary>
            Construct the <see cref="T:NPOI.Util.LongField"/> class with its offset into its containing
            byte array and initialize its value from its byte array
            </summary>
            <param name="offset">The offset of the field within its byte array</param>
            <param name="data">the byte array to read the value from</param>
        </member>
        <member name="M:NPOI.Util.LongField.#ctor(System.Int32,System.Int64,System.Byte[])">
            <summary>
            construct the <see cref="T:NPOI.Util.LongField"/> class with its offset into its containing
            byte array, initialize its value, and write the value to a byte
            array
            </summary>
            <param name="offset">offset of the field within its byte array</param>
            <param name="value">the initial value</param>
            <param name="data">the byte array to write the value to</param>
        </member>
        <member name="P:NPOI.Util.LongField.Value">
            <summary>
            Getg or sets the LongField's current value
            </summary>
            <value>The current value</value>
        </member>
        <member name="M:NPOI.Util.LongField.Set(System.Int64,System.Byte[])">
            <summary>
            set the LongField's current value and write it to a byte array
            </summary>
            <param name="value">value to be set</param>
            <param name="data">the byte array to write the value to</param>
        </member>
        <member name="M:NPOI.Util.LongField.ReadFromBytes(System.Byte[])">
            <summary>
            set the value from its offset into an array of bytes
            </summary>
            <param name="data">the byte array from which the value is to be read</param>
        </member>
        <member name="M:NPOI.Util.LongField.ReadFromStream(System.IO.Stream)">
            <summary>
            set the value from an Stream
            </summary>
            <param name="stream">the Stream from which the value is to be</param>
        </member>
        <member name="M:NPOI.Util.LongField.WriteToBytes(System.Byte[])">
            <summary>
            write the value out to an array of bytes at the appropriate offset
            </summary>
            <param name="data">the array of bytes to which the value is to be written</param>
        </member>
        <member name="M:NPOI.Util.LongField.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="T:NPOI.Util.NullLogger">
            <summary>
            A Logger class that strives to make it as easy as possible for
            developers to write Log calls, while simultaneously making those
            calls as cheap as possible by performing lazy evaluation of the Log
            message.
            @author Marc Johnson (mjohnson at apache dot org)
            @author Glen Stampoultzis (glens at apache.org)
            @author Nicola Ken Barozzi (nicolaken at apache.org)
            </summary>
        </member>
        <member name="M:NPOI.Util.NullLogger.Log(System.Int32,System.Object)">
             Log a message
            
             @param level One of DEBUG, INFO, WARN, ERROR, FATAL
             @param obj1 The object to Log.
        </member>
        <member name="M:NPOI.Util.NullLogger.Check(System.Int32)">
             Check if a Logger is enabled to Log at the specified level
            
             @param level One of DEBUG, INFO, WARN, ERROR, FATAL
        </member>
        <member name="M:NPOI.Util.NullLogger.Log(System.Int32,System.Object,System.Object)">
             Log a message. Lazily appends Object parameters together.
            
             @param level One of DEBUG, INFO, WARN, ERROR, FATAL
             @param obj1 first object to place in the message
             @param obj2 second object to place in the message
        </member>
        <member name="M:NPOI.Util.NullLogger.Log(System.Int32,System.Object,System.Object,System.Object)">
             Log a message. Lazily appends Object parameters together.
            
             @param level One of DEBUG, INFO, WARN, ERROR, FATAL
             @param obj1 first Object to place in the message
             @param obj2 second Object to place in the message
             @param obj3 third Object to place in the message
        </member>
        <member name="M:NPOI.Util.NullLogger.Log(System.Int32,System.Object,System.Object,System.Object,System.Object)">
             Log a message. Lazily appends Object parameters together.
            
             @param level One of DEBUG, INFO, WARN, ERROR, FATAL
             @param obj1 first Object to place in the message
             @param obj2 second Object to place in the message
             @param obj3 third Object to place in the message
             @param obj4 fourth Object to place in the message
        </member>
        <member name="M:NPOI.Util.NullLogger.Log(System.Int32,System.Object,System.Object,System.Object,System.Object,System.Object)">
             Log a message. Lazily appends Object parameters together.
            
             @param level One of DEBUG, INFO, WARN, ERROR, FATAL
             @param obj1 first Object to place in the message
             @param obj2 second Object to place in the message
             @param obj3 third Object to place in the message
             @param obj4 fourth Object to place in the message
             @param obj5 fifth Object to place in the message
        </member>
        <member name="M:NPOI.Util.NullLogger.Log(System.Int32,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object)">
             Log a message. Lazily appends Object parameters together.
            
             @param level One of DEBUG, INFO, WARN, ERROR, FATAL
             @param obj1 first Object to place in the message
             @param obj2 second Object to place in the message
             @param obj3 third Object to place in the message
             @param obj4 fourth Object to place in the message
             @param obj5 fifth Object to place in the message
             @param obj6 sixth Object to place in the message
        </member>
        <member name="M:NPOI.Util.NullLogger.Log(System.Int32,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object)">
             Log a message. Lazily appends Object parameters together.
            
             @param level One of DEBUG, INFO, WARN, ERROR, FATAL
             @param obj1 first Object to place in the message
             @param obj2 second Object to place in the message
             @param obj3 third Object to place in the message
             @param obj4 fourth Object to place in the message
             @param obj5 fifth Object to place in the message
             @param obj6 sixth Object to place in the message
             @param obj7 seventh Object to place in the message
        </member>
        <member name="M:NPOI.Util.NullLogger.Log(System.Int32,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object)">
             Log a message. Lazily appends Object parameters together.
            
             @param level One of DEBUG, INFO, WARN, ERROR, FATAL
             @param obj1 first Object to place in the message
             @param obj2 second Object to place in the message
             @param obj3 third Object to place in the message
             @param obj4 fourth Object to place in the message
             @param obj5 fifth Object to place in the message
             @param obj6 sixth Object to place in the message
             @param obj7 seventh Object to place in the message
             @param obj8 eighth Object to place in the message
        </member>
        <member name="M:NPOI.Util.NullLogger.Log(System.Int32,System.Object,System.Exception)">
             Log a message
            
             @param level One of DEBUG, INFO, WARN, ERROR, FATAL
             @param obj1 The object to Log.  This is converted to a string.
             @param exception An exception to be Logged
        </member>
        <member name="M:NPOI.Util.NullLogger.Log(System.Int32,System.Object,System.Object,System.Exception)">
             Log a message. Lazily appends Object parameters together.
            
             @param level One of DEBUG, INFO, WARN, ERROR, FATAL
             @param obj1 first Object to place in the message
             @param obj2 second Object to place in the message
             @param exception An exception to be Logged
        </member>
        <member name="M:NPOI.Util.NullLogger.Log(System.Int32,System.Object,System.Object,System.Object,System.Exception)">
             Log a message. Lazily appends Object parameters together.
            
             @param level One of DEBUG, INFO, WARN, ERROR, FATAL
             @param obj1 first Object to place in the message
             @param obj2 second Object to place in the message
             @param obj3 third object to place in the message
             @param exception An error message to be Logged
        </member>
        <member name="M:NPOI.Util.NullLogger.Log(System.Int32,System.Object,System.Object,System.Object,System.Object,System.Exception)">
             Log a message. Lazily appends Object parameters together.
            
             @param level One of DEBUG, INFO, WARN, ERROR, FATAL
             @param obj1 first Object to place in the message
             @param obj2 second Object to place in the message
             @param obj3 third object to place in the message
             @param obj4 fourth object to place in the message
             @param exception An exception to be Logged
        </member>
        <member name="M:NPOI.Util.NullLogger.Log(System.Int32,System.Object,System.Object,System.Object,System.Object,System.Object,System.Exception)">
             Log a message. Lazily appends Object parameters together.
            
             @param level One of DEBUG, INFO, WARN, ERROR, FATAL
             @param obj1 first Object to place in the message
             @param obj2 second Object to place in the message
             @param obj3 third object to place in the message
             @param obj4 fourth object to place in the message
             @param obj5 fifth object to place in the message
             @param exception An exception to be Logged
        </member>
        <member name="M:NPOI.Util.NullLogger.Log(System.Int32,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Exception)">
             Log a message. Lazily appends Object parameters together.
            
             @param level One of DEBUG, INFO, WARN, ERROR, FATAL
             @param obj1 first Object to place in the message
             @param obj2 second Object to place in the message
             @param obj3 third object to place in the message
             @param obj4 fourth object to place in the message
             @param obj5 fifth object to place in the message
             @param obj6 sixth object to place in the message
             @param exception An exception to be Logged
        </member>
        <member name="M:NPOI.Util.NullLogger.Log(System.Int32,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Exception)">
             Log a message. Lazily appends Object parameters together.
            
             @param level One of DEBUG, INFO, WARN, ERROR, FATAL
             @param obj1 first Object to place in the message
             @param obj2 second Object to place in the message
             @param obj3 third object to place in the message
             @param obj4 fourth object to place in the message
             @param obj5 fifth object to place in the message
             @param obj6 sixth object to place in the message
             @param obj7 seventh object to place in the message
             @param exception An exception to be Logged
        </member>
        <member name="M:NPOI.Util.NullLogger.Log(System.Int32,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Exception)">
             Log a message. Lazily appends Object parameters together.
            
             @param level One of DEBUG, INFO, WARN, ERROR, FATAL
             @param obj1 first Object to place in the message
             @param obj2 second Object to place in the message
             @param obj3 third object to place in the message
             @param obj4 fourth object to place in the message
             @param obj5 fifth object to place in the message
             @param obj6 sixth object to place in the message
             @param obj7 seventh object to place in the message
             @param obj8 eighth object to place in the message
             @param exception An exception to be Logged
        </member>
        <member name="M:NPOI.Util.NullLogger.LogFormatted(System.Int32,System.String,System.Object)">
             Logs a formated message. The message itself may contain %
             characters as place holders. This routine will attempt to match
             the placeholder by looking at the type of parameter passed to
             obj1.
            
             If the parameter is an array, it traverses the array first and
             matches parameters sequentially against the array items.
             Otherwise the parameters after <c>message</c> are matched
             in order.
            
             If the place holder matches against a number it is printed as a
             whole number. This can be overridden by specifying a precision
             in the form %n.m where n is the padding for the whole part and
             m is the number of decimal places to display. n can be excluded
             if desired. n and m may not be more than 9.
            
             If the last parameter (after flattening) is a Exception it is
             Logged specially.
            
             @param level One of DEBUG, INFO, WARN, ERROR, FATAL
             @param message The message to Log.
             @param obj1 The first object to match against.
        </member>
        <member name="M:NPOI.Util.NullLogger.LogFormatted(System.Int32,System.String,System.Object,System.Object)">
             Logs a formated message. The message itself may contain %
             characters as place holders. This routine will attempt to match
             the placeholder by looking at the type of parameter passed to
             obj1.
            
             If the parameter is an array, it traverses the array first and
             matches parameters sequentially against the array items.
             Otherwise the parameters after <c>message</c> are matched
             in order.
            
             If the place holder matches against a number it is printed as a
             whole number. This can be overridden by specifying a precision
             in the form %n.m where n is the padding for the whole part and
             m is the number of decimal places to display. n can be excluded
             if desired. n and m may not be more than 9.
            
             If the last parameter (after flattening) is a Exception it is
             Logged specially.
            
             @param level One of DEBUG, INFO, WARN, ERROR, FATAL
             @param message The message to Log.
             @param obj1 The first object to match against.
             @param obj2 The second object to match against.
        </member>
        <member name="M:NPOI.Util.NullLogger.LogFormatted(System.Int32,System.String,System.Object,System.Object,System.Object)">
             Logs a formated message. The message itself may contain %
             characters as place holders. This routine will attempt to match
             the placeholder by looking at the type of parameter passed to
             obj1.
            
             If the parameter is an array, it traverses the array first and
             matches parameters sequentially against the array items.
             Otherwise the parameters after <c>message</c> are matched
             in order.
            
             If the place holder matches against a number it is printed as a
             whole number. This can be overridden by specifying a precision
             in the form %n.m where n is the padding for the whole part and
             m is the number of decimal places to display. n can be excluded
             if desired. n and m may not be more than 9.
            
             If the last parameter (after flattening) is a Exception it is
             Logged specially.
            
             @param level One of DEBUG, INFO, WARN, ERROR, FATAL
             @param message The message to Log.
             @param obj1 The first object to match against.
             @param obj2 The second object to match against.
             @param obj3 The third object to match against.
        </member>
        <member name="M:NPOI.Util.NullLogger.LogFormatted(System.Int32,System.String,System.Object,System.Object,System.Object,System.Object)">
             Logs a formated message. The message itself may contain %
             characters as place holders. This routine will attempt to match
             the placeholder by looking at the type of parameter passed to
             obj1.
            
             If the parameter is an array, it traverses the array first and
             matches parameters sequentially against the array items.
             Otherwise the parameters after <c>message</c> are matched
             in order.
            
             If the place holder matches against a number it is printed as a
             whole number. This can be overridden by specifying a precision
             in the form %n.m where n is the padding for the whole part and
             m is the number of decimal places to display. n can be excluded
             if desired. n and m may not be more than 9.
            
             If the last parameter (after flattening) is a Exception it is
             Logged specially.
            
             @param level One of DEBUG, INFO, WARN, ERROR, FATAL
             @param message The message to Log.
             @param obj1 The first object to match against.
             @param obj2 The second object to match against.
             @param obj3 The third object to match against.
             @param obj4 The forth object to match against.
        </member>
        <member name="F:NPOI.Util.POILogFactory._loggers">
            Map of POILogger instances, with classes as keys
        </member>
        <member name="F:NPOI.Util.POILogFactory._nullLogger">
            A common instance of NullLogger, as it does nothing
             we only need the one
        </member>
        <member name="F:NPOI.Util.POILogFactory._loggerClassName">
            The name of the class to use. Initialised the
             first time we need it
        </member>
        <member name="M:NPOI.Util.POILogFactory.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NPOI.Util.POILogFactory"/> class.
            </summary>
        </member>
        <member name="M:NPOI.Util.POILogFactory.GetLogger(System.Type)">
            <summary>
            Get a logger, based on a class name
            </summary>
            <param name="type">the class whose name defines the log</param>
            <returns>a POILogger for the specified class</returns>
        </member>
        <member name="M:NPOI.Util.POILogFactory.GetLogger(System.String)">
            <summary>
            Get a logger, based on a String
            </summary>
            <param name="cat">the String that defines the log</param>
            <returns>a POILogger for the specified class</returns>
        </member>
        <member name="M:NPOI.Util.POILogger.#ctor">
             package scope so it cannot be instantiated outside of the util
             package. You need a POILogger? Go to the POILogFactory for one
            
        </member>
        <member name="M:NPOI.Util.POILogger.Log(System.Int32,System.Object)">
             Log a message
            
             @param level One of DEBUG, INFO, WARN, ERROR, FATAL
             @param obj1 The object to Log.  This is converted to a string.
        </member>
        <member name="M:NPOI.Util.POILogger.Log(System.Int32,System.Object,System.Exception)">
             Log a message
            
             @param level One of DEBUG, INFO, WARN, ERROR, FATAL
             @param obj1 The object to Log.  This is converted to a string.
             @param exception An exception to be Logged
        </member>
        <member name="M:NPOI.Util.POILogger.Check(System.Int32)">
             Check if a Logger is enabled to Log at the specified level
            
             @param level One of DEBUG, INFO, WARN, ERROR, FATAL
        </member>
        <member name="M:NPOI.Util.POILogger.Log(System.Int32,System.Object,System.Object)">
             Log a message. Lazily appends Object parameters together.
            
             @param level One of DEBUG, INFO, WARN, ERROR, FATAL
             @param obj1 first object to place in the message
             @param obj2 second object to place in the message
             Log a message. Lazily appends Object parameters together.
            
             @param level One of DEBUG, INFO, WARN, ERROR, FATAL
             @param obj1 first object to place in the message
             @param obj2 second object to place in the message
        </member>
        <member name="M:NPOI.Util.POILogger.Log(System.Int32,System.Object,System.Object,System.Object)">
             Log a message. Lazily appends Object parameters together.
            
             @param level One of DEBUG, INFO, WARN, ERROR, FATAL
             @param obj1 first Object to place in the message
             @param obj2 second Object to place in the message
             @param obj3 third Object to place in the message
        </member>
        <member name="M:NPOI.Util.POILogger.Log(System.Int32,System.Object,System.Object,System.Object,System.Object)">
             Log a message. Lazily appends Object parameters together.
            
             @param level One of DEBUG, INFO, WARN, ERROR, FATAL
             @param obj1 first Object to place in the message
             @param obj2 second Object to place in the message
             @param obj3 third Object to place in the message
             @param obj4 fourth Object to place in the message
        </member>
        <member name="M:NPOI.Util.POILogger.Log(System.Int32,System.Object,System.Object,System.Object,System.Object,System.Object)">
             Log a message. Lazily appends Object parameters together.
            
             @param level One of DEBUG, INFO, WARN, ERROR, FATAL
             @param obj1 first Object to place in the message
             @param obj2 second Object to place in the message
             @param obj3 third Object to place in the message
             @param obj4 fourth Object to place in the message
             @param obj5 fifth Object to place in the message
        </member>
        <member name="M:NPOI.Util.POILogger.Log(System.Int32,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object)">
             Log a message. Lazily appends Object parameters together.
            
             @param level One of DEBUG, INFO, WARN, ERROR, FATAL
             @param obj1 first Object to place in the message
             @param obj2 second Object to place in the message
             @param obj3 third Object to place in the message
             @param obj4 fourth Object to place in the message
             @param obj5 fifth Object to place in the message
             @param obj6 sixth Object to place in the message
        </member>
        <member name="M:NPOI.Util.POILogger.Log(System.Int32,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object)">
             Log a message. Lazily appends Object parameters together.
            
             @param level One of DEBUG, INFO, WARN, ERROR, FATAL
             @param obj1 first Object to place in the message
             @param obj2 second Object to place in the message
             @param obj3 third Object to place in the message
             @param obj4 fourth Object to place in the message
             @param obj5 fifth Object to place in the message
             @param obj6 sixth Object to place in the message
             @param obj7 seventh Object to place in the message
        </member>
        <member name="M:NPOI.Util.POILogger.Log(System.Int32,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object)">
             Log a message. Lazily appends Object parameters together.
            
             @param level One of DEBUG, INFO, WARN, ERROR, FATAL
             @param obj1 first Object to place in the message
             @param obj2 second Object to place in the message
             @param obj3 third Object to place in the message
             @param obj4 fourth Object to place in the message
             @param obj5 fifth Object to place in the message
             @param obj6 sixth Object to place in the message
             @param obj7 seventh Object to place in the message
             @param obj8 eighth Object to place in the message
        </member>
        <member name="M:NPOI.Util.POILogger.Log(System.Int32,System.Exception)">
             Log an exception, without a message
            
             @param level One of DEBUG, INFO, WARN, ERROR, FATAL
             @param exception An exception to be Logged
        </member>
        <member name="M:NPOI.Util.POILogger.Log(System.Int32,System.Object,System.Object,System.Exception)">
             Log a message. Lazily appends Object parameters together.
            
             @param level One of DEBUG, INFO, WARN, ERROR, FATAL
             @param obj1 first Object to place in the message
             @param obj2 second Object to place in the message
             @param exception An exception to be Logged
        </member>
        <member name="M:NPOI.Util.POILogger.Log(System.Int32,System.Object,System.Object,System.Object,System.Exception)">
             Log a message. Lazily appends Object parameters together.
            
             @param level One of DEBUG, INFO, WARN, ERROR, FATAL
             @param obj1 first Object to place in the message
             @param obj2 second Object to place in the message
             @param obj3 third object to place in the message
             @param exception An error message to be Logged
        </member>
        <member name="M:NPOI.Util.POILogger.Log(System.Int32,System.Object,System.Object,System.Object,System.Object,System.Exception)">
             Log a message. Lazily appends Object parameters together.
            
             @param level One of DEBUG, INFO, WARN, ERROR, FATAL
             @param obj1 first Object to place in the message
             @param obj2 second Object to place in the message
             @param obj3 third object to place in the message
             @param obj4 fourth object to place in the message
             @param exception An exception to be Logged
        </member>
        <member name="M:NPOI.Util.POILogger.Log(System.Int32,System.Object,System.Object,System.Object,System.Object,System.Object,System.Exception)">
             Log a message. Lazily appends Object parameters together.
            
             @param level One of DEBUG, INFO, WARN, ERROR, FATAL
             @param obj1 first Object to place in the message
             @param obj2 second Object to place in the message
             @param obj3 third object to place in the message
             @param obj4 fourth object to place in the message
             @param obj5 fifth object to place in the message
             @param exception An exception to be Logged
        </member>
        <member name="M:NPOI.Util.POILogger.Log(System.Int32,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Exception)">
             Log a message. Lazily appends Object parameters together.
            
             @param level One of DEBUG, INFO, WARN, ERROR, FATAL
             @param obj1 first Object to place in the message
             @param obj2 second Object to place in the message
             @param obj3 third object to place in the message
             @param obj4 fourth object to place in the message
             @param obj5 fifth object to place in the message
             @param obj6 sixth object to place in the message
             @param exception An exception to be Logged
        </member>
        <member name="M:NPOI.Util.POILogger.Log(System.Int32,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Exception)">
             Log a message. Lazily appends Object parameters together.
            
             @param level One of DEBUG, INFO, WARN, ERROR, FATAL
             @param obj1 first Object to place in the message
             @param obj2 second Object to place in the message
             @param obj3 third object to place in the message
             @param obj4 fourth object to place in the message
             @param obj5 fifth object to place in the message
             @param obj6 sixth object to place in the message
             @param obj7 seventh object to place in the message
             @param exception An exception to be Logged
        </member>
        <member name="M:NPOI.Util.POILogger.Log(System.Int32,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Exception)">
             Log a message. Lazily appends Object parameters together.
            
             @param level One of DEBUG, INFO, WARN, ERROR, FATAL
             @param obj1 first Object to place in the message
             @param obj2 second Object to place in the message
             @param obj3 third object to place in the message
             @param obj4 fourth object to place in the message
             @param obj5 fifth object to place in the message
             @param obj6 sixth object to place in the message
             @param obj7 seventh object to place in the message
             @param obj8 eighth object to place in the message
             @param exception An exception to be Logged
        </member>
        <member name="M:NPOI.Util.POILogger.LogFormatted(System.Int32,System.String,System.Object)">
             Logs a formated message. The message itself may contain %
             characters as place holders. This routine will attempt to match
             the placeholder by looking at the type of parameter passed to
             obj1.
            
             If the parameter is an array, it traverses the array first and
             matches parameters sequentially against the array items.
             Otherwise the parameters after <c>message</c> are matched
             in order.
            
             If the place holder matches against a number it is printed as a
             whole number. This can be overridden by specifying a precision
             in the form %n.m where n is the padding for the whole part and
             m is the number of decimal places to display. n can be excluded
             if desired. n and m may not be more than 9.
            
             If the last parameter (after flattening) is a Exception it is
             Logged specially.
            
             @param level One of DEBUG, INFO, WARN, ERROR, FATAL
             @param message The message to Log.
             @param obj1 The first object to match against.
        </member>
        <member name="M:NPOI.Util.POILogger.LogFormatted(System.Int32,System.String,System.Object,System.Object)">
             Logs a formated message. The message itself may contain %
             characters as place holders. This routine will attempt to match
             the placeholder by looking at the type of parameter passed to
             obj1.
            
             If the parameter is an array, it traverses the array first and
             matches parameters sequentially against the array items.
             Otherwise the parameters after <c>message</c> are matched
             in order.
            
             If the place holder matches against a number it is printed as a
             whole number. This can be overridden by specifying a precision
             in the form %n.m where n is the padding for the whole part and
             m is the number of decimal places to display. n can be excluded
             if desired. n and m may not be more than 9.
            
             If the last parameter (after flattening) is a Exception it is
             Logged specially.
            
             @param level One of DEBUG, INFO, WARN, ERROR, FATAL
             @param message The message to Log.
             @param obj1 The first object to match against.
             @param obj2 The second object to match against.
        </member>
        <member name="M:NPOI.Util.POILogger.LogFormatted(System.Int32,System.String,System.Object,System.Object,System.Object)">
             Logs a formated message. The message itself may contain %
             characters as place holders. This routine will attempt to match
             the placeholder by looking at the type of parameter passed to
             obj1.
            
             If the parameter is an array, it traverses the array first and
             matches parameters sequentially against the array items.
             Otherwise the parameters after <c>message</c> are matched
             in order.
            
             If the place holder matches against a number it is printed as a
             whole number. This can be overridden by specifying a precision
             in the form %n.m where n is the padding for the whole part and
             m is the number of decimal places to display. n can be excluded
             if desired. n and m may not be more than 9.
            
             If the last parameter (after flattening) is a Exception it is
             Logged specially.
            
             @param level One of DEBUG, INFO, WARN, ERROR, FATAL
             @param message The message to Log.
             @param obj1 The first object to match against.
             @param obj2 The second object to match against.
             @param obj3 The third object to match against.
        </member>
        <member name="M:NPOI.Util.POILogger.LogFormatted(System.Int32,System.String,System.Object,System.Object,System.Object,System.Object)">
             Logs a formated message. The message itself may contain %
             characters as place holders. This routine will attempt to match
             the placeholder by looking at the type of parameter passed to
             obj1.
            
             If the parameter is an array, it traverses the array first and
             matches parameters sequentially against the array items.
             Otherwise the parameters after <c>message</c> are matched
             in order.
            
             If the place holder matches against a number it is printed as a
             whole number. This can be overridden by specifying a precision
             in the form %n.m where n is the padding for the whole part and
             m is the number of decimal places to display. n can be excluded
             if desired. n and m may not be more than 9.
            
             If the last parameter (after flattening) is a Exception it is
             Logged specially.
            
             @param level One of DEBUG, INFO, WARN, ERROR, FATAL
             @param message The message to Log.
             @param obj1 The first object to match against.
             @param obj2 The second object to match against.
             @param obj3 The third object to match against.
             @param obj4 The forth object to match against.
        </member>
        <member name="M:NPOI.Util.POILogger.FlattenArrays(System.Object[])">
            Flattens any contained objects. Only tranverses one level deep.
        </member>
        <member name="M:NPOI.Util.ShortField.#ctor(System.Int32)">
             <summary>
             construct the ShortField with its offset into its containing
             byte array
             </summary>
             <param name="offset">offset of the field within its byte array</param>
            <exception cref="T:System.IndexOutOfRangeException">if offset is negative</exception>
        </member>
        <member name="M:NPOI.Util.ShortField.#ctor(System.Int32,System.Int16)">
            <summary>
            construct the ShortField with its offset into its containing byte array and initialize its value
            </summary>
            <param name="offset">offset of the field within its byte array</param>
            <param name="value">the initial value</param>
            <exception cref="T:System.IndexOutOfRangeException">if offset is negative</exception> 
        </member>
        <member name="M:NPOI.Util.ShortField.#ctor(System.Int32,System.Byte[])">
            <summary>
            Construct the ShortField with its offset into its containing
            byte array and initialize its value from its byte array
            </summary>
            <param name="offset">offset of the field within its byte array</param>
            <param name="data">the byte array to read the value from</param>
            <exception cref="T:System.IndexOutOfRangeException">if the offset is not
            within the range of 0..(data.length - 1)</exception> 
        </member>
        <member name="M:NPOI.Util.ShortField.#ctor(System.Int32,System.Int16,System.Byte[]@)">
            <summary>
            construct the ShortField with its offset into its containing
            byte array, initialize its value, and write its value to its
            byte array
            </summary>
            <param name="offset">offset of the field within its byte array</param>
            <param name="value">the initial value</param>
            <param name="data">the byte array to write the value to</param>
            <exception cref="T:System.IndexOutOfRangeException">if offset is negative</exception>
        </member>
        <member name="P:NPOI.Util.ShortField.Value">
            <summary>
            Gets or sets the value.
            </summary>
            <value>The value.</value>
        </member>
        <member name="M:NPOI.Util.ShortField.Set(System.Int16,System.Byte[]@)">
            <summary>
            set the ShortField's current value and write it to a byte array
            </summary>
            <param name="value">value to be set</param>
            <param name="data">the byte array to write the value to</param>
            <exception cref="T:System.IndexOutOfRangeException">if the offset is out
            of range</exception>
        </member>
        <member name="M:NPOI.Util.ShortField.ReadFromBytes(System.Byte[])">
            <summary>
            set the value from its offset into an array of bytes
            </summary>
            <param name="data">the byte array from which the value is to be read</param>
            <exception cref="T:System.IndexOutOfRangeException">if the offset is out
            of range</exception>
        </member>
        <member name="M:NPOI.Util.ShortField.ReadFromStream(System.IO.Stream)">
            <summary>
            set the value from an Stream
            </summary>
            <param name="stream">the Stream from which the value is to be
            read</param>
            <exception cref="T:System.IO.IOException">if an IOException is thrown from reading
            the Stream</exception>
            <exception cref="T:NPOI.Util.BufferUnderrunException">if there is not enough data
            available from the Stream</exception>
        </member>
        <member name="M:NPOI.Util.ShortField.WriteToBytes(System.Byte[])">
            <summary>
            write the value out to an array of bytes at the appropriate
            offset
            </summary>
            <param name="data">the array of bytes to which the value is to be
            written</param>
            <exception cref="T:System.IndexOutOfRangeException">if the offset is out
            of range</exception>
        </member>
        <member name="M:NPOI.Util.ShortField.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="T:NPOI.Util.StringUtil">
            <summary>
            Title: String Utility Description: Collection of string handling utilities
            @author     Andrew C. Oliver
            @author     Sergei Kozello (sergeikozello at mail.ru)
            @author     Toshiaki Kamoshida (kamoshida.toshiaki at future dot co dot jp)
            @since      May 10, 2002
            @version    1.0
            </summary>
        </member>
        <member name="M:NPOI.Util.StringUtil.#ctor">
            Constructor for the StringUtil object     
        </member>
        <member name="M:NPOI.Util.StringUtil.GetFromUnicodeLE(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Given a byte array of 16-bit unicode characters in Little Endian
            Format (most important byte last), return a Java String representation
            of it.
            { 0x16, 0x00 } -0x16
            </summary>
            <param name="str">the byte array to be converted</param>
            <param name="offset">the initial offset into the
            byte array. it is assumed that string[ offset ] and string[ offset + 1 ] contain the first 16-bit unicode character</param>
            <param name="len">the Length of the string</param>
            <returns>the converted string</returns>                              
        </member>
        <member name="M:NPOI.Util.StringUtil.GetFromUnicodeLE(System.Byte[])">
             <summary>
             Given a byte array of 16-bit unicode characters in little endian
             Format (most important byte last), return a Java String representation
             of it.
            { 0x16, 0x00 } -0x16
             </summary>
             <param name="str">the byte array to be converted</param>
             <returns>the converted string</returns>  
        </member>
        <member name="M:NPOI.Util.StringUtil.GetFromUnicodeBE(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Given a byte array of 16-bit unicode characters in big endian
            Format (most important byte first), return a Java String representation
            of it.
             { 0x00, 0x16 } -0x16
            </summary>
            <param name="str">the byte array to be converted</param>
            <param name="offset">the initial offset into the
            byte array. it is assumed that string[ offset ] and string[ offset + 1 ] contain the first 16-bit unicode character</param>
            <param name="len">the Length of the string</param>
            <returns> the converted string</returns>
        </member>
        <member name="M:NPOI.Util.StringUtil.GetFromUnicodeBE(System.Byte[])">
            <summary>
            Given a byte array of 16-bit unicode characters in big endian
            Format (most important byte first), return a Java String representation
            of it.
            { 0x00, 0x16 } -0x16
            </summary>
            <param name="str">the byte array to be converted</param>
            <returns>the converted string</returns>      
        </member>
        <member name="M:NPOI.Util.StringUtil.GetFromCompressedUnicode(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read 8 bit data (in IsO-8859-1 codepage) into a (unicode) Java
            String and return.
            (In Excel terms, read compressed 8 bit unicode as a string)
            </summary>
            <param name="str">byte array to read</param>
            <param name="offset">offset to read byte array</param>
            <param name="len">Length to read byte array</param>
            <returns>generated String instance by reading byte array</returns>
        </member>
        <member name="M:NPOI.Util.StringUtil.PutCompressedUnicode(System.String,System.Byte[],System.Int32)">
            <summary>
            Takes a unicode (java) string, and returns it as 8 bit data (in IsO-8859-1
            codepage).
            (In Excel terms, write compressed 8 bit unicode)
            </summary>
            <param name="input">the String containing the data to be written</param>
            <param name="output">the byte array to which the data Is to be written</param>
            <param name="offset">an offset into the byte arrat at which the data Is start when written</param>
        </member>
        <member name="M:NPOI.Util.StringUtil.PutUnicodeLE(System.String,System.Byte[],System.Int32)">
            <summary>
            Takes a unicode string, and returns it as little endian (most
            important byte last) bytes in the supplied byte array.
            (In Excel terms, write uncompressed unicode)
            </summary>
            <param name="input">the String containing the unicode data to be written</param>
            <param name="output">the byte array to hold the uncompressed unicode, should be twice the Length of the String</param>
            <param name="offset">the offset to start writing into the byte array</param>
        </member>
        <member name="M:NPOI.Util.StringUtil.PutUnicodeBE(System.String,System.Byte[],System.Int32)">
            <summary>
            Takes a unicode string, and returns it as big endian (most
            important byte first) bytes in the supplied byte array.
            (In Excel terms, write uncompressed unicode)
            </summary>
            <param name="input">the String containing the unicode data to be written</param>
            <param name="output">the byte array to hold the uncompressed unicode, should be twice the Length of the String.</param>
            <param name="offset">the offset to start writing into the byte array</param>
        </member>
        <member name="M:NPOI.Util.StringUtil.GetPreferredEncoding">
            <summary>
            Gets the preferred encoding.
            </summary>
            <returns>the encoding we want to use, currently hardcoded to IsO-8859-1</returns>
        </member>
        <member name="M:NPOI.Util.StringUtil.HasMultibyte(System.String)">
            <summary>
            check the parameter Has multibyte character
            </summary>
            <param name="value"> string to check</param>
            <returns>
            	<c>true</c> if Has at least one multibyte character; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NPOI.Util.StringUtil.ReadUnicodeString(NPOI.Util.IO.LittleEndianInput)">
            InputStream <tt>in</tt> is expected to contain:
            <ol>
            <li>ushort nChars</li>
            <li>byte is16BitFlag</li>
            <li>byte[]/char[] characterData</li>
            </ol>
            For this encoding, the is16BitFlag is always present even if nChars==0.
        </member>
        <member name="M:NPOI.Util.StringUtil.ReadUnicodeString(NPOI.Util.IO.LittleEndianInput,System.Int32)">
            InputStream <tt>in</tt> is expected to contain:
            <ol>
            <li>byte is16BitFlag</li>
            <li>byte[]/char[] characterData</li>
            </ol>
            For this encoding, the is16BitFlag is always present even if nChars==0.
            <br/>
            This method should be used when the nChars field is <em>not</em> stored 
            as a ushort immediately before the is16BitFlag. Otherwise, {@link 
            #readUnicodeString(LittleEndianInput)} can be used. 
        </member>
        <member name="M:NPOI.Util.StringUtil.WriteUnicodeString(NPOI.Util.IO.LittleEndianOutput,System.String)">
            OutputStream <tt>out</tt> will get:
            <ol>
            <li>ushort nChars</li>
            <li>byte is16BitFlag</li>
            <li>byte[]/char[] characterData</li>
            </ol>
            For this encoding, the is16BitFlag is always present even if nChars==0.
        </member>
        <member name="M:NPOI.Util.StringUtil.WriteUnicodeStringFlagAndData(NPOI.Util.IO.LittleEndianOutput,System.String)">
            OutputStream <tt>out</tt> will get:
            <ol>
            <li>byte is16BitFlag</li>
            <li>byte[]/char[] characterData</li>
            </ol>
            For this encoding, the is16BitFlag is always present even if nChars==0.
            <br/>
            This method should be used when the nChars field is <em>not</em> stored 
            as a ushort immediately before the is16BitFlag. Otherwise, {@link 
            #writeUnicodeString(LittleEndianOutput, String)} can be used. 
        </member>
        <member name="M:NPOI.Util.StringUtil.GetEncodedSize(System.String)">
            <summary>
            Gets the number of bytes that would be written by WriteUnicodeString(LittleEndianOutput, String)
            </summary>
            <param name="value">The value.</param>
            <returns></returns>
        </member>
        <member name="M:NPOI.Util.StringUtil.IsUnicodeString(System.String)">
             <summary>
             Checks to see if a given String needs to be represented as Unicode
             </summary>
             <param name="value">The value.</param>
             <returns>
             	<c>true</c> if string needs Unicode to be represented.; otherwise, <c>false</c>.
             </returns>
            <remarks>Tony Qu change the logic</remarks>
        </member>
        <member name="M:NPOI.Util.StringUtil.ToHexString(System.String)">
            <summary> 
            Encodes non-US-ASCII characters in a string, good for encoding file names for download 
            http://www.acriticsreview.com/List.aspx?listid=42
            </summary> 
            <param name="s"></param> 
            <returns></returns> 
        </member>
        <member name="M:NPOI.Util.StringUtil.ToHexString(System.Char)">
            <summary> 
            Encodes a non-US-ASCII character. 
            </summary> 
            <param name="chr"></param> 
            <returns></returns> 
        </member>
        <member name="M:NPOI.Util.StringUtil.ToHexString(System.Int16)">
            <summary> 
            Encodes a non-US-ASCII character. 
            </summary> 
            <param name="chr"></param> 
            <returns></returns> 
        </member>
        <member name="M:NPOI.Util.StringUtil.ToHexString(System.Int32)">
            <summary> 
            Encodes a non-US-ASCII character. 
            </summary> 
            <param name="chr"></param> 
            <returns></returns> 
        </member>
        <member name="M:NPOI.Util.StringUtil.NeedToEncode(System.Char)">
            <summary> 
            Determines if the character needs to be encoded. 
            http://www.acriticsreview.com/List.aspx?listid=42
            </summary> 
            <param name="chr"></param> 
            <returns></returns> 
        </member>
        <member name="T:NPOI.Util.ULongField">
            <summary>
            
            </summary>
        </member>
        <member name="M:NPOI.Util.ULongField.#ctor(System.Int32)">
            <summary>
            construct the <see cref="T:NPOI.Util.LongField"/> with its offset into its containing byte array
            </summary>
            <param name="offset">The offset.</param>
        </member>
        <member name="M:NPOI.Util.ULongField.#ctor(System.Int32,System.UInt64)">
            <summary>
            construct the LongField with its offset into its containing
            byte array and initialize its value
            </summary>
            <param name="offset">offset of the field within its byte array</param>
            <param name="value">the initial value</param>
        </member>
        <member name="M:NPOI.Util.ULongField.#ctor(System.Int32,System.Byte[])">
            <summary>
            Construct the <see cref="T:NPOI.Util.LongField"/> class with its offset into its containing
            byte array and initialize its value from its byte array
            </summary>
            <param name="offset">The offset of the field within its byte array</param>
            <param name="data">the byte array to read the value from</param>
        </member>
        <member name="M:NPOI.Util.ULongField.#ctor(System.Int32,System.UInt64,System.Byte[])">
            <summary>
            construct the <see cref="T:NPOI.Util.LongField"/> class with its offset into its containing
            byte array, initialize its value, and write the value to a byte
            array
            </summary>
            <param name="offset">offset of the field within its byte array</param>
            <param name="value">the initial value</param>
            <param name="data">the byte array to write the value to</param>
        </member>
        <member name="P:NPOI.Util.ULongField.Value">
            <summary>
            Getg or sets the LongField's current value
            </summary>
            <value>The current value</value>
        </member>
        <member name="M:NPOI.Util.ULongField.Set(System.UInt64,System.Byte[])">
            <summary>
            set the LongField's current value and write it to a byte array
            </summary>
            <param name="value">value to be set</param>
            <param name="data">the byte array to write the value to</param>
        </member>
        <member name="M:NPOI.Util.ULongField.ReadFromBytes(System.Byte[])">
            <summary>
            set the value from its offset into an array of bytes
            </summary>
            <param name="data">the byte array from which the value is to be read</param>
        </member>
        <member name="M:NPOI.Util.ULongField.ReadFromStream(System.IO.Stream)">
            <summary>
            set the value from an Stream
            </summary>
            <param name="stream">the Stream from which the value is to be</param>
        </member>
        <member name="M:NPOI.Util.ULongField.WriteToBytes(System.Byte[])">
            <summary>
            write the value out to an array of bytes at the appropriate offset
            </summary>
            <param name="data">the array of bytes to which the value is to be written</param>
        </member>
        <member name="M:NPOI.Util.ULongField.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="T:POIFSReaderEvent">
             Class POIFSReaderEvent
            
             @author Marc Johnson (mjohnson at apache dot org)
             @version %I%, %G%
        </member>
        <member name="M:POIFSReaderEvent.#ctor(System.IO.Stream,NPOI.POIFS.FileSystem.POIFSDocumentPath,System.String)">
             package scoped constructor
            
             @param stream the DocumentInputStream, freshly opened
             @param path the path of the document
             @param documentName the name of the document
        </member>
        <member name="P:POIFSReaderEvent.Stream">
            @return the DocumentInputStream, freshly opened
        </member>
        <member name="P:POIFSReaderEvent.Path">
            @return the document's path
        </member>
        <member name="P:POIFSReaderEvent.Name">
            @return the document's name
        </member>
        <member name="T:POIFSReaderListener">
             Interface POIFSReaderListener
            
             @author Marc Johnson (mjohnson at apache dot org)
             @version %I%, %G%
        </member>
        <member name="M:POIFSReaderListener.ProcessPOIFSReaderEvent(POIFSReaderEvent)">
             Process a POIFSReaderEvent that this listener had Registered
             for
            
             @param event the POIFSReaderEvent
        </member>
        <member name="T:POIFSReaderRegistry">
             A registry for POIFSReaderListeners and the DocumentDescriptors of
             the documents those listeners are interested in
            
             @author Marc Johnson (mjohnson at apache dot org)
             @version %I%, %G%
        </member>
        <member name="M:POIFSReaderRegistry.#ctor">
            Construct the registry
        </member>
        <member name="M:POIFSReaderRegistry.RegisterListener(POIFSReaderListener,NPOI.POIFS.FileSystem.POIFSDocumentPath,System.String)">
             Register a POIFSReaderListener for a particular document
            
             @param listener the listener
             @param path the path of the document of interest
             @param documentName the name of the document of interest
        </member>
        <member name="M:POIFSReaderRegistry.RegisterListener(POIFSReaderListener)">
             Register for all documents
            
             @param listener the listener who wants to Get all documents
        </member>
        <member name="M:POIFSReaderRegistry.GetListeners(NPOI.POIFS.FileSystem.POIFSDocumentPath,System.String)">
             Get am iterator of listeners for a particular document
            
             @param path the document path
             @param name the name of the document
            
             @return an Iterator POIFSReaderListeners; may be empty
        </member>
        <member name="T:Import.NPOI.SS.Resource1">
            <summary>
              一个强类型的资源类，用于查找本地化的字符串等。
            </summary>
        </member>
        <member name="P:Import.NPOI.SS.Resource1.ResourceManager">
            <summary>
              返回此类使用的缓存的 ResourceManager 实例。
            </summary>
        </member>
        <member name="P:Import.NPOI.SS.Resource1.Culture">
            <summary>
              使用此强类型资源类，为所有资源查找
              重写当前线程的 CurrentUICulture 属性。
            </summary>
        </member>
        <member name="P:Import.NPOI.SS.Resource1.font_metrics">
            <summary>
              查找 System.Byte[] 类型的本地化资源。
            </summary>
        </member>
        <member name="P:Import.NPOI.SS.Resource1.functionMetadata">
             <summary>
               查找类似 # Licensed to the Apache Software Foundation (ASF) under one or more
            # contributor license agreements.  See the NOTICE file distributed with
            # this work for additional information regarding copyright ownership.
            # The ASF licenses this file to You under the Apache License, Version 2.0
            # (the &quot;License&quot;); you may not use this file except in compliance with
            # the License.  You may obtain a copy of the License at
            # 
            #     http://www.apache.org/licenses/LICENSE-2.0
            # 
            # Unless required by applicable law  [字符串的其余部分被截断]&quot;; 的本地化字符串。
             </summary>
        </member>
        <member name="T:Import.Properties.Resources">
            <summary>
              一个强类型的资源类，用于查找本地化的字符串等。
            </summary>
        </member>
        <member name="P:Import.Properties.Resources.ResourceManager">
            <summary>
              返回此类使用的缓存的 ResourceManager 实例。
            </summary>
        </member>
        <member name="P:Import.Properties.Resources.Culture">
            <summary>
              使用此强类型资源类，为所有资源查找
              重写当前线程的 CurrentUICulture 属性。
            </summary>
        </member>
        <member name="P:Import.Properties.Resources.font_metrics">
            <summary>
              查找 System.Byte[] 类型的本地化资源。
            </summary>
        </member>
        <member name="P:Import.Properties.Resources.functionmetadata">
             <summary>
               查找类似 # Licensed to the Apache Software Foundation (ASF) under one or more
            # contributor license agreements.  See the NOTICE file distributed with
            # this work for additional information regarding copyright ownership.
            # The ASF licenses this file to You under the Apache License, Version 2.0
            # (the &quot;License&quot;); you may not use this file except in compliance with
            # the License.  You may obtain a copy of the License at
            # 
            #     http://www.apache.org/licenses/LICENSE-2.0
            # 
            # Unless required by applicable law  [字符串的其余部分被截断]&quot;; 的本地化字符串。
             </summary>
        </member>
        <member name="T:Amib.Threading.Internal.CallerThreadContext">
            <summary>
            This class stores the caller call context in order to restore
            it when the work item is executed in the thread pool environment. 
            </summary>
        </member>
        <member name="M:Amib.Threading.Internal.CallerThreadContext.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Amib.Threading.Internal.CallerThreadContext.Capture(System.Boolean,System.Boolean)">
            <summary>
            Captures the current thread context
            </summary>
            <returns></returns>
        </member>
        <member name="M:Amib.Threading.Internal.CallerThreadContext.Apply(Amib.Threading.Internal.CallerThreadContext)">
            <summary>
            Applies the thread context stored earlier
            </summary>
            <param name="callerThreadContext"></param>
        </member>
        <member name="T:Amib.Threading.Internal.EventWaitHandleFactory">
            <summary>
            EventWaitHandleFactory class.
            This is a static class that creates AutoResetEvent and ManualResetEvent objects.
            In WindowCE the WaitForMultipleObjects API fails to use the Handle property 
            of XxxResetEvent. It can use only handles that were created by the CreateEvent API.
            Consequently this class creates the needed XxxResetEvent and replaces the handle if
            it's a WindowsCE OS.
            </summary>
        </member>
        <member name="M:Amib.Threading.Internal.EventWaitHandleFactory.CreateAutoResetEvent">
            <summary>
            Create a new AutoResetEvent object
            </summary>
            <returns>Return a new AutoResetEvent object</returns>
        </member>
        <member name="M:Amib.Threading.Internal.EventWaitHandleFactory.CreateManualResetEvent(System.Boolean)">
            <summary>
            Create a new ManualResetEvent object
            </summary>
            <returns>Return a new ManualResetEvent object</returns>
        </member>
        <member name="T:Amib.Threading.Internal.WorkItemStateCallback">
            <summary>
            An internal delegate to call when the WorkItem starts or completes
            </summary>
        </member>
        <member name="M:Amib.Threading.Internal.IInternalWaitableResult.GetWorkItemResult">
            <summary>
            This method is intent for internal use.
            </summary>   
        </member>
        <member name="T:Amib.Threading.Internal.PriorityQueue">
            <summary>
            PriorityQueue class
            This class is not thread safe because we use external lock
            </summary>
        </member>
        <member name="F:Amib.Threading.Internal.PriorityQueue._queuesCount">
            <summary>
            The number of queues, there is one for each type of priority
            </summary>
        </member>
        <member name="F:Amib.Threading.Internal.PriorityQueue._queues">
            <summary>
            Work items queues. There is one for each type of priority
            </summary>
        </member>
        <member name="F:Amib.Threading.Internal.PriorityQueue._workItemsCount">
            <summary>
            The total number of work items within the queues 
            </summary>
        </member>
        <member name="F:Amib.Threading.Internal.PriorityQueue._version">
            <summary>
            Use with IEnumerable interface
            </summary>
        </member>
        <member name="M:Amib.Threading.Internal.PriorityQueue.Enqueue(Amib.Threading.Internal.IHasWorkItemPriority)">
            <summary>
            Enqueue a work item.
            </summary>
            <param name="workItem">A work item</param>
        </member>
        <member name="M:Amib.Threading.Internal.PriorityQueue.Dequeue">
            <summary>
            Dequeque a work item.
            </summary>
            <returns>Returns the next work item</returns>
        </member>
        <member name="M:Amib.Threading.Internal.PriorityQueue.GetNextNonEmptyQueue(System.Int32)">
            <summary>
            Find the next non empty queue starting at queue queueIndex+1
            </summary>
            <param name="queueIndex">The index-1 to start from</param>
            <returns>
            The index of the next non empty queue or -1 if all the queues are empty
            </returns>
        </member>
        <member name="P:Amib.Threading.Internal.PriorityQueue.Count">
            <summary>
            The number of work items 
            </summary>
        </member>
        <member name="M:Amib.Threading.Internal.PriorityQueue.Clear">
            <summary>
            Clear all the work items 
            </summary>
        </member>
        <member name="M:Amib.Threading.Internal.PriorityQueue.GetEnumerator">
            <summary>
            Returns an enumerator to iterate over the work items
            </summary>
            <returns>Returns an enumerator</returns>
        </member>
        <member name="T:Amib.Threading.Internal.PriorityQueue.PriorityQueueEnumerator">
            <summary>
            The class the implements the enumerator
            </summary>
        </member>
        <member name="T:Amib.Threading.Internal.STPPerformanceCounter">
            <summary>
            Summary description for STPPerformanceCounter.
            </summary>
        </member>
        <member name="T:Amib.Threading.Internal.WorkItem">
            <summary>
            Holds a callback delegate and the state for that delegate.
            </summary>
        </member>
        <member name="T:Amib.Threading.Internal.WorkItem.WorkItemState">
            <summary>
            Indicates the state of the work item in the thread pool
            </summary>
        </member>
        <member name="F:Amib.Threading.Internal.WorkItem._callback">
            <summary>
            Callback delegate for the callback.
            </summary>
        </member>
        <member name="F:Amib.Threading.Internal.WorkItem._state">
            <summary>
            State with which to call the callback delegate.
            </summary>
        </member>
        <member name="F:Amib.Threading.Internal.WorkItem._callerContext">
            <summary>
            Stores the caller's context
            </summary>
        </member>
        <member name="F:Amib.Threading.Internal.WorkItem._result">
            <summary>
            Holds the result of the mehtod
            </summary>
        </member>
        <member name="F:Amib.Threading.Internal.WorkItem._exception">
            <summary>
            Hold the exception if the method threw it
            </summary>
        </member>
        <member name="F:Amib.Threading.Internal.WorkItem._workItemState">
            <summary>
            Hold the state of the work item
            </summary>
        </member>
        <member name="F:Amib.Threading.Internal.WorkItem._workItemCompleted">
            <summary>
            A ManualResetEvent to indicate that the result is ready
            </summary>
        </member>
        <member name="F:Amib.Threading.Internal.WorkItem._workItemCompletedRefCount">
            <summary>
            A reference count to the _workItemCompleted. 
            When it reaches to zero _workItemCompleted is Closed
            </summary>
        </member>
        <member name="F:Amib.Threading.Internal.WorkItem._workItemResult">
            <summary>
            Represents the result state of the work item
            </summary>
        </member>
        <member name="F:Amib.Threading.Internal.WorkItem._workItemInfo">
            <summary>
            Work item info
            </summary>
        </member>
        <member name="E:Amib.Threading.Internal.WorkItem._workItemStartedEvent">
            <summary>
            Called when the WorkItem starts
            </summary>
        </member>
        <member name="E:Amib.Threading.Internal.WorkItem._workItemCompletedEvent">
            <summary>
            Called when the WorkItem completes
            </summary>
        </member>
        <member name="F:Amib.Threading.Internal.WorkItem._canceledWorkItemsGroup">
            <summary>
            A reference to an object that indicates whatever the 
            WorkItemsGroup has been canceled
            </summary>
        </member>
        <member name="F:Amib.Threading.Internal.WorkItem._canceledSmartThreadPool">
            <summary>
            A reference to an object that indicates whatever the 
            SmartThreadPool has been canceled
            </summary>
        </member>
        <member name="F:Amib.Threading.Internal.WorkItem._workItemsGroup">
            <summary>
            The work item group this work item belong to.
            </summary>
        </member>
        <member name="F:Amib.Threading.Internal.WorkItem._executingThread">
            <summary>
            The thread that executes this workitem.
            This field is available for the period when the work item is executed, before and after it is null.
            </summary>
        </member>
        <member name="F:Amib.Threading.Internal.WorkItem._expirationTime">
            <summary>
            The absulote time when the work item will be timeout
            </summary>
        </member>
        <member name="F:Amib.Threading.Internal.WorkItem._waitingOnQueueStopwatch">
            <summary>
            Stores how long the work item waited on the stp queue
            </summary>
        </member>
        <member name="F:Amib.Threading.Internal.WorkItem._processingStopwatch">
            <summary>
            Stores how much time it took the work item to execute after it went out of the queue
            </summary>
        </member>
        <member name="M:Amib.Threading.Internal.WorkItem.#ctor(Amib.Threading.IWorkItemsGroup,Amib.Threading.WorkItemInfo,Amib.Threading.WorkItemCallback,System.Object)">
            <summary>
            Initialize the callback holding object.
            </summary>
            <param name="workItemsGroup">The workItemGroup of the workitem</param>
            <param name="workItemInfo">The WorkItemInfo of te workitem</param>
            <param name="callback">Callback delegate for the callback.</param>
            <param name="state">State with which to call the callback delegate.</param>
            
            We assume that the WorkItem object is created within the thread
            that meant to run the callback
        </member>
        <member name="M:Amib.Threading.Internal.WorkItem.StartingWorkItem">
            <summary>
            Change the state of the work item to in progress if it wasn't canceled.
            </summary>
            <returns>
            Return true on success or false in case the work item was canceled.
            If the work item needs to run a post execute then the method will return true.
            </returns>
        </member>
        <member name="M:Amib.Threading.Internal.WorkItem.Execute">
            <summary>
            Execute the work item and the post execute
            </summary>
        </member>
        <member name="M:Amib.Threading.Internal.WorkItem.ExecuteWorkItem">
            <summary>
            Execute the work item
            </summary>
        </member>
        <member name="M:Amib.Threading.Internal.WorkItem.PostExecute">
            <summary>
            Runs the post execute callback
            </summary>
        </member>
        <member name="M:Amib.Threading.Internal.WorkItem.SetResult(System.Object,System.Exception)">
            <summary>
            Set the result of the work item to return
            </summary>
            <param name="result">The result of the work item</param>
            <param name="exception">The exception that was throw while the workitem executed, null
            if there was no exception.</param>
        </member>
        <member name="M:Amib.Threading.Internal.WorkItem.GetWorkItemResult">
            <summary>
            Returns the work item result
            </summary>
            <returns>The work item result</returns>
        </member>
        <member name="M:Amib.Threading.Internal.WorkItem.WaitAll(Amib.Threading.IWaitableResult[],System.Int32,System.Boolean,System.Threading.WaitHandle)">
            <summary>
            Wait for all work items to complete
            </summary>
            <param name="waitableResults">Array of work item result objects</param>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or Timeout.Infinite (-1) to wait indefinitely.</param>
            <param name="exitContext">
            true to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it; otherwise, false. 
            </param>
            <param name="cancelWaitHandle">A cancel wait handle to interrupt the wait if needed</param>
            <returns>
            true when every work item in waitableResults has completed; otherwise false.
            </returns>
        </member>
        <member name="M:Amib.Threading.Internal.WorkItem.WaitAny(Amib.Threading.IWaitableResult[],System.Int32,System.Boolean,System.Threading.WaitHandle)">
            <summary>
            Waits for any of the work items in the specified array to complete, cancel, or timeout
            </summary>
            <param name="waitableResults">Array of work item result objects</param>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or Timeout.Infinite (-1) to wait indefinitely.</param>
            <param name="exitContext">
            true to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it; otherwise, false. 
            </param>
            <param name="cancelWaitHandle">A cancel wait handle to interrupt the wait if needed</param>
            <returns>
            The array index of the work item result that satisfied the wait, or WaitTimeout if no work item result satisfied the wait and a time interval equivalent to millisecondsTimeout has passed or the work item has been canceled.
            </returns>
        </member>
        <member name="M:Amib.Threading.Internal.WorkItem.GetWaitHandles(Amib.Threading.IWaitableResult[],System.Threading.WaitHandle[])">
            <summary>
            Fill an array of wait handles with the work items wait handles.
            </summary>
            <param name="waitableResults">An array of work item results</param>
            <param name="waitHandles">An array of wait handles to fill</param>
        </member>
        <member name="M:Amib.Threading.Internal.WorkItem.ReleaseWaitHandles(Amib.Threading.IWaitableResult[])">
            <summary>
            Release the work items' wait handles
            </summary>
            <param name="waitableResults">An array of work item results</param>
        </member>
        <member name="M:Amib.Threading.Internal.WorkItem.SetWorkItemState(Amib.Threading.Internal.WorkItem.WorkItemState)">
            <summary>
            Sets the work item's state
            </summary>
            <param name="workItemState">The state to set the work item to</param>
        </member>
        <member name="M:Amib.Threading.Internal.WorkItem.SignalComplete(System.Boolean)">
            <summary>
            Signals that work item has been completed or canceled
            </summary>
            <param name="canceled">Indicates that the work item has been canceled</param>
        </member>
        <member name="M:Amib.Threading.Internal.WorkItem.Cancel(System.Boolean)">
            <summary>
            Cancel the work item if it didn't start running yet.
            </summary>
            <returns>Returns true on success or false if the work item is in progress or already completed</returns>
        </member>
        <member name="M:Amib.Threading.Internal.WorkItem.GetResult(System.Int32,System.Boolean,System.Threading.WaitHandle)">
            <summary>
            Get the result of the work item.
            If the work item didn't run yet then the caller waits for the result, timeout, or cancel.
            In case of error the method throws and exception
            </summary>
            <returns>The result of the work item</returns>
        </member>
        <member name="M:Amib.Threading.Internal.WorkItem.GetResult(System.Int32,System.Boolean,System.Threading.WaitHandle,System.Exception@)">
            <summary>
            Get the result of the work item.
            If the work item didn't run yet then the caller waits for the result, timeout, or cancel.
            In case of error the e argument is filled with the exception
            </summary>
            <returns>The result of the work item</returns>
        </member>
        <member name="M:Amib.Threading.Internal.WorkItem.GetWaitHandle">
            <summary>
            A wait handle to wait for completion, cancel, or timeout 
            </summary>
        </member>
        <member name="P:Amib.Threading.Internal.WorkItem.IsCompleted">
            <summary>
            Returns true when the work item has completed or canceled
            </summary>
        </member>
        <member name="P:Amib.Threading.Internal.WorkItem.IsCanceled">
            <summary>
            Returns true when the work item has canceled
            </summary>
        </member>
        <member name="P:Amib.Threading.Internal.WorkItem.WorkItemPriority">
            <summary>
            Returns the priority of the work item
            </summary>
        </member>
        <member name="M:Amib.Threading.Internal.WorkItem.DisposeOfState">
            <summary>
            
            </summary>
        </member>
        <member name="F:Amib.Threading.Internal.WorkItem.WorkItemResult._workItem">
            <summary>
            A back reference to the work item
            </summary>
        </member>
        <member name="P:Amib.Threading.Internal.WorkItem.WorkItemResult.Result">
            <summary>
            Return the result, same as GetResult()
            </summary>
        </member>
        <member name="P:Amib.Threading.Internal.WorkItem.WorkItemResult.Exception">
            <summary>
            Returns the exception if occured otherwise returns null.
            This value is valid only after the work item completed,
            before that it is always null.
            </summary>
        </member>
        <member name="T:Amib.Threading.Internal.WorkItemFactory">
            <summary>
            表示任务信息工厂
            </summary>
        </member>
        <member name="M:Amib.Threading.Internal.WorkItemFactory.CreateWorkItem(Amib.Threading.IWorkItemsGroup,Amib.Threading.WIGStartInfo,Amib.Threading.WorkItemCallback)">
            <summary>
            Create a new work item
            </summary>
            <param name="workItemsGroup">The WorkItemsGroup of this workitem</param>
            <param name="wigStartInfo">Work item group start information</param>
            <param name="callback">A callback to execute</param>
            <returns>Returns a work item</returns>
        </member>
        <member name="M:Amib.Threading.Internal.WorkItemFactory.CreateWorkItem(Amib.Threading.IWorkItemsGroup,Amib.Threading.WIGStartInfo,Amib.Threading.WorkItemCallback,Amib.Threading.WorkItemPriority)">
            <summary>
            Create a new work item
            </summary>
            <param name="workItemsGroup">The WorkItemsGroup of this workitem</param>
            <param name="wigStartInfo">Work item group start information</param>
            <param name="callback">A callback to execute</param>
            <param name="workItemPriority">The priority of the work item</param>
            <returns>Returns a work item</returns>
        </member>
        <member name="M:Amib.Threading.Internal.WorkItemFactory.CreateWorkItem(Amib.Threading.IWorkItemsGroup,Amib.Threading.WIGStartInfo,Amib.Threading.WorkItemInfo,Amib.Threading.WorkItemCallback)">
            <summary>
            Create a new work item
            </summary>
            <param name="workItemsGroup">The WorkItemsGroup of this workitem</param>
            <param name="wigStartInfo">Work item group start information</param>
            <param name="workItemInfo">Work item info</param>
            <param name="callback">A callback to execute</param>
            <returns>Returns a work item</returns>
        </member>
        <member name="M:Amib.Threading.Internal.WorkItemFactory.CreateWorkItem(Amib.Threading.IWorkItemsGroup,Amib.Threading.WIGStartInfo,Amib.Threading.WorkItemCallback,System.Object)">
            <summary>
            Create a new work item
            </summary>
            <param name="workItemsGroup">The WorkItemsGroup of this workitem</param>
            <param name="wigStartInfo">Work item group start information</param>
            <param name="callback">A callback to execute</param>
            <param name="state">
            The context object of the work item. Used for passing arguments to the work item. 
            </param>
            <returns>Returns a work item</returns>
        </member>
        <member name="M:Amib.Threading.Internal.WorkItemFactory.CreateWorkItem(Amib.Threading.IWorkItemsGroup,Amib.Threading.WIGStartInfo,Amib.Threading.WorkItemCallback,System.Object,Amib.Threading.WorkItemPriority)">
            <summary>
            Create a new work item
            </summary>
            <param name="workItemsGroup">The work items group</param>
            <param name="wigStartInfo">Work item group start information</param>
            <param name="callback">A callback to execute</param>
            <param name="state">
            The context object of the work item. Used for passing arguments to the work item. 
            </param>
            <param name="workItemPriority">The work item priority</param>
            <returns>Returns a work item</returns>
        </member>
        <member name="M:Amib.Threading.Internal.WorkItemFactory.CreateWorkItem(Amib.Threading.IWorkItemsGroup,Amib.Threading.WIGStartInfo,Amib.Threading.WorkItemInfo,Amib.Threading.WorkItemCallback,System.Object)">
            <summary>
            Create a new work item
            </summary>
            <param name="workItemsGroup">The work items group</param>
            <param name="wigStartInfo">Work item group start information</param>
            <param name="workItemInfo">Work item information</param>
            <param name="callback">A callback to execute</param>
            <param name="state">
            The context object of the work item. Used for passing arguments to the work item. 
            </param>
            <returns>Returns a work item</returns>
        </member>
        <member name="M:Amib.Threading.Internal.WorkItemFactory.CreateWorkItem(Amib.Threading.IWorkItemsGroup,Amib.Threading.WIGStartInfo,Amib.Threading.WorkItemCallback,System.Object,Amib.Threading.PostExecuteWorkItemCallback)">
            <summary>
            Create a new work item
            </summary>
            <param name="workItemsGroup">The work items group</param>
            <param name="wigStartInfo">Work item group start information</param>
            <param name="callback">A callback to execute</param>
            <param name="state">
            The context object of the work item. Used for passing arguments to the work item. 
            </param>
            <param name="postExecuteWorkItemCallback">
            A delegate to call after the callback completion
            </param>
            <returns>Returns a work item</returns>
        </member>
        <member name="M:Amib.Threading.Internal.WorkItemFactory.CreateWorkItem(Amib.Threading.IWorkItemsGroup,Amib.Threading.WIGStartInfo,Amib.Threading.WorkItemCallback,System.Object,Amib.Threading.PostExecuteWorkItemCallback,Amib.Threading.WorkItemPriority)">
            <summary>
            Create a new work item
            </summary>
            <param name="workItemsGroup">The work items group</param>
            <param name="wigStartInfo">Work item group start information</param>
            <param name="callback">A callback to execute</param>
            <param name="state">
            The context object of the work item. Used for passing arguments to the work item. 
            </param>
            <param name="postExecuteWorkItemCallback">
            A delegate to call after the callback completion
            </param>
            <param name="workItemPriority">The work item priority</param>
            <returns>Returns a work item</returns>
        </member>
        <member name="M:Amib.Threading.Internal.WorkItemFactory.CreateWorkItem(Amib.Threading.IWorkItemsGroup,Amib.Threading.WIGStartInfo,Amib.Threading.WorkItemCallback,System.Object,Amib.Threading.PostExecuteWorkItemCallback,Amib.Threading.CallToPostExecute)">
            <summary>
            Create a new work item
            </summary>
            <param name="workItemsGroup">The work items group</param>
            <param name="wigStartInfo">Work item group start information</param>
            <param name="callback">A callback to execute</param>
            <param name="state">
            The context object of the work item. Used for passing arguments to the work item. 
            </param>
            <param name="postExecuteWorkItemCallback">
            A delegate to call after the callback completion
            </param>
            <param name="callToPostExecute">Indicates on which cases to call to the post execute callback</param>
            <returns>Returns a work item</returns>
        </member>
        <member name="M:Amib.Threading.Internal.WorkItemFactory.CreateWorkItem(Amib.Threading.IWorkItemsGroup,Amib.Threading.WIGStartInfo,Amib.Threading.WorkItemCallback,System.Object,Amib.Threading.PostExecuteWorkItemCallback,Amib.Threading.CallToPostExecute,Amib.Threading.WorkItemPriority)">
            <summary>
            Create a new work item
            </summary>
            <param name="workItemsGroup">The work items group</param>
            <param name="wigStartInfo">Work item group start information</param>
            <param name="callback">A callback to execute</param>
            <param name="state">
            The context object of the work item. Used for passing arguments to the work item. 
            </param>
            <param name="postExecuteWorkItemCallback">
            A delegate to call after the callback completion
            </param>
            <param name="callToPostExecute">Indicates on which cases to call to the post execute callback</param>
            <param name="workItemPriority">The work item priority</param>
            <returns>Returns a work item</returns>
        </member>
        <member name="T:Amib.Threading.Internal.WorkItemsGroup">
            <summary>
            Summary description for WorkItemsGroup.
            </summary>
        </member>
        <member name="F:Amib.Threading.Internal.WorkItemsGroup._stp">
            <summary>
            A reference to the SmartThreadPool instance that created this 
            WorkItemsGroup.
            </summary>
        </member>
        <member name="E:Amib.Threading.Internal.WorkItemsGroup._onIdle">
            <summary>
            The OnIdle event
            </summary>
        </member>
        <member name="F:Amib.Threading.Internal.WorkItemsGroup._isSuspended">
            <summary>
            A flag to indicate if the Work Items Group is now suspended.
            </summary>
        </member>
        <member name="F:Amib.Threading.Internal.WorkItemsGroup._concurrency">
            <summary>
            Defines how many work items of this WorkItemsGroup can run at once.
            </summary>
        </member>
        <member name="F:Amib.Threading.Internal.WorkItemsGroup._workItemsQueue">
            <summary>
            Priority queue to hold work items before they are passed 
            to the SmartThreadPool.
            </summary>
        </member>
        <member name="F:Amib.Threading.Internal.WorkItemsGroup._workItemsInStpQueue">
            <summary>
            Indicate how many work items are waiting in the SmartThreadPool
            queue.
            This value is used to apply the concurrency.
            </summary>
        </member>
        <member name="F:Amib.Threading.Internal.WorkItemsGroup._workItemsExecutingInStp">
            <summary>
            Indicate how many work items are currently running in the SmartThreadPool.
            This value is used with the Cancel, to calculate if we can send new 
            work items to the STP.
            </summary>
        </member>
        <member name="F:Amib.Threading.Internal.WorkItemsGroup._workItemsGroupStartInfo">
            <summary>
            WorkItemsGroup start information
            </summary>
        </member>
        <member name="F:Amib.Threading.Internal.WorkItemsGroup._isIdleWaitHandle">
            <summary>
            Signaled when all of the WorkItemsGroup's work item completed.
            </summary>
        </member>
        <member name="F:Amib.Threading.Internal.WorkItemsGroup._canceledWorkItemsGroup">
            <summary>
            A common object for all the work items that this work items group
            generate so we can mark them to cancel in O(1)
            </summary>
        </member>
        <member name="P:Amib.Threading.Internal.WorkItemsGroup.WIGStartInfo">
            <summary>
            WorkItemsGroup start information
            </summary>
        </member>
        <member name="M:Amib.Threading.Internal.WorkItemsGroup.Start">
            <summary>
            Start the Work Items Group if it was started suspended
            </summary>
        </member>
        <member name="M:Amib.Threading.Internal.WorkItemsGroup.WaitForIdle(System.Int32)">
            <summary>
            Wait for the thread pool to be idle
            </summary>
        </member>
        <member name="F:Amib.Threading.Internal.WorkItemsGroupBase._name">
            <summary>
            Contains the name of this instance of SmartThreadPool.
            Can be changed by the user.
            </summary>
        </member>
        <member name="P:Amib.Threading.Internal.WorkItemsGroupBase.Name">
            <summary>
            Get/Set the name of the SmartThreadPool/WorkItemsGroup instance
            </summary>
        </member>
        <member name="M:Amib.Threading.Internal.WorkItemsGroupBase.Cancel">
            <summary>
            Cancel all the work items.
            Same as Cancel(false)
            </summary>
        </member>
        <member name="M:Amib.Threading.Internal.WorkItemsGroupBase.WaitForIdle">
            <summary>
            Wait for the SmartThreadPool/WorkItemsGroup to be idle
            </summary>
        </member>
        <member name="M:Amib.Threading.Internal.WorkItemsGroupBase.WaitForIdle(System.TimeSpan)">
            <summary>
            Wait for the SmartThreadPool/WorkItemsGroup to be idle
            </summary>
        </member>
        <member name="P:Amib.Threading.Internal.WorkItemsGroupBase.IsIdle">
            <summary>
            IsIdle is true when there are no work items running or queued.
            </summary>
        </member>
        <member name="M:Amib.Threading.Internal.WorkItemsGroupBase.QueueWorkItem(Amib.Threading.WorkItemCallback)">
            <summary>
            Queue a work item
            </summary>
            <param name="callback">A callback to execute</param>
            <returns>Returns a work item result</returns>
        </member>
        <member name="M:Amib.Threading.Internal.WorkItemsGroupBase.QueueWorkItem(Amib.Threading.WorkItemCallback,Amib.Threading.WorkItemPriority)">
            <summary>
            Queue a work item
            </summary>
            <param name="callback">A callback to execute</param>
            <param name="workItemPriority">The priority of the work item</param>
            <returns>Returns a work item result</returns>
        </member>
        <member name="M:Amib.Threading.Internal.WorkItemsGroupBase.QueueWorkItem(Amib.Threading.WorkItemInfo,Amib.Threading.WorkItemCallback)">
            <summary>
            Queue a work item
            </summary>
            <param name="workItemInfo">Work item info</param>
            <param name="callback">A callback to execute</param>
            <returns>Returns a work item result</returns>
        </member>
        <member name="M:Amib.Threading.Internal.WorkItemsGroupBase.QueueWorkItem(Amib.Threading.WorkItemCallback,System.Object)">
            <summary>
            Queue a work item
            </summary>
            <param name="callback">A callback to execute</param>
            <param name="state">
            The context object of the work item. Used for passing arguments to the work item. 
            </param>
            <returns>Returns a work item result</returns>
        </member>
        <member name="M:Amib.Threading.Internal.WorkItemsGroupBase.QueueWorkItem(Amib.Threading.WorkItemCallback,System.Object,Amib.Threading.WorkItemPriority)">
            <summary>
            Queue a work item
            </summary>
            <param name="callback">A callback to execute</param>
            <param name="state">
            The context object of the work item. Used for passing arguments to the work item. 
            </param>
            <param name="workItemPriority">The work item priority</param>
            <returns>Returns a work item result</returns>
        </member>
        <member name="M:Amib.Threading.Internal.WorkItemsGroupBase.QueueWorkItem(Amib.Threading.WorkItemInfo,Amib.Threading.WorkItemCallback,System.Object)">
            <summary>
            Queue a work item
            </summary>
            <param name="workItemInfo">Work item information</param>
            <param name="callback">A callback to execute</param>
            <param name="state">
            The context object of the work item. Used for passing arguments to the work item. 
            </param>
            <returns>Returns a work item result</returns>
        </member>
        <member name="M:Amib.Threading.Internal.WorkItemsGroupBase.QueueWorkItem(Amib.Threading.WorkItemCallback,System.Object,Amib.Threading.PostExecuteWorkItemCallback)">
            <summary>
            Queue a work item
            </summary>
            <param name="callback">A callback to execute</param>
            <param name="state">
            The context object of the work item. Used for passing arguments to the work item. 
            </param>
            <param name="postExecuteWorkItemCallback">
            A delegate to call after the callback completion
            </param>
            <returns>Returns a work item result</returns>
        </member>
        <member name="M:Amib.Threading.Internal.WorkItemsGroupBase.QueueWorkItem(Amib.Threading.WorkItemCallback,System.Object,Amib.Threading.PostExecuteWorkItemCallback,Amib.Threading.WorkItemPriority)">
            <summary>
            Queue a work item
            </summary>
            <param name="callback">A callback to execute</param>
            <param name="state">
            The context object of the work item. Used for passing arguments to the work item. 
            </param>
            <param name="postExecuteWorkItemCallback">
            A delegate to call after the callback completion
            </param>
            <param name="workItemPriority">The work item priority</param>
            <returns>Returns a work item result</returns>
        </member>
        <member name="M:Amib.Threading.Internal.WorkItemsGroupBase.QueueWorkItem(Amib.Threading.WorkItemCallback,System.Object,Amib.Threading.PostExecuteWorkItemCallback,Amib.Threading.CallToPostExecute)">
            <summary>
            Queue a work item
            </summary>
            <param name="callback">A callback to execute</param>
            <param name="state">
            The context object of the work item. Used for passing arguments to the work item. 
            </param>
            <param name="postExecuteWorkItemCallback">
            A delegate to call after the callback completion
            </param>
            <param name="callToPostExecute">Indicates on which cases to call to the post execute callback</param>
            <returns>Returns a work item result</returns>
        </member>
        <member name="M:Amib.Threading.Internal.WorkItemsGroupBase.QueueWorkItem(Amib.Threading.WorkItemCallback,System.Object,Amib.Threading.PostExecuteWorkItemCallback,Amib.Threading.CallToPostExecute,Amib.Threading.WorkItemPriority)">
            <summary>
            Queue a work item
            </summary>
            <param name="callback">A callback to execute</param>
            <param name="state">
            The context object of the work item. Used for passing arguments to the work item. 
            </param>
            <param name="postExecuteWorkItemCallback">
            A delegate to call after the callback completion
            </param>
            <param name="callToPostExecute">Indicates on which cases to call to the post execute callback</param>
            <param name="workItemPriority">The work item priority</param>
            <returns>Returns a work item result</returns>
        </member>
        <member name="T:Amib.Threading.Internal.WorkItemsQueue">
            <summary>
            WorkItemsQueue class.
            </summary>
        </member>
        <member name="F:Amib.Threading.Internal.WorkItemsQueue._headWaiterEntry">
            <summary>
            Waiters queue (implemented as stack).
            </summary>
        </member>
        <member name="F:Amib.Threading.Internal.WorkItemsQueue._waitersCount">
            <summary>
            Waiters count
            </summary>
        </member>
        <member name="F:Amib.Threading.Internal.WorkItemsQueue._workItems">
            <summary>
            Work items queue
            </summary>
        </member>
        <member name="F:Amib.Threading.Internal.WorkItemsQueue._isWorkItemsQueueActive">
            <summary>
            Indicate that work items are allowed to be queued
            </summary>
        </member>
        <member name="P:Amib.Threading.Internal.WorkItemsQueue.CurrentWaiterEntry">
            <summary>
            Each thread in the thread pool keeps its own waiter entry.
            </summary>
        </member>
        <member name="F:Amib.Threading.Internal.WorkItemsQueue._isDisposed">
            <summary>
            A flag that indicates if the WorkItemsQueue has been disposed.
            </summary>
        </member>
        <member name="P:Amib.Threading.Internal.WorkItemsQueue.Count">
            <summary>
            Returns the current number of work items in the queue
            </summary>
        </member>
        <member name="P:Amib.Threading.Internal.WorkItemsQueue.WaitersCount">
            <summary>
            Returns the current number of waiters
            </summary>
        </member>
        <member name="M:Amib.Threading.Internal.WorkItemsQueue.EnqueueWorkItem(Amib.Threading.Internal.WorkItem)">
            <summary>
            Enqueue a work item to the queue.
            </summary>
        </member>
        <member name="M:Amib.Threading.Internal.WorkItemsQueue.DequeueWorkItem(System.Int32,System.Threading.WaitHandle)">
            <summary>
            Waits for a work item or exits on timeout or cancel
            </summary>
            <param name="millisecondsTimeout">Timeout in milliseconds</param>
            <param name="cancelEvent">Cancel wait handle</param>
            <returns>Returns true if the resource was granted</returns>
        </member>
        <member name="M:Amib.Threading.Internal.WorkItemsQueue.Cleanup">
            <summary>
            Cleanup the work items queue, hence no more work 
            items are allowed to be queue
            </summary>
        </member>
        <member name="M:Amib.Threading.Internal.WorkItemsQueue.GetStates">
            <summary>
            获取一个状态信息集合
            </summary>
            <returns></returns>
        </member>
        <member name="M:Amib.Threading.Internal.WorkItemsQueue.GetThreadWaiterEntry">
            <summary>
            Returns the WaiterEntry of the current thread
            </summary>
            <returns></returns>
            In order to avoid creation and destuction of WaiterEntry
            objects each thread has its own WaiterEntry object.
        </member>
        <member name="M:Amib.Threading.Internal.WorkItemsQueue.PushWaiter(Amib.Threading.Internal.WorkItemsQueue.WaiterEntry)">
            <summary>
            Push a new waiter into the waiter's stack
            </summary>
            <param name="newWaiterEntry">A waiter to put in the stack</param>
        </member>
        <member name="M:Amib.Threading.Internal.WorkItemsQueue.PopWaiter">
            <summary>
            Pop a waiter from the waiter's stack
            </summary>
            <returns>Returns the first waiter in the stack</returns>
        </member>
        <member name="M:Amib.Threading.Internal.WorkItemsQueue.RemoveWaiter(Amib.Threading.Internal.WorkItemsQueue.WaiterEntry,System.Boolean)">
            <summary>
            Remove a waiter from the stack
            </summary>
            <param name="waiterEntry">A waiter entry to remove</param>
            <param name="popDecrement">If true the waiter count is always decremented</param>
        </member>
        <member name="T:Amib.Threading.Internal.WorkItemsQueue.WaiterEntry">
            <summary>
            
            </summary>
        </member>
        <member name="F:Amib.Threading.Internal.WorkItemsQueue.WaiterEntry._waitHandle">
            <summary>
            Event to signal the waiter that it got the work item.
            </summary>
        </member>
        <member name="F:Amib.Threading.Internal.WorkItemsQueue.WaiterEntry._isTimedout">
            <summary>
            Flag to know if this waiter already quited from the queue 
            because of a timeout.
            </summary>
        </member>
        <member name="F:Amib.Threading.Internal.WorkItemsQueue.WaiterEntry._isSignaled">
            <summary>
            Flag to know if the waiter was signaled and got a work item. 
            </summary>
        </member>
        <member name="F:Amib.Threading.Internal.WorkItemsQueue.WaiterEntry._workItem">
            <summary>
            A work item that passed directly to the waiter withou going 
            through the queue
            </summary>
        </member>
        <member name="M:Amib.Threading.Internal.WorkItemsQueue.WaiterEntry.#ctor">
            <summary>
            对象初始化
            </summary>
        </member>
        <member name="P:Amib.Threading.Internal.WorkItemsQueue.WaiterEntry.WaitHandle">
            <summary>
            获取当前等待信息的句柄信息
            </summary>
        </member>
        <member name="P:Amib.Threading.Internal.WorkItemsQueue.WaiterEntry.WorkItem">
            <summary>
            获取当前的工作任务项信息
            </summary>
        </member>
        <member name="M:Amib.Threading.Internal.WorkItemsQueue.WaiterEntry.Signal(Amib.Threading.Internal.WorkItem)">
            <summary>
            Signal the waiter that it got a work item.
            </summary>
            <returns>Return true on success</returns>
            The method fails if Timeout() preceded its call
        </member>
        <member name="M:Amib.Threading.Internal.WorkItemsQueue.WaiterEntry.Timeout">
            <summary>
            Mark the wait entry that it has been timed out
            </summary>
            <returns>Return true on success</returns>
            The method fails if Signal() preceded its call
        </member>
        <member name="M:Amib.Threading.Internal.WorkItemsQueue.WaiterEntry.Reset">
            <summary>
            Reset the wait entry so it can be used again
            </summary>
        </member>
        <member name="M:Amib.Threading.Internal.WorkItemsQueue.WaiterEntry.Close">
            <summary>
            Free resources
            </summary>
        </member>
        <member name="M:Amib.Threading.Internal.WorkItemsQueue.WaiterEntry.Dispose">
            <summary>
            释放使用的资源对象信息
            </summary>
        </member>
        <member name="M:Amib.Threading.Internal.WorkItemsQueue.Dispose">
            <summary>
            释放使用的资源对象信息
            </summary>
        </member>
        <member name="T:Amib.Threading.WorkItemCancelException">
            <summary>
            Represents an exception in case IWorkItemResult.GetResult has been canceled
            </summary>
            <summary>
            Represents an exception in case IWorkItemResult.GetResult has been canceled
            </summary>
        </member>
        <member name="T:Amib.Threading.WorkItemTimeoutException">
            <summary>
            Represents an exception in case IWorkItemResult.GetResult has been timed out
            </summary>
            <summary>
            Represents an exception in case IWorkItemResult.GetResult has been timed out
            </summary>
        </member>
        <member name="T:Amib.Threading.WorkItemResultException">
            <summary>
            Represents an exception in case IWorkItemResult.GetResult has been timed out
            </summary>
            <summary>
            Represents an exception in case IWorkItemResult.GetResult has been timed out
            </summary>
        </member>
        <member name="T:Amib.Threading.QueueRejectedException">
            <summary>
            Represents an exception in case the STP queue is full and work item cannot be queued.
            Relevant when the STP has a queue size limit
            </summary>
            <summary>
            Represents an exception in case IWorkItemResult.GetResult has been timed out
            </summary>
        </member>
        <member name="T:Amib.Threading.WorkItemCallback">
            <summary>
            A delegate that represents the method to run as the work item
            </summary>
            <param name="state">A state object for the method to run</param>
        </member>
        <member name="T:Amib.Threading.PostExecuteWorkItemCallback">
            <summary>
            A delegate to call after the WorkItemCallback completed
            </summary>
            <param name="wir">The work item result object</param>
        </member>
        <member name="T:Amib.Threading.PostExecuteWorkItemCallback`1">
            <summary>
            A delegate to call after the WorkItemCallback completed
            </summary>
            <param name="wir">The work item result object</param>
        </member>
        <member name="T:Amib.Threading.WorkItemsGroupIdleHandler">
            <summary>
            A delegate to call when a WorkItemsGroup becomes idle
            </summary>
            <param name="workItemsGroup">A reference to the WorkItemsGroup that became idle</param>
        </member>
        <member name="T:Amib.Threading.ThreadInitializationHandler">
            <summary>
            A delegate to call after a thread is created, but before 
            it's first use.
            </summary>
        </member>
        <member name="T:Amib.Threading.ThreadTerminationHandler">
            <summary>
            A delegate to call when a thread is about to exit, after 
            it is no longer belong to the pool.
            </summary>
        </member>
        <member name="T:Amib.Threading.WorkItemPriority">
            <summary>
            Defines the availeable priorities of a work item.
            The higher the priority a work item has, the sooner
            it will be executed.
            </summary>
        </member>
        <member name="T:Amib.Threading.IWorkItemsGroup">
            <summary>
            IWorkItemsGroup interface
            Created by SmartThreadPool.CreateWorkItemsGroup()
            </summary>
        </member>
        <member name="P:Amib.Threading.IWorkItemsGroup.Name">
            <summary>
            Get/Set the name of the WorkItemsGroup
            </summary>
        </member>
        <member name="P:Amib.Threading.IWorkItemsGroup.Concurrency">
            <summary>
            Get/Set the maximum number of workitem that execute cocurrency on the thread pool
            </summary>
        </member>
        <member name="P:Amib.Threading.IWorkItemsGroup.WaitingCallbacks">
            <summary>
            Get the number of work items waiting in the queue.
            </summary>
        </member>
        <member name="P:Amib.Threading.IWorkItemsGroup.InUseThreads">
            <summary>
            Get the number of currently executing work items
            </summary>
        </member>
        <member name="M:Amib.Threading.IWorkItemsGroup.GetStates">
            <summary>
            Get an array with all the state objects of the currently running items.
            The array represents a snap shot and impact performance.
            </summary>
        </member>
        <member name="P:Amib.Threading.IWorkItemsGroup.WIGStartInfo">
            <summary>
            Get the WorkItemsGroup start information
            </summary>
        </member>
        <member name="M:Amib.Threading.IWorkItemsGroup.Start">
            <summary>
            Starts to execute work items
            </summary>
        </member>
        <member name="M:Amib.Threading.IWorkItemsGroup.Cancel">
            <summary>
            Cancel all the work items.
            Same as Cancel(false)
            </summary>
        </member>
        <member name="M:Amib.Threading.IWorkItemsGroup.Cancel(System.Boolean)">
            <summary>
            Cancel all work items using thread abortion
            </summary>
            <param name="abortExecution">True to stop work items by raising ThreadAbortException</param>
        </member>
        <member name="M:Amib.Threading.IWorkItemsGroup.WaitForIdle">
            <summary>
            Wait for all work item to complete.
            </summary>
        </member>
        <member name="M:Amib.Threading.IWorkItemsGroup.WaitForIdle(System.TimeSpan)">
            <summary>
            Wait for all work item to complete, until timeout expired
            </summary>
            <param name="timeout">How long to wait for the work items to complete</param>
            <returns>Returns true if work items completed within the timeout, otherwise false.</returns>
        </member>
        <member name="M:Amib.Threading.IWorkItemsGroup.WaitForIdle(System.Int32)">
            <summary>
            Wait for all work item to complete, until timeout expired
            </summary>
            <param name="millisecondsTimeout">How long to wait for the work items to complete in milliseconds</param>
            <returns>Returns true if work items completed within the timeout, otherwise false.</returns>
        </member>
        <member name="P:Amib.Threading.IWorkItemsGroup.IsIdle">
            <summary>
            IsIdle is true when there are no work items running or queued.
            </summary>
        </member>
        <member name="E:Amib.Threading.IWorkItemsGroup.OnIdle">
            <summary>
            This event is fired when all work items are completed.
            (When IsIdle changes to true)
            This event only work on WorkItemsGroup. On SmartThreadPool
            it throws the NotImplementedException.
            </summary>
        </member>
        <member name="M:Amib.Threading.IWorkItemsGroup.QueueWorkItem(Amib.Threading.WorkItemCallback)">
            <summary>
            Queue a work item
            </summary>
            <param name="callback">A callback to execute</param>
            <returns>Returns a work item result</returns>        
        </member>
        <member name="M:Amib.Threading.IWorkItemsGroup.QueueWorkItem(Amib.Threading.WorkItemCallback,Amib.Threading.WorkItemPriority)">
            <summary>
            Queue a work item
            </summary>
            <param name="callback">A callback to execute</param>
            <param name="workItemPriority">The priority of the work item</param>
            <returns>Returns a work item result</returns>
        </member>
        <member name="M:Amib.Threading.IWorkItemsGroup.QueueWorkItem(Amib.Threading.WorkItemCallback,System.Object)">
            <summary>
            Queue a work item
            </summary>
            <param name="callback">A callback to execute</param>
            <param name="state">
            The context object of the work item. Used for passing arguments to the work item. 
            </param>
            <returns>Returns a work item result</returns>
        </member>
        <member name="M:Amib.Threading.IWorkItemsGroup.QueueWorkItem(Amib.Threading.WorkItemCallback,System.Object,Amib.Threading.WorkItemPriority)">
            <summary>
            Queue a work item
            </summary>
            <param name="callback">A callback to execute</param>
            <param name="state">
            The context object of the work item. Used for passing arguments to the work item. 
            </param>
            <param name="workItemPriority">The work item priority</param>
            <returns>Returns a work item result</returns>
        </member>
        <member name="M:Amib.Threading.IWorkItemsGroup.QueueWorkItem(Amib.Threading.WorkItemCallback,System.Object,Amib.Threading.PostExecuteWorkItemCallback)">
            <summary>
            Queue a work item
            </summary>
            <param name="callback">A callback to execute</param>
            <param name="state">
            The context object of the work item. Used for passing arguments to the work item. 
            </param>
            <param name="postExecuteWorkItemCallback">
            A delegate to call after the callback completion
            </param>
            <returns>Returns a work item result</returns>
        </member>
        <member name="M:Amib.Threading.IWorkItemsGroup.QueueWorkItem(Amib.Threading.WorkItemCallback,System.Object,Amib.Threading.PostExecuteWorkItemCallback,Amib.Threading.WorkItemPriority)">
            <summary>
            Queue a work item
            </summary>
            <param name="callback">A callback to execute</param>
            <param name="state">
            The context object of the work item. Used for passing arguments to the work item. 
            </param>
            <param name="postExecuteWorkItemCallback">
            A delegate to call after the callback completion
            </param>
            <param name="workItemPriority">The work item priority</param>
            <returns>Returns a work item result</returns>
        </member>
        <member name="M:Amib.Threading.IWorkItemsGroup.QueueWorkItem(Amib.Threading.WorkItemCallback,System.Object,Amib.Threading.PostExecuteWorkItemCallback,Amib.Threading.CallToPostExecute)">
            <summary>
            Queue a work item
            </summary>
            <param name="callback">A callback to execute</param>
            <param name="state">
            The context object of the work item. Used for passing arguments to the work item. 
            </param>
            <param name="postExecuteWorkItemCallback">
            A delegate to call after the callback completion
            </param>
            <param name="callToPostExecute">Indicates on which cases to call to the post execute callback</param>
            <returns>Returns a work item result</returns>
        </member>
        <member name="M:Amib.Threading.IWorkItemsGroup.QueueWorkItem(Amib.Threading.WorkItemCallback,System.Object,Amib.Threading.PostExecuteWorkItemCallback,Amib.Threading.CallToPostExecute,Amib.Threading.WorkItemPriority)">
            <summary>
            Queue a work item
            </summary>
            <param name="callback">A callback to execute</param>
            <param name="state">
            The context object of the work item. Used for passing arguments to the work item. 
            </param>
            <param name="postExecuteWorkItemCallback">
            A delegate to call after the callback completion
            </param>
            <param name="callToPostExecute">Indicates on which cases to call to the post execute callback</param>
            <param name="workItemPriority">The work item priority</param>
            <returns>Returns a work item result</returns>
        </member>
        <member name="M:Amib.Threading.IWorkItemsGroup.QueueWorkItem(Amib.Threading.WorkItemInfo,Amib.Threading.WorkItemCallback)">
            <summary>
            Queue a work item
            </summary>
            <param name="workItemInfo">Work item info</param>
            <param name="callback">A callback to execute</param>
            <returns>Returns a work item result</returns>
        </member>
        <member name="M:Amib.Threading.IWorkItemsGroup.QueueWorkItem(Amib.Threading.WorkItemInfo,Amib.Threading.WorkItemCallback,System.Object)">
            <summary>
            Queue a work item
            </summary>
            <param name="workItemInfo">Work item information</param>
            <param name="callback">A callback to execute</param>
            <param name="state">
            The context object of the work item. Used for passing arguments to the work item. 
            </param>
            <returns>Returns a work item result</returns>
        </member>
        <member name="M:Amib.Threading.IWorkItemsGroup.QueueWorkItem(Amib.Threading.Action,Amib.Threading.WorkItemPriority)">
            <summary>
            Queue a work item.
            </summary>
            <returns>Returns a IWorkItemResult object, but its GetResult() will always return null</returns>
        </member>
        <member name="M:Amib.Threading.IWorkItemsGroup.QueueWorkItem``1(System.Action{``0},``0,Amib.Threading.WorkItemPriority)">
            <summary>
            Queue a work item.
            </summary>
            <returns>Returns a IWorkItemResult object, but its GetResult() will always return null</returns>
        </member>
        <member name="M:Amib.Threading.IWorkItemsGroup.QueueWorkItem``2(Amib.Threading.Action{``0,``1},``0,``1,Amib.Threading.WorkItemPriority)">
            <summary>
            Queue a work item.
            </summary>
            <returns>Returns a IWorkItemResult object, but its GetResult() will always return null</returns>
        </member>
        <member name="M:Amib.Threading.IWorkItemsGroup.QueueWorkItem``3(Amib.Threading.Action{``0,``1,``2},``0,``1,``2,Amib.Threading.WorkItemPriority)">
            <summary>
            Queue a work item.
            </summary>
            <returns>Returns a IWorkItemResult object, but its GetResult() will always return null</returns>
        </member>
        <member name="M:Amib.Threading.IWorkItemsGroup.QueueWorkItem``4(Amib.Threading.Action{``0,``1,``2,``3},``0,``1,``2,``3,Amib.Threading.WorkItemPriority)">
            <summary>
            Queue a work item.
            </summary>
            <returns>Returns a IWorkItemResult object, but its GetResult() will always return null</returns>
        </member>
        <member name="M:Amib.Threading.IWorkItemsGroup.QueueWorkItem``1(Amib.Threading.Func{``0},Amib.Threading.WorkItemPriority)">
            <summary>
            Queue a work item.
            </summary>
            <returns>Returns a IWorkItemResult&lt;TResult&gt; object. 
            its GetResult() returns a TResult object</returns>
        </member>
        <member name="M:Amib.Threading.IWorkItemsGroup.QueueWorkItem``2(Amib.Threading.Func{``0,``1},``0,Amib.Threading.WorkItemPriority)">
            <summary>
            Queue a work item.
            </summary>
            <returns>Returns a IWorkItemResult&lt;TResult&gt; object. 
            its GetResult() returns a TResult object</returns>
        </member>
        <member name="M:Amib.Threading.IWorkItemsGroup.QueueWorkItem``3(Amib.Threading.Func{``0,``1,``2},``0,``1,Amib.Threading.WorkItemPriority)">
            <summary>
            Queue a work item.
            </summary>
            <returns>Returns a IWorkItemResult&lt;TResult&gt; object. 
            its GetResult() returns a TResult object</returns>
        </member>
        <member name="M:Amib.Threading.IWorkItemsGroup.QueueWorkItem``4(Amib.Threading.Func{``0,``1,``2,``3},``0,``1,``2,Amib.Threading.WorkItemPriority)">
            <summary>
            Queue a work item.
            </summary>
            <returns>Returns a IWorkItemResult&lt;TResult&gt; object. 
            its GetResult() returns a TResult object</returns>
        </member>
        <member name="M:Amib.Threading.IWorkItemsGroup.QueueWorkItem``5(Amib.Threading.Func{``0,``1,``2,``3,``4},``0,``1,``2,``3,Amib.Threading.WorkItemPriority)">
            <summary>
            Queue a work item.
            </summary>
            <returns>Returns a IWorkItemResult&lt;TResult&gt; object. 
            its GetResult() returns a TResult object</returns>
        </member>
        <member name="F:Amib.Threading.CallToPostExecute.Never">
            <summary>
            Never call to the PostExecute call back
            </summary>
        </member>
        <member name="F:Amib.Threading.CallToPostExecute.WhenWorkItemCanceled">
            <summary>
            Call to the PostExecute only when the work item is cancelled
            </summary>
        </member>
        <member name="F:Amib.Threading.CallToPostExecute.WhenWorkItemNotCanceled">
            <summary>
            Call to the PostExecute only when the work item is not cancelled
            </summary>
        </member>
        <member name="F:Amib.Threading.CallToPostExecute.Always">
            <summary>
            Always call to the PostExecute
            </summary>
        </member>
        <member name="T:Amib.Threading.IWaitableResult">
            <summary>
            The common interface of IWorkItemResult and IWorkItemResult&lt;T&gt;
            </summary>
        </member>
        <member name="M:Amib.Threading.IWaitableResult.GetWorkItemResult">
            <summary>
            This method intent is for internal use.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Amib.Threading.IWaitableResult.GetWorkItemResultT``1">
            <summary>
            This method intent is for internal use.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Amib.Threading.IWorkItemResult">
            <summary>
            IWorkItemResult interface.
            Created when a WorkItemCallback work item is queued.
            </summary>
        </member>
        <member name="T:Amib.Threading.IWorkItemResult`1">
            <summary>
            IWorkItemResult&lt;TResult&gt; interface.
            Created when a Func&lt;TResult&gt; work item is queued.
            </summary>
        </member>
        <member name="M:Amib.Threading.IWorkItemResult`1.GetResult">
            <summary>
            Get the result of the work item.
            If the work item didn't run yet then the caller waits.
            </summary>
            <returns>The result of the work item</returns>
        </member>
        <member name="M:Amib.Threading.IWorkItemResult`1.GetResult(System.Int32,System.Boolean)">
            <summary>
            Get the result of the work item.
            If the work item didn't run yet then the caller waits until timeout.
            </summary>
            <returns>The result of the work item</returns>
            On timeout throws WorkItemTimeoutException
        </member>
        <member name="M:Amib.Threading.IWorkItemResult`1.GetResult(System.TimeSpan,System.Boolean)">
            <summary>
            Get the result of the work item.
            If the work item didn't run yet then the caller waits until timeout.
            </summary>
            <returns>The result of the work item</returns>
            On timeout throws WorkItemTimeoutException
        </member>
        <member name="M:Amib.Threading.IWorkItemResult`1.GetResult(System.Int32,System.Boolean,System.Threading.WaitHandle)">
            <summary>
            Get the result of the work item.
            If the work item didn't run yet then the caller waits until timeout or until the cancelWaitHandle is signaled.
            </summary>
            <param name="millisecondsTimeout">Timeout in milliseconds, or -1 for infinite</param>
            <param name="exitContext">
            true to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it; otherwise, false. 
            </param>
            <param name="cancelWaitHandle">A cancel wait handle to interrupt the blocking if needed</param>
            <returns>The result of the work item</returns>
            On timeout throws WorkItemTimeoutException
            On cancel throws WorkItemCancelException
        </member>
        <member name="M:Amib.Threading.IWorkItemResult`1.GetResult(System.TimeSpan,System.Boolean,System.Threading.WaitHandle)">
            <summary>
            Get the result of the work item.
            If the work item didn't run yet then the caller waits until timeout or until the cancelWaitHandle is signaled.
            </summary>
            <returns>The result of the work item</returns>
            On timeout throws WorkItemTimeoutException
            On cancel throws WorkItemCancelException
        </member>
        <member name="M:Amib.Threading.IWorkItemResult`1.GetResult(System.Exception@)">
            <summary>
            Get the result of the work item.
            If the work item didn't run yet then the caller waits.
            </summary>
            <param name="e">Filled with the exception if one was thrown</param>
            <returns>The result of the work item</returns>
        </member>
        <member name="M:Amib.Threading.IWorkItemResult`1.GetResult(System.Int32,System.Boolean,System.Exception@)">
            <summary>
            Get the result of the work item.
            If the work item didn't run yet then the caller waits until timeout.
            </summary>
            <param name="millisecondsTimeout"></param>
            <param name="exitContext"></param>
            <param name="e">Filled with the exception if one was thrown</param>
            <returns>The result of the work item</returns>
            On timeout throws WorkItemTimeoutException
        </member>
        <member name="M:Amib.Threading.IWorkItemResult`1.GetResult(System.TimeSpan,System.Boolean,System.Exception@)">
            <summary>
            Get the result of the work item.
            If the work item didn't run yet then the caller waits until timeout.
            </summary>
            <param name="exitContext"></param>
            <param name="e">Filled with the exception if one was thrown</param>
            <param name="timeout"></param>
            <returns>The result of the work item</returns>
            On timeout throws WorkItemTimeoutException
        </member>
        <member name="M:Amib.Threading.IWorkItemResult`1.GetResult(System.Int32,System.Boolean,System.Threading.WaitHandle,System.Exception@)">
            <summary>
            Get the result of the work item.
            If the work item didn't run yet then the caller waits until timeout or until the cancelWaitHandle is signaled.
            </summary>
            <param name="millisecondsTimeout">Timeout in milliseconds, or -1 for infinite</param>
            <param name="exitContext">
            true to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it; otherwise, false. 
            </param>
            <param name="cancelWaitHandle">A cancel wait handle to interrupt the blocking if needed</param>
            <param name="e">Filled with the exception if one was thrown</param>
            <returns>The result of the work item</returns>
            On timeout throws WorkItemTimeoutException
            On cancel throws WorkItemCancelException
        </member>
        <member name="M:Amib.Threading.IWorkItemResult`1.GetResult(System.TimeSpan,System.Boolean,System.Threading.WaitHandle,System.Exception@)">
            <summary>
            Get the result of the work item.
            If the work item didn't run yet then the caller waits until timeout or until the cancelWaitHandle is signaled.
            </summary>
            <returns>The result of the work item</returns>
            <param name="cancelWaitHandle"></param>
            <param name="e">Filled with the exception if one was thrown</param>
            <param name="timeout"></param>
            <param name="exitContext"></param>
            On timeout throws WorkItemTimeoutException
            On cancel throws WorkItemCancelException
        </member>
        <member name="P:Amib.Threading.IWorkItemResult`1.IsCompleted">
            <summary>
            Gets an indication whether the asynchronous operation has completed.
            </summary>
        </member>
        <member name="P:Amib.Threading.IWorkItemResult`1.IsCanceled">
            <summary>
            Gets an indication whether the asynchronous operation has been canceled.
            </summary>
        </member>
        <member name="P:Amib.Threading.IWorkItemResult`1.State">
            <summary>
            Gets the user-defined object that contains context data 
            for the work item method.
            </summary>
        </member>
        <member name="M:Amib.Threading.IWorkItemResult`1.Cancel">
            <summary>
            Same as Cancel(false).
            </summary>
        </member>
        <member name="M:Amib.Threading.IWorkItemResult`1.Cancel(System.Boolean)">
            <summary>
            Cancel the work item execution.
            If the work item is in the queue then it won't execute
            If the work item is completed, it will remain completed
            If the work item is in progress then the user can check the SmartThreadPool.IsWorkItemCanceled
              property to check if the work item has been cancelled. If the abortExecution is set to true then
              the Smart Thread Pool will send an AbortException to the running thread to stop the execution 
              of the work item. When an in progress work item is canceled its GetResult will throw WorkItemCancelException.
            If the work item is already cancelled it will remain cancelled
            </summary>
            <param name="abortExecution">When true send an AbortException to the executing thread.</param>
            <returns>Returns true if the work item was not completed, otherwise false.</returns>
        </member>
        <member name="P:Amib.Threading.IWorkItemResult`1.WorkItemPriority">
            <summary>
            Get the work item's priority
            </summary>
        </member>
        <member name="P:Amib.Threading.IWorkItemResult`1.Result">
            <summary>
            Return the result, same as GetResult()
            </summary>
        </member>
        <member name="P:Amib.Threading.IWorkItemResult`1.Exception">
            <summary>
            Returns the exception if occured otherwise returns null.
            </summary>
        </member>
        <member name="T:Amib.Threading.Action">
            <summary>
            
            </summary>
        </member>
        <member name="T:Amib.Threading.Action`2">
            <summary>
            
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <param name="arg1"></param>
            <param name="arg2"></param>
        </member>
        <member name="T:Amib.Threading.Action`3">
            <summary>
            
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
        </member>
        <member name="T:Amib.Threading.Action`4">
            <summary>
            
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <typeparam name="T4"></typeparam>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
            <param name="arg4"></param>
        </member>
        <member name="T:Amib.Threading.Func`1">
            <summary>
            
            </summary>
            <typeparam name="TResult"></typeparam>
            <returns></returns>
        </member>
        <member name="T:Amib.Threading.Func`2">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="arg1"></param>
            <returns></returns>
        </member>
        <member name="T:Amib.Threading.Func`3">
            <summary>
            
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <returns></returns>
        </member>
        <member name="T:Amib.Threading.Func`4">
            <summary>
            
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
            <returns></returns>
        </member>
        <member name="T:Amib.Threading.Func`5">
            <summary>
            
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <typeparam name="T4"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
            <param name="arg4"></param>
            <returns></returns>
        </member>
        <member name="T:Amib.Threading.SmartThreadPool">
            <summary>
            Smart thread pool class.
            </summary>
        </member>
        <member name="F:Amib.Threading.SmartThreadPool.DefaultMinWorkerThreads">
            <summary>
            Default minimum number of threads the thread pool contains. (0)
            </summary>
        </member>
        <member name="F:Amib.Threading.SmartThreadPool.DefaultMaxWorkerThreads">
            <summary>
            Default maximum number of threads the thread pool contains. (25)
            </summary>
        </member>
        <member name="F:Amib.Threading.SmartThreadPool.DefaultIdleTimeout">
            <summary>
            Default idle timeout in milliseconds. (One minute)
            </summary>
        </member>
        <member name="F:Amib.Threading.SmartThreadPool.DefaultUseCallerCallContext">
            <summary>
            Indicate to copy the security context of the caller and then use it in the call. (false)
            </summary>
        </member>
        <member name="F:Amib.Threading.SmartThreadPool.DefaultUseCallerHttpContext">
            <summary>
            Indicate to copy the HTTP context of the caller and then use it in the call. (false)
            </summary>
        </member>
        <member name="F:Amib.Threading.SmartThreadPool.DefaultDisposeOfStateObjects">
            <summary>
            Indicate to dispose of the state objects if they support the IDispose interface. (false)
            </summary>
        </member>
        <member name="F:Amib.Threading.SmartThreadPool.DefaultCallToPostExecute">
            <summary>
            The default option to run the post execute (CallToPostExecute.Always)
            </summary>
        </member>
        <member name="F:Amib.Threading.SmartThreadPool.DefaultPostExecuteWorkItemCallback">
            <summary>
            The default post execute method to run. (None)
            When null it means not to call it.
            </summary>
        </member>
        <member name="F:Amib.Threading.SmartThreadPool.DefaultWorkItemPriority">
            <summary>
            The default work item priority (WorkItemPriority.Normal)
            </summary>
        </member>
        <member name="F:Amib.Threading.SmartThreadPool.DefaultStartSuspended">
            <summary>
            The default is to work on work items as soon as they arrive
            and not to wait for the start. (false)
            </summary>
        </member>
        <member name="F:Amib.Threading.SmartThreadPool.DefaultPerformanceCounterInstanceName">
            <summary>
            The default name to use for the performance counters instance. (null)
            </summary>
        </member>
        <member name="F:Amib.Threading.SmartThreadPool.DefaultThreadPriority">
            <summary>
            The default thread priority (ThreadPriority.Normal)
            </summary>
        </member>
        <member name="F:Amib.Threading.SmartThreadPool.DefaultThreadPoolName">
            <summary>
            The default thread pool name. (SmartThreadPool)
            </summary>
        </member>
        <member name="F:Amib.Threading.SmartThreadPool.DefaultMaxStackSize">
            <summary>
            The default Max Stack Size. (null)
            </summary>
        </member>
        <member name="F:Amib.Threading.SmartThreadPool.DefaultMaxQueueLength">
            <summary>
            The default Max Queue Length (null).
            </summary>
        </member>
        <member name="F:Amib.Threading.SmartThreadPool.DefaultFillStateWithArgs">
            <summary>
            The default fill state with params. (false)
            It is relevant only to QueueWorkItem of Action&lt;...&gt;/Func&lt;...&gt;
            </summary>
        </member>
        <member name="F:Amib.Threading.SmartThreadPool.DefaultAreThreadsBackground">
            <summary>
            The default thread backgroundness. (true)
            </summary>
        </member>
        <member name="F:Amib.Threading.SmartThreadPool.DefaultApartmentState">
            <summary>
            The default apartment state of a thread in the thread pool. 
            The default is ApartmentState.Unknown which means the STP will not 
            set the apartment of the thread. It will use the .NET default.
            </summary>
        </member>
        <member name="F:Amib.Threading.SmartThreadPool._workerThreads">
            <summary>
            Dictionary of all the threads in the thread pool.
            </summary>
        </member>
        <member name="F:Amib.Threading.SmartThreadPool._workItemsQueue">
            <summary>
            Queue of work items.
            </summary>
        </member>
        <member name="F:Amib.Threading.SmartThreadPool._workItemsProcessed">
            <summary>
            Count the work items handled.
            Used by the performance counter.
            </summary>
        </member>
        <member name="F:Amib.Threading.SmartThreadPool._inUseWorkerThreads">
            <summary>
            Number of threads that currently work (not idle).
            </summary>
        </member>
        <member name="F:Amib.Threading.SmartThreadPool._stpStartInfo">
            <summary>
            Stores a copy of the original STPStartInfo.
            It is used to change the MinThread and MaxThreads
            </summary>
        </member>
        <member name="F:Amib.Threading.SmartThreadPool._currentWorkItemsCount">
            <summary>
            Total number of work items that are stored in the work items queue 
            plus the work items that the threads in the pool are working on.
            </summary>
        </member>
        <member name="F:Amib.Threading.SmartThreadPool._isIdleWaitHandle">
            <summary>
            Signaled when the thread pool is idle, i.e. no thread is busy
            and the work items queue is empty
            </summary>
        </member>
        <member name="F:Amib.Threading.SmartThreadPool._shuttingDownEvent">
            <summary>
            An event to signal all the threads to quit immediately.
            </summary>
        </member>
        <member name="F:Amib.Threading.SmartThreadPool._isSuspended">
            <summary>
            A flag to indicate if the Smart Thread Pool is now suspended.
            </summary>
        </member>
        <member name="F:Amib.Threading.SmartThreadPool._shutdown">
            <summary>
            A flag to indicate the threads to quit.
            </summary>
        </member>
        <member name="F:Amib.Threading.SmartThreadPool._threadCounter">
            <summary>
            Counts the threads created in the pool.
            It is used to name the threads.
            </summary>
        </member>
        <member name="F:Amib.Threading.SmartThreadPool._isDisposed">
            <summary>
            Indicate that the SmartThreadPool has been disposed
            </summary>
        </member>
        <member name="F:Amib.Threading.SmartThreadPool._workItemsGroups">
            <summary>
            Holds all the WorkItemsGroup instaces that have at least one 
            work item int the SmartThreadPool
            This variable is used in case of Shutdown
            </summary>
        </member>
        <member name="F:Amib.Threading.SmartThreadPool._canceledSmartThreadPool">
            <summary>
            A common object for all the work items int the STP
            so we can mark them to cancel in O(1)
            </summary>
        </member>
        <member name="F:Amib.Threading.SmartThreadPool._windowsPCs">
            <summary>
            Windows STP performance counters
            </summary>
        </member>
        <member name="F:Amib.Threading.SmartThreadPool._localPCs">
            <summary>
            Local STP performance counters
            </summary>
        </member>
        <member name="E:Amib.Threading.SmartThreadPool._onThreadInitialization">
            <summary>
            An event to call after a thread is created, but before 
            it's first use.
            </summary>
        </member>
        <member name="E:Amib.Threading.SmartThreadPool._onThreadTermination">
            <summary>
            An event to call when a thread is about to exit, after 
            it is no longer belong to the pool.
            </summary>
        </member>
        <member name="P:Amib.Threading.SmartThreadPool.CurrentThreadEntry">
            <summary>
            A reference to the current work item a thread from the thread pool 
            is executing.
            </summary>
        </member>
        <member name="M:Amib.Threading.SmartThreadPool.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Amib.Threading.SmartThreadPool.#ctor(System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="idleTimeout">Idle timeout in milliseconds</param>
        </member>
        <member name="M:Amib.Threading.SmartThreadPool.#ctor(System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="startSuspended">Set it to True to start thread pool in suspended mode; Explicit call to Start() will be needed to start the Thread pool.</param>
        </member>
        <member name="M:Amib.Threading.SmartThreadPool.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="idleTimeout">Idle timeout in milliseconds</param>
            <param name="maxWorkerThreads">Upper limit of threads in the pool</param>
        </member>
        <member name="M:Amib.Threading.SmartThreadPool.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="idleTimeout">Idle timeout in milliseconds</param>
            <param name="maxWorkerThreads">Upper limit of threads in the pool</param>
            <param name="minWorkerThreads">Lower limit of threads in the pool</param>
        </member>
        <member name="M:Amib.Threading.SmartThreadPool.#ctor(Amib.Threading.STPStartInfo)">
            <summary>
            Constructor
            </summary>
            <param name="stpStartInfo">A SmartThreadPool configuration that overrides the default behavior</param>
        </member>
        <member name="M:Amib.Threading.SmartThreadPool.Dequeue">
            <summary>
            Waits on the queue for a work item, shutdown, or timeout.
            </summary>
            <returns>
            Returns the WaitingCallback or null in case of timeout or shutdown.
            </returns>
        </member>
        <member name="M:Amib.Threading.SmartThreadPool.Enqueue(Amib.Threading.Internal.WorkItem)">
            <summary>
            Put a new work item in the queue
            </summary>
            <param name="workItem">A work item to queue</param>
        </member>
        <member name="M:Amib.Threading.SmartThreadPool.InformCompleted">
            <summary>
            Inform that the current thread is about to quit or quiting.
            The same thread may call this method more than once.
            </summary>
        </member>
        <member name="M:Amib.Threading.SmartThreadPool.StartThreads(System.Int32)">
            <summary>
            Starts new threads
            </summary>
            <param name="threadsCount">The number of threads to start</param>
        </member>
        <member name="M:Amib.Threading.SmartThreadPool.ProcessQueuedItems">
            <summary>
            A worker thread method that processes work items from the work items queue.
            </summary>
        </member>
        <member name="M:Amib.Threading.SmartThreadPool.Shutdown">
            <summary>
            Force the SmartThreadPool to shutdown
            </summary>
        </member>
        <member name="M:Amib.Threading.SmartThreadPool.Shutdown(System.Boolean,System.TimeSpan)">
            <summary>
            Force the SmartThreadPool to shutdown with timeout
            </summary>
        </member>
        <member name="M:Amib.Threading.SmartThreadPool.Shutdown(System.Boolean,System.Int32)">
            <summary>
            Empties the queue of work items and abort the threads in the pool.
            </summary>
        </member>
        <member name="M:Amib.Threading.SmartThreadPool.WaitAll(Amib.Threading.IWaitableResult[])">
            <summary>
            Wait for all work items to complete
            </summary>
            <param name="waitableResults">Array of work item result objects</param>
            <returns>
            true when every work item in workItemResults has completed; otherwise false.
            </returns>
        </member>
        <member name="M:Amib.Threading.SmartThreadPool.WaitAll(Amib.Threading.IWaitableResult[],System.TimeSpan,System.Boolean)">
            <summary>
            Wait for all work items to complete
            </summary>
            <param name="waitableResults">Array of work item result objects</param>
            <param name="timeout">The number of milliseconds to wait, or a TimeSpan that represents -1 milliseconds to wait indefinitely. </param>
            <param name="exitContext">
            true to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it; otherwise, false. 
            </param>
            <returns>
            true when every work item in workItemResults has completed; otherwise false.
            </returns>
        </member>
        <member name="M:Amib.Threading.SmartThreadPool.WaitAll(Amib.Threading.IWaitableResult[],System.TimeSpan,System.Boolean,System.Threading.WaitHandle)">
            <summary>
            Wait for all work items to complete
            </summary>
            <param name="waitableResults">Array of work item result objects</param>
            <param name="timeout">The number of milliseconds to wait, or a TimeSpan that represents -1 milliseconds to wait indefinitely. </param>
            <param name="exitContext">
            true to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it; otherwise, false. 
            </param>
            <param name="cancelWaitHandle">A cancel wait handle to interrupt the wait if needed</param>
            <returns>
            true when every work item in workItemResults has completed; otherwise false.
            </returns>
        </member>
        <member name="M:Amib.Threading.SmartThreadPool.WaitAll(Amib.Threading.IWaitableResult[],System.Int32,System.Boolean)">
            <summary>
            Wait for all work items to complete
            </summary>
            <param name="waitableResults">Array of work item result objects</param>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or Timeout.Infinite (-1) to wait indefinitely.</param>
            <param name="exitContext">
            true to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it; otherwise, false. 
            </param>
            <returns>
            true when every work item in workItemResults has completed; otherwise false.
            </returns>
        </member>
        <member name="M:Amib.Threading.SmartThreadPool.WaitAll(Amib.Threading.IWaitableResult[],System.Int32,System.Boolean,System.Threading.WaitHandle)">
            <summary>
            Wait for all work items to complete
            </summary>
            <param name="waitableResults">Array of work item result objects</param>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or Timeout.Infinite (-1) to wait indefinitely.</param>
            <param name="exitContext">
            true to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it; otherwise, false. 
            </param>
            <param name="cancelWaitHandle">A cancel wait handle to interrupt the wait if needed</param>
            <returns>
            true when every work item in workItemResults has completed; otherwise false.
            </returns>
        </member>
        <member name="M:Amib.Threading.SmartThreadPool.WaitAny(Amib.Threading.IWaitableResult[])">
            <summary>
            Waits for any of the work items in the specified array to complete, cancel, or timeout
            </summary>
            <param name="waitableResults">Array of work item result objects</param>
            <returns>
            The array index of the work item result that satisfied the wait, or WaitTimeout if any of the work items has been canceled.
            </returns>
        </member>
        <member name="M:Amib.Threading.SmartThreadPool.WaitAny(Amib.Threading.IWaitableResult[],System.TimeSpan,System.Boolean)">
            <summary>
            Waits for any of the work items in the specified array to complete, cancel, or timeout
            </summary>
            <param name="waitableResults">Array of work item result objects</param>
            <param name="timeout">The number of milliseconds to wait, or a TimeSpan that represents -1 milliseconds to wait indefinitely. </param>
            <param name="exitContext">
            true to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it; otherwise, false. 
            </param>
            <returns>
            The array index of the work item result that satisfied the wait, or WaitTimeout if no work item result satisfied the wait and a time interval equivalent to millisecondsTimeout has passed or the work item has been canceled.
            </returns>
        </member>
        <member name="M:Amib.Threading.SmartThreadPool.WaitAny(Amib.Threading.IWaitableResult[],System.TimeSpan,System.Boolean,System.Threading.WaitHandle)">
            <summary>
            Waits for any of the work items in the specified array to complete, cancel, or timeout
            </summary>
            <param name="waitableResults">Array of work item result objects</param>
            <param name="timeout">The number of milliseconds to wait, or a TimeSpan that represents -1 milliseconds to wait indefinitely. </param>
            <param name="exitContext">
            true to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it; otherwise, false. 
            </param>
            <param name="cancelWaitHandle">A cancel wait handle to interrupt the wait if needed</param>
            <returns>
            The array index of the work item result that satisfied the wait, or WaitTimeout if no work item result satisfied the wait and a time interval equivalent to millisecondsTimeout has passed or the work item has been canceled.
            </returns>
        </member>
        <member name="M:Amib.Threading.SmartThreadPool.WaitAny(Amib.Threading.IWaitableResult[],System.Int32,System.Boolean)">
            <summary>
            Waits for any of the work items in the specified array to complete, cancel, or timeout
            </summary>
            <param name="waitableResults">Array of work item result objects</param>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or Timeout.Infinite (-1) to wait indefinitely.</param>
            <param name="exitContext">
            true to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it; otherwise, false. 
            </param>
            <returns>
            The array index of the work item result that satisfied the wait, or WaitTimeout if no work item result satisfied the wait and a time interval equivalent to millisecondsTimeout has passed or the work item has been canceled.
            </returns>
        </member>
        <member name="M:Amib.Threading.SmartThreadPool.WaitAny(Amib.Threading.IWaitableResult[],System.Int32,System.Boolean,System.Threading.WaitHandle)">
            <summary>
            Waits for any of the work items in the specified array to complete, cancel, or timeout
            </summary>
            <param name="waitableResults">Array of work item result objects</param>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or Timeout.Infinite (-1) to wait indefinitely.</param>
            <param name="exitContext">
            true to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it; otherwise, false. 
            </param>
            <param name="cancelWaitHandle">A cancel wait handle to interrupt the wait if needed</param>
            <returns>
            The array index of the work item result that satisfied the wait, or WaitTimeout if no work item result satisfied the wait and a time interval equivalent to millisecondsTimeout has passed or the work item has been canceled.
            </returns>
        </member>
        <member name="M:Amib.Threading.SmartThreadPool.CreateWorkItemsGroup(System.Int32)">
            <summary>
            Creates a new WorkItemsGroup.
            </summary>
            <param name="concurrency">The number of work items that can be run concurrently</param>
            <returns>A reference to the WorkItemsGroup</returns>
        </member>
        <member name="M:Amib.Threading.SmartThreadPool.CreateWorkItemsGroup(System.Int32,Amib.Threading.WIGStartInfo)">
            <summary>
            Creates a new WorkItemsGroup.
            </summary>
            <param name="concurrency">The number of work items that can be run concurrently</param>
            <param name="wigStartInfo">A WorkItemsGroup configuration that overrides the default behavior</param>
            <returns>A reference to the WorkItemsGroup</returns>
        </member>
        <member name="E:Amib.Threading.SmartThreadPool.OnThreadInitialization">
            <summary>
            This event is fired when a thread is created.
            Use it to initialize a thread before the work items use it.
            </summary>
        </member>
        <member name="E:Amib.Threading.SmartThreadPool.OnThreadTermination">
            <summary>
            This event is fired when a thread is terminating.
            Use it for cleanup.
            </summary>
        </member>
        <member name="P:Amib.Threading.SmartThreadPool.MinThreads">
            <summary>
            Get/Set the lower limit of threads in the pool.
            </summary>
        </member>
        <member name="P:Amib.Threading.SmartThreadPool.MaxThreads">
            <summary>
            Get/Set the upper limit of threads in the pool.
            </summary>
        </member>
        <member name="P:Amib.Threading.SmartThreadPool.MaxQueueLength">
            <summary>
            设置当前线程池的最大容量
            </summary>
        </member>
        <member name="P:Amib.Threading.SmartThreadPool.ActiveThreads">
            <summary>
            Get the number of threads in the thread pool.
            Should be between the lower and the upper limits.
            </summary>
        </member>
        <member name="P:Amib.Threading.SmartThreadPool.CurrentWorkItemsCount">
            <summary>
            Get the number of work items that haven't finished execution (i.e.
            items being worked on by threads + items in the queue).
            </summary>
        </member>
        <member name="P:Amib.Threading.SmartThreadPool.IsWorkItemCanceled">
            <summary>
            Returns true if the current running work item has been cancelled.
            Must be used within the work item's callback method.
            The work item should sample this value in order to know if it
            needs to quit before its completion.
            </summary>
        </member>
        <member name="M:Amib.Threading.SmartThreadPool.AbortOnWorkItemCancel">
            <summary>
            Checks if the work item has been cancelled, and if yes then abort the thread.
            Can be used with Cancel and timeout
            </summary>
        </member>
        <member name="P:Amib.Threading.SmartThreadPool.STPStartInfo">
            <summary>
            Thread Pool start information (readonly)
            </summary>
        </member>
        <member name="P:Amib.Threading.SmartThreadPool.IsShuttingdown">
            <summary>
            指示当前的我线程是否已经终止
            </summary>
        </member>
        <member name="P:Amib.Threading.SmartThreadPool.PerformanceCountersReader">
            <summary>
            Return the local calculated performance counters
            Available only if STPStartInfo.EnableLocalPerformanceCounters is true.
            </summary>
        </member>
        <member name="M:Amib.Threading.SmartThreadPool.Dispose">
            <summary>
            释放使用的资源
            </summary>
        </member>
        <member name="P:Amib.Threading.SmartThreadPool.Concurrency">
            <summary>
            Get/Set the maximum number of work items that execute cocurrency on the thread pool
            </summary>
        </member>
        <member name="P:Amib.Threading.SmartThreadPool.InUseThreads">
            <summary>
            Get the number of busy (not idle) threads in the thread pool.
            </summary>
        </member>
        <member name="P:Amib.Threading.SmartThreadPool.WaitingCallbacks">
            <summary>
            Get the number of work items in the queue.
            </summary>
        </member>
        <member name="M:Amib.Threading.SmartThreadPool.GetStates">
            <summary>
            Get an array with all the state objects of the currently running items.
            The array represents a snap shot and impact performance.
            </summary>
        </member>
        <member name="P:Amib.Threading.SmartThreadPool.WIGStartInfo">
            <summary>
            WorkItemsGroup start information (readonly)
            </summary>
        </member>
        <member name="M:Amib.Threading.SmartThreadPool.Start">
            <summary>
            Start the thread pool if it was started suspended.
            If it is already running, this method is ignored.
            </summary>
        </member>
        <member name="M:Amib.Threading.SmartThreadPool.Cancel(System.Boolean)">
            <summary>
            Cancel all work items using thread abortion
            </summary>
            <param name="abortExecution">True to stop work items by raising ThreadAbortException</param>
        </member>
        <member name="M:Amib.Threading.SmartThreadPool.WaitForIdle(System.Int32)">
            <summary>
            Wait for the thread pool to be idle
            </summary>
        </member>
        <member name="E:Amib.Threading.SmartThreadPool.OnIdle">
            <summary>
            This event is fired when all work items are completed.
            (When IsIdle changes to true)
            This event only work on WorkItemsGroup. On SmartThreadPool
            it throws the NotImplementedException.
            </summary>
        </member>
        <member name="M:Amib.Threading.SmartThreadPool.Join(System.Collections.Generic.IEnumerable{Amib.Threading.Action})">
            <summary>
            Executes all actions in parallel.
            Returns when they all finish.
            </summary>
            <param name="actions">Actions to execute</param>
        </member>
        <member name="M:Amib.Threading.SmartThreadPool.Join(Amib.Threading.Action[])">
            <summary>
            Executes all actions in parallel.
            Returns when they all finish.
            </summary>
            <param name="actions">Actions to execute</param>
        </member>
        <member name="M:Amib.Threading.SmartThreadPool.Choice(System.Collections.Generic.IEnumerable{Amib.Threading.Action})">
            <summary>
            Executes all actions in parallel
            Returns when the first one completes
            </summary>
            <param name="actions">Actions to execute</param>
        </member>
        <member name="M:Amib.Threading.SmartThreadPool.Choice(Amib.Threading.Action[])">
            <summary>
            Executes all actions in parallel
            Returns when the first one completes
            </summary>
            <param name="actions">Actions to execute</param>
        </member>
        <member name="M:Amib.Threading.SmartThreadPool.Pipe``1(``0,System.Collections.Generic.IEnumerable{System.Action{``0}})">
            <summary>
            Executes actions in sequence asynchronously.
            Returns immediately.
            </summary>
            <param name="pipeState">A state context that passes </param>
            <param name="actions">Actions to execute in the order they should run</param>
        </member>
        <member name="M:Amib.Threading.SmartThreadPool.Pipe``1(``0,System.Action{``0}[])">
            <summary>
            Executes actions in sequence asynchronously.
            Returns immediately.
            </summary>
            <param name="pipeState"></param>
            <param name="actions">Actions to execute in the order they should run</param>
        </member>
        <member name="F:Amib.Threading.SmartThreadPool.ThreadEntry._creationTime">
            <summary>
            The thread creation time
            The value is stored as UTC value.
            </summary>
        </member>
        <member name="F:Amib.Threading.SmartThreadPool.ThreadEntry._lastAliveTime">
            <summary>
            The last time this thread has been running
            It is updated by IAmAlive() method
            The value is stored as UTC value.
            </summary>
        </member>
        <member name="F:Amib.Threading.SmartThreadPool.ThreadEntry._associatedSmartThreadPool">
            <summary>
            A reference from each thread in the thread pool to its SmartThreadPool
            object container.
            With this variable a thread can know whatever it belongs to a 
            SmartThreadPool.
            </summary>
        </member>
        <member name="P:Amib.Threading.SmartThreadPool.ThreadEntry.CurrentWorkItem">
            <summary>
            A reference to the current work item a thread from the thread pool 
            is executing.
            </summary>            
        </member>
        <member name="T:Amib.Threading.STPStartInfo">
            <summary>
            Summary description for STPStartInfo.
            </summary>
        </member>
        <member name="P:Amib.Threading.STPStartInfo.IdleTimeout">
            <summary>
            Get/Set the idle timeout in milliseconds.
            If a thread is idle (starved) longer than IdleTimeout then it may quit.
            </summary>
        </member>
        <member name="P:Amib.Threading.STPStartInfo.MinWorkerThreads">
            <summary>
            Get/Set the lower limit of threads in the pool.
            </summary>
        </member>
        <member name="P:Amib.Threading.STPStartInfo.MaxWorkerThreads">
            <summary>
            Get/Set the upper limit of threads in the pool.
            </summary>
        </member>
        <member name="P:Amib.Threading.STPStartInfo.ThreadPriority">
            <summary>
            Get/Set the scheduling priority of the threads in the pool.
            The Os handles the scheduling.
            </summary>
        </member>
        <member name="P:Amib.Threading.STPStartInfo.ThreadPoolName">
            <summary>
            Get/Set the thread pool name. Threads will get names depending on this.
            </summary>
        </member>
        <member name="P:Amib.Threading.STPStartInfo.PerformanceCounterInstanceName">
            <summary>
            Get/Set the performance counter instance name of this SmartThreadPool
            The default is null which indicate not to use performance counters at all.
            </summary>
        </member>
        <member name="P:Amib.Threading.STPStartInfo.EnableLocalPerformanceCounters">
            <summary>
            Enable/Disable the local performance counter.
            This enables the user to get some performance information about the SmartThreadPool 
            without using Windows performance counters. (Useful on WindowsCE, Silverlight, etc.)
            The default is false.
            </summary>
        </member>
        <member name="P:Amib.Threading.STPStartInfo.AreThreadsBackground">
            <summary>
            Get/Set backgroundness of thread in thread pool.
            </summary>
        </member>
        <member name="P:Amib.Threading.STPStartInfo.MaxQueueLength">
            <summary>
            The maximum number of items allowed in the queue. Items attempting to be queued
            when the queue is at its maximum will throw a QueueRejectedException.
            
            Value must be > 0. A <code>null</code> value will leave the queue unbounded (i.e.
            bounded only by available resources).
            
            Ignored when <code>Enqueue()</code>ing on a Thread Pool from within a
            <code>WorkItemsGroup</code>.
            </summary>
        </member>
        <member name="M:Amib.Threading.STPStartInfo.AsReadOnly">
            <summary>
            Get a readonly version of this STPStartInfo.
            </summary>
            <returns>Returns a readonly reference to this STPStartInfo</returns>
        </member>
        <member name="P:Amib.Threading.STPStartInfo.ApartmentState">
            <summary>
            Get/Set the apartment state of threads in the thread pool
            </summary>
        </member>
        <member name="P:Amib.Threading.STPStartInfo.MaxStackSize">
            <summary>
            Get/Set the max stack size of threads in the thread pool
            </summary>
        </member>
        <member name="T:Amib.Threading.WIGStartInfo">
            <summary>
            Summary description for WIGStartInfo.
            </summary>
        </member>
        <member name="P:Amib.Threading.WIGStartInfo.UseCallerCallContext">
            <summary>
            Get/Set if to use the caller's security context
            </summary>
        </member>
        <member name="P:Amib.Threading.WIGStartInfo.UseCallerHttpContext">
            <summary>
            Get/Set if to use the caller's HTTP context
            </summary>
        </member>
        <member name="P:Amib.Threading.WIGStartInfo.DisposeOfStateObjects">
            <summary>
            Get/Set if to dispose of the state object of a work item
            </summary>
        </member>
        <member name="P:Amib.Threading.WIGStartInfo.CallToPostExecute">
            <summary>
            Get/Set the run the post execute options
            </summary>
        </member>
        <member name="P:Amib.Threading.WIGStartInfo.PostExecuteWorkItemCallback">
            <summary>
            Get/Set the default post execute callback
            </summary>
        </member>
        <member name="P:Amib.Threading.WIGStartInfo.StartSuspended">
            <summary>
            Get/Set if the work items execution should be suspended until the Start()
            method is called.
            </summary>
        </member>
        <member name="P:Amib.Threading.WIGStartInfo.WorkItemPriority">
            <summary>
            Get/Set the default priority that a work item gets when it is enqueued
            </summary>
        </member>
        <member name="P:Amib.Threading.WIGStartInfo.FillStateWithArgs">
            <summary>
            Get/Set the if QueueWorkItem of Action&lt;...&gt;/Func&lt;...&gt; fill the
            arguments as an object array into the state of the work item.
            The arguments can be access later by IWorkItemResult.State.
            </summary>
        </member>
        <member name="M:Amib.Threading.WIGStartInfo.AsReadOnly">
            <summary>
            Get a readonly version of this WIGStartInfo
            </summary>
            <returns>Returns a readonly reference to this WIGStartInfoRO</returns>
        </member>
        <member name="T:Amib.Threading.WorkItemInfo">
            <summary>
            Summary description for WorkItemInfo.
            </summary>
        </member>
        <member name="M:Amib.Threading.WorkItemInfo.#ctor">
            <summary>
            表示一个工作项信息
            </summary>
        </member>
        <member name="M:Amib.Threading.WorkItemInfo.#ctor(Amib.Threading.WorkItemInfo)">
            <summary>
            初始化
            </summary>
            <param name="workItemInfo"></param>
        </member>
        <member name="P:Amib.Threading.WorkItemInfo.UseCallerCallContext">
            <summary>
            Get/Set if to use the caller's security context
            </summary>
        </member>
        <member name="P:Amib.Threading.WorkItemInfo.UseCallerHttpContext">
            <summary>
            Get/Set if to use the caller's HTTP context
            </summary>
        </member>
        <member name="P:Amib.Threading.WorkItemInfo.DisposeOfStateObjects">
            <summary>
            Get/Set if to dispose of the state object of a work item
            </summary>
        </member>
        <member name="P:Amib.Threading.WorkItemInfo.CallToPostExecute">
            <summary>
            Get/Set the run the post execute options
            </summary>
        </member>
        <member name="P:Amib.Threading.WorkItemInfo.PostExecuteWorkItemCallback">
            <summary>
            Get/Set the post execute callback
            </summary>
        </member>
        <member name="P:Amib.Threading.WorkItemInfo.WorkItemPriority">
            <summary>
            Get/Set the work item's priority
            </summary>
        </member>
        <member name="P:Amib.Threading.WorkItemInfo.Timeout">
            <summary>
            Get/Set the work item's timout in milliseconds.
            This is a passive timout. When the timout expires the work item won't be actively aborted!
            </summary>
        </member>
    </members>
</doc>
